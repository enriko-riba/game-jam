(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~main"],{

/***/ "./node_modules/pixi-particles/lib/pixi-particles.es.js":
/*!**************************************************************!*\
  !*** ./node_modules/pixi-particles/lib/pixi-particles.es.js ***!
  \**************************************************************/
/*! exports provided: GetTextureFromString, ParticleUtils, Particle, Emitter, PathParticle, AnimatedParticle, PolygonalChain, PropertyList, PropertyNode */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetTextureFromString\", function() { return GetTextureFromString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParticleUtils\", function() { return ParticleUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Particle\", function() { return Particle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Emitter\", function() { return Emitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PathParticle\", function() { return PathParticle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AnimatedParticle\", function() { return AnimatedParticle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolygonalChain\", function() { return PolygonalChain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyList\", function() { return PropertyList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyNode\", function() { return PropertyNode; });\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/lib/pixi.es.js\");\n/*!\n * pixi-particles - v4.2.0\n * Compiled Sat, 26 Oct 2019 14:40:23 UTC\n *\n * pixi-particles is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n\n\n\n/**\r\n * A single node in a PropertyList.\r\n */\r\nvar PropertyNode = /** @class */ (function () {\r\n    /**\r\n     * @param value The value for this node\r\n     * @param time The time for this node, between 0-1\r\n     * @param [ease] Custom ease for this list. Only relevant for the first node.\r\n     */\r\n    function PropertyNode(value, time, ease) {\r\n        this.value = value;\r\n        this.time = time;\r\n        this.next = null;\r\n        this.isStepped = false;\r\n        if (ease) {\r\n            this.ease = typeof ease == \"function\" ? ease : ParticleUtils.generateEase(ease);\r\n        }\r\n        else {\r\n            this.ease = null;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a list of property values from a data object {list, isStepped} with a list of objects in\r\n     * the form {value, time}. Alternatively, the data object can be in the deprecated form of\r\n     * {start, end}.\r\n     * @param data The data for the list.\r\n     * @param data.list The array of value and time objects.\r\n     * @param data.isStepped If the list is stepped rather than interpolated.\r\n     * @param data.ease Custom ease for this list.\r\n     * @return The first node in the list\r\n     */\r\n    PropertyNode.createList = function (data) {\r\n        if (\"list\" in data) {\r\n            var array = data.list;\r\n            var node = void 0, first = void 0;\r\n            var _a = array[0], value = _a.value, time = _a.time;\r\n            first = node = new PropertyNode(typeof value === 'string' ? ParticleUtils.hexToRGB(value) : value, time, data.ease);\r\n            //only set up subsequent nodes if there are a bunch or the 2nd one is different from the first\r\n            if (array.length > 2 || (array.length === 2 && array[1].value !== value)) {\r\n                for (var i = 1; i < array.length; ++i) {\r\n                    var _b = array[i], value_1 = _b.value, time_1 = _b.time;\r\n                    node.next = new PropertyNode(typeof value_1 === 'string' ? ParticleUtils.hexToRGB(value_1) : value_1, time_1);\r\n                    node = node.next;\r\n                }\r\n            }\r\n            first.isStepped = !!data.isStepped;\r\n            return first;\r\n        }\r\n        else {\r\n            //Handle deprecated version here\r\n            var start = new PropertyNode(typeof data.start === 'string' ? ParticleUtils.hexToRGB(data.start) : data.start, 0);\r\n            //only set up a next value if it is different from the starting value\r\n            if (data.end !== data.start)\r\n                start.next = new PropertyNode(typeof data.end === 'string' ? ParticleUtils.hexToRGB(data.end) : data.end, 1);\r\n            return start;\r\n        }\r\n    };\r\n    return PropertyNode;\r\n}());\n\n// get Texture.from()/Texture.fromImage(), in V4 and V5 friendly methods\r\n/**\r\n * @hidden\r\n */\r\nvar TextureFromString;\r\n// to avoid Rollup transforming our import, save pixi namespace in a variable\r\nvar pixiNS = pixi_js__WEBPACK_IMPORTED_MODULE_0__;\r\nif (parseInt(/^(\\d+)\\./.exec(pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"VERSION\"])[1]) < 5) {\r\n    TextureFromString = pixiNS.Texture.fromImage;\r\n}\r\nelse {\r\n    TextureFromString = pixiNS.Texture.from;\r\n}\r\nfunction GetTextureFromString(s) {\r\n    return TextureFromString(s);\r\n}\r\n/**\r\n * Contains helper functions for particles and emitters to use.\r\n */\r\nvar ParticleUtils;\r\n(function (ParticleUtils) {\r\n    /**\r\n     * If errors and warnings should be logged within the library.\r\n     */\r\n    ParticleUtils.verbose = false;\r\n    ParticleUtils.DEG_TO_RADS = Math.PI / 180;\r\n    /**\r\n     * Rotates a point by a given angle.\r\n     * @param angle The angle to rotate by in degrees\r\n     * @param p The point to rotate around 0,0.\r\n     */\r\n    function rotatePoint(angle, p) {\r\n        if (!angle)\r\n            return;\r\n        angle *= ParticleUtils.DEG_TO_RADS;\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        var xnew = p.x * c - p.y * s;\r\n        var ynew = p.x * s + p.y * c;\r\n        p.x = xnew;\r\n        p.y = ynew;\r\n    }\r\n    ParticleUtils.rotatePoint = rotatePoint;\r\n    /**\r\n     * Combines separate color components (0-255) into a single uint color.\r\n     * @param r The red value of the color\r\n     * @param g The green value of the color\r\n     * @param b The blue value of the color\r\n     * @return The color in the form of 0xRRGGBB\r\n     */\r\n    function combineRGBComponents(r, g, b /*, a*/) {\r\n        return /*a << 24 |*/ r << 16 | g << 8 | b;\r\n    }\r\n    ParticleUtils.combineRGBComponents = combineRGBComponents;\r\n    /**\r\n     * Reduces the point to a length of 1.\r\n     * @param point The point to normalize\r\n     */\r\n    function normalize(point) {\r\n        var oneOverLen = 1 / ParticleUtils.length(point);\r\n        point.x *= oneOverLen;\r\n        point.y *= oneOverLen;\r\n    }\r\n    ParticleUtils.normalize = normalize;\r\n    /**\r\n     * Multiplies the x and y values of this point by a value.\r\n     * @param point The point to scaleBy\r\n     * @param value The value to scale by.\r\n     */\r\n    function scaleBy(point, value) {\r\n        point.x *= value;\r\n        point.y *= value;\r\n    }\r\n    ParticleUtils.scaleBy = scaleBy;\r\n    /**\r\n     * Returns the length (or magnitude) of this point.\r\n     * @param point The point to measure length\r\n     * @return The length of this point.\r\n     */\r\n    function length(point) {\r\n        return Math.sqrt(point.x * point.x + point.y * point.y);\r\n    }\r\n    ParticleUtils.length = length;\r\n    /**\r\n     * Converts a hex string from \"#AARRGGBB\", \"#RRGGBB\", \"0xAARRGGBB\", \"0xRRGGBB\",\r\n     * \"AARRGGBB\", or \"RRGGBB\" to an object of ints of 0-255, as\r\n     * {r, g, b, (a)}.\r\n     * @param color The input color string.\r\n     * @param output An object to put the output in. If omitted, a new object is created.\r\n     * @return The object with r, g, and b properties, possibly with an a property.\r\n     */\r\n    function hexToRGB(color, output) {\r\n        if (!output)\r\n            output = {};\r\n        if (color.charAt(0) == \"#\")\r\n            color = color.substr(1);\r\n        else if (color.indexOf(\"0x\") === 0)\r\n            color = color.substr(2);\r\n        var alpha;\r\n        if (color.length == 8) {\r\n            alpha = color.substr(0, 2);\r\n            color = color.substr(2);\r\n        }\r\n        output.r = parseInt(color.substr(0, 2), 16); //Red\r\n        output.g = parseInt(color.substr(2, 2), 16); //Green\r\n        output.b = parseInt(color.substr(4, 2), 16); //Blue\r\n        if (alpha)\r\n            output.a = parseInt(alpha, 16);\r\n        return output;\r\n    }\r\n    ParticleUtils.hexToRGB = hexToRGB;\r\n    /**\r\n     * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated\r\n     * by the related tool at http://www.greensock.com/customease/.\r\n     * @param segments An array of segments, as created by\r\n     * http://www.greensock.com/customease/.\r\n     * @return A function that calculates the percentage of change at\r\n     *                    a given point in time (0-1 inclusive).\r\n     */\r\n    function generateEase(segments) {\r\n        var qty = segments.length;\r\n        var oneOverQty = 1 / qty;\r\n        /*\r\n         * Calculates the percentage of change at a given point in time (0-1 inclusive).\r\n         * @param {Number} time The time of the ease, 0-1 inclusive.\r\n         * @return {Number} The percentage of the change, 0-1 inclusive (unless your\r\n         *                  ease goes outside those bounds).\r\n         */\r\n        return function (time) {\r\n            var t, s;\r\n            var i = (qty * time) | 0; //do a quick floor operation\r\n            t = (time - (i * oneOverQty)) * qty;\r\n            s = segments[i] || segments[qty - 1];\r\n            return (s.s + t * (2 * (1 - t) * (s.cp - s.s) + t * (s.e - s.s)));\r\n        };\r\n    }\r\n    ParticleUtils.generateEase = generateEase;\r\n    /**\r\n     * Gets a blend mode, ensuring that it is valid.\r\n     * @param name The name of the blend mode to get.\r\n     * @return The blend mode as specified in the PIXI.BLEND_MODES enumeration.\r\n     */\r\n    function getBlendMode(name) {\r\n        if (!name)\r\n            return pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"BLEND_MODES\"].NORMAL;\r\n        name = name.toUpperCase();\r\n        while (name.indexOf(\" \") >= 0)\r\n            name = name.replace(\" \", \"_\");\r\n        return pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"BLEND_MODES\"][name] || pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"BLEND_MODES\"].NORMAL;\r\n    }\r\n    ParticleUtils.getBlendMode = getBlendMode;\r\n    /**\r\n     * Converts a list of {value, time} objects starting at time 0 and ending at time 1 into an evenly\r\n     * spaced stepped list of PropertyNodes for color values. This is primarily to handle conversion of\r\n     * linear gradients to fewer colors, allowing for some optimization for Canvas2d fallbacks.\r\n     * @param list The list of data to convert.\r\n     * @param [numSteps=10] The number of steps to use.\r\n     * @return The blend mode as specified in the PIXI.blendModes enumeration.\r\n     */\r\n    function createSteppedGradient(list, numSteps) {\r\n        if (numSteps === void 0) { numSteps = 10; }\r\n        if (typeof numSteps !== 'number' || numSteps <= 0)\r\n            numSteps = 10;\r\n        var first = new PropertyNode(ParticleUtils.hexToRGB(list[0].value), list[0].time);\r\n        first.isStepped = true;\r\n        var currentNode = first;\r\n        var current = list[0];\r\n        var nextIndex = 1;\r\n        var next = list[nextIndex];\r\n        for (var i = 1; i < numSteps; ++i) {\r\n            var lerp = i / numSteps;\r\n            //ensure we are on the right segment, if multiple\r\n            while (lerp > next.time) {\r\n                current = next;\r\n                next = list[++nextIndex];\r\n            }\r\n            //convert the lerp value to the segment range\r\n            lerp = (lerp - current.time) / (next.time - current.time);\r\n            var curVal = ParticleUtils.hexToRGB(current.value);\r\n            var nextVal = ParticleUtils.hexToRGB(next.value);\r\n            var output = {\r\n                r: (nextVal.r - curVal.r) * lerp + curVal.r,\r\n                g: (nextVal.g - curVal.g) * lerp + curVal.g,\r\n                b: (nextVal.b - curVal.b) * lerp + curVal.b,\r\n            };\r\n            currentNode.next = new PropertyNode(output, i / numSteps);\r\n            currentNode = currentNode.next;\r\n        }\r\n        //we don't need to have a PropertyNode for time of 1, because in a stepped version at that point\r\n        //the particle has died of old age\r\n        return first;\r\n    }\r\n    ParticleUtils.createSteppedGradient = createSteppedGradient;\r\n})(ParticleUtils || (ParticleUtils = {}));\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\r\n * Singly linked list container for keeping track of interpolated properties for particles.\r\n * Each Particle will have one of these for each interpolated property.\r\n */\r\nvar PropertyList = /** @class */ (function () {\r\n    /**\r\n     * @param isColor If this list handles color values\r\n     */\r\n    function PropertyList(isColor) {\r\n        if (isColor === void 0) { isColor = false; }\r\n        this.current = null;\r\n        this.next = null;\r\n        this.isColor = !!isColor;\r\n        this.interpolate = null;\r\n        this.ease = null;\r\n    }\r\n    /**\r\n     * Resets the list for use.\r\n     * @param first The first node in the list.\r\n     * @param first.isStepped If the values should be stepped instead of interpolated linearly.\r\n     */\r\n    PropertyList.prototype.reset = function (first) {\r\n        this.current = first;\r\n        this.next = first.next;\r\n        var isSimple = this.next && this.next.time >= 1;\r\n        if (isSimple) {\r\n            this.interpolate = this.isColor ? intColorSimple : intValueSimple;\r\n        }\r\n        else if (first.isStepped) {\r\n            this.interpolate = this.isColor ? intColorStepped : intValueStepped;\r\n        }\r\n        else {\r\n            this.interpolate = this.isColor ? intColorComplex : intValueComplex;\r\n        }\r\n        this.ease = this.current.ease;\r\n    };\r\n    return PropertyList;\r\n}());\r\nfunction intValueSimple(lerp) {\r\n    if (this.ease)\r\n        lerp = this.ease(lerp);\r\n    return (this.next.value - this.current.value) * lerp + this.current.value;\r\n}\r\nfunction intColorSimple(lerp) {\r\n    if (this.ease)\r\n        lerp = this.ease(lerp);\r\n    var curVal = this.current.value, nextVal = this.next.value;\r\n    var r = (nextVal.r - curVal.r) * lerp + curVal.r;\r\n    var g = (nextVal.g - curVal.g) * lerp + curVal.g;\r\n    var b = (nextVal.b - curVal.b) * lerp + curVal.b;\r\n    return ParticleUtils.combineRGBComponents(r, g, b);\r\n}\r\nfunction intValueComplex(lerp) {\r\n    if (this.ease)\r\n        lerp = this.ease(lerp);\r\n    //make sure we are on the right segment\r\n    while (lerp > this.next.time) {\r\n        this.current = this.next;\r\n        this.next = this.next.next;\r\n    }\r\n    //convert the lerp value to the segment range\r\n    lerp = (lerp - this.current.time) / (this.next.time - this.current.time);\r\n    return (this.next.value - this.current.value) * lerp + this.current.value;\r\n}\r\nfunction intColorComplex(lerp) {\r\n    if (this.ease)\r\n        lerp = this.ease(lerp);\r\n    //make sure we are on the right segment\r\n    while (lerp > this.next.time) {\r\n        this.current = this.next;\r\n        this.next = this.next.next;\r\n    }\r\n    //convert the lerp value to the segment range\r\n    lerp = (lerp - this.current.time) / (this.next.time - this.current.time);\r\n    var curVal = this.current.value, nextVal = this.next.value;\r\n    var r = (nextVal.r - curVal.r) * lerp + curVal.r;\r\n    var g = (nextVal.g - curVal.g) * lerp + curVal.g;\r\n    var b = (nextVal.b - curVal.b) * lerp + curVal.b;\r\n    return ParticleUtils.combineRGBComponents(r, g, b);\r\n}\r\nfunction intValueStepped(lerp) {\r\n    if (this.ease)\r\n        lerp = this.ease(lerp);\r\n    //make sure we are on the right segment\r\n    while (this.next && lerp > this.next.time) {\r\n        this.current = this.next;\r\n        this.next = this.next.next;\r\n    }\r\n    return this.current.value;\r\n}\r\nfunction intColorStepped(lerp) {\r\n    if (this.ease)\r\n        lerp = this.ease(lerp);\r\n    //make sure we are on the right segment\r\n    while (this.next && lerp > this.next.time) {\r\n        this.current = this.next;\r\n        this.next = this.next.next;\r\n    }\r\n    var curVal = this.current.value;\r\n    return ParticleUtils.combineRGBComponents(curVal.r, curVal.g, curVal.b);\r\n}\n\n/**\r\n * An individual particle image. You shouldn't have to deal with these.\r\n */\r\nvar Particle = /** @class */ (function (_super) {\r\n    __extends(Particle, _super);\r\n    /**\r\n     * @param {PIXI.particles.Emitter} emitter The emitter that controls this particle.\r\n     */\r\n    function Particle(emitter) {\r\n        var _this = \r\n        //start off the sprite with a blank texture, since we are going to replace it\r\n        //later when the particle is initialized.\r\n        _super.call(this) || this;\r\n        _this.emitter = emitter;\r\n        //particles should be centered\r\n        _this.anchor.x = _this.anchor.y = 0.5;\r\n        _this.velocity = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]();\r\n        _this.rotationSpeed = 0;\r\n        _this.rotationAcceleration = 0;\r\n        _this.maxLife = 0;\r\n        _this.age = 0;\r\n        _this.ease = null;\r\n        _this.extraData = null;\r\n        _this.alphaList = new PropertyList();\r\n        _this.speedList = new PropertyList();\r\n        _this.speedMultiplier = 1;\r\n        _this.acceleration = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]();\r\n        _this.maxSpeed = NaN;\r\n        _this.scaleList = new PropertyList();\r\n        _this.scaleMultiplier = 1;\r\n        _this.colorList = new PropertyList(true);\r\n        _this._doAlpha = false;\r\n        _this._doScale = false;\r\n        _this._doSpeed = false;\r\n        _this._doAcceleration = false;\r\n        _this._doColor = false;\r\n        _this._doNormalMovement = false;\r\n        _this._oneOverLife = 0;\r\n        _this.next = null;\r\n        _this.prev = null;\r\n        //save often used functions on the instance instead of the prototype for better speed\r\n        _this.init = _this.init;\r\n        _this.Particle_init = Particle.prototype.init;\r\n        _this.update = _this.update;\r\n        _this.Particle_update = Particle.prototype.update;\r\n        _this.Sprite_destroy = _super.prototype.destroy;\r\n        _this.Particle_destroy = Particle.prototype.destroy;\r\n        _this.applyArt = _this.applyArt;\r\n        _this.kill = _this.kill;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Initializes the particle for use, based on the properties that have to\r\n     * have been set already on the particle.\r\n     */\r\n    Particle.prototype.init = function () {\r\n        //reset the age\r\n        this.age = 0;\r\n        //set up the velocity based on the start speed and rotation\r\n        this.velocity.x = this.speedList.current.value * this.speedMultiplier;\r\n        this.velocity.y = 0;\r\n        ParticleUtils.rotatePoint(this.rotation, this.velocity);\r\n        if (this.noRotation) {\r\n            this.rotation = 0;\r\n        }\r\n        else {\r\n            //convert rotation to Radians from Degrees\r\n            this.rotation *= ParticleUtils.DEG_TO_RADS;\r\n        }\r\n        //convert rotation speed to Radians from Degrees\r\n        this.rotationSpeed *= ParticleUtils.DEG_TO_RADS;\r\n        this.rotationAcceleration *= ParticleUtils.DEG_TO_RADS;\r\n        //set alpha to inital alpha\r\n        this.alpha = this.alphaList.current.value;\r\n        //set scale to initial scale\r\n        this.scale.x = this.scale.y = this.scaleList.current.value;\r\n        //figure out what we need to interpolate\r\n        this._doAlpha = !!this.alphaList.current.next;\r\n        this._doSpeed = !!this.speedList.current.next;\r\n        this._doScale = !!this.scaleList.current.next;\r\n        this._doColor = !!this.colorList.current.next;\r\n        this._doAcceleration = this.acceleration.x !== 0 || this.acceleration.y !== 0;\r\n        //_doNormalMovement can be cancelled by subclasses\r\n        this._doNormalMovement = this._doSpeed || this.speedList.current.value !== 0 || this._doAcceleration;\r\n        //save our lerp helper\r\n        this._oneOverLife = 1 / this.maxLife;\r\n        //set the inital color\r\n        var color = this.colorList.current.value;\r\n        this.tint = ParticleUtils.combineRGBComponents(color.r, color.g, color.b);\r\n        //ensure visibility\r\n        this.visible = true;\r\n    };\r\n    /**\r\n     * Sets the texture for the particle. This can be overridden to allow\r\n     * for an animated particle.\r\n     * @param art The texture to set.\r\n     */\r\n    Particle.prototype.applyArt = function (art) {\r\n        this.texture = art || pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"].EMPTY;\r\n    };\r\n    /**\r\n     * Updates the particle.\r\n     * @param delta Time elapsed since the previous frame, in __seconds__.\r\n     * @return The standard interpolation multiplier (0-1) used for all\r\n     *         relevant particle properties. A value of -1 means the particle\r\n     *         died of old age instead.\r\n     */\r\n    Particle.prototype.update = function (delta) {\r\n        //increase age\r\n        this.age += delta;\r\n        //recycle particle if it is too old\r\n        if (this.age >= this.maxLife || this.age < 0) {\r\n            this.kill();\r\n            return -1;\r\n        }\r\n        //determine our interpolation value\r\n        var lerp = this.age * this._oneOverLife; //lifetime / maxLife;\r\n        if (this.ease) {\r\n            if (this.ease.length == 4) {\r\n                //the t, b, c, d parameters that some tween libraries use\r\n                //(time, initial value, end value, duration)\r\n                lerp = this.ease(lerp, 0, 1, 1);\r\n            }\r\n            else {\r\n                //the simplified version that we like that takes\r\n                //one parameter, time from 0-1. TweenJS eases provide this usage.\r\n                lerp = this.ease(lerp);\r\n            }\r\n        }\r\n        //interpolate alpha\r\n        if (this._doAlpha)\r\n            this.alpha = this.alphaList.interpolate(lerp);\r\n        //interpolate scale\r\n        if (this._doScale) {\r\n            var scale = this.scaleList.interpolate(lerp) * this.scaleMultiplier;\r\n            this.scale.x = this.scale.y = scale;\r\n        }\r\n        //handle movement\r\n        if (this._doNormalMovement) {\r\n            var deltaX = void 0;\r\n            var deltaY = void 0;\r\n            //interpolate speed\r\n            if (this._doSpeed) {\r\n                var speed = this.speedList.interpolate(lerp) * this.speedMultiplier;\r\n                ParticleUtils.normalize(this.velocity);\r\n                ParticleUtils.scaleBy(this.velocity, speed);\r\n                deltaX = this.velocity.x * delta;\r\n                deltaY = this.velocity.y * delta;\r\n            }\r\n            else if (this._doAcceleration) {\r\n                var oldVX = this.velocity.x;\r\n                var oldVY = this.velocity.y;\r\n                this.velocity.x += this.acceleration.x * delta;\r\n                this.velocity.y += this.acceleration.y * delta;\r\n                if (this.maxSpeed) {\r\n                    var currentSpeed = ParticleUtils.length(this.velocity);\r\n                    //if we are going faster than we should, clamp at the max speed\r\n                    //DO NOT recalculate vector length\r\n                    if (currentSpeed > this.maxSpeed) {\r\n                        ParticleUtils.scaleBy(this.velocity, this.maxSpeed / currentSpeed);\r\n                    }\r\n                }\r\n                // calculate position delta by the midpoint between our old velocity and our new velocity\r\n                deltaX = (oldVX + this.velocity.x) / 2 * delta;\r\n                deltaY = (oldVY + this.velocity.y) / 2 * delta;\r\n            }\r\n            else {\r\n                deltaX = this.velocity.x * delta;\r\n                deltaY = this.velocity.y * delta;\r\n            }\r\n            //adjust position based on velocity\r\n            this.position.x += deltaX;\r\n            this.position.y += deltaY;\r\n        }\r\n        //interpolate color\r\n        if (this._doColor) {\r\n            this.tint = this.colorList.interpolate(lerp);\r\n        }\r\n        //update rotation\r\n        if (this.rotationAcceleration !== 0) {\r\n            var newRotationSpeed = this.rotationSpeed + this.rotationAcceleration * delta;\r\n            this.rotation += (this.rotationSpeed + newRotationSpeed) / 2 * delta;\r\n            this.rotationSpeed = newRotationSpeed;\r\n        }\r\n        else if (this.rotationSpeed !== 0) {\r\n            this.rotation += this.rotationSpeed * delta;\r\n        }\r\n        else if (this.acceleration && !this.noRotation) {\r\n            this.rotation = Math.atan2(this.velocity.y, this.velocity.x); // + Math.PI / 2;\r\n        }\r\n        return lerp;\r\n    };\r\n    /**\r\n     * Kills the particle, removing it from the display list\r\n     * and telling the emitter to recycle it.\r\n     */\r\n    Particle.prototype.kill = function () {\r\n        this.emitter.recycle(this);\r\n    };\r\n    /**\r\n     * Destroys the particle, removing references and preventing future use.\r\n     */\r\n    Particle.prototype.destroy = function () {\r\n        if (this.parent)\r\n            this.parent.removeChild(this);\r\n        this.Sprite_destroy();\r\n        this.emitter = this.velocity = this.colorList = this.scaleList = this.alphaList =\r\n            this.speedList = this.ease = this.next = this.prev = null;\r\n    };\r\n    /**\r\n     * Checks over the art that was passed to the Emitter's init() function, to do any special\r\n     * modifications to prepare it ahead of time.\r\n     * @param art The array of art data. For Particle, it should be an array of\r\n     *            Textures. Any strings in the array will be converted to\r\n     *            Textures via Texture.from().\r\n     * @return The art, after any needed modifications.\r\n     */\r\n    Particle.parseArt = function (art) {\r\n        //convert any strings to Textures.\r\n        var i;\r\n        for (i = art.length; i >= 0; --i) {\r\n            if (typeof art[i] == \"string\")\r\n                art[i] = GetTextureFromString(art[i]);\r\n        }\r\n        //particles from different base textures will be slower in WebGL than if they\r\n        //were from one spritesheet\r\n        if (ParticleUtils.verbose) {\r\n            for (i = art.length - 1; i > 0; --i) {\r\n                if (art[i].baseTexture != art[i - 1].baseTexture) {\r\n                    if (window.console)\r\n                        console.warn(\"PixiParticles: using particle textures from different images may hinder performance in WebGL\");\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return art;\r\n    };\r\n    /**\r\n     * Parses extra emitter data to ensure it is set up for this particle class.\r\n     * Particle does nothing to the extra data.\r\n     * @param extraData The extra data from the particle config.\r\n     * @return The parsed extra data.\r\n     */\r\n    Particle.parseData = function (extraData) {\r\n        return extraData;\r\n    };\r\n    return Particle;\r\n}(pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Sprite\"]));\n\n/**\r\n * Chain of line segments for generating spawn positions.\r\n */\r\nvar PolygonalChain = /** @class */ (function () {\r\n    /**\r\n     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\r\n     */\r\n    function PolygonalChain(data) {\r\n        this.segments = [];\r\n        this.countingLengths = [];\r\n        this.totalLength = 0;\r\n        this.init(data);\r\n    }\r\n    /**\r\n     * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\r\n     */\r\n    PolygonalChain.prototype.init = function (data) {\r\n        // if data is not present, set up a segment of length 0\r\n        if (!data || !data.length) {\r\n            this.segments.push({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 }, l: 0 });\r\n        }\r\n        else {\r\n            if (Array.isArray(data[0])) {\r\n                // list of segment chains, each defined as a list of points\r\n                for (var i = 0; i < data.length; ++i) {\r\n                    // loop through the chain, connecting points\r\n                    var chain = data[i];\r\n                    var prevPoint = chain[0];\r\n                    for (var j = 1; j < chain.length; ++j) {\r\n                        var second = chain[j];\r\n                        this.segments.push({ p1: prevPoint, p2: second, l: 0 });\r\n                        prevPoint = second;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                var prevPoint = data[0];\r\n                // list of points\r\n                for (var i = 1; i < data.length; ++i) {\r\n                    var second = data[i];\r\n                    this.segments.push({ p1: prevPoint, p2: second, l: 0 });\r\n                    prevPoint = second;\r\n                }\r\n            }\r\n        }\r\n        // now go through our segments to calculate the lengths so that we\r\n        // can set up a nice weighted random distribution\r\n        for (var i = 0; i < this.segments.length; ++i) {\r\n            var _a = this.segments[i], p1 = _a.p1, p2 = _a.p2;\r\n            var segLength = Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\r\n            // save length so we can turn a random number into a 0-1 interpolation value later\r\n            this.segments[i].l = segLength;\r\n            this.totalLength += segLength;\r\n            // keep track of the length so far, counting up\r\n            this.countingLengths.push(this.totalLength);\r\n        }\r\n    };\r\n    /**\r\n     * Gets a random point in the chain.\r\n     * @param out The point to store the selected position in.\r\n     */\r\n    PolygonalChain.prototype.getRandomPoint = function (out) {\r\n        // select a random spot in the length of the chain\r\n        var rand = Math.random() * this.totalLength;\r\n        var chosenSeg;\r\n        var lerp;\r\n        // if only one segment, it wins\r\n        if (this.segments.length === 1) {\r\n            chosenSeg = this.segments[0];\r\n            lerp = rand;\r\n        }\r\n        else {\r\n            // otherwise, go through countingLengths until we have determined\r\n            // which segment we chose\r\n            for (var i = 0; i < this.countingLengths.length; ++i) {\r\n                if (rand < this.countingLengths[i]) {\r\n                    chosenSeg = this.segments[i];\r\n                    // set lerp equal to the length into that segment (i.e. the remainder after subtracting all the segments before it)\r\n                    lerp = i === 0 ? rand : rand - this.countingLengths[i - 1];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // divide lerp by the segment length, to result in a 0-1 number.\r\n        lerp /= chosenSeg.l || 1;\r\n        var p1 = chosenSeg.p1, p2 = chosenSeg.p2;\r\n        // now calculate the position in the segment that the lerp value represents\r\n        out.x = p1.x + lerp * (p2.x - p1.x);\r\n        out.y = p1.y + lerp * (p2.y - p1.y);\r\n    };\r\n    return PolygonalChain;\r\n}());\n\n// get the shared ticker, in V4 and V5 friendly methods\r\n/**\r\n * @hidden\r\n */\r\nvar ticker;\r\n// to avoid Rollup transforming our import, save pixi namespace in a variable\r\nvar pixiNS$1 = pixi_js__WEBPACK_IMPORTED_MODULE_0__;\r\nif (parseInt(/^(\\d+)\\./.exec(pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"VERSION\"])[1]) < 5) {\r\n    ticker = pixiNS$1.ticker.shared;\r\n}\r\nelse {\r\n    ticker = pixiNS$1.Ticker.shared;\r\n}\r\n/**\r\n * @hidden\r\n */\r\nvar helperPoint = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]();\r\n/**\r\n * A particle emitter.\r\n */\r\nvar Emitter = /** @class */ (function () {\r\n    /**\r\n     * @param particleParent The container to add the particles to.\r\n     * @param particleImages A texture or array of textures to use\r\n     *                       for the particles. Strings will be turned\r\n     *                       into textures via Texture.fromImage().\r\n     * @param config A configuration object containing settings for the emitter.\r\n     * @param config.emit If config.emit is explicitly passed as false, the\r\n     *                    Emitter will start disabled.\r\n     * @param config.autoUpdate If config.autoUpdate is explicitly passed as\r\n     *                          true, the Emitter will automatically call\r\n     *                          update via the PIXI shared ticker.\r\n     */\r\n    function Emitter(particleParent, particleImages, config) {\r\n        /**\r\n         * A number keeping index of currently applied image. Used to emit arts in order.\r\n         */\r\n        this._currentImageIndex = -1;\r\n        this._particleConstructor = Particle;\r\n        //properties for individual particles\r\n        this.particleImages = null;\r\n        this.startAlpha = null;\r\n        this.startSpeed = null;\r\n        this.minimumSpeedMultiplier = 1;\r\n        this.acceleration = null;\r\n        this.maxSpeed = NaN;\r\n        this.startScale = null;\r\n        this.minimumScaleMultiplier = 1;\r\n        this.startColor = null;\r\n        this.minLifetime = 0;\r\n        this.maxLifetime = 0;\r\n        this.minStartRotation = 0;\r\n        this.maxStartRotation = 0;\r\n        this.noRotation = false;\r\n        this.minRotationSpeed = 0;\r\n        this.maxRotationSpeed = 0;\r\n        this.particleBlendMode = 0;\r\n        this.customEase = null;\r\n        this.extraData = null;\r\n        //properties for spawning particles\r\n        this._frequency = 1;\r\n        this.spawnChance = 1;\r\n        this.maxParticles = 1000;\r\n        this.emitterLifetime = -1;\r\n        this.spawnPos = null;\r\n        this.spawnType = null;\r\n        this._spawnFunc = null;\r\n        this.spawnRect = null;\r\n        this.spawnCircle = null;\r\n        this.spawnPolygonalChain = null;\r\n        this.particlesPerWave = 1;\r\n        this.particleSpacing = 0;\r\n        this.angleStart = 0;\r\n        //emitter properties\r\n        this.rotation = 0;\r\n        this.ownerPos = null;\r\n        this._prevEmitterPos = null;\r\n        this._prevPosIsValid = false;\r\n        this._posChanged = false;\r\n        this._parent = null;\r\n        this.addAtBack = false;\r\n        this.particleCount = 0;\r\n        this._emit = false;\r\n        this._spawnTimer = 0;\r\n        this._emitterLife = -1;\r\n        this._activeParticlesFirst = null;\r\n        this._activeParticlesLast = null;\r\n        this._poolFirst = null;\r\n        this._origConfig = null;\r\n        this._origArt = null;\r\n        this._autoUpdate = false;\r\n        this._currentImageIndex = -1;\r\n        this._destroyWhenComplete = false;\r\n        this._completeCallback = null;\r\n        //set the initial parent\r\n        this.parent = particleParent;\r\n        if (particleImages && config)\r\n            this.init(particleImages, config);\r\n        //save often used functions on the instance instead of the prototype for better speed\r\n        this.recycle = this.recycle;\r\n        this.update = this.update;\r\n        this.rotate = this.rotate;\r\n        this.updateSpawnPos = this.updateSpawnPos;\r\n        this.updateOwnerPos = this.updateOwnerPos;\r\n    }\r\n    Object.defineProperty(Emitter.prototype, \"orderedArt\", {\r\n        /**\r\n         * If the emitter is using particle art in order as provided in `particleImages`.\r\n         * Effective only when `particleImages` has multiple art options.\r\n         * This is particularly useful ensuring that each art shows up once, in case you need to emit a body in an order.\r\n         * For example: dragon - [Head, body1, body2, ..., tail]\r\n         */\r\n        get: function () { return this._currentImageIndex !== -1; },\r\n        set: function (value) {\r\n            this._currentImageIndex = value ? 0 : -1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Emitter.prototype, \"frequency\", {\r\n        /**\r\n         * Time between particle spawns in seconds. If this value is not a number greater than 0,\r\n         * it will be set to 1 (particle per second) to prevent infinite loops.\r\n         */\r\n        get: function () { return this._frequency; },\r\n        set: function (value) {\r\n            //do some error checking to prevent infinite loops\r\n            if (typeof value == \"number\" && value > 0)\r\n                this._frequency = value;\r\n            else\r\n                this._frequency = 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Emitter.prototype, \"particleConstructor\", {\r\n        /**\r\n         * The constructor used to create new particles. The default is\r\n         * the built in Particle class. Setting this will dump any active or\r\n         * pooled particles, if the emitter has already been used.\r\n         */\r\n        get: function () { return this._particleConstructor; },\r\n        set: function (value) {\r\n            if (value != this._particleConstructor) {\r\n                this._particleConstructor = value;\r\n                //clean up existing particles\r\n                this.cleanup();\r\n                //scrap all the particles\r\n                for (var particle = this._poolFirst; particle; particle = particle.next) {\r\n                    particle.destroy();\r\n                }\r\n                this._poolFirst = null;\r\n                //re-initialize the emitter so that the new constructor can do anything it needs to\r\n                if (this._origConfig && this._origArt)\r\n                    this.init(this._origArt, this._origConfig);\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Emitter.prototype, \"parent\", {\r\n        /**\r\n        * The container to add particles to. Settings this will dump any active particles.\r\n        */\r\n        get: function () { return this._parent; },\r\n        set: function (value) {\r\n            this.cleanup();\r\n            this._parent = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Sets up the emitter based on the config settings.\r\n     * @param art A texture or array of textures to use for the particles.\r\n     * @param config A configuration object containing settings for the emitter.\r\n     */\r\n    Emitter.prototype.init = function (art, config) {\r\n        if (!art || !config)\r\n            return;\r\n        //clean up any existing particles\r\n        this.cleanup();\r\n        //store the original config and particle images, in case we need to re-initialize\r\n        //when the particle constructor is changed\r\n        this._origConfig = config;\r\n        this._origArt = art;\r\n        //set up the array of data, also ensuring that it is an array\r\n        art = Array.isArray(art) ? art.slice() : [art];\r\n        //run the art through the particle class's parsing function\r\n        var partClass = this._particleConstructor;\r\n        this.particleImages = partClass.parseArt ? partClass.parseArt(art) : art;\r\n        ///////////////////////////\r\n        // Particle Properties   //\r\n        ///////////////////////////\r\n        //set up the alpha\r\n        if (config.alpha) {\r\n            this.startAlpha = PropertyNode.createList(config.alpha);\r\n        }\r\n        else\r\n            this.startAlpha = new PropertyNode(1, 0);\r\n        //set up the speed\r\n        if (config.speed) {\r\n            this.startSpeed = PropertyNode.createList(config.speed);\r\n            this.minimumSpeedMultiplier = ('minimumSpeedMultiplier' in config ? config.minimumSpeedMultiplier : config.speed.minimumSpeedMultiplier) || 1;\r\n        }\r\n        else {\r\n            this.minimumSpeedMultiplier = 1;\r\n            this.startSpeed = new PropertyNode(0, 0);\r\n        }\r\n        //set up acceleration\r\n        var acceleration = config.acceleration;\r\n        if (acceleration && (acceleration.x || acceleration.y)) {\r\n            //make sure we disable speed interpolation\r\n            this.startSpeed.next = null;\r\n            this.acceleration = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](acceleration.x, acceleration.y);\r\n            this.maxSpeed = config.maxSpeed || NaN;\r\n        }\r\n        else\r\n            this.acceleration = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]();\r\n        //set up the scale\r\n        if (config.scale) {\r\n            this.startScale = PropertyNode.createList(config.scale);\r\n            this.minimumScaleMultiplier = ('minimumScaleMultiplier' in config ? config.minimumScaleMultiplier : config.scale.minimumScaleMultiplier) || 1;\r\n        }\r\n        else {\r\n            this.startScale = new PropertyNode(1, 0);\r\n            this.minimumScaleMultiplier = 1;\r\n        }\r\n        //set up the color\r\n        if (config.color) {\r\n            this.startColor = PropertyNode.createList(config.color);\r\n        }\r\n        else {\r\n            this.startColor = new PropertyNode({ r: 0xFF, g: 0xFF, b: 0xFF }, 0);\r\n        }\r\n        //set up the start rotation\r\n        if (config.startRotation) {\r\n            this.minStartRotation = config.startRotation.min;\r\n            this.maxStartRotation = config.startRotation.max;\r\n        }\r\n        else\r\n            this.minStartRotation = this.maxStartRotation = 0;\r\n        if (config.noRotation &&\r\n            (this.minStartRotation || this.maxStartRotation)) {\r\n            this.noRotation = !!config.noRotation;\r\n        }\r\n        else\r\n            this.noRotation = false;\r\n        //set up the rotation speed\r\n        if (config.rotationSpeed) {\r\n            this.minRotationSpeed = config.rotationSpeed.min;\r\n            this.maxRotationSpeed = config.rotationSpeed.max;\r\n        }\r\n        else\r\n            this.minRotationSpeed = this.maxRotationSpeed = 0;\r\n        this.rotationAcceleration = config.rotationAcceleration || 0;\r\n        //set up the lifetime\r\n        this.minLifetime = config.lifetime.min;\r\n        this.maxLifetime = config.lifetime.max;\r\n        //get the blend mode\r\n        this.particleBlendMode = ParticleUtils.getBlendMode(config.blendMode);\r\n        //use the custom ease if provided\r\n        if (config.ease) {\r\n            this.customEase = typeof config.ease == \"function\" ?\r\n                config.ease : ParticleUtils.generateEase(config.ease);\r\n        }\r\n        else\r\n            this.customEase = null;\r\n        //set up the extra data, running it through the particle class's parseData function.\r\n        if (partClass.parseData)\r\n            this.extraData = partClass.parseData(config.extraData);\r\n        else\r\n            this.extraData = config.extraData || null;\r\n        //////////////////////////\r\n        // Emitter Properties   //\r\n        //////////////////////////\r\n        //reset spawn type specific settings\r\n        this.spawnRect = this.spawnCircle = null;\r\n        this.particlesPerWave = 1;\r\n        if (config.particlesPerWave && config.particlesPerWave > 1)\r\n            this.particlesPerWave = config.particlesPerWave;\r\n        this.particleSpacing = 0;\r\n        this.angleStart = 0;\r\n        //determine the spawn function to use\r\n        this.parseSpawnType(config);\r\n        //set the spawning frequency\r\n        this.frequency = config.frequency;\r\n        this.spawnChance = (typeof config.spawnChance === 'number' && config.spawnChance > 0) ? config.spawnChance : 1;\r\n        //set the emitter lifetime\r\n        this.emitterLifetime = config.emitterLifetime || -1;\r\n        //set the max particles\r\n        this.maxParticles = config.maxParticles > 0 ? config.maxParticles : 1000;\r\n        //determine if we should add the particle at the back of the list or not\r\n        this.addAtBack = !!config.addAtBack;\r\n        //reset the emitter position and rotation variables\r\n        this.rotation = 0;\r\n        this.ownerPos = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]();\r\n        this.spawnPos = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](config.pos.x, config.pos.y);\r\n        this.initAdditional(art, config);\r\n        this._prevEmitterPos = this.spawnPos.clone();\r\n        //previous emitter position is invalid and should not be used for interpolation\r\n        this._prevPosIsValid = false;\r\n        //start emitting\r\n        this._spawnTimer = 0;\r\n        this.emit = config.emit === undefined ? true : !!config.emit;\r\n        this.autoUpdate = !!config.autoUpdate;\r\n        this.orderedArt = !!config.orderedArt;\r\n    };\r\n    /**\r\n     * Sets up additional parameters to the emitter from config settings.\r\n     * Using for parsing additional parameters on classes that extend from Emitter\r\n     * @param art A texture or array of textures to use for the particles.\r\n     * @param config A configuration object containing settings for the emitter.\r\n     */\r\n    Emitter.prototype.initAdditional = function (art, config) {\r\n    };\r\n    /**\r\n     * Parsing emitter spawn type from config settings.\r\n     * Place for override and add new kind of spawn type\r\n     * @param config A configuration object containing settings for the emitter.\r\n     */\r\n    Emitter.prototype.parseSpawnType = function (config) {\r\n        var spawnCircle;\r\n        switch (config.spawnType) {\r\n            case \"rect\":\r\n                this.spawnType = \"rect\";\r\n                this._spawnFunc = this._spawnRect;\r\n                var spawnRect = config.spawnRect;\r\n                this.spawnRect = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Rectangle\"](spawnRect.x, spawnRect.y, spawnRect.w, spawnRect.h);\r\n                break;\r\n            case \"circle\":\r\n                this.spawnType = \"circle\";\r\n                this._spawnFunc = this._spawnCircle;\r\n                spawnCircle = config.spawnCircle;\r\n                this.spawnCircle = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Circle\"](spawnCircle.x, spawnCircle.y, spawnCircle.r);\r\n                break;\r\n            case \"ring\":\r\n                this.spawnType = \"ring\";\r\n                this._spawnFunc = this._spawnRing;\r\n                spawnCircle = config.spawnCircle;\r\n                this.spawnCircle = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Circle\"](spawnCircle.x, spawnCircle.y, spawnCircle.r);\r\n                this.spawnCircle.minRadius = spawnCircle.minR;\r\n                break;\r\n            case \"burst\":\r\n                this.spawnType = \"burst\";\r\n                this._spawnFunc = this._spawnBurst;\r\n                this.particleSpacing = config.particleSpacing;\r\n                this.angleStart = config.angleStart ? config.angleStart : 0;\r\n                break;\r\n            case \"point\":\r\n                this.spawnType = \"point\";\r\n                this._spawnFunc = this._spawnPoint;\r\n                break;\r\n            case \"polygonalChain\":\r\n                this.spawnType = \"polygonalChain\";\r\n                this._spawnFunc = this._spawnPolygonalChain;\r\n                this.spawnPolygonalChain = new PolygonalChain(config.spawnPolygon);\r\n                break;\r\n            default:\r\n                this.spawnType = \"point\";\r\n                this._spawnFunc = this._spawnPoint;\r\n                break;\r\n        }\r\n    };\r\n    /**\r\n     * Recycles an individual particle. For internal use only.\r\n     * @param particle The particle to recycle.\r\n     * @internal\r\n     */\r\n    Emitter.prototype.recycle = function (particle) {\r\n        if (particle.next)\r\n            particle.next.prev = particle.prev;\r\n        if (particle.prev)\r\n            particle.prev.next = particle.next;\r\n        if (particle == this._activeParticlesLast)\r\n            this._activeParticlesLast = particle.prev;\r\n        if (particle == this._activeParticlesFirst)\r\n            this._activeParticlesFirst = particle.next;\r\n        //add to pool\r\n        particle.prev = null;\r\n        particle.next = this._poolFirst;\r\n        this._poolFirst = particle;\r\n        //remove child from display, or make it invisible if it is in a ParticleContainer\r\n        if (particle.parent)\r\n            particle.parent.removeChild(particle);\r\n        //decrease count\r\n        --this.particleCount;\r\n    };\r\n    /**\r\n     * Sets the rotation of the emitter to a new value.\r\n     * @param newRot The new rotation, in degrees.\r\n     */\r\n    Emitter.prototype.rotate = function (newRot) {\r\n        if (this.rotation == newRot)\r\n            return;\r\n        //caclulate the difference in rotation for rotating spawnPos\r\n        var diff = newRot - this.rotation;\r\n        this.rotation = newRot;\r\n        //rotate spawnPos\r\n        ParticleUtils.rotatePoint(diff, this.spawnPos);\r\n        //mark the position as having changed\r\n        this._posChanged = true;\r\n    };\r\n    /**\r\n     * Changes the spawn position of the emitter.\r\n     * @param x The new x value of the spawn position for the emitter.\r\n     * @param y The new y value of the spawn position for the emitter.\r\n     */\r\n    Emitter.prototype.updateSpawnPos = function (x, y) {\r\n        this._posChanged = true;\r\n        this.spawnPos.x = x;\r\n        this.spawnPos.y = y;\r\n    };\r\n    /**\r\n     * Changes the position of the emitter's owner. You should call this if you are adding\r\n     * particles to the world container that your emitter's owner is moving around in.\r\n     * @param x The new x value of the emitter's owner.\r\n     * @param y The new y value of the emitter's owner.\r\n     */\r\n    Emitter.prototype.updateOwnerPos = function (x, y) {\r\n        this._posChanged = true;\r\n        this.ownerPos.x = x;\r\n        this.ownerPos.y = y;\r\n    };\r\n    /**\r\n     * Prevents emitter position interpolation in the next update.\r\n     * This should be used if you made a major position change of your emitter's owner\r\n     * that was not normal movement.\r\n     */\r\n    Emitter.prototype.resetPositionTracking = function () {\r\n        this._prevPosIsValid = false;\r\n    };\r\n    Object.defineProperty(Emitter.prototype, \"emit\", {\r\n        /**\r\n         * If particles should be emitted during update() calls. Setting this to false\r\n         * stops new particles from being created, but allows existing ones to die out.\r\n         */\r\n        get: function () { return this._emit; },\r\n        set: function (value) {\r\n            this._emit = !!value;\r\n            this._emitterLife = this.emitterLifetime;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Emitter.prototype, \"autoUpdate\", {\r\n        /**\r\n         * If the update function is called automatically from the shared ticker.\r\n         * Setting this to false requires calling the update function manually.\r\n         */\r\n        get: function () { return this._autoUpdate; },\r\n        set: function (value) {\r\n            if (this._autoUpdate && !value) {\r\n                ticker.remove(this.update, this);\r\n            }\r\n            else if (!this._autoUpdate && value) {\r\n                ticker.add(this.update, this);\r\n            }\r\n            this._autoUpdate = !!value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself\r\n     * when particle emission is complete.\r\n     * @param callback Callback for when emission is complete (all particles have died off)\r\n     */\r\n    Emitter.prototype.playOnceAndDestroy = function (callback) {\r\n        this.autoUpdate = true;\r\n        this.emit = true;\r\n        this._destroyWhenComplete = true;\r\n        this._completeCallback = callback;\r\n    };\r\n    /**\r\n     * Starts emitting particles and optionally calls a callback when particle emission is complete.\r\n     * @param callback Callback for when emission is complete (all particles have died off)\r\n     */\r\n    Emitter.prototype.playOnce = function (callback) {\r\n        this.emit = true;\r\n        this._completeCallback = callback;\r\n    };\r\n    /**\r\n     * Updates all particles spawned by this emitter and emits new ones.\r\n     * @param delta Time elapsed since the previous frame, in __seconds__.\r\n     */\r\n    Emitter.prototype.update = function (delta) {\r\n        if (this._autoUpdate) {\r\n            delta = delta / pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"settings\"].TARGET_FPMS / 1000;\r\n        }\r\n        //if we don't have a parent to add particles to, then don't do anything.\r\n        //this also works as a isDestroyed check\r\n        if (!this._parent)\r\n            return;\r\n        //update existing particles\r\n        var i, particle, next;\r\n        for (particle = this._activeParticlesFirst; particle; particle = next) {\r\n            next = particle.next;\r\n            particle.update(delta);\r\n        }\r\n        var prevX, prevY;\r\n        //if the previous position is valid, store these for later interpolation\r\n        if (this._prevPosIsValid) {\r\n            prevX = this._prevEmitterPos.x;\r\n            prevY = this._prevEmitterPos.y;\r\n        }\r\n        //store current position of the emitter as local variables\r\n        var curX = this.ownerPos.x + this.spawnPos.x;\r\n        var curY = this.ownerPos.y + this.spawnPos.y;\r\n        //spawn new particles\r\n        if (this._emit) {\r\n            //decrease spawn timer\r\n            this._spawnTimer -= delta < 0 ? 0 : delta;\r\n            //while _spawnTimer < 0, we have particles to spawn\r\n            while (this._spawnTimer <= 0) {\r\n                //determine if the emitter should stop spawning\r\n                if (this._emitterLife > 0) {\r\n                    this._emitterLife -= this._frequency;\r\n                    if (this._emitterLife <= 0) {\r\n                        this._spawnTimer = 0;\r\n                        this._emitterLife = 0;\r\n                        this.emit = false;\r\n                        break;\r\n                    }\r\n                }\r\n                //determine if we have hit the particle limit\r\n                if (this.particleCount >= this.maxParticles) {\r\n                    this._spawnTimer += this._frequency;\r\n                    continue;\r\n                }\r\n                //determine the particle lifetime\r\n                var lifetime = void 0;\r\n                if (this.minLifetime == this.maxLifetime)\r\n                    lifetime = this.minLifetime;\r\n                else\r\n                    lifetime = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime;\r\n                //only make the particle if it wouldn't immediately destroy itself\r\n                if (-this._spawnTimer < lifetime) {\r\n                    //If the position has changed and this isn't the first spawn,\r\n                    //interpolate the spawn position\r\n                    var emitPosX = void 0, emitPosY = void 0;\r\n                    if (this._prevPosIsValid && this._posChanged) {\r\n                        //1 - _spawnTimer / delta, but _spawnTimer is negative\r\n                        var lerp = 1 + this._spawnTimer / delta;\r\n                        emitPosX = (curX - prevX) * lerp + prevX;\r\n                        emitPosY = (curY - prevY) * lerp + prevY;\r\n                    }\r\n                    else //otherwise just set to the spawn position\r\n                     {\r\n                        emitPosX = curX;\r\n                        emitPosY = curY;\r\n                    }\r\n                    //create enough particles to fill the wave (non-burst types have a wave of 1)\r\n                    i = 0;\r\n                    for (var len = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount); i < len; ++i) {\r\n                        //see if we actually spawn one\r\n                        if (this.spawnChance < 1 && Math.random() >= this.spawnChance)\r\n                            continue;\r\n                        //create particle\r\n                        var p = void 0;\r\n                        if (this._poolFirst) {\r\n                            p = this._poolFirst;\r\n                            this._poolFirst = this._poolFirst.next;\r\n                            p.next = null;\r\n                        }\r\n                        else {\r\n                            p = new this.particleConstructor(this);\r\n                        }\r\n                        //set a random texture if we have more than one\r\n                        if (this.particleImages.length > 1) {\r\n                            // if using ordered art\r\n                            if (this._currentImageIndex !== -1) {\r\n                                // get current art index, then increment for the next particle\r\n                                p.applyArt(this.particleImages[this._currentImageIndex++]);\r\n                                // loop around if needed\r\n                                if (this._currentImageIndex < 0 || this._currentImageIndex >= this.particleImages.length) {\r\n                                    this._currentImageIndex = 0;\r\n                                }\r\n                            }\r\n                            // otherwise grab a random one\r\n                            else {\r\n                                p.applyArt(this.particleImages[Math.floor(Math.random() * this.particleImages.length)]);\r\n                            }\r\n                        }\r\n                        else {\r\n                            //if they are actually the same texture, a standard particle\r\n                            //will quit early from the texture setting in setTexture().\r\n                            p.applyArt(this.particleImages[0]);\r\n                        }\r\n                        //set up the start and end values\r\n                        p.alphaList.reset(this.startAlpha);\r\n                        if (this.minimumSpeedMultiplier != 1) {\r\n                            p.speedMultiplier = Math.random() * (1 - this.minimumSpeedMultiplier) + this.minimumSpeedMultiplier;\r\n                        }\r\n                        p.speedList.reset(this.startSpeed);\r\n                        p.acceleration.x = this.acceleration.x;\r\n                        p.acceleration.y = this.acceleration.y;\r\n                        p.maxSpeed = this.maxSpeed;\r\n                        if (this.minimumScaleMultiplier != 1) {\r\n                            p.scaleMultiplier = Math.random() * (1 - this.minimumScaleMultiplier) + this.minimumScaleMultiplier;\r\n                        }\r\n                        p.scaleList.reset(this.startScale);\r\n                        p.colorList.reset(this.startColor);\r\n                        //randomize the rotation speed\r\n                        if (this.minRotationSpeed == this.maxRotationSpeed)\r\n                            p.rotationSpeed = this.minRotationSpeed;\r\n                        else\r\n                            p.rotationSpeed = Math.random() * (this.maxRotationSpeed - this.minRotationSpeed) + this.minRotationSpeed;\r\n                        p.rotationAcceleration = this.rotationAcceleration;\r\n                        p.noRotation = this.noRotation;\r\n                        //set up the lifetime\r\n                        p.maxLife = lifetime;\r\n                        //set the blend mode\r\n                        p.blendMode = this.particleBlendMode;\r\n                        //set the custom ease, if any\r\n                        p.ease = this.customEase;\r\n                        //set the extra data, if any\r\n                        p.extraData = this.extraData;\r\n                        //set additional properties to particle\r\n                        this.applyAdditionalProperties(p);\r\n                        //call the proper function to handle rotation and position of particle\r\n                        this._spawnFunc(p, emitPosX, emitPosY, i);\r\n                        //initialize particle\r\n                        p.init();\r\n                        //update the particle by the time passed, so the particles are spread out properly\r\n                        p.update(-this._spawnTimer); //we want a positive delta, because a negative delta messes things up\r\n                        //add the particle to the display list\r\n                        if (!p.parent) {\r\n                            if (this.addAtBack)\r\n                                this._parent.addChildAt(p, 0);\r\n                            else\r\n                                this._parent.addChild(p);\r\n                        }\r\n                        else {\r\n                            //kind of hacky, but performance friendly\r\n                            //shuffle children to correct place\r\n                            var children = this._parent.children;\r\n                            //avoid using splice if possible\r\n                            if (children[0] == p)\r\n                                children.shift();\r\n                            else if (children[children.length - 1] == p)\r\n                                children.pop();\r\n                            else {\r\n                                var index = children.indexOf(p);\r\n                                children.splice(index, 1);\r\n                            }\r\n                            if (this.addAtBack)\r\n                                children.unshift(p);\r\n                            else\r\n                                children.push(p);\r\n                        }\r\n                        //add particle to list of active particles\r\n                        if (this._activeParticlesLast) {\r\n                            this._activeParticlesLast.next = p;\r\n                            p.prev = this._activeParticlesLast;\r\n                            this._activeParticlesLast = p;\r\n                        }\r\n                        else {\r\n                            this._activeParticlesLast = this._activeParticlesFirst = p;\r\n                        }\r\n                        ++this.particleCount;\r\n                    }\r\n                }\r\n                //increase timer and continue on to any other particles that need to be created\r\n                this._spawnTimer += this._frequency;\r\n            }\r\n        }\r\n        //if the position changed before this update, then keep track of that\r\n        if (this._posChanged) {\r\n            this._prevEmitterPos.x = curX;\r\n            this._prevEmitterPos.y = curY;\r\n            this._prevPosIsValid = true;\r\n            this._posChanged = false;\r\n        }\r\n        //if we are all done and should destroy ourselves, take care of that\r\n        if (!this._emit && !this._activeParticlesFirst) {\r\n            if (this._completeCallback) {\r\n                var cb = this._completeCallback;\r\n                this._completeCallback = null;\r\n                cb();\r\n            }\r\n            if (this._destroyWhenComplete) {\r\n                this.destroy();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Set additional properties to new particle.\r\n     * Using on classes that extend from Emitter\r\n     * @param p The particle\r\n     */\r\n    Emitter.prototype.applyAdditionalProperties = function (p) {\r\n    };\r\n    /**\r\n     * Positions a particle for a point type emitter.\r\n     * @param p The particle to position and rotate.\r\n     * @param emitPosX The emitter's x position\r\n     * @param emitPosY The emitter's y position\r\n     * @param i The particle number in the current wave. Not used for this function.\r\n     */\r\n    Emitter.prototype._spawnPoint = function (p, emitPosX, emitPosY) {\r\n        //set the initial rotation/direction of the particle based on\r\n        //starting particle angle and rotation of emitter\r\n        if (this.minStartRotation == this.maxStartRotation)\r\n            p.rotation = this.minStartRotation + this.rotation;\r\n        else\r\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;\r\n        //drop the particle at the emitter's position\r\n        p.position.x = emitPosX;\r\n        p.position.y = emitPosY;\r\n    };\r\n    /**\r\n     * Positions a particle for a rectangle type emitter.\r\n     * @param p The particle to position and rotate.\r\n     * @param emitPosX The emitter's x position\r\n     * @param emitPosY The emitter's y position\r\n     * @param i The particle number in the current wave. Not used for this function.\r\n     */\r\n    Emitter.prototype._spawnRect = function (p, emitPosX, emitPosY) {\r\n        //set the initial rotation/direction of the particle based on starting\r\n        //particle angle and rotation of emitter\r\n        if (this.minStartRotation == this.maxStartRotation)\r\n            p.rotation = this.minStartRotation + this.rotation;\r\n        else\r\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) + this.minStartRotation + this.rotation;\r\n        //place the particle at a random point in the rectangle\r\n        helperPoint.x = Math.random() * this.spawnRect.width + this.spawnRect.x;\r\n        helperPoint.y = Math.random() * this.spawnRect.height + this.spawnRect.y;\r\n        if (this.rotation !== 0)\r\n            ParticleUtils.rotatePoint(this.rotation, helperPoint);\r\n        p.position.x = emitPosX + helperPoint.x;\r\n        p.position.y = emitPosY + helperPoint.y;\r\n    };\r\n    /**\r\n     * Positions a particle for a circle type emitter.\r\n     * @param p The particle to position and rotate.\r\n     * @param emitPosX The emitter's x position\r\n     * @param emitPosY The emitter's y position\r\n     * @param i The particle number in the current wave. Not used for this function.\r\n     */\r\n    Emitter.prototype._spawnCircle = function (p, emitPosX, emitPosY) {\r\n        //set the initial rotation/direction of the particle based on starting\r\n        //particle angle and rotation of emitter\r\n        if (this.minStartRotation == this.maxStartRotation)\r\n            p.rotation = this.minStartRotation + this.rotation;\r\n        else\r\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\r\n                this.minStartRotation + this.rotation;\r\n        //place the particle at a random radius in the circle\r\n        helperPoint.x = Math.random() * this.spawnCircle.radius;\r\n        helperPoint.y = 0;\r\n        //rotate the point to a random angle in the circle\r\n        ParticleUtils.rotatePoint(Math.random() * 360, helperPoint);\r\n        //offset by the circle's center\r\n        helperPoint.x += this.spawnCircle.x;\r\n        helperPoint.y += this.spawnCircle.y;\r\n        //rotate the point by the emitter's rotation\r\n        if (this.rotation !== 0)\r\n            ParticleUtils.rotatePoint(this.rotation, helperPoint);\r\n        //set the position, offset by the emitter's position\r\n        p.position.x = emitPosX + helperPoint.x;\r\n        p.position.y = emitPosY + helperPoint.y;\r\n    };\r\n    /**\r\n     * Positions a particle for a ring type emitter.\r\n     * @param p The particle to position and rotate.\r\n     * @param emitPosX The emitter's x position\r\n     * @param emitPosY The emitter's y position\r\n     * @param i The particle number in the current wave. Not used for this function.\r\n     */\r\n    Emitter.prototype._spawnRing = function (p, emitPosX, emitPosY) {\r\n        var spawnCircle = this.spawnCircle;\r\n        //set the initial rotation/direction of the particle based on starting\r\n        //particle angle and rotation of emitter\r\n        if (this.minStartRotation == this.maxStartRotation)\r\n            p.rotation = this.minStartRotation + this.rotation;\r\n        else\r\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\r\n                this.minStartRotation + this.rotation;\r\n        //place the particle at a random radius in the ring\r\n        if (spawnCircle.minRadius !== spawnCircle.radius) {\r\n            helperPoint.x = Math.random() * (spawnCircle.radius - spawnCircle.minRadius) +\r\n                spawnCircle.minRadius;\r\n        }\r\n        else\r\n            helperPoint.x = spawnCircle.radius;\r\n        helperPoint.y = 0;\r\n        //rotate the point to a random angle in the circle\r\n        var angle = Math.random() * 360;\r\n        p.rotation += angle;\r\n        ParticleUtils.rotatePoint(angle, helperPoint);\r\n        //offset by the circle's center\r\n        helperPoint.x += this.spawnCircle.x;\r\n        helperPoint.y += this.spawnCircle.y;\r\n        //rotate the point by the emitter's rotation\r\n        if (this.rotation !== 0)\r\n            ParticleUtils.rotatePoint(this.rotation, helperPoint);\r\n        //set the position, offset by the emitter's position\r\n        p.position.x = emitPosX + helperPoint.x;\r\n        p.position.y = emitPosY + helperPoint.y;\r\n    };\r\n    /**\r\n     * Positions a particle for polygonal chain.\r\n     * @param p The particle to position and rotate.\r\n     * @param emitPosX The emitter's x position\r\n     * @param emitPosY The emitter's y position\r\n     * @param i The particle number in the current wave. Not used for this function.\r\n     */\r\n    Emitter.prototype._spawnPolygonalChain = function (p, emitPosX, emitPosY) {\r\n        //set the initial rotation/direction of the particle based on starting\r\n        //particle angle and rotation of emitter\r\n        if (this.minStartRotation == this.maxStartRotation)\r\n            p.rotation = this.minStartRotation + this.rotation;\r\n        else\r\n            p.rotation = Math.random() * (this.maxStartRotation - this.minStartRotation) +\r\n                this.minStartRotation + this.rotation;\r\n        // get random point on the polygon chain\r\n        this.spawnPolygonalChain.getRandomPoint(helperPoint);\r\n        //rotate the point by the emitter's rotation\r\n        if (this.rotation !== 0)\r\n            ParticleUtils.rotatePoint(this.rotation, helperPoint);\r\n        //set the position, offset by the emitter's position\r\n        p.position.x = emitPosX + helperPoint.x;\r\n        p.position.y = emitPosY + helperPoint.y;\r\n    };\r\n    /**\r\n     * Positions a particle for a burst type emitter.\r\n     * @param p The particle to position and rotate.\r\n     * @param emitPosX The emitter's x position\r\n     * @param emitPosY The emitter's y position\r\n     * @param i The particle number in the current wave.\r\n     */\r\n    Emitter.prototype._spawnBurst = function (p, emitPosX, emitPosY, i) {\r\n        //set the initial rotation/direction of the particle based on spawn\r\n        //angle and rotation of emitter\r\n        if (this.particleSpacing === 0)\r\n            p.rotation = Math.random() * 360;\r\n        else\r\n            p.rotation = this.angleStart + (this.particleSpacing * i) + this.rotation;\r\n        //drop the particle at the emitter's position\r\n        p.position.x = emitPosX;\r\n        p.position.y = emitPosY;\r\n    };\r\n    /**\r\n     * Kills all active particles immediately.\r\n     */\r\n    Emitter.prototype.cleanup = function () {\r\n        var particle, next;\r\n        for (particle = this._activeParticlesFirst; particle; particle = next) {\r\n            next = particle.next;\r\n            this.recycle(particle);\r\n            if (particle.parent)\r\n                particle.parent.removeChild(particle);\r\n        }\r\n        this._activeParticlesFirst = this._activeParticlesLast = null;\r\n        this.particleCount = 0;\r\n    };\r\n    /**\r\n     * Destroys the emitter and all of its particles.\r\n     */\r\n    Emitter.prototype.destroy = function () {\r\n        //make sure we aren't still listening to any tickers\r\n        this.autoUpdate = false;\r\n        //puts all active particles in the pool, and removes them from the particle parent\r\n        this.cleanup();\r\n        //wipe the pool clean\r\n        var next;\r\n        for (var particle = this._poolFirst; particle; particle = next) {\r\n            //store next value so we don't lose it in our destroy call\r\n            next = particle.next;\r\n            particle.destroy();\r\n        }\r\n        this._poolFirst = this._parent = this.particleImages = this.spawnPos = this.ownerPos =\r\n            this.startColor = this.startScale = this.startAlpha = this.startSpeed =\r\n                this.customEase = this._completeCallback = null;\r\n    };\r\n    return Emitter;\r\n}());\n\n/**\r\n * A helper point for math things.\r\n * @hidden\r\n */\r\nvar helperPoint$1 = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]();\r\n/**\r\n * A hand picked list of Math functions (and a couple properties) that are\r\n * allowable. They should be used without the preceding \"Math.\"\r\n * @hidden\r\n */\r\nvar MATH_FUNCS = [\r\n    \"pow\",\r\n    \"sqrt\",\r\n    \"abs\",\r\n    \"floor\",\r\n    \"round\",\r\n    \"ceil\",\r\n    \"E\",\r\n    \"PI\",\r\n    \"sin\",\r\n    \"cos\",\r\n    \"tan\",\r\n    \"asin\",\r\n    \"acos\",\r\n    \"atan\",\r\n    \"atan2\",\r\n    \"log\"\r\n];\r\n/**\r\n * create an actual regular expression object from the string\r\n * @hidden\r\n */\r\nvar WHITELISTER = new RegExp([\r\n    //Allow the 4 basic operations, parentheses and all numbers/decimals, as well\r\n    //as 'x', for the variable usage.\r\n    \"[01234567890\\\\.\\\\*\\\\-\\\\+\\\\/\\\\(\\\\)x ,]\",\r\n].concat(MATH_FUNCS).join(\"|\"), \"g\");\r\n/**\r\n * Parses a string into a function for path following.\r\n * This involves whitelisting the string for safety, inserting \"Math.\" to math function\r\n * names, and using `new Function()` to generate a function.\r\n * @hidden\r\n * @param pathString The string to parse.\r\n * @return The path function - takes x, outputs y.\r\n */\r\nvar parsePath = function (pathString) {\r\n    var matches = pathString.match(WHITELISTER);\r\n    for (var i = matches.length - 1; i >= 0; --i) {\r\n        if (MATH_FUNCS.indexOf(matches[i]) >= 0)\r\n            matches[i] = \"Math.\" + matches[i];\r\n    }\r\n    pathString = matches.join(\"\");\r\n    return new Function(\"x\", \"return \" + pathString + \";\");\r\n};\r\n/**\r\n * An particle that follows a path defined by an algebraic expression, e.g. \"sin(x)\" or\r\n * \"5x + 3\".\r\n * To use this class, the particle config must have a \"path\" string in the\r\n * \"extraData\" parameter. This string should have \"x\" in it to represent movement (from the\r\n * speed settings of the particle). It may have numbers, parentheses, the four basic\r\n * operations, and the following Math functions or properties (without the preceding \"Math.\"):\r\n * \"pow\", \"sqrt\", \"abs\", \"floor\", \"round\", \"ceil\", \"E\", \"PI\", \"sin\", \"cos\", \"tan\", \"asin\",\r\n * \"acos\", \"atan\", \"atan2\", \"log\".\r\n * The overall movement of the particle and the expression value become x and y positions for\r\n * the particle, respectively. The final position is rotated by the spawn rotation/angle of\r\n * the particle.\r\n *\r\n * Some example paths:\r\n *\r\n * \t\"sin(x/10) * 20\" // A sine wave path.\r\n * \t\"cos(x/100) * 30\" // Particles curve counterclockwise (for medium speed/low lifetime particles)\r\n * \t\"pow(x/10, 2) / 2\" // Particles curve clockwise (remember, +y is down).\r\n */\r\nvar PathParticle = /** @class */ (function (_super) {\r\n    __extends(PathParticle, _super);\r\n    /**\r\n     * @param {PIXI.particles.Emitter} emitter The emitter that controls this PathParticle.\r\n     */\r\n    function PathParticle(emitter) {\r\n        var _this = _super.call(this, emitter) || this;\r\n        _this.path = null;\r\n        _this.initialRotation = 0;\r\n        _this.initialPosition = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]();\r\n        _this.movement = 0;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Initializes the particle for use, based on the properties that have to\r\n     * have been set already on the particle.\r\n     */\r\n    PathParticle.prototype.init = function () {\r\n        //get initial rotation before it is converted to radians\r\n        this.initialRotation = this.rotation;\r\n        //standard init\r\n        this.Particle_init();\r\n        //set the path for the particle\r\n        this.path = this.extraData.path;\r\n        //cancel the normal movement behavior\r\n        this._doNormalMovement = !this.path;\r\n        //reset movement\r\n        this.movement = 0;\r\n        //grab position\r\n        this.initialPosition.x = this.position.x;\r\n        this.initialPosition.y = this.position.y;\r\n    };\r\n    /**\r\n     * Updates the particle.\r\n     * @param delta Time elapsed since the previous frame, in __seconds__.\r\n     */\r\n    PathParticle.prototype.update = function (delta) {\r\n        var lerp = this.Particle_update(delta);\r\n        //if the particle died during the update, then don't bother\r\n        if (lerp >= 0 && this.path) {\r\n            //increase linear movement based on speed\r\n            var speed = this.speedList.interpolate(lerp) * this.speedMultiplier;\r\n            this.movement += speed * delta;\r\n            //set up the helper point for rotation\r\n            helperPoint$1.x = this.movement;\r\n            helperPoint$1.y = this.path(this.movement);\r\n            ParticleUtils.rotatePoint(this.initialRotation, helperPoint$1);\r\n            this.position.x = this.initialPosition.x + helperPoint$1.x;\r\n            this.position.y = this.initialPosition.y + helperPoint$1.y;\r\n        }\r\n        return lerp;\r\n    };\r\n    /**\r\n     * Destroys the particle, removing references and preventing future use.\r\n     */\r\n    PathParticle.prototype.destroy = function () {\r\n        this.Particle_destroy();\r\n        this.path = this.initialPosition = null;\r\n    };\r\n    /**\r\n     * Checks over the art that was passed to the Emitter's init() function, to do any special\r\n     * modifications to prepare it ahead of time. This just runs Particle.parseArt().\r\n     * @param art The array of art data. For Particle, it should be an array of\r\n     *            Textures. Any strings in the array will be converted to\r\n     *            Textures via Texture.fromImage().\r\n     * @return The art, after any needed modifications.\r\n     */\r\n    PathParticle.parseArt = function (art) {\r\n        return Particle.parseArt(art);\r\n    };\r\n    /**\r\n     * Parses extra emitter data to ensure it is set up for this particle class.\r\n     * PathParticle checks for the existence of path data, and parses the path data for use\r\n     * by particle instances.\r\n     * @param extraData The extra data from the particle config.\r\n     * @return The parsed extra data.\r\n     */\r\n    PathParticle.parseData = function (extraData) {\r\n        var output = {};\r\n        if (extraData && extraData.path) {\r\n            try {\r\n                output.path = parsePath(extraData.path);\r\n            }\r\n            catch (e) {\r\n                if (ParticleUtils.verbose)\r\n                    console.error(\"PathParticle: error in parsing path expression\");\r\n                output.path = null;\r\n            }\r\n        }\r\n        else {\r\n            if (ParticleUtils.verbose)\r\n                console.error(\"PathParticle requires a path string in extraData!\");\r\n            output.path = null;\r\n        }\r\n        return output;\r\n    };\r\n    return PathParticle;\r\n}(Particle));\n\n/**\r\n * An individual particle image with an animation. Art data passed to the emitter must be\r\n * formatted in a particular way for AnimatedParticle to be able to handle it:\r\n *\r\n * ```typescript\r\n * {\r\n *     //framerate is required. It is the animation speed of the particle in frames per\r\n *     //second.\r\n *     //A value of \"matchLife\" causes the animation to match the lifetime of an individual\r\n *     //particle, instead of at a constant framerate. This causes the animation to play\r\n *     //through one time, completing when the particle expires.\r\n *     framerate: 6,\r\n *     //loop is optional, and defaults to false.\r\n *     loop: true,\r\n *     //textures is required, and can be an array of any (non-zero) length.\r\n *     textures: [\r\n *         //each entry represents a single texture that should be used for one or more\r\n *         //frames. Any strings will be converted to Textures with Texture.from().\r\n *         //Instances of PIXI.Texture will be used directly.\r\n *         \"animFrame1.png\",\r\n *         //entries can be an object with a 'count' property, telling AnimatedParticle to\r\n *         //use that texture for 'count' frames sequentially.\r\n *         {\r\n *             texture: \"animFrame2.png\",\r\n *             count: 3\r\n *         },\r\n *         \"animFrame3.png\"\r\n *     ]\r\n * }\r\n * ```\r\n */\r\nvar AnimatedParticle = /** @class */ (function (_super) {\r\n    __extends(AnimatedParticle, _super);\r\n    /**\r\n     * @param emitter The emitter that controls this AnimatedParticle.\r\n     */\r\n    function AnimatedParticle(emitter) {\r\n        var _this = _super.call(this, emitter) || this;\r\n        _this.textures = null;\r\n        _this.duration = 0;\r\n        _this.framerate = 0;\r\n        _this.elapsed = 0;\r\n        _this.loop = false;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Initializes the particle for use, based on the properties that have to\r\n     * have been set already on the particle.\r\n     */\r\n    AnimatedParticle.prototype.init = function () {\r\n        this.Particle_init();\r\n        this.elapsed = 0;\r\n        //if the animation needs to match the particle's life, then cacluate variables\r\n        if (this.framerate < 0) {\r\n            this.duration = this.maxLife;\r\n            this.framerate = this.textures.length / this.duration;\r\n        }\r\n    };\r\n    /**\r\n     * Sets the textures for the particle.\r\n     * @param art An array of PIXI.Texture objects for this animated particle.\r\n     */\r\n    AnimatedParticle.prototype.applyArt = function (art) {\r\n        this.textures = art.textures;\r\n        this.framerate = art.framerate;\r\n        this.duration = art.duration;\r\n        this.loop = art.loop;\r\n    };\r\n    /**\r\n     * Updates the particle.\r\n     * @param delta Time elapsed since the previous frame, in __seconds__.\r\n     */\r\n    AnimatedParticle.prototype.update = function (delta) {\r\n        var lerp = this.Particle_update(delta);\r\n        //only animate the particle if it is still alive\r\n        if (lerp >= 0) {\r\n            this.elapsed += delta;\r\n            if (this.elapsed > this.duration) {\r\n                //loop elapsed back around\r\n                if (this.loop)\r\n                    this.elapsed = this.elapsed % this.duration;\r\n                //subtract a small amount to prevent attempting to go past the end of the animation\r\n                else\r\n                    this.elapsed = this.duration - 0.000001;\r\n            }\r\n            // add a very small number to the frame and then floor it to avoid\r\n            // the frame being one short due to floating point errors.\r\n            var frame = (this.elapsed * this.framerate + 0.0000001) | 0;\r\n            this.texture = this.textures[frame] || pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"].EMPTY;\r\n        }\r\n        return lerp;\r\n    };\r\n    /**\r\n     * Destroys the particle, removing references and preventing future use.\r\n     */\r\n    AnimatedParticle.prototype.destroy = function () {\r\n        this.Particle_destroy();\r\n        this.textures = null;\r\n    };\r\n    /**\r\n     * Checks over the art that was passed to the Emitter's init() function, to do any special\r\n     * modifications to prepare it ahead of time.\r\n     * @param art The array of art data, properly formatted for AnimatedParticle.\r\n     * @return The art, after any needed modifications.\r\n     */\r\n    AnimatedParticle.parseArt = function (art) {\r\n        var data, output, textures, tex, outTextures;\r\n        var outArr = [];\r\n        for (var i = 0; i < art.length; ++i) {\r\n            data = art[i];\r\n            outArr[i] = output = {};\r\n            output.textures = outTextures = [];\r\n            textures = data.textures;\r\n            for (var j = 0; j < textures.length; ++j) {\r\n                tex = textures[j];\r\n                if (typeof tex == \"string\")\r\n                    outTextures.push(GetTextureFromString(tex));\r\n                else if (tex instanceof pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"])\r\n                    outTextures.push(tex);\r\n                //assume an object with extra data determining duplicate frame data\r\n                else {\r\n                    var dupe = tex.count || 1;\r\n                    if (typeof tex.texture == \"string\")\r\n                        tex = GetTextureFromString(tex.texture);\r\n                    else // if(tex.texture instanceof Texture)\r\n                        tex = tex.texture;\r\n                    for (; dupe > 0; --dupe) {\r\n                        outTextures.push(tex);\r\n                    }\r\n                }\r\n            }\r\n            //use these values to signify that the animation should match the particle life time.\r\n            if (data.framerate == \"matchLife\") {\r\n                //-1 means that it should be calculated\r\n                output.framerate = -1;\r\n                output.duration = 0;\r\n                output.loop = false;\r\n            }\r\n            else {\r\n                //determine if the animation should loop\r\n                output.loop = !!data.loop;\r\n                //get the framerate, default to 60\r\n                output.framerate = data.framerate > 0 ? data.framerate : 60;\r\n                //determine the duration\r\n                output.duration = outTextures.length / output.framerate;\r\n            }\r\n        }\r\n        return outArr;\r\n    };\r\n    return AnimatedParticle;\r\n}(Particle));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGl4aS1wYXJ0aWNsZXMvbGliL3BpeGktcGFydGljbGVzLmVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3NyYy9Qcm9wZXJ0eU5vZGUudHM/MTQ1YyIsIndlYnBhY2s6Ly8vLi4vc3JjL1BhcnRpY2xlVXRpbHMudHM/MzU0MSIsIndlYnBhY2s6Ly8vLi4vc3JjL1Byb3BlcnR5TGlzdC50cz9iZTZlIiwid2VicGFjazovLy8uLi9zcmMvUGFydGljbGUudHM/MjlmNyIsIndlYnBhY2s6Ly8vLi4vc3JjL1BvbHlnb25hbENoYWluLnRzP2E3ZDAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9FbWl0dGVyLnRzPzhiMTEiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9QYXRoUGFydGljbGUudHM/NWQ1OCIsIndlYnBhY2s6Ly8vLi4vc3JjL0FuaW1hdGVkUGFydGljbGUudHM/MDBiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1BhcnRpY2xlVXRpbHMsIEVhc2VTZWdtZW50LCBTaW1wbGVFYXNlLCBDb2xvcn0gZnJvbSBcIi4vUGFydGljbGVVdGlsc1wiO1xuaW1wb3J0IHtCYXNpY1R3ZWVuYWJsZX0gZnJvbSBcIi4vRW1pdHRlckNvbmZpZ1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFZhbHVlU3RlcDxUPiB7XG5cdHZhbHVlOlQ7XG5cdHRpbWU6bnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZhbHVlTGlzdDxUPiB7XG5cdGxpc3Q6IFZhbHVlU3RlcDxUPltdLFxuXHRpc1N0ZXBwZWQ/OiBib29sZWFuO1xuXHRlYXNlPzogU2ltcGxlRWFzZXxFYXNlU2VnbWVudFtdO1xufVxuLyoqXG4gKiBBIHNpbmdsZSBub2RlIGluIGEgUHJvcGVydHlMaXN0LlxuICovXG5leHBvcnQgY2xhc3MgUHJvcGVydHlOb2RlPFY+XG57XG5cdC8qKlxuXHQgKiBWYWx1ZSBmb3IgdGhlIG5vZGUuXG5cdCAqL1xuXHRwdWJsaWMgdmFsdWU6IFY7XG5cdC8qKlxuXHQgKiBUaW1lIHZhbHVlIGZvciB0aGUgbm9kZS4gQmV0d2VlbiAwLTEuXG5cdCAqL1xuXHRwdWJsaWMgdGltZTogbnVtYmVyO1xuXHQvKipcblx0ICogVGhlIG5leHQgbm9kZSBpbiBsaW5lLlxuXHQgKi9cblx0cHVibGljIG5leHQ6IFByb3BlcnR5Tm9kZTxWPjtcblx0LyoqXG5cdCAqIElmIHRoaXMgaXMgdGhlIGZpcnN0IG5vZGUgaW4gdGhlIGxpc3QsIGNvbnRyb2xzIGlmIHRoZSBlbnRpcmUgbGlzdCBpcyBzdGVwcGVkIG9yIG5vdC5cblx0ICovXG5cdHB1YmxpYyBpc1N0ZXBwZWQ6IGJvb2xlYW47XG5cdHB1YmxpYyBlYXNlOiBTaW1wbGVFYXNlO1xuXHRcblx0LyoqXG5cdCAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgZm9yIHRoaXMgbm9kZVxuXHQgKiBAcGFyYW0gdGltZSBUaGUgdGltZSBmb3IgdGhpcyBub2RlLCBiZXR3ZWVuIDAtMVxuXHQgKiBAcGFyYW0gW2Vhc2VdIEN1c3RvbSBlYXNlIGZvciB0aGlzIGxpc3QuIE9ubHkgcmVsZXZhbnQgZm9yIHRoZSBmaXJzdCBub2RlLlxuXHQgKi9cblx0Y29uc3RydWN0b3IodmFsdWU6IFYsIHRpbWU6bnVtYmVyLCBlYXNlPzogU2ltcGxlRWFzZXxFYXNlU2VnbWVudFtdKVxuXHR7XG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdHRoaXMudGltZSA9IHRpbWU7XG5cdFx0dGhpcy5uZXh0ID0gbnVsbDtcblx0XHR0aGlzLmlzU3RlcHBlZCA9IGZhbHNlO1xuXHRcdGlmIChlYXNlKVxuXHRcdHtcblx0XHRcdHRoaXMuZWFzZSA9IHR5cGVvZiBlYXNlID09IFwiZnVuY3Rpb25cIiA/IGVhc2UgOiBQYXJ0aWNsZVV0aWxzLmdlbmVyYXRlRWFzZShlYXNlKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuZWFzZSA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBsaXN0IG9mIHByb3BlcnR5IHZhbHVlcyBmcm9tIGEgZGF0YSBvYmplY3Qge2xpc3QsIGlzU3RlcHBlZH0gd2l0aCBhIGxpc3Qgb2Ygb2JqZWN0cyBpblxuXHQgKiB0aGUgZm9ybSB7dmFsdWUsIHRpbWV9LiBBbHRlcm5hdGl2ZWx5LCB0aGUgZGF0YSBvYmplY3QgY2FuIGJlIGluIHRoZSBkZXByZWNhdGVkIGZvcm0gb2Zcblx0ICoge3N0YXJ0LCBlbmR9LlxuXHQgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIGxpc3QuXG5cdCAqIEBwYXJhbSBkYXRhLmxpc3QgVGhlIGFycmF5IG9mIHZhbHVlIGFuZCB0aW1lIG9iamVjdHMuXG5cdCAqIEBwYXJhbSBkYXRhLmlzU3RlcHBlZCBJZiB0aGUgbGlzdCBpcyBzdGVwcGVkIHJhdGhlciB0aGFuIGludGVycG9sYXRlZC5cblx0ICogQHBhcmFtIGRhdGEuZWFzZSBDdXN0b20gZWFzZSBmb3IgdGhpcyBsaXN0LlxuXHQgKiBAcmV0dXJuIFRoZSBmaXJzdCBub2RlIGluIHRoZSBsaXN0XG5cdCAqL1xuXHRwdWJsaWMgc3RhdGljIGNyZWF0ZUxpc3Q8VCBleHRlbmRzIChzdHJpbmd8bnVtYmVyKT4oZGF0YTogVmFsdWVMaXN0PFQ+fEJhc2ljVHdlZW5hYmxlPFQ+KTpQcm9wZXJ0eU5vZGU8VCBleHRlbmRzIHN0cmluZyA/IENvbG9yIDogVD5cblx0e1xuXHRcdGlmIChcImxpc3RcIiBpbiBkYXRhKVxuXHRcdHtcblx0XHRcdGxldCBhcnJheSA9IGRhdGEubGlzdDtcblx0XHRcdGxldCBub2RlLCBmaXJzdDtcblx0XHRcdGNvbnN0IHt2YWx1ZSwgdGltZX0gPSBhcnJheVswXTtcblx0XHRcdGZpcnN0ID0gbm9kZSA9IG5ldyBQcm9wZXJ0eU5vZGUodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IFBhcnRpY2xlVXRpbHMuaGV4VG9SR0IodmFsdWUpIDogdmFsdWUsIHRpbWUsIGRhdGEuZWFzZSk7XG5cdFx0XHQvL29ubHkgc2V0IHVwIHN1YnNlcXVlbnQgbm9kZXMgaWYgdGhlcmUgYXJlIGEgYnVuY2ggb3IgdGhlIDJuZCBvbmUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGZpcnN0XG5cdFx0XHRpZiAoYXJyYXkubGVuZ3RoID4gMiB8fCAoYXJyYXkubGVuZ3RoID09PSAyICYmIGFycmF5WzFdLnZhbHVlICE9PSB2YWx1ZSkpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCB7dmFsdWUsIHRpbWV9ID0gYXJyYXlbaV07XG5cdFx0XHRcdFx0bm9kZS5uZXh0ID0gbmV3IFByb3BlcnR5Tm9kZSh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gUGFydGljbGVVdGlscy5oZXhUb1JHQih2YWx1ZSkgOiB2YWx1ZSwgdGltZSk7XG5cdFx0XHRcdFx0bm9kZSA9IG5vZGUubmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zmlyc3QuaXNTdGVwcGVkID0gISFkYXRhLmlzU3RlcHBlZDtcblx0XHRcdHJldHVybiBmaXJzdCBhcyBQcm9wZXJ0eU5vZGU8VCBleHRlbmRzIHN0cmluZyA/IENvbG9yIDogVD47XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvL0hhbmRsZSBkZXByZWNhdGVkIHZlcnNpb24gaGVyZVxuXHRcdFx0bGV0IHN0YXJ0ID0gbmV3IFByb3BlcnR5Tm9kZSh0eXBlb2YgZGF0YS5zdGFydCA9PT0gJ3N0cmluZycgPyBQYXJ0aWNsZVV0aWxzLmhleFRvUkdCKGRhdGEuc3RhcnQpIDogZGF0YS5zdGFydCwgMCk7XG5cdFx0XHQvL29ubHkgc2V0IHVwIGEgbmV4dCB2YWx1ZSBpZiBpdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgc3RhcnRpbmcgdmFsdWVcblx0XHRcdGlmIChkYXRhLmVuZCAhPT0gZGF0YS5zdGFydClcblx0XHRcdFx0c3RhcnQubmV4dCA9IG5ldyBQcm9wZXJ0eU5vZGUodHlwZW9mIGRhdGEuZW5kID09PSAnc3RyaW5nJyA/IFBhcnRpY2xlVXRpbHMuaGV4VG9SR0IoZGF0YS5lbmQpIDogZGF0YS5lbmQsIDEpO1xuXHRcdFx0cmV0dXJuIHN0YXJ0IGFzIFByb3BlcnR5Tm9kZTxUIGV4dGVuZHMgc3RyaW5nID8gQ29sb3IgOiBUPjtcblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQge0JMRU5EX01PREVTLCBQb2ludCwgVGV4dHVyZX0gZnJvbSBcInBpeGkuanNcIjtcbmltcG9ydCB7UHJvcGVydHlOb2RlLCBWYWx1ZVN0ZXB9IGZyb20gXCIuL1Byb3BlcnR5Tm9kZVwiO1xuaW1wb3J0ICogYXMgcGl4aSBmcm9tIFwicGl4aS5qc1wiO1xuLy8gZ2V0IFRleHR1cmUuZnJvbSgpL1RleHR1cmUuZnJvbUltYWdlKCksIGluIFY0IGFuZCBWNSBmcmllbmRseSBtZXRob2RzXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFRleHR1cmVGcm9tU3RyaW5nOiAoczpzdHJpbmcpID0+IHBpeGkuVGV4dHVyZTtcbi8vIHRvIGF2b2lkIFJvbGx1cCB0cmFuc2Zvcm1pbmcgb3VyIGltcG9ydCwgc2F2ZSBwaXhpIG5hbWVzcGFjZSBpbiBhIHZhcmlhYmxlXG5jb25zdCBwaXhpTlMgPSBwaXhpO1xuaWYgKHBhcnNlSW50KC9eKFxcZCspXFwuLy5leGVjKHBpeGkuVkVSU0lPTilbMV0pIDwgNSlcbntcblx0VGV4dHVyZUZyb21TdHJpbmcgPSBwaXhpTlMuVGV4dHVyZS5mcm9tSW1hZ2U7XG59XG5lbHNlXG57XG5cdFRleHR1cmVGcm9tU3RyaW5nID0gKHBpeGlOUyBhcyBhbnkpLlRleHR1cmUuZnJvbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEdldFRleHR1cmVGcm9tU3RyaW5nKHM6c3RyaW5nKTogVGV4dHVyZSB7XG5cdHJldHVybiBUZXh0dXJlRnJvbVN0cmluZyhzKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2xvciB7XG5cdHI6IG51bWJlcixcblx0ZzogbnVtYmVyLFxuXHRiOiBudW1iZXIsXG5cdGE/OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFYXNlU2VnbWVudCB7XG5cdGNwOm51bWJlcjtcblx0czpudW1iZXI7XG5cdGU6bnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBTaW1wbGVFYXNlID0gKHRpbWU6bnVtYmVyKSA9PiBudW1iZXI7XG5cbi8qKlxuICogQ29udGFpbnMgaGVscGVyIGZ1bmN0aW9ucyBmb3IgcGFydGljbGVzIGFuZCBlbWl0dGVycyB0byB1c2UuXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2UgUGFydGljbGVVdGlscyB7XG5cdC8qKlxuXHQgKiBJZiBlcnJvcnMgYW5kIHdhcm5pbmdzIHNob3VsZCBiZSBsb2dnZWQgd2l0aGluIHRoZSBsaWJyYXJ5LlxuXHQgKi9cblx0ZXhwb3J0IGxldCB2ZXJib3NlID0gZmFsc2U7XG5cblx0ZXhwb3J0IGNvbnN0IERFR19UT19SQURTID0gTWF0aC5QSSAvIDE4MDtcblxuXHQvKipcblx0ICogUm90YXRlcyBhIHBvaW50IGJ5IGEgZ2l2ZW4gYW5nbGUuXG5cdCAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5IGluIGRlZ3JlZXNcblx0ICogQHBhcmFtIHAgVGhlIHBvaW50IHRvIHJvdGF0ZSBhcm91bmQgMCwwLlxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVBvaW50KGFuZ2xlOm51bWJlciwgcDpQb2ludClcblx0e1xuXHRcdGlmICghYW5nbGUpIHJldHVybjtcblx0XHRhbmdsZSAqPSBQYXJ0aWNsZVV0aWxzLkRFR19UT19SQURTO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRjb25zdCB4bmV3ID0gcC54ICogYyAtIHAueSAqIHM7XG5cdFx0Y29uc3QgeW5ldyA9IHAueCAqIHMgKyBwLnkgKiBjO1xuXHRcdHAueCA9IHhuZXc7XG5cdFx0cC55ID0geW5ldztcblx0fVxuXG5cdC8qKlxuXHQgKiBDb21iaW5lcyBzZXBhcmF0ZSBjb2xvciBjb21wb25lbnRzICgwLTI1NSkgaW50byBhIHNpbmdsZSB1aW50IGNvbG9yLlxuXHQgKiBAcGFyYW0gciBUaGUgcmVkIHZhbHVlIG9mIHRoZSBjb2xvclxuXHQgKiBAcGFyYW0gZyBUaGUgZ3JlZW4gdmFsdWUgb2YgdGhlIGNvbG9yXG5cdCAqIEBwYXJhbSBiIFRoZSBibHVlIHZhbHVlIG9mIHRoZSBjb2xvclxuXHQgKiBAcmV0dXJuIFRoZSBjb2xvciBpbiB0aGUgZm9ybSBvZiAweFJSR0dCQlxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVSR0JDb21wb25lbnRzKHI6bnVtYmVyLCBnOm51bWJlciwgYjpudW1iZXIvKiwgYSovKTogbnVtYmVyXG5cdHtcblx0XHRyZXR1cm4gLyphIDw8IDI0IHwqLyByIDw8IDE2IHwgZyA8PCA4IHwgYjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWR1Y2VzIHRoZSBwb2ludCB0byBhIGxlbmd0aCBvZiAxLlxuXHQgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIG5vcm1hbGl6ZVxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShwb2ludDpQb2ludCk6IHZvaWRcblx0e1xuXHRcdGxldCBvbmVPdmVyTGVuID0gMSAvIFBhcnRpY2xlVXRpbHMubGVuZ3RoKHBvaW50KTtcblx0XHRwb2ludC54ICo9IG9uZU92ZXJMZW47XG5cdFx0cG9pbnQueSAqPSBvbmVPdmVyTGVuO1xuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGxpZXMgdGhlIHggYW5kIHkgdmFsdWVzIG9mIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZS5cblx0ICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBzY2FsZUJ5XG5cdCAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2NhbGUgYnkuXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gc2NhbGVCeShwb2ludDpQb2ludCwgdmFsdWU6bnVtYmVyKTogdm9pZFxuXHR7XG5cdFx0cG9pbnQueCAqPSB2YWx1ZTtcblx0XHRwb2ludC55ICo9IHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxlbmd0aCAob3IgbWFnbml0dWRlKSBvZiB0aGlzIHBvaW50LlxuXHQgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIG1lYXN1cmUgbGVuZ3RoXG5cdCAqIEByZXR1cm4gVGhlIGxlbmd0aCBvZiB0aGlzIHBvaW50LlxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChwb2ludDpQb2ludCk6IG51bWJlclxuXHR7XG5cdFx0cmV0dXJuIE1hdGguc3FydChwb2ludC54ICogcG9pbnQueCArIHBvaW50LnkgKiBwb2ludC55KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgZnJvbSBcIiNBQVJSR0dCQlwiLCBcIiNSUkdHQkJcIiwgXCIweEFBUlJHR0JCXCIsIFwiMHhSUkdHQkJcIixcblx0ICogXCJBQVJSR0dCQlwiLCBvciBcIlJSR0dCQlwiIHRvIGFuIG9iamVjdCBvZiBpbnRzIG9mIDAtMjU1LCBhc1xuXHQgKiB7ciwgZywgYiwgKGEpfS5cblx0ICogQHBhcmFtIGNvbG9yIFRoZSBpbnB1dCBjb2xvciBzdHJpbmcuXG5cdCAqIEBwYXJhbSBvdXRwdXQgQW4gb2JqZWN0IHRvIHB1dCB0aGUgb3V0cHV0IGluLiBJZiBvbWl0dGVkLCBhIG5ldyBvYmplY3QgaXMgY3JlYXRlZC5cblx0ICogQHJldHVybiBUaGUgb2JqZWN0IHdpdGggciwgZywgYW5kIGIgcHJvcGVydGllcywgcG9zc2libHkgd2l0aCBhbiBhIHByb3BlcnR5LlxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGhleFRvUkdCKGNvbG9yOnN0cmluZywgb3V0cHV0PzpDb2xvcik6IENvbG9yXG5cdHtcblx0XHRpZiAoIW91dHB1dClcblx0XHRcdG91dHB1dCA9IHt9IGFzIENvbG9yO1xuXHRcdGlmIChjb2xvci5jaGFyQXQoMCkgPT0gXCIjXCIpXG5cdFx0XHRjb2xvciA9IGNvbG9yLnN1YnN0cigxKTtcblx0XHRlbHNlIGlmIChjb2xvci5pbmRleE9mKFwiMHhcIikgPT09IDApXG5cdFx0XHRjb2xvciA9IGNvbG9yLnN1YnN0cigyKTtcblx0XHRsZXQgYWxwaGE7XG5cdFx0aWYgKGNvbG9yLmxlbmd0aCA9PSA4KVxuXHRcdHtcblx0XHRcdGFscGhhID0gY29sb3Iuc3Vic3RyKDAsIDIpO1xuXHRcdFx0Y29sb3IgPSBjb2xvci5zdWJzdHIoMik7XG5cdFx0fVxuXHRcdG91dHB1dC5yID0gcGFyc2VJbnQoY29sb3Iuc3Vic3RyKDAsIDIpLCAxNik7Ly9SZWRcblx0XHRvdXRwdXQuZyA9IHBhcnNlSW50KGNvbG9yLnN1YnN0cigyLCAyKSwgMTYpOy8vR3JlZW5cblx0XHRvdXRwdXQuYiA9IHBhcnNlSW50KGNvbG9yLnN1YnN0cig0LCAyKSwgMTYpOy8vQmx1ZVxuXHRcdGlmIChhbHBoYSlcblx0XHRcdG91dHB1dC5hID0gcGFyc2VJbnQoYWxwaGEsIDE2KTtcblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBhIGN1c3RvbSBlYXNlIGZ1bmN0aW9uLCBiYXNlZCBvbiB0aGUgR3JlZW5Tb2NrIGN1c3RvbSBlYXNlLCBhcyBkZW1vbnN0cmF0ZWRcblx0ICogYnkgdGhlIHJlbGF0ZWQgdG9vbCBhdCBodHRwOi8vd3d3LmdyZWVuc29jay5jb20vY3VzdG9tZWFzZS8uXG5cdCAqIEBwYXJhbSBzZWdtZW50cyBBbiBhcnJheSBvZiBzZWdtZW50cywgYXMgY3JlYXRlZCBieVxuXHQgKiBodHRwOi8vd3d3LmdyZWVuc29jay5jb20vY3VzdG9tZWFzZS8uXG5cdCAqIEByZXR1cm4gQSBmdW5jdGlvbiB0aGF0IGNhbGN1bGF0ZXMgdGhlIHBlcmNlbnRhZ2Ugb2YgY2hhbmdlIGF0XG5cdCAqICAgICAgICAgICAgICAgICAgICBhIGdpdmVuIHBvaW50IGluIHRpbWUgKDAtMSBpbmNsdXNpdmUpLlxuXHQgKi9cblx0ZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRWFzZShzZWdtZW50czpFYXNlU2VnbWVudFtdKTogU2ltcGxlRWFzZVxuXHR7XG5cdFx0Y29uc3QgcXR5ID0gc2VnbWVudHMubGVuZ3RoO1xuXHRcdGNvbnN0IG9uZU92ZXJRdHkgPSAxIC8gcXR5O1xuXHRcdC8qXG5cdFx0ICogQ2FsY3VsYXRlcyB0aGUgcGVyY2VudGFnZSBvZiBjaGFuZ2UgYXQgYSBnaXZlbiBwb2ludCBpbiB0aW1lICgwLTEgaW5jbHVzaXZlKS5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgdGltZSBvZiB0aGUgZWFzZSwgMC0xIGluY2x1c2l2ZS5cblx0XHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaGFuZ2UsIDAtMSBpbmNsdXNpdmUgKHVubGVzcyB5b3VyXG5cdFx0ICogICAgICAgICAgICAgICAgICBlYXNlIGdvZXMgb3V0c2lkZSB0aG9zZSBib3VuZHMpLlxuXHRcdCAqL1xuXHRcdHJldHVybiBmdW5jdGlvbih0aW1lOm51bWJlcilcblx0XHR7XG5cdFx0XHRsZXQgdDogbnVtYmVyLCBzOiBFYXNlU2VnbWVudDtcblx0XHRcdGxldCBpID0gKHF0eSAqIHRpbWUpIHwgMDsvL2RvIGEgcXVpY2sgZmxvb3Igb3BlcmF0aW9uXG5cdFx0XHR0ID0gKHRpbWUgLSAoaSAqIG9uZU92ZXJRdHkpKSAqIHF0eTtcblx0XHRcdHMgPSBzZWdtZW50c1tpXSB8fCBzZWdtZW50c1txdHkgLSAxXTtcblx0XHRcdHJldHVybiAocy5zICsgdCAqICgyICogKDEgLSB0KSAqIChzLmNwIC0gcy5zKSArIHQgKiAocy5lIC0gcy5zKSkpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyBhIGJsZW5kIG1vZGUsIGVuc3VyaW5nIHRoYXQgaXQgaXMgdmFsaWQuXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBibGVuZCBtb2RlIHRvIGdldC5cblx0ICogQHJldHVybiBUaGUgYmxlbmQgbW9kZSBhcyBzcGVjaWZpZWQgaW4gdGhlIFBJWEkuQkxFTkRfTU9ERVMgZW51bWVyYXRpb24uXG5cdCAqL1xuXHRleHBvcnQgZnVuY3Rpb24gZ2V0QmxlbmRNb2RlKG5hbWU6c3RyaW5nKTogbnVtYmVyXG5cdHtcblx0XHRpZiAoIW5hbWUpIHJldHVybiBCTEVORF9NT0RFUy5OT1JNQUw7XG5cdFx0bmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcblx0XHR3aGlsZSAobmFtZS5pbmRleE9mKFwiIFwiKSA+PSAwKVxuXHRcdFx0bmFtZSA9IG5hbWUucmVwbGFjZShcIiBcIiwgXCJfXCIpO1xuXHRcdHJldHVybiAoQkxFTkRfTU9ERVMgYXMgYW55KVtuYW1lXSB8fCBCTEVORF9NT0RFUy5OT1JNQUw7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBsaXN0IG9mIHt2YWx1ZSwgdGltZX0gb2JqZWN0cyBzdGFydGluZyBhdCB0aW1lIDAgYW5kIGVuZGluZyBhdCB0aW1lIDEgaW50byBhbiBldmVubHlcblx0ICogc3BhY2VkIHN0ZXBwZWQgbGlzdCBvZiBQcm9wZXJ0eU5vZGVzIGZvciBjb2xvciB2YWx1ZXMuIFRoaXMgaXMgcHJpbWFyaWx5IHRvIGhhbmRsZSBjb252ZXJzaW9uIG9mXG5cdCAqIGxpbmVhciBncmFkaWVudHMgdG8gZmV3ZXIgY29sb3JzLCBhbGxvd2luZyBmb3Igc29tZSBvcHRpbWl6YXRpb24gZm9yIENhbnZhczJkIGZhbGxiYWNrcy5cblx0ICogQHBhcmFtIGxpc3QgVGhlIGxpc3Qgb2YgZGF0YSB0byBjb252ZXJ0LlxuXHQgKiBAcGFyYW0gW251bVN0ZXBzPTEwXSBUaGUgbnVtYmVyIG9mIHN0ZXBzIHRvIHVzZS5cblx0ICogQHJldHVybiBUaGUgYmxlbmQgbW9kZSBhcyBzcGVjaWZpZWQgaW4gdGhlIFBJWEkuYmxlbmRNb2RlcyBlbnVtZXJhdGlvbi5cblx0ICovXG5cdGV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGVwcGVkR3JhZGllbnQobGlzdDpWYWx1ZVN0ZXA8c3RyaW5nPltdLCBudW1TdGVwczpudW1iZXIgPSAxMCkge1xuXHRcdGlmICh0eXBlb2YgbnVtU3RlcHMgIT09ICdudW1iZXInIHx8IG51bVN0ZXBzIDw9IDApXG5cdFx0XHRudW1TdGVwcyA9IDEwO1xuXHRcdGxldCBmaXJzdCA9IG5ldyBQcm9wZXJ0eU5vZGU8Q29sb3I+KFBhcnRpY2xlVXRpbHMuaGV4VG9SR0IobGlzdFswXS52YWx1ZSksIGxpc3RbMF0udGltZSk7XG5cdFx0Zmlyc3QuaXNTdGVwcGVkID0gdHJ1ZTtcblx0XHRsZXQgY3VycmVudE5vZGUgPSBmaXJzdDtcblx0XHRsZXQgY3VycmVudCA9IGxpc3RbMF07XG5cdFx0bGV0IG5leHRJbmRleCA9IDE7XG5cdFx0bGV0IG5leHQgPSBsaXN0W25leHRJbmRleF07XG5cdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBudW1TdGVwczsgKytpKVxuXHRcdHtcblx0XHRcdGxldCBsZXJwID0gaSAvIG51bVN0ZXBzO1xuXHRcdFx0Ly9lbnN1cmUgd2UgYXJlIG9uIHRoZSByaWdodCBzZWdtZW50LCBpZiBtdWx0aXBsZVxuXHRcdFx0d2hpbGUgKGxlcnAgPiBuZXh0LnRpbWUpXG5cdFx0XHR7XG5cdFx0XHRcdGN1cnJlbnQgPSBuZXh0O1xuXHRcdFx0XHRuZXh0ID0gbGlzdFsrK25leHRJbmRleF07XG5cdFx0XHR9XG5cdFx0XHQvL2NvbnZlcnQgdGhlIGxlcnAgdmFsdWUgdG8gdGhlIHNlZ21lbnQgcmFuZ2Vcblx0XHRcdGxlcnAgPSAobGVycCAtIGN1cnJlbnQudGltZSkgLyAobmV4dC50aW1lIC0gY3VycmVudC50aW1lKTtcblx0XHRcdGxldCBjdXJWYWwgPSBQYXJ0aWNsZVV0aWxzLmhleFRvUkdCKGN1cnJlbnQudmFsdWUpO1xuXHRcdFx0bGV0IG5leHRWYWwgPSBQYXJ0aWNsZVV0aWxzLmhleFRvUkdCKG5leHQudmFsdWUpO1xuXHRcdFx0bGV0IG91dHB1dDpDb2xvciA9IHtcblx0XHRcdFx0cjogKG5leHRWYWwuciAtIGN1clZhbC5yKSAqIGxlcnAgKyBjdXJWYWwucixcblx0XHRcdFx0ZzogKG5leHRWYWwuZyAtIGN1clZhbC5nKSAqIGxlcnAgKyBjdXJWYWwuZyxcblx0XHRcdFx0YjogKG5leHRWYWwuYiAtIGN1clZhbC5iKSAqIGxlcnAgKyBjdXJWYWwuYixcblx0XHRcdH07XG5cdFx0XHRjdXJyZW50Tm9kZS5uZXh0ID0gbmV3IFByb3BlcnR5Tm9kZShvdXRwdXQsIGkgLyBudW1TdGVwcyk7XG5cdFx0XHRjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG5cdFx0fVxuXHRcdC8vd2UgZG9uJ3QgbmVlZCB0byBoYXZlIGEgUHJvcGVydHlOb2RlIGZvciB0aW1lIG9mIDEsIGJlY2F1c2UgaW4gYSBzdGVwcGVkIHZlcnNpb24gYXQgdGhhdCBwb2ludFxuXHRcdC8vdGhlIHBhcnRpY2xlIGhhcyBkaWVkIG9mIG9sZCBhZ2Vcblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH1cbn0iLCJpbXBvcnQge1BhcnRpY2xlVXRpbHMsIFNpbXBsZUVhc2UsIENvbG9yfSBmcm9tIFwiLi9QYXJ0aWNsZVV0aWxzXCI7XG5pbXBvcnQge1Byb3BlcnR5Tm9kZX0gZnJvbSBcIi4vUHJvcGVydHlOb2RlXCI7XG5cbi8qKlxuICogU2luZ2x5IGxpbmtlZCBsaXN0IGNvbnRhaW5lciBmb3Iga2VlcGluZyB0cmFjayBvZiBpbnRlcnBvbGF0ZWQgcHJvcGVydGllcyBmb3IgcGFydGljbGVzLlxuICogRWFjaCBQYXJ0aWNsZSB3aWxsIGhhdmUgb25lIG9mIHRoZXNlIGZvciBlYWNoIGludGVycG9sYXRlZCBwcm9wZXJ0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIFByb3BlcnR5TGlzdDxWPlxue1xuXHQvKipcblx0ICogVGhlIGN1cnJlbnQgcHJvcGVydHkgbm9kZSBpbiB0aGUgbGlua2VkIGxpc3QuXG5cdCAqL1xuXHRwdWJsaWMgY3VycmVudDogUHJvcGVydHlOb2RlPFY+O1xuXHQvKipcblx0ICogVGhlIG5leHQgcHJvcGVydHkgbm9kZSBpbiB0aGUgbGlua2VkIGxpc3QuIFN0b3JlZCBzZXBhcmF0ZWx5IGZvciBzbGlnaHRseSBsZXNzIHZhcmlhYmxlXG5cdCAqIGFjY2Vzcy5cblx0ICovXG5cdHB1YmxpYyBuZXh0OiBQcm9wZXJ0eU5vZGU8Vj47XG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIHRoZSBjb3JyZWN0IHZhbHVlIGZvciB0aGUgY3VycmVudCBpbnRlcnBvbGF0aW9uIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBzZXQgaW5cblx0ICogdGhlIHJlc2V0KCkgbWV0aG9kLlxuXHQgKiBAcGFyYW0gbGVycCBUaGUgaW50ZXJwb2xhdGlvbiB2YWx1ZSBmcm9tIDAtMS5cblx0ICogQHJldHVybiBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlLiBDb2xvcnMgYXJlIGNvbnZlcnRlZCB0byB0aGUgaGV4IHZhbHVlLlxuXHQgKi9cblx0cHVibGljIGludGVycG9sYXRlOiAobGVycDpudW1iZXIpPT5udW1iZXI7XG5cdC8qKlxuXHQgKiBBIGN1c3RvbSBlYXNpbmcgbWV0aG9kIGZvciB0aGlzIGxpc3QuXG5cdCAqIEBwYXJhbSBsZXJwIFRoZSBpbnRlcnBvbGF0aW9uIHZhbHVlIGZyb20gMC0xLlxuXHQgKiBAcmV0dXJuIFRoZSBlYXNlZCB2YWx1ZSwgYWxzbyBmcm9tIDAtMS5cblx0ICovXG5cdHB1YmxpYyBlYXNlOiBTaW1wbGVFYXNlO1xuXHQvKipcblx0ICogSWYgdGhpcyBsaXN0IG1hbmFnZXMgY29sb3JzLCB3aGljaCByZXF1aXJlcyBhIGRpZmZlcmVudCBtZXRob2QgZm9yIGludGVycG9sYXRpb24uXG5cdCAqL1xuXHRwcml2YXRlIGlzQ29sb3I6IGJvb2xlYW47XG5cdFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpc0NvbG9yIElmIHRoaXMgbGlzdCBoYW5kbGVzIGNvbG9yIHZhbHVlc1xuICAgICAqL1xuXHRjb25zdHJ1Y3Rvcihpc0NvbG9yOiBib29sZWFuID0gZmFsc2UpXG5cdHtcblx0XHR0aGlzLmN1cnJlbnQgPSBudWxsO1xuXHRcdHRoaXMubmV4dCA9IG51bGw7XG5cdFx0dGhpcy5pc0NvbG9yID0gISFpc0NvbG9yO1xuXHRcdHRoaXMuaW50ZXJwb2xhdGUgPSBudWxsO1xuXHRcdHRoaXMuZWFzZSA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBsaXN0IGZvciB1c2UuXG5cdCAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3Qgbm9kZSBpbiB0aGUgbGlzdC5cblx0ICogQHBhcmFtIGZpcnN0LmlzU3RlcHBlZCBJZiB0aGUgdmFsdWVzIHNob3VsZCBiZSBzdGVwcGVkIGluc3RlYWQgb2YgaW50ZXJwb2xhdGVkIGxpbmVhcmx5LlxuXHQgKi9cblx0cHVibGljIHJlc2V0KGZpcnN0OiBQcm9wZXJ0eU5vZGU8Vj4pXG5cdHtcblx0XHR0aGlzLmN1cnJlbnQgPSBmaXJzdDtcblx0XHR0aGlzLm5leHQgPSBmaXJzdC5uZXh0O1xuXHRcdGNvbnN0IGlzU2ltcGxlID0gdGhpcy5uZXh0ICYmIHRoaXMubmV4dC50aW1lID49IDE7XG5cdFx0aWYgKGlzU2ltcGxlKVxuXHRcdHtcblx0XHRcdHRoaXMuaW50ZXJwb2xhdGUgPSB0aGlzLmlzQ29sb3IgPyBpbnRDb2xvclNpbXBsZSA6IGludFZhbHVlU2ltcGxlO1xuXHRcdH1cblx0XHRlbHNlIGlmIChmaXJzdC5pc1N0ZXBwZWQpXG5cdFx0e1xuXHRcdFx0dGhpcy5pbnRlcnBvbGF0ZSA9IHRoaXMuaXNDb2xvciA/IGludENvbG9yU3RlcHBlZCA6IGludFZhbHVlU3RlcHBlZDtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuaW50ZXJwb2xhdGUgPSB0aGlzLmlzQ29sb3IgPyBpbnRDb2xvckNvbXBsZXggOiBpbnRWYWx1ZUNvbXBsZXg7XG5cdFx0fVxuXHRcdHRoaXMuZWFzZSA9IHRoaXMuY3VycmVudC5lYXNlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGludFZhbHVlU2ltcGxlKHRoaXM6IFByb3BlcnR5TGlzdDxudW1iZXI+LCBsZXJwOiBudW1iZXIpXG57XG5cdGlmICh0aGlzLmVhc2UpXG5cdFx0bGVycCA9IHRoaXMuZWFzZShsZXJwKTtcblx0cmV0dXJuICh0aGlzLm5leHQudmFsdWUgLSB0aGlzLmN1cnJlbnQudmFsdWUpICogbGVycCArIHRoaXMuY3VycmVudC52YWx1ZTtcbn1cblxuZnVuY3Rpb24gaW50Q29sb3JTaW1wbGUodGhpczogUHJvcGVydHlMaXN0PENvbG9yPiwgbGVycDogbnVtYmVyKVxue1xuXHRpZiAodGhpcy5lYXNlKVxuXHRcdGxlcnAgPSB0aGlzLmVhc2UobGVycCk7XG5cdGxldCBjdXJWYWwgPSB0aGlzLmN1cnJlbnQudmFsdWUsIG5leHRWYWwgPSB0aGlzLm5leHQudmFsdWU7XG5cdGxldCByID0gKG5leHRWYWwuciAtIGN1clZhbC5yKSAqIGxlcnAgKyBjdXJWYWwucjtcblx0bGV0IGcgPSAobmV4dFZhbC5nIC0gY3VyVmFsLmcpICogbGVycCArIGN1clZhbC5nO1xuXHRsZXQgYiA9IChuZXh0VmFsLmIgLSBjdXJWYWwuYikgKiBsZXJwICsgY3VyVmFsLmI7XG5cdHJldHVybiBQYXJ0aWNsZVV0aWxzLmNvbWJpbmVSR0JDb21wb25lbnRzKHIsIGcsIGIpO1xufVxuXG5mdW5jdGlvbiBpbnRWYWx1ZUNvbXBsZXgodGhpczogUHJvcGVydHlMaXN0PG51bWJlcj4sIGxlcnA6IG51bWJlcilcbntcblx0aWYgKHRoaXMuZWFzZSlcblx0XHRsZXJwID0gdGhpcy5lYXNlKGxlcnApO1xuXHQvL21ha2Ugc3VyZSB3ZSBhcmUgb24gdGhlIHJpZ2h0IHNlZ21lbnRcblx0d2hpbGUgKGxlcnAgPiB0aGlzLm5leHQudGltZSlcblx0e1xuXHRcdHRoaXMuY3VycmVudCA9IHRoaXMubmV4dDtcblx0XHR0aGlzLm5leHQgPSB0aGlzLm5leHQubmV4dDtcblx0fVxuXHQvL2NvbnZlcnQgdGhlIGxlcnAgdmFsdWUgdG8gdGhlIHNlZ21lbnQgcmFuZ2Vcblx0bGVycCA9IChsZXJwIC0gdGhpcy5jdXJyZW50LnRpbWUpIC8gKHRoaXMubmV4dC50aW1lIC0gdGhpcy5jdXJyZW50LnRpbWUpO1xuXHRyZXR1cm4gKHRoaXMubmV4dC52YWx1ZSAtIHRoaXMuY3VycmVudC52YWx1ZSkgKiBsZXJwICsgdGhpcy5jdXJyZW50LnZhbHVlO1xufVxuXG5mdW5jdGlvbiBpbnRDb2xvckNvbXBsZXgodGhpczogUHJvcGVydHlMaXN0PENvbG9yPiwgbGVycDogbnVtYmVyKVxue1xuXHRpZiAodGhpcy5lYXNlKVxuXHRcdGxlcnAgPSB0aGlzLmVhc2UobGVycCk7XG5cdC8vbWFrZSBzdXJlIHdlIGFyZSBvbiB0aGUgcmlnaHQgc2VnbWVudFxuXHR3aGlsZSAobGVycCA+IHRoaXMubmV4dC50aW1lKVxuXHR7XG5cdFx0dGhpcy5jdXJyZW50ID0gdGhpcy5uZXh0O1xuXHRcdHRoaXMubmV4dCA9IHRoaXMubmV4dC5uZXh0O1xuXHR9XG5cdC8vY29udmVydCB0aGUgbGVycCB2YWx1ZSB0byB0aGUgc2VnbWVudCByYW5nZVxuXHRsZXJwID0gKGxlcnAgLSB0aGlzLmN1cnJlbnQudGltZSkgLyAodGhpcy5uZXh0LnRpbWUgLSB0aGlzLmN1cnJlbnQudGltZSk7XG5cdGxldCBjdXJWYWwgPSB0aGlzLmN1cnJlbnQudmFsdWUsIG5leHRWYWwgPSB0aGlzLm5leHQudmFsdWU7XG5cdGxldCByID0gKG5leHRWYWwuciAtIGN1clZhbC5yKSAqIGxlcnAgKyBjdXJWYWwucjtcblx0bGV0IGcgPSAobmV4dFZhbC5nIC0gY3VyVmFsLmcpICogbGVycCArIGN1clZhbC5nO1xuXHRsZXQgYiA9IChuZXh0VmFsLmIgLSBjdXJWYWwuYikgKiBsZXJwICsgY3VyVmFsLmI7XG5cdHJldHVybiBQYXJ0aWNsZVV0aWxzLmNvbWJpbmVSR0JDb21wb25lbnRzKHIsIGcsIGIpO1xufVxuXG5mdW5jdGlvbiBpbnRWYWx1ZVN0ZXBwZWQodGhpczogUHJvcGVydHlMaXN0PG51bWJlcj4sIGxlcnA6IG51bWJlcilcbntcblx0aWYgKHRoaXMuZWFzZSlcblx0XHRsZXJwID0gdGhpcy5lYXNlKGxlcnApO1xuXHQvL21ha2Ugc3VyZSB3ZSBhcmUgb24gdGhlIHJpZ2h0IHNlZ21lbnRcblx0d2hpbGUgKHRoaXMubmV4dCAmJiBsZXJwID4gdGhpcy5uZXh0LnRpbWUpXG5cdHtcblx0XHR0aGlzLmN1cnJlbnQgPSB0aGlzLm5leHQ7XG5cdFx0dGhpcy5uZXh0ID0gdGhpcy5uZXh0Lm5leHQ7XG5cdH1cblx0cmV0dXJuIHRoaXMuY3VycmVudC52YWx1ZTtcbn1cblxuZnVuY3Rpb24gaW50Q29sb3JTdGVwcGVkKHRoaXM6IFByb3BlcnR5TGlzdDxDb2xvcj4sIGxlcnA6IG51bWJlcilcbntcblx0aWYgKHRoaXMuZWFzZSlcblx0XHRsZXJwID0gdGhpcy5lYXNlKGxlcnApO1xuXHQvL21ha2Ugc3VyZSB3ZSBhcmUgb24gdGhlIHJpZ2h0IHNlZ21lbnRcblx0d2hpbGUgKHRoaXMubmV4dCAmJiBsZXJwID4gdGhpcy5uZXh0LnRpbWUpXG5cdHtcblx0XHR0aGlzLmN1cnJlbnQgPSB0aGlzLm5leHQ7XG5cdFx0dGhpcy5uZXh0ID0gdGhpcy5uZXh0Lm5leHQ7XG5cdH1cblx0bGV0IGN1clZhbCA9IHRoaXMuY3VycmVudC52YWx1ZTtcblx0cmV0dXJuIFBhcnRpY2xlVXRpbHMuY29tYmluZVJHQkNvbXBvbmVudHMoY3VyVmFsLnIsIGN1clZhbC5nLCBjdXJWYWwuYik7XG59IiwiaW1wb3J0IHtFbWl0dGVyfSBmcm9tIFwiLi9FbWl0dGVyXCI7XG5pbXBvcnQge1BhcnRpY2xlVXRpbHMsIFNpbXBsZUVhc2UsIENvbG9yLCBHZXRUZXh0dXJlRnJvbVN0cmluZ30gZnJvbSBcIi4vUGFydGljbGVVdGlsc1wiO1xuaW1wb3J0IHtQcm9wZXJ0eUxpc3R9IGZyb20gXCIuL1Byb3BlcnR5TGlzdFwiO1xuaW1wb3J0IHtTcHJpdGUsIFBvaW50LCBUZXh0dXJlfSBmcm9tIFwicGl4aS5qc1wiO1xuXG4vKipcbiAqIEFuIGluZGl2aWR1YWwgcGFydGljbGUgaW1hZ2UuIFlvdSBzaG91bGRuJ3QgaGF2ZSB0byBkZWFsIHdpdGggdGhlc2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJ0aWNsZSBleHRlbmRzIFNwcml0ZVxue1xuXHQvKipcblx0ICogVGhlIGVtaXR0ZXIgdGhhdCBjb250cm9scyB0aGlzIHBhcnRpY2xlLlxuXHQgKi9cblx0cHVibGljIGVtaXR0ZXI6IEVtaXR0ZXI7XG5cdC8qKlxuXHQgKiBUaGUgdmVsb2NpdHkgb2YgdGhlIHBhcnRpY2xlLiBTcGVlZCBtYXkgY2hhbmdlLCBidXQgdGhlIGFuZ2xlIGFsc29cblx0ICogY29udGFpbmVkIGluIHZlbG9jaXR5IGlzIGNvbnN0YW50LlxuXHQgKi9cblx0cHVibGljIHZlbG9jaXR5OiBQb2ludDtcblx0LyoqXG5cdCAqIFRoZSBtYXhpbXVtIGxpZmV0aW1lIG9mIHRoaXMgcGFydGljbGUsIGluIHNlY29uZHMuXG5cdCAqL1xuXHRwdWJsaWMgbWF4TGlmZTogbnVtYmVyO1xuXHQvKipcblx0ICogVGhlIGN1cnJlbnQgYWdlIG9mIHRoZSBwYXJ0aWNsZSwgaW4gc2Vjb25kcy5cblx0ICovXG5cdHB1YmxpYyBhZ2U6IG51bWJlcjtcblx0LyoqXG5cdCAqIEEgc2ltcGxlIGVhc2luZyBmdW5jdGlvbiB0byBiZSBhcHBsaWVkIHRvIGFsbCBwcm9wZXJ0aWVzIHRoYXRcblx0ICogYXJlIGJlaW5nIGludGVycG9sYXRlZC5cblx0ICovXG5cdHB1YmxpYyBlYXNlOiBTaW1wbGVFYXNlO1xuXHQvKipcblx0ICogRXh0cmEgZGF0YSB0aGF0IHRoZSBlbWl0dGVyIHBhc3NlcyBhbG9uZyBmb3IgY3VzdG9tIHBhcnRpY2xlcy5cblx0ICovXG5cdHB1YmxpYyBleHRyYURhdGE6IGFueTtcblx0LyoqXG5cdCAqIFRoZSBhbHBoYSBvZiB0aGUgcGFydGljbGUgdGhyb3VnaG91dCBpdHMgbGlmZS5cblx0ICovXG5cdHB1YmxpYyBhbHBoYUxpc3Q6IFByb3BlcnR5TGlzdDxudW1iZXI+O1xuXHQvKipcblx0ICogVGhlIHNwZWVkIG9mIHRoZSBwYXJ0aWNsZSB0aHJvdWdob3V0IGl0cyBsaWZlLlxuXHQgKi9cblx0cHVibGljIHNwZWVkTGlzdDogUHJvcGVydHlMaXN0PG51bWJlcj47XG5cdC8qKlxuXHQgKiBBIG11bHRpcGxpZXIgZnJvbSAwLTEgYXBwbGllZCB0byB0aGUgc3BlZWQgb2YgdGhlIHBhcnRpY2xlIGF0IGFsbCB0aW1lcy5cblx0ICovXG5cdHB1YmxpYyBzcGVlZE11bHRpcGxpZXI6IG51bWJlcjtcblx0LyoqXG5cdCAqIEFjY2VsZXJhdGlvbiB0byBhcHBseSB0byB0aGUgcGFydGljbGUuXG5cdCAqL1xuXHRwdWJsaWMgYWNjZWxlcmF0aW9uOiBQb2ludDtcblx0LyoqXG5cdCAqIFRoZSBtYXhpbXVtIHNwZWVkIGFsbG93ZWQgZm9yIGFjY2VsZXJhdGluZyBwYXJ0aWNsZXMuIE5lZ2F0aXZlIHZhbHVlcywgdmFsdWVzIG9mIDAgb3IgTmFOXG5cdCAqIHdpbGwgZGlzYWJsZSB0aGUgbWF4aW11bSBzcGVlZC5cblx0ICovXG5cdHB1YmxpYyBtYXhTcGVlZDogbnVtYmVyO1xuXHQvKipcblx0ICogU3BlZWQgYXQgd2hpY2ggdGhlIHBhcnRpY2xlIHJvdGF0ZXMsIGluIHJhZGlhbnMgcGVyIHNlY29uZC5cblx0ICovXG5cdHB1YmxpYyByb3RhdGlvblNwZWVkOiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIEFjY2VsZXJhdGlvbiBvZiByb3RhdGlvbiAoYW5ndWxhciBhY2NlbGVyYXRpb24pIHRvIGFwcGx5IHRvIHRoZSBwYXJ0aWNsZS5cblx0ICovXG5cdHB1YmxpYyByb3RhdGlvbkFjY2VsZXJhdGlvbjogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBJZiBwYXJ0aWNsZSByb3RhdGlvbiBpcyBsb2NrZWQsIHByZXZlbnRpbmcgcm90YXRpb24gZnJvbSBvY2N1cnJpbmcgZHVlXG5cdCAqIHRvIGRpcmVjdGlvbmFsIGNoYW5nZXMuXG5cdCAqL1xuXHRwdWJsaWMgbm9Sb3RhdGlvbjogYm9vbGVhbjtcblx0LyoqXG5cdCAqIFRoZSBzY2FsZSBvZiB0aGUgcGFydGljbGUgdGhyb3VnaG91dCBpdHMgbGlmZS5cblx0ICovXG5cdHB1YmxpYyBzY2FsZUxpc3Q6IFByb3BlcnR5TGlzdDxudW1iZXI+O1xuXHQvKipcblx0ICogQSBtdWx0aXBsaWVyIGZyb20gMC0xIGFwcGxpZWQgdG8gdGhlIHNjYWxlIG9mIHRoZSBwYXJ0aWNsZSBhdCBhbGwgdGltZXMuXG5cdCAqL1xuXHRwdWJsaWMgc2NhbGVNdWx0aXBsaWVyOiBudW1iZXI7XG5cdC8qKlxuXHQgKiBUaGUgdGludCBvZiB0aGUgcGFydGljbGUgdGhyb3VnaG91dCBpdHMgbGlmZS5cblx0ICovXG5cdHB1YmxpYyBjb2xvckxpc3Q6IFByb3BlcnR5TGlzdDxDb2xvcj47XG5cdC8qKlxuXHQgKiBBIHJlZmVyZW5jZSB0byBpbml0LCBzbyB0aGF0IHN1YmNsYXNzZXMgY2FuIGFjY2VzcyBpdCB3aXRob3V0IHRoZSBwZW5hbHR5IG9mIEZ1bmN0aW9uLmNhbGwoKVxuXHQgKi9cblx0cHJvdGVjdGVkIFBhcnRpY2xlX2luaXQ6IHR5cGVvZiBQYXJ0aWNsZS5wcm90b3R5cGUuaW5pdDtcblx0LyoqXG5cdCAqIEEgcmVmZXJlbmNlIHRvIHVwZGF0ZSBzbyB0aGF0IHN1YmNsYXNzZXMgY2FuIGFjY2VzcyB0aGUgb3JpZ2luYWwgd2l0aG91dCB0aGUgb3ZlcmhlYWRcblx0ICogb2YgRnVuY3Rpb24uY2FsbCgpLlxuXHQgKiBAcGFyYW0gZGVsdGEgVGltZSBlbGFwc2VkIHNpbmNlIHRoZSBwcmV2aW91cyBmcmFtZSwgaW4gX19zZWNvbmRzX18uXG5cdCAqIEByZXR1cm4gVGhlIHN0YW5kYXJkIGludGVycG9sYXRpb24gbXVsdGlwbGllciAoMC0xKSB1c2VkIGZvciBhbGwgcmVsZXZhbnQgcGFydGljbGVcblx0ICogICAgICAgICAgICAgICAgICAgcHJvcGVydGllcy4gQSB2YWx1ZSBvZiAtMSBtZWFucyB0aGUgcGFydGljbGUgZGllZCBvZiBvbGQgYWdlIGluc3RlYWQuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgUGFydGljbGVfdXBkYXRlOiB0eXBlb2YgUGFydGljbGUucHJvdG90eXBlLnVwZGF0ZTtcblx0cHJvdGVjdGVkIFBhcnRpY2xlX2Rlc3Ryb3k6IHR5cGVvZiBQYXJ0aWNsZS5wcm90b3R5cGUuZGVzdHJveTtcblx0cHJvdGVjdGVkIFNwcml0ZV9kZXN0cm95OiB0eXBlb2YgU3ByaXRlLnByb3RvdHlwZS5kZXN0cm95O1xuXHQvKipcblx0ICogSWYgYWxwaGEgc2hvdWxkIGJlIGludGVycG9sYXRlZCBhdCBhbGwuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgX2RvQWxwaGE6IGJvb2xlYW47XG5cdC8qKlxuXHQgKiBJZiBzY2FsZSBzaG91bGQgYmUgaW50ZXJwb2xhdGVkIGF0IGFsbC5cblx0ICovXG5cdHByb3RlY3RlZCBfZG9TY2FsZTogYm9vbGVhbjtcblx0LyoqXG5cdCAqIElmIHNwZWVkIHNob3VsZCBiZSBpbnRlcnBvbGF0ZWQgYXQgYWxsLlxuXHQgKi9cblx0cHJvdGVjdGVkIF9kb1NwZWVkOiBib29sZWFuO1xuXHQvKipcblx0ICogSWYgYWNjZWxlcmF0aW9uIHNob3VsZCBiZSBoYW5kbGVkIGF0IGFsbC4gX2RvU3BlZWQgaXMgbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggdGhpcyxcblx0ICogYW5kIF9kb1NwZWVkIGdldHMgcHJpb3JpdHkuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgX2RvQWNjZWxlcmF0aW9uOiBib29sZWFuO1xuXHQvKipcblx0ICogSWYgY29sb3Igc2hvdWxkIGJlIGludGVycG9sYXRlZCBhdCBhbGwuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgX2RvQ29sb3I6IGJvb2xlYW47XG5cdC8qKlxuXHQgKiBJZiBub3JtYWwgbW92ZW1lbnQgc2hvdWxkIGJlIGhhbmRsZWQuIFN1YmNsYXNzZXMgd2lzaGluZyB0byBvdmVycmlkZSBtb3ZlbWVudFxuXHQgKiBjYW4gc2V0IHRoaXMgdG8gZmFsc2UgaW4gaW5pdCgpLlxuXHQgKi9cblx0cHJvdGVjdGVkIF9kb05vcm1hbE1vdmVtZW50OiBib29sZWFuO1xuXHQvKipcblx0ICogT25lIGRpdmlkZWQgYnkgdGhlIG1heCBsaWZlIG9mIHRoZSBwYXJ0aWNsZSwgc2F2ZWQgZm9yIHNsaWdodGx5IGZhc3RlciBtYXRoLlxuXHQgKi9cblx0cHJpdmF0ZSBfb25lT3ZlckxpZmU6IG51bWJlcjtcblx0LyoqXG5cdCAqIFJlZmVyZW5jZSB0byB0aGUgbmV4dCBwYXJ0aWNsZSBpbiB0aGUgbGlzdC5cblx0ICovXG5cdHB1YmxpYyBuZXh0OiBQYXJ0aWNsZTtcblxuXHQvKipcblx0ICogUmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91cyBwYXJ0aWNsZSBpbiB0aGUgbGlzdC5cblx0ICovXG5cdHB1YmxpYyBwcmV2OiBQYXJ0aWNsZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtQSVhJLnBhcnRpY2xlcy5FbWl0dGVyfSBlbWl0dGVyIFRoZSBlbWl0dGVyIHRoYXQgY29udHJvbHMgdGhpcyBwYXJ0aWNsZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKGVtaXR0ZXI6IEVtaXR0ZXIpXG5cdHtcblx0XHQvL3N0YXJ0IG9mZiB0aGUgc3ByaXRlIHdpdGggYSBibGFuayB0ZXh0dXJlLCBzaW5jZSB3ZSBhcmUgZ29pbmcgdG8gcmVwbGFjZSBpdFxuXHRcdC8vbGF0ZXIgd2hlbiB0aGUgcGFydGljbGUgaXMgaW5pdGlhbGl6ZWQuXG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuXHRcdC8vcGFydGljbGVzIHNob3VsZCBiZSBjZW50ZXJlZFxuXHRcdHRoaXMuYW5jaG9yLnggPSB0aGlzLmFuY2hvci55ID0gMC41O1xuXHRcdHRoaXMudmVsb2NpdHkgPSBuZXcgUG9pbnQoKTtcblx0XHR0aGlzLnJvdGF0aW9uU3BlZWQgPSAwO1xuXHRcdHRoaXMucm90YXRpb25BY2NlbGVyYXRpb24gPSAwO1xuXHRcdHRoaXMubWF4TGlmZSA9IDA7XG5cdFx0dGhpcy5hZ2UgPSAwO1xuXHRcdHRoaXMuZWFzZSA9IG51bGw7XG5cdFx0dGhpcy5leHRyYURhdGEgPSBudWxsO1xuXHRcdHRoaXMuYWxwaGFMaXN0ID0gbmV3IFByb3BlcnR5TGlzdCgpO1xuXHRcdHRoaXMuc3BlZWRMaXN0ID0gbmV3IFByb3BlcnR5TGlzdCgpO1xuXHRcdHRoaXMuc3BlZWRNdWx0aXBsaWVyID0gMTtcblx0XHR0aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBQb2ludCgpO1xuXHRcdHRoaXMubWF4U3BlZWQgPSBOYU47XG5cdFx0dGhpcy5zY2FsZUxpc3QgPSBuZXcgUHJvcGVydHlMaXN0KCk7XG5cdFx0dGhpcy5zY2FsZU11bHRpcGxpZXIgPSAxO1xuXHRcdHRoaXMuY29sb3JMaXN0ID0gbmV3IFByb3BlcnR5TGlzdCh0cnVlKTtcblx0XHR0aGlzLl9kb0FscGhhID0gZmFsc2U7XG5cdFx0dGhpcy5fZG9TY2FsZSA9IGZhbHNlO1xuXHRcdHRoaXMuX2RvU3BlZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9kb0FjY2VsZXJhdGlvbiA9IGZhbHNlO1xuXHRcdHRoaXMuX2RvQ29sb3IgPSBmYWxzZTtcblx0XHR0aGlzLl9kb05vcm1hbE1vdmVtZW50ID0gZmFsc2U7XG5cdFx0dGhpcy5fb25lT3ZlckxpZmUgPSAwO1xuXHRcdHRoaXMubmV4dCA9IG51bGw7XG5cdFx0dGhpcy5wcmV2ID0gbnVsbDtcblxuXHRcdC8vc2F2ZSBvZnRlbiB1c2VkIGZ1bmN0aW9ucyBvbiB0aGUgaW5zdGFuY2UgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlIGZvciBiZXR0ZXIgc3BlZWRcblx0XHR0aGlzLmluaXQgPSB0aGlzLmluaXQ7XG5cdFx0dGhpcy5QYXJ0aWNsZV9pbml0ID0gUGFydGljbGUucHJvdG90eXBlLmluaXQ7XG5cdFx0dGhpcy51cGRhdGUgPSB0aGlzLnVwZGF0ZTtcblx0XHR0aGlzLlBhcnRpY2xlX3VwZGF0ZSA9IFBhcnRpY2xlLnByb3RvdHlwZS51cGRhdGU7XG5cdFx0dGhpcy5TcHJpdGVfZGVzdHJveSA9IHN1cGVyLmRlc3Ryb3k7XG5cdFx0dGhpcy5QYXJ0aWNsZV9kZXN0cm95ID0gUGFydGljbGUucHJvdG90eXBlLmRlc3Ryb3k7XG5cdFx0dGhpcy5hcHBseUFydCA9IHRoaXMuYXBwbHlBcnQ7XG5cdFx0dGhpcy5raWxsID0gdGhpcy5raWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRoZSBwYXJ0aWNsZSBmb3IgdXNlLCBiYXNlZCBvbiB0aGUgcHJvcGVydGllcyB0aGF0IGhhdmUgdG9cblx0ICogaGF2ZSBiZWVuIHNldCBhbHJlYWR5IG9uIHRoZSBwYXJ0aWNsZS5cblx0ICovXG5cdHB1YmxpYyBpbml0KClcblx0e1xuXHRcdC8vcmVzZXQgdGhlIGFnZVxuXHRcdHRoaXMuYWdlID0gMDtcblx0XHQvL3NldCB1cCB0aGUgdmVsb2NpdHkgYmFzZWQgb24gdGhlIHN0YXJ0IHNwZWVkIGFuZCByb3RhdGlvblxuXHRcdHRoaXMudmVsb2NpdHkueCA9IHRoaXMuc3BlZWRMaXN0LmN1cnJlbnQudmFsdWUgKiB0aGlzLnNwZWVkTXVsdGlwbGllcjtcblx0XHR0aGlzLnZlbG9jaXR5LnkgPSAwO1xuXHRcdFBhcnRpY2xlVXRpbHMucm90YXRlUG9pbnQodGhpcy5yb3RhdGlvbiwgdGhpcy52ZWxvY2l0eSk7XG5cdFx0aWYgKHRoaXMubm9Sb3RhdGlvbilcblx0XHR7XG5cdFx0XHR0aGlzLnJvdGF0aW9uID0gMDtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdC8vY29udmVydCByb3RhdGlvbiB0byBSYWRpYW5zIGZyb20gRGVncmVlc1xuXHRcdFx0dGhpcy5yb3RhdGlvbiAqPSBQYXJ0aWNsZVV0aWxzLkRFR19UT19SQURTO1xuXHRcdH1cblx0XHQvL2NvbnZlcnQgcm90YXRpb24gc3BlZWQgdG8gUmFkaWFucyBmcm9tIERlZ3JlZXNcblx0XHR0aGlzLnJvdGF0aW9uU3BlZWQgKj0gUGFydGljbGVVdGlscy5ERUdfVE9fUkFEUztcblx0XHR0aGlzLnJvdGF0aW9uQWNjZWxlcmF0aW9uICo9IFBhcnRpY2xlVXRpbHMuREVHX1RPX1JBRFM7XG5cblx0XHQvL3NldCBhbHBoYSB0byBpbml0YWwgYWxwaGFcblx0XHR0aGlzLmFscGhhID0gdGhpcy5hbHBoYUxpc3QuY3VycmVudC52YWx1ZTtcblx0XHQvL3NldCBzY2FsZSB0byBpbml0aWFsIHNjYWxlXG5cdFx0dGhpcy5zY2FsZS54ID0gdGhpcy5zY2FsZS55ID0gdGhpcy5zY2FsZUxpc3QuY3VycmVudC52YWx1ZTtcblx0XHQvL2ZpZ3VyZSBvdXQgd2hhdCB3ZSBuZWVkIHRvIGludGVycG9sYXRlXG5cdFx0dGhpcy5fZG9BbHBoYSA9ICEhdGhpcy5hbHBoYUxpc3QuY3VycmVudC5uZXh0O1xuXHRcdHRoaXMuX2RvU3BlZWQgPSAhIXRoaXMuc3BlZWRMaXN0LmN1cnJlbnQubmV4dDtcblx0XHR0aGlzLl9kb1NjYWxlID0gISF0aGlzLnNjYWxlTGlzdC5jdXJyZW50Lm5leHQ7XG5cdFx0dGhpcy5fZG9Db2xvciA9ICEhdGhpcy5jb2xvckxpc3QuY3VycmVudC5uZXh0O1xuXHRcdHRoaXMuX2RvQWNjZWxlcmF0aW9uID0gdGhpcy5hY2NlbGVyYXRpb24ueCAhPT0gMCB8fCB0aGlzLmFjY2VsZXJhdGlvbi55ICE9PSAwO1xuXHRcdC8vX2RvTm9ybWFsTW92ZW1lbnQgY2FuIGJlIGNhbmNlbGxlZCBieSBzdWJjbGFzc2VzXG5cdFx0dGhpcy5fZG9Ob3JtYWxNb3ZlbWVudCA9IHRoaXMuX2RvU3BlZWQgfHwgdGhpcy5zcGVlZExpc3QuY3VycmVudC52YWx1ZSAhPT0gMCB8fCB0aGlzLl9kb0FjY2VsZXJhdGlvbjtcblx0XHQvL3NhdmUgb3VyIGxlcnAgaGVscGVyXG5cdFx0dGhpcy5fb25lT3ZlckxpZmUgPSAxIC8gdGhpcy5tYXhMaWZlO1xuXHRcdC8vc2V0IHRoZSBpbml0YWwgY29sb3Jcblx0XHRsZXQgY29sb3IgPSB0aGlzLmNvbG9yTGlzdC5jdXJyZW50LnZhbHVlO1xuXHRcdHRoaXMudGludCA9IFBhcnRpY2xlVXRpbHMuY29tYmluZVJHQkNvbXBvbmVudHMoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cdFx0Ly9lbnN1cmUgdmlzaWJpbGl0eVxuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgdGV4dHVyZSBmb3IgdGhlIHBhcnRpY2xlLiBUaGlzIGNhbiBiZSBvdmVycmlkZGVuIHRvIGFsbG93XG5cdCAqIGZvciBhbiBhbmltYXRlZCBwYXJ0aWNsZS5cblx0ICogQHBhcmFtIGFydCBUaGUgdGV4dHVyZSB0byBzZXQuXG5cdCAqL1xuXHRwdWJsaWMgYXBwbHlBcnQoYXJ0OiBhbnkpXG5cdHtcblx0XHR0aGlzLnRleHR1cmUgPSBhcnQgfHwgVGV4dHVyZS5FTVBUWTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBwYXJ0aWNsZS5cblx0ICogQHBhcmFtIGRlbHRhIFRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgcHJldmlvdXMgZnJhbWUsIGluIF9fc2Vjb25kc19fLlxuXHQgKiBAcmV0dXJuIFRoZSBzdGFuZGFyZCBpbnRlcnBvbGF0aW9uIG11bHRpcGxpZXIgKDAtMSkgdXNlZCBmb3IgYWxsXG5cdCAqICAgICAgICAgcmVsZXZhbnQgcGFydGljbGUgcHJvcGVydGllcy4gQSB2YWx1ZSBvZiAtMSBtZWFucyB0aGUgcGFydGljbGVcblx0ICogICAgICAgICBkaWVkIG9mIG9sZCBhZ2UgaW5zdGVhZC5cblx0ICovXG5cdHB1YmxpYyB1cGRhdGUoZGVsdGE6IG51bWJlcik6IG51bWJlclxuXHR7XG5cdFx0Ly9pbmNyZWFzZSBhZ2Vcblx0XHR0aGlzLmFnZSArPSBkZWx0YTtcblx0XHQvL3JlY3ljbGUgcGFydGljbGUgaWYgaXQgaXMgdG9vIG9sZFxuXHRcdGlmKHRoaXMuYWdlID49IHRoaXMubWF4TGlmZSB8fCB0aGlzLmFnZSA8IDApXG5cdFx0e1xuXHRcdFx0dGhpcy5raWxsKCk7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXG5cdFx0Ly9kZXRlcm1pbmUgb3VyIGludGVycG9sYXRpb24gdmFsdWVcblx0XHRsZXQgbGVycCA9IHRoaXMuYWdlICogdGhpcy5fb25lT3ZlckxpZmU7Ly9saWZldGltZSAvIG1heExpZmU7XG5cdFx0aWYgKHRoaXMuZWFzZSlcblx0XHR7XG5cdFx0XHRpZih0aGlzLmVhc2UubGVuZ3RoID09IDQpXG5cdFx0XHR7XG5cdFx0XHRcdC8vdGhlIHQsIGIsIGMsIGQgcGFyYW1ldGVycyB0aGF0IHNvbWUgdHdlZW4gbGlicmFyaWVzIHVzZVxuXHRcdFx0XHQvLyh0aW1lLCBpbml0aWFsIHZhbHVlLCBlbmQgdmFsdWUsIGR1cmF0aW9uKVxuXHRcdFx0XHRsZXJwID0gKHRoaXMuZWFzZSBhcyBhbnkpKGxlcnAsIDAsIDEsIDEpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHQvL3RoZSBzaW1wbGlmaWVkIHZlcnNpb24gdGhhdCB3ZSBsaWtlIHRoYXQgdGFrZXNcblx0XHRcdFx0Ly9vbmUgcGFyYW1ldGVyLCB0aW1lIGZyb20gMC0xLiBUd2VlbkpTIGVhc2VzIHByb3ZpZGUgdGhpcyB1c2FnZS5cblx0XHRcdFx0bGVycCA9IHRoaXMuZWFzZShsZXJwKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL2ludGVycG9sYXRlIGFscGhhXG5cdFx0aWYgKHRoaXMuX2RvQWxwaGEpXG5cdFx0XHR0aGlzLmFscGhhID0gdGhpcy5hbHBoYUxpc3QuaW50ZXJwb2xhdGUobGVycCk7XG5cdFx0Ly9pbnRlcnBvbGF0ZSBzY2FsZVxuXHRcdGlmICh0aGlzLl9kb1NjYWxlKVxuXHRcdHtcblx0XHRcdGxldCBzY2FsZSA9IHRoaXMuc2NhbGVMaXN0LmludGVycG9sYXRlKGxlcnApICogdGhpcy5zY2FsZU11bHRpcGxpZXI7XG5cdFx0XHR0aGlzLnNjYWxlLnggPSB0aGlzLnNjYWxlLnkgPSBzY2FsZTtcblx0XHR9XG5cdFx0Ly9oYW5kbGUgbW92ZW1lbnRcblx0XHRpZih0aGlzLl9kb05vcm1hbE1vdmVtZW50KVxuXHRcdHtcblx0XHRcdGxldCBkZWx0YVg6bnVtYmVyO1xuXHRcdFx0bGV0IGRlbHRhWTpudW1iZXI7XG5cdFx0XHQvL2ludGVycG9sYXRlIHNwZWVkXG5cdFx0XHRpZiAodGhpcy5fZG9TcGVlZClcblx0XHRcdHtcblx0XHRcdFx0bGV0IHNwZWVkID0gdGhpcy5zcGVlZExpc3QuaW50ZXJwb2xhdGUobGVycCkgKiB0aGlzLnNwZWVkTXVsdGlwbGllcjtcblx0XHRcdFx0UGFydGljbGVVdGlscy5ub3JtYWxpemUodGhpcy52ZWxvY2l0eSk7XG5cdFx0XHRcdFBhcnRpY2xlVXRpbHMuc2NhbGVCeSh0aGlzLnZlbG9jaXR5LCBzcGVlZCk7XG5cdFx0XHRcdGRlbHRhWCA9IHRoaXMudmVsb2NpdHkueCAqIGRlbHRhO1xuXHRcdFx0XHRkZWx0YVkgPSB0aGlzLnZlbG9jaXR5LnkgKiBkZWx0YTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYodGhpcy5fZG9BY2NlbGVyYXRpb24pXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IG9sZFZYID0gdGhpcy52ZWxvY2l0eS54O1xuXHRcdFx0XHRjb25zdCBvbGRWWSA9IHRoaXMudmVsb2NpdHkueTtcblx0XHRcdFx0dGhpcy52ZWxvY2l0eS54ICs9IHRoaXMuYWNjZWxlcmF0aW9uLnggKiBkZWx0YTtcblx0XHRcdFx0dGhpcy52ZWxvY2l0eS55ICs9IHRoaXMuYWNjZWxlcmF0aW9uLnkgKiBkZWx0YTtcblx0XHRcdFx0aWYgKHRoaXMubWF4U3BlZWQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsZXQgY3VycmVudFNwZWVkID0gUGFydGljbGVVdGlscy5sZW5ndGgodGhpcy52ZWxvY2l0eSk7XG5cdFx0XHRcdFx0Ly9pZiB3ZSBhcmUgZ29pbmcgZmFzdGVyIHRoYW4gd2Ugc2hvdWxkLCBjbGFtcCBhdCB0aGUgbWF4IHNwZWVkXG5cdFx0XHRcdFx0Ly9ETyBOT1QgcmVjYWxjdWxhdGUgdmVjdG9yIGxlbmd0aFxuXHRcdFx0XHRcdGlmIChjdXJyZW50U3BlZWQgPiB0aGlzLm1heFNwZWVkKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFBhcnRpY2xlVXRpbHMuc2NhbGVCeSh0aGlzLnZlbG9jaXR5LCB0aGlzLm1heFNwZWVkIC8gY3VycmVudFNwZWVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHBvc2l0aW9uIGRlbHRhIGJ5IHRoZSBtaWRwb2ludCBiZXR3ZWVuIG91ciBvbGQgdmVsb2NpdHkgYW5kIG91ciBuZXcgdmVsb2NpdHlcblx0XHRcdFx0ZGVsdGFYID0gKG9sZFZYICsgdGhpcy52ZWxvY2l0eS54KSAvIDIgKiBkZWx0YTtcblx0XHRcdFx0ZGVsdGFZID0gKG9sZFZZICsgdGhpcy52ZWxvY2l0eS55KSAvIDIgKiBkZWx0YTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0ZGVsdGFYID0gdGhpcy52ZWxvY2l0eS54ICogZGVsdGE7XG5cdFx0XHRcdGRlbHRhWSA9IHRoaXMudmVsb2NpdHkueSAqIGRlbHRhO1xuXHRcdFx0fVxuXHRcdFx0Ly9hZGp1c3QgcG9zaXRpb24gYmFzZWQgb24gdmVsb2NpdHlcblx0XHRcdHRoaXMucG9zaXRpb24ueCArPSBkZWx0YVg7XG5cdFx0XHR0aGlzLnBvc2l0aW9uLnkgKz0gZGVsdGFZO1xuXHRcdH1cblx0XHQvL2ludGVycG9sYXRlIGNvbG9yXG5cdFx0aWYgKHRoaXMuX2RvQ29sb3IpXG5cdFx0e1xuXHRcdFx0dGhpcy50aW50ID0gdGhpcy5jb2xvckxpc3QuaW50ZXJwb2xhdGUobGVycCk7XG5cdFx0fVxuXHRcdC8vdXBkYXRlIHJvdGF0aW9uXG5cdFx0aWYgKHRoaXMucm90YXRpb25BY2NlbGVyYXRpb24gIT09IDApXG5cdFx0e1xuXHRcdFx0Y29uc3QgbmV3Um90YXRpb25TcGVlZCA9IHRoaXMucm90YXRpb25TcGVlZCArIHRoaXMucm90YXRpb25BY2NlbGVyYXRpb24gKiBkZWx0YTtcblxuXHRcdFx0dGhpcy5yb3RhdGlvbiArPSAodGhpcy5yb3RhdGlvblNwZWVkICsgbmV3Um90YXRpb25TcGVlZCkgLyAyICogZGVsdGE7XG5cdFx0XHR0aGlzLnJvdGF0aW9uU3BlZWQgPSBuZXdSb3RhdGlvblNwZWVkO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLnJvdGF0aW9uU3BlZWQgIT09IDApXG5cdFx0e1xuXHRcdFx0dGhpcy5yb3RhdGlvbiArPSB0aGlzLnJvdGF0aW9uU3BlZWQgKiBkZWx0YTtcblx0XHR9XG5cdFx0ZWxzZSBpZih0aGlzLmFjY2VsZXJhdGlvbiAmJiAhdGhpcy5ub1JvdGF0aW9uKVxuXHRcdHtcblx0XHRcdHRoaXMucm90YXRpb24gPSBNYXRoLmF0YW4yKHRoaXMudmVsb2NpdHkueSwgdGhpcy52ZWxvY2l0eS54KTsvLyArIE1hdGguUEkgLyAyO1xuXHRcdH1cblx0XHRyZXR1cm4gbGVycDtcblx0fVxuXG5cdC8qKlxuXHQgKiBLaWxscyB0aGUgcGFydGljbGUsIHJlbW92aW5nIGl0IGZyb20gdGhlIGRpc3BsYXkgbGlzdFxuXHQgKiBhbmQgdGVsbGluZyB0aGUgZW1pdHRlciB0byByZWN5Y2xlIGl0LlxuXHQgKi9cblx0cHVibGljIGtpbGwoKVxuXHR7XG5cdFx0dGhpcy5lbWl0dGVyLnJlY3ljbGUodGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICogRGVzdHJveXMgdGhlIHBhcnRpY2xlLCByZW1vdmluZyByZWZlcmVuY2VzIGFuZCBwcmV2ZW50aW5nIGZ1dHVyZSB1c2UuXG5cdCAqL1xuXHRwdWJsaWMgZGVzdHJveSgpXG5cdHtcblx0XHRpZiAodGhpcy5wYXJlbnQpXG5cdFx0XHR0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcblx0XHR0aGlzLlNwcml0ZV9kZXN0cm95KCk7XG5cdFx0dGhpcy5lbWl0dGVyID0gdGhpcy52ZWxvY2l0eSA9IHRoaXMuY29sb3JMaXN0ID0gdGhpcy5zY2FsZUxpc3QgPSB0aGlzLmFscGhhTGlzdCA9XG5cdFx0XHR0aGlzLnNwZWVkTGlzdCA9IHRoaXMuZWFzZSA9IHRoaXMubmV4dCA9IHRoaXMucHJldiA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIG92ZXIgdGhlIGFydCB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIEVtaXR0ZXIncyBpbml0KCkgZnVuY3Rpb24sIHRvIGRvIGFueSBzcGVjaWFsXG5cdCAqIG1vZGlmaWNhdGlvbnMgdG8gcHJlcGFyZSBpdCBhaGVhZCBvZiB0aW1lLlxuXHQgKiBAcGFyYW0gYXJ0IFRoZSBhcnJheSBvZiBhcnQgZGF0YS4gRm9yIFBhcnRpY2xlLCBpdCBzaG91bGQgYmUgYW4gYXJyYXkgb2Zcblx0ICogICAgICAgICAgICBUZXh0dXJlcy4gQW55IHN0cmluZ3MgaW4gdGhlIGFycmF5IHdpbGwgYmUgY29udmVydGVkIHRvXG5cdCAqICAgICAgICAgICAgVGV4dHVyZXMgdmlhIFRleHR1cmUuZnJvbSgpLlxuXHQgKiBAcmV0dXJuIFRoZSBhcnQsIGFmdGVyIGFueSBuZWVkZWQgbW9kaWZpY2F0aW9ucy5cblx0ICovXG5cdHB1YmxpYyBzdGF0aWMgcGFyc2VBcnQoYXJ0OmFueVtdKTogYW55W11cblx0e1xuXHRcdC8vY29udmVydCBhbnkgc3RyaW5ncyB0byBUZXh0dXJlcy5cblx0XHRsZXQgaTtcblx0XHRmb3IoaSA9IGFydC5sZW5ndGg7IGkgPj0gMDsgLS1pKVxuXHRcdHtcblx0XHRcdGlmKHR5cGVvZiBhcnRbaV0gPT0gXCJzdHJpbmdcIilcblx0XHRcdFx0YXJ0W2ldID0gR2V0VGV4dHVyZUZyb21TdHJpbmcoYXJ0W2ldKTtcblx0XHR9XG5cdFx0Ly9wYXJ0aWNsZXMgZnJvbSBkaWZmZXJlbnQgYmFzZSB0ZXh0dXJlcyB3aWxsIGJlIHNsb3dlciBpbiBXZWJHTCB0aGFuIGlmIHRoZXlcblx0XHQvL3dlcmUgZnJvbSBvbmUgc3ByaXRlc2hlZXRcblx0XHRpZihQYXJ0aWNsZVV0aWxzLnZlcmJvc2UpXG5cdFx0e1xuXHRcdFx0Zm9yKGkgPSBhcnQubGVuZ3RoIC0gMTsgaSA+IDA7IC0taSlcblx0XHRcdHtcblx0XHRcdFx0aWYoYXJ0W2ldLmJhc2VUZXh0dXJlICE9IGFydFtpIC0gMV0uYmFzZVRleHR1cmUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAod2luZG93LmNvbnNvbGUpXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJQaXhpUGFydGljbGVzOiB1c2luZyBwYXJ0aWNsZSB0ZXh0dXJlcyBmcm9tIGRpZmZlcmVudCBpbWFnZXMgbWF5IGhpbmRlciBwZXJmb3JtYW5jZSBpbiBXZWJHTFwiKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnQ7XG5cdH1cblxuXHQvKipcblx0ICogUGFyc2VzIGV4dHJhIGVtaXR0ZXIgZGF0YSB0byBlbnN1cmUgaXQgaXMgc2V0IHVwIGZvciB0aGlzIHBhcnRpY2xlIGNsYXNzLlxuXHQgKiBQYXJ0aWNsZSBkb2VzIG5vdGhpbmcgdG8gdGhlIGV4dHJhIGRhdGEuXG5cdCAqIEBwYXJhbSBleHRyYURhdGEgVGhlIGV4dHJhIGRhdGEgZnJvbSB0aGUgcGFydGljbGUgY29uZmlnLlxuXHQgKiBAcmV0dXJuIFRoZSBwYXJzZWQgZXh0cmEgZGF0YS5cblx0ICovXG5cdHB1YmxpYyBzdGF0aWMgcGFyc2VEYXRhKGV4dHJhRGF0YTogYW55KTogYW55XG5cdHtcblx0XHRyZXR1cm4gZXh0cmFEYXRhO1xuXHR9XG59XG4iLCJpbXBvcnQge1BvaW50fSBmcm9tIFwicGl4aS5qc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhc2ljUG9pbnRcbntcblx0eDogbnVtYmVyO1xuXHR5OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VnbWVudFxue1xuXHRwMTogQmFzaWNQb2ludDtcblx0cDI6IEJhc2ljUG9pbnQ7XG5cdGw6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDaGFpbiBvZiBsaW5lIHNlZ21lbnRzIGZvciBnZW5lcmF0aW5nIHNwYXduIHBvc2l0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBvbHlnb25hbENoYWluXG57XG5cdC8qKlxuXHQgKiBMaXN0IG9mIHNlZ21lbnQgb2JqZWN0cyBpbiB0aGUgY2hhaW4uXG5cdCAqL1xuXHRwcml2YXRlIHNlZ21lbnRzOlNlZ21lbnRbXTtcblx0LyoqXG5cdCAqIFRvdGFsIGxlbmd0aCBvZiBhbGwgc2VnbWVudHMgb2YgdGhlIGNoYWluLlxuXHQgKi9cblx0cHJpdmF0ZSB0b3RhbExlbmd0aDpudW1iZXI7XG5cdC8qKlxuXHQgKiBUb3RhbCBsZW5ndGggb2Ygc2VnbWVudHMgdXAgdG8gYW5kIGluY2x1ZGluZyB0aGUgc2VnbWVudCBvZiB0aGUgc2FtZSBpbmRleC5cblx0ICogVXNlZCBmb3Igd2VpZ2h0ZWQgcmFuZG9tIHNlbGVjdGlvbiBvZiBzZWdtZW50LlxuXHQgKi9cblx0cHJpdmF0ZSBjb3VudGluZ0xlbmd0aHM6bnVtYmVyW107XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIGRhdGEgUG9pbnQgZGF0YSBmb3IgcG9seWdvbiBjaGFpbnMuIEVpdGhlciBhIGxpc3Qgb2YgcG9pbnRzIGZvciBhIHNpbmdsZSBjaGFpbiwgb3IgYSBsaXN0IG9mIGNoYWlucy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKGRhdGE6QmFzaWNQb2ludFtdfEJhc2ljUG9pbnRbXVtdKVxuXHR7XG5cdFx0dGhpcy5zZWdtZW50cyA9IFtdO1xuXHRcdHRoaXMuY291bnRpbmdMZW5ndGhzID0gW107XG5cdFx0dGhpcy50b3RhbExlbmd0aCA9IDA7XG5cdFx0dGhpcy5pbml0KGRhdGEpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIGRhdGEgUG9pbnQgZGF0YSBmb3IgcG9seWdvbiBjaGFpbnMuIEVpdGhlciBhIGxpc3Qgb2YgcG9pbnRzIGZvciBhIHNpbmdsZSBjaGFpbiwgb3IgYSBsaXN0IG9mIGNoYWlucy5cblx0ICovXG5cdHByaXZhdGUgaW5pdChkYXRhOkJhc2ljUG9pbnRbXXxCYXNpY1BvaW50W11bXSlcblx0e1xuXHRcdC8vIGlmIGRhdGEgaXMgbm90IHByZXNlbnQsIHNldCB1cCBhIHNlZ21lbnQgb2YgbGVuZ3RoIDBcblx0XHRpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKVxuXHRcdHtcblx0XHRcdHRoaXMuc2VnbWVudHMucHVzaCh7cDE6e3g6MCwgeTowfSwgcDI6e3g6MCwgeTowfSwgbDowfSk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShkYXRhWzBdKSlcblx0XHRcdHtcblx0XHRcdFx0Ly8gbGlzdCBvZiBzZWdtZW50IGNoYWlucywgZWFjaCBkZWZpbmVkIGFzIGEgbGlzdCBvZiBwb2ludHNcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gbG9vcCB0aHJvdWdoIHRoZSBjaGFpbiwgY29ubmVjdGluZyBwb2ludHNcblx0XHRcdFx0XHRjb25zdCBjaGFpbiA9IGRhdGFbaV0gYXMgQmFzaWNQb2ludFtdO1xuXHRcdFx0XHRcdGxldCBwcmV2UG9pbnQgPSBjaGFpblswXSBhcyBCYXNpY1BvaW50O1xuXHRcdFx0XHRcdGZvciAobGV0IGogPSAxOyBqIDwgY2hhaW4ubGVuZ3RoOyArK2opXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2Vjb25kID0gY2hhaW5bal0gYXMgQmFzaWNQb2ludDtcblx0XHRcdFx0XHRcdHRoaXMuc2VnbWVudHMucHVzaCh7cDE6IHByZXZQb2ludCwgcDI6IHNlY29uZCwgbDowfSk7XG5cdFx0XHRcdFx0XHRwcmV2UG9pbnQgPSBzZWNvbmQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGxldCBwcmV2UG9pbnQgPSBkYXRhWzBdIGFzIEJhc2ljUG9pbnQ7XG5cdFx0XHRcdC8vIGxpc3Qgb2YgcG9pbnRzXG5cdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5sZW5ndGg7ICsraSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHNlY29uZCA9IGRhdGFbaV0gYXMgQmFzaWNQb2ludDtcblx0XHRcdFx0XHR0aGlzLnNlZ21lbnRzLnB1c2goe3AxOiBwcmV2UG9pbnQsIHAyOiBzZWNvbmQsIGw6MH0pO1xuXHRcdFx0XHRcdHByZXZQb2ludCA9IHNlY29uZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBub3cgZ28gdGhyb3VnaCBvdXIgc2VnbWVudHMgdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGhzIHNvIHRoYXQgd2Vcblx0XHQvLyBjYW4gc2V0IHVwIGEgbmljZSB3ZWlnaHRlZCByYW5kb20gZGlzdHJpYnV0aW9uXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlZ21lbnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRjb25zdCB7cDEsIHAyfSA9IHRoaXMuc2VnbWVudHNbaV07XG5cdFx0XHRjb25zdCBzZWdMZW5ndGggPSBNYXRoLnNxcnQoKHAyLnggLSBwMS54KSAqIChwMi54IC0gcDEueCkgKyAocDIueSAtIHAxLnkpICogKHAyLnkgLSBwMS55KSk7XG5cdFx0XHQvLyBzYXZlIGxlbmd0aCBzbyB3ZSBjYW4gdHVybiBhIHJhbmRvbSBudW1iZXIgaW50byBhIDAtMSBpbnRlcnBvbGF0aW9uIHZhbHVlIGxhdGVyXG5cdFx0XHR0aGlzLnNlZ21lbnRzW2ldLmwgPSBzZWdMZW5ndGg7XG5cdFx0XHR0aGlzLnRvdGFsTGVuZ3RoICs9IHNlZ0xlbmd0aDtcblx0XHRcdC8vIGtlZXAgdHJhY2sgb2YgdGhlIGxlbmd0aCBzbyBmYXIsIGNvdW50aW5nIHVwXG5cdFx0XHR0aGlzLmNvdW50aW5nTGVuZ3Rocy5wdXNoKHRoaXMudG90YWxMZW5ndGgpO1xuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIEdldHMgYSByYW5kb20gcG9pbnQgaW4gdGhlIGNoYWluLlxuXHQgKiBAcGFyYW0gb3V0IFRoZSBwb2ludCB0byBzdG9yZSB0aGUgc2VsZWN0ZWQgcG9zaXRpb24gaW4uXG5cdCAqL1xuXHRwdWJsaWMgZ2V0UmFuZG9tUG9pbnQob3V0OlBvaW50KVxuXHR7XG5cdFx0Ly8gc2VsZWN0IGEgcmFuZG9tIHNwb3QgaW4gdGhlIGxlbmd0aCBvZiB0aGUgY2hhaW5cblx0XHRjb25zdCByYW5kID0gTWF0aC5yYW5kb20oKSAqIHRoaXMudG90YWxMZW5ndGg7XG5cdFx0bGV0IGNob3NlblNlZzpTZWdtZW50O1xuXHRcdGxldCBsZXJwOm51bWJlcjtcblx0XHQvLyBpZiBvbmx5IG9uZSBzZWdtZW50LCBpdCB3aW5zXG5cdFx0aWYgKHRoaXMuc2VnbWVudHMubGVuZ3RoID09PSAxKVxuXHRcdHtcblx0XHRcdGNob3NlblNlZyA9IHRoaXMuc2VnbWVudHNbMF07XG5cdFx0XHRsZXJwID0gcmFuZDtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdC8vIG90aGVyd2lzZSwgZ28gdGhyb3VnaCBjb3VudGluZ0xlbmd0aHMgdW50aWwgd2UgaGF2ZSBkZXRlcm1pbmVkXG5cdFx0XHQvLyB3aGljaCBzZWdtZW50IHdlIGNob3NlXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY291bnRpbmdMZW5ndGhzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGlmIChyYW5kIDwgdGhpcy5jb3VudGluZ0xlbmd0aHNbaV0pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjaG9zZW5TZWcgPSB0aGlzLnNlZ21lbnRzW2ldO1xuXHRcdFx0XHRcdC8vIHNldCBsZXJwIGVxdWFsIHRvIHRoZSBsZW5ndGggaW50byB0aGF0IHNlZ21lbnQgKGkuZS4gdGhlIHJlbWFpbmRlciBhZnRlciBzdWJ0cmFjdGluZyBhbGwgdGhlIHNlZ21lbnRzIGJlZm9yZSBpdClcblx0XHRcdFx0XHRsZXJwID0gaSA9PT0gMCA/IHJhbmQgOiByYW5kIC0gdGhpcy5jb3VudGluZ0xlbmd0aHNbaSAtIDFdO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGRpdmlkZSBsZXJwIGJ5IHRoZSBzZWdtZW50IGxlbmd0aCwgdG8gcmVzdWx0IGluIGEgMC0xIG51bWJlci5cblx0XHRsZXJwIC89IGNob3NlblNlZy5sIHx8IDE7XG5cdFx0Y29uc3Qge3AxLCBwMn0gPSBjaG9zZW5TZWc7XG5cdFx0Ly8gbm93IGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gaW4gdGhlIHNlZ21lbnQgdGhhdCB0aGUgbGVycCB2YWx1ZSByZXByZXNlbnRzXG5cdFx0b3V0LnggPSBwMS54ICsgbGVycCAqIChwMi54IC0gcDEueCk7XG5cdFx0b3V0LnkgPSBwMS55ICsgbGVycCAqIChwMi55IC0gcDEueSk7XG5cdH1cbn0iLCJpbXBvcnQge1BhcnRpY2xlVXRpbHMsIENvbG9yLCBTaW1wbGVFYXNlfSBmcm9tIFwiLi9QYXJ0aWNsZVV0aWxzXCI7XG5pbXBvcnQge1BhcnRpY2xlfSBmcm9tIFwiLi9QYXJ0aWNsZVwiO1xuaW1wb3J0IHtQcm9wZXJ0eU5vZGV9IGZyb20gXCIuL1Byb3BlcnR5Tm9kZVwiO1xuaW1wb3J0IHtQb2x5Z29uYWxDaGFpbn0gZnJvbSBcIi4vUG9seWdvbmFsQ2hhaW5cIjtcbmltcG9ydCB7RW1pdHRlckNvbmZpZywgT2xkRW1pdHRlckNvbmZpZ30gZnJvbSBcIi4vRW1pdHRlckNvbmZpZ1wiO1xuaW1wb3J0IHtQb2ludCwgQ2lyY2xlLCBSZWN0YW5nbGUsIENvbnRhaW5lciwgc2V0dGluZ3N9IGZyb20gXCJwaXhpLmpzXCI7XG5pbXBvcnQgKiBhcyBwaXhpIGZyb20gXCJwaXhpLmpzXCI7XG4vLyBnZXQgdGhlIHNoYXJlZCB0aWNrZXIsIGluIFY0IGFuZCBWNSBmcmllbmRseSBtZXRob2RzXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IHRpY2tlcjogcGl4aS50aWNrZXIuVGlja2VyO1xuLy8gdG8gYXZvaWQgUm9sbHVwIHRyYW5zZm9ybWluZyBvdXIgaW1wb3J0LCBzYXZlIHBpeGkgbmFtZXNwYWNlIGluIGEgdmFyaWFibGVcbmNvbnN0IHBpeGlOUyA9IHBpeGk7XG5pZiAocGFyc2VJbnQoL14oXFxkKylcXC4vLmV4ZWMocGl4aS5WRVJTSU9OKVsxXSkgPCA1KVxue1xuXHR0aWNrZXIgPSBwaXhpTlMudGlja2VyLnNoYXJlZDtcbn1cbmVsc2Vcbntcblx0dGlja2VyID0gKHBpeGlOUyBhcyBhbnkpLlRpY2tlci5zaGFyZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFydGljbGVDb25zdHJ1Y3Rvclxue1xuXHRuZXcgKGVtaXR0ZXI6RW1pdHRlcik6UGFydGljbGU7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBoZWxwZXJQb2ludCA9IG5ldyBQb2ludCgpO1xuXG4vKipcbiAqIEEgcGFydGljbGUgZW1pdHRlci5cbiAqL1xuZXhwb3J0IGNsYXNzIEVtaXR0ZXJcbntcblx0LyoqXG5cdCAqIFRoZSBjb25zdHJ1Y3RvciB1c2VkIHRvIGNyZWF0ZSBuZXcgcGFydGljbGVzLiBUaGUgZGVmYXVsdCBpc1xuXHQgKiB0aGUgYnVpbHQgaW4gcGFydGljbGUgY2xhc3MuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgX3BhcnRpY2xlQ29uc3RydWN0b3I6IHR5cGVvZiBQYXJ0aWNsZTtcblx0Ly9wcm9wZXJ0aWVzIGZvciBpbmRpdmlkdWFsIHBhcnRpY2xlc1xuXHQvKipcblx0ICogQW4gYXJyYXkgb2YgUElYSSBUZXh0dXJlIG9iamVjdHMuXG5cdCAqL1xuXHRwdWJsaWMgcGFydGljbGVJbWFnZXM6IGFueVtdO1xuXHQvKipcblx0ICogVGhlIGZpcnN0IG5vZGUgaW4gdGhlIGxpc3Qgb2YgYWxwaGEgdmFsdWVzIGZvciBhbGwgcGFydGljbGVzLlxuXHQgKi9cblx0cHVibGljIHN0YXJ0QWxwaGE6IFByb3BlcnR5Tm9kZTxudW1iZXI+O1xuXHQvKipcblx0ICogVGhlIGZpcnN0IG5vZGUgaW4gdGhlIGxpc3Qgb2Ygc3BlZWQgdmFsdWVzIG9mIGFsbCBwYXJ0aWNsZXMuXG5cdCAqL1xuXHRwdWJsaWMgc3RhcnRTcGVlZDogUHJvcGVydHlOb2RlPG51bWJlcj47XG5cdC8qKlxuXHQgKiBBIG1pbmltdW0gbXVsdGlwbGllciBmb3IgdGhlIHNwZWVkIG9mIGEgcGFydGljbGUgYXQgYWxsIHN0YWdlcyBvZiBpdHMgbGlmZS4gQSB2YWx1ZSBiZXR3ZWVuXG5cdCAqIG1pbmltdW1TcGVlZE11bHRpcGxpZXIgYW5kIDEgaXMgcmFuZG9tbHkgZ2VuZXJhdGVkIGZvciBlYWNoIHBhcnRpY2xlLlxuXHQgKi9cblx0cHVibGljIG1pbmltdW1TcGVlZE11bHRpcGxpZXI6IG51bWJlcjtcblx0LyoqXG5cdCAqIEFjY2VsZXJhdGlvbiB0byBhcHBseSB0byBwYXJ0aWNsZXMuIFVzaW5nIHRoaXMgZGlzYWJsZXNcblx0ICogYW55IGludGVycG9sYXRpb24gb2YgcGFydGljbGUgc3BlZWQuIElmIHRoZSBwYXJ0aWNsZXMgZG9cblx0ICogbm90IGhhdmUgYSByb3RhdGlvbiBzcGVlZCwgdGhlbiB0aGV5IHdpbGwgYmUgcm90YXRlZCB0b1xuXHQgKiBtYXRjaCB0aGUgZGlyZWN0aW9uIG9mIHRyYXZlbC5cblx0ICovXG5cdHB1YmxpYyBhY2NlbGVyYXRpb246IFBvaW50O1xuXHQvKipcblx0ICogVGhlIG1heGltdW0gc3BlZWQgYWxsb3dlZCBmb3IgYWNjZWxlcmF0aW5nIHBhcnRpY2xlcy4gTmVnYXRpdmUgdmFsdWVzLCB2YWx1ZXMgb2YgMCBvciBOYU5cblx0ICogd2lsbCBkaXNhYmxlIHRoZSBtYXhpbXVtIHNwZWVkLlxuXHQgKi9cblx0cHVibGljIG1heFNwZWVkOiBudW1iZXI7XG5cdC8qKlxuXHQgKiBUaGUgZmlyc3Qgbm9kZSBpbiB0aGUgbGlzdCBvZiBzY2FsZSB2YWx1ZXMgb2YgYWxsIHBhcnRpY2xlcy5cblx0ICovXG5cdHB1YmxpYyBzdGFydFNjYWxlOiBQcm9wZXJ0eU5vZGU8bnVtYmVyPjtcblx0LyoqXG5cdCAqIEEgbWluaW11bSBtdWx0aXBsaWVyIGZvciB0aGUgc2NhbGUgb2YgYSBwYXJ0aWNsZSBhdCBhbGwgc3RhZ2VzIG9mIGl0cyBsaWZlLiBBIHZhbHVlIGJldHdlZW5cblx0ICogbWluaW11bVNjYWxlTXVsdGlwbGllciBhbmQgMSBpcyByYW5kb21seSBnZW5lcmF0ZWQgZm9yIGVhY2ggcGFydGljbGUuXG5cdCAqL1xuXHRwdWJsaWMgbWluaW11bVNjYWxlTXVsdGlwbGllcjogbnVtYmVyO1xuXHQvKipcblx0ICogVGhlIGZpcnN0IG5vZGUgaW4gdGhlIGxpc3Qgb2YgIGNvbG9yIHZhbHVlcyBvZiBhbGwgcGFydGljbGVzLCBhcyByZWQsIGdyZWVuLCBhbmQgYmx1ZVxuXHQgKiB1aW50cyBmcm9tIDAtMjU1LlxuXHQgKi9cblx0cHVibGljIHN0YXJ0Q29sb3I6IFByb3BlcnR5Tm9kZTxDb2xvcj47XG5cdC8qKlxuXHQgKiBUaGUgbWluaW11bSBsaWZldGltZSBmb3IgYSBwYXJ0aWNsZSwgaW4gc2Vjb25kcy5cblx0ICovXG5cdHB1YmxpYyBtaW5MaWZldGltZTogbnVtYmVyO1xuXHQvKipcblx0ICogVGhlIG1heGltdW0gbGlmZXRpbWUgZm9yIGEgcGFydGljbGUsIGluIHNlY29uZHMuXG5cdCAqL1xuXHRwdWJsaWMgbWF4TGlmZXRpbWU6IG51bWJlcjtcblx0LyoqXG5cdCAqIFRoZSBtaW5pbXVtIHN0YXJ0IHJvdGF0aW9uIGZvciBhIHBhcnRpY2xlLCBpbiBkZWdyZWVzLiBUaGlzIHZhbHVlXG5cdCAqIGlzIGlnbm9yZWQgaWYgdGhlIHNwYXduIHR5cGUgaXMgXCJidXJzdFwiIG9yIFwiYXJjXCIuXG5cdCAqL1xuXHRwdWJsaWMgbWluU3RhcnRSb3RhdGlvbjogbnVtYmVyO1xuXHQvKipcblx0ICogVGhlIG1heGltdW0gc3RhcnQgcm90YXRpb24gZm9yIGEgcGFydGljbGUsIGluIGRlZ3JlZXMuIFRoaXMgdmFsdWVcblx0ICogaXMgaWdub3JlZCBpZiB0aGUgc3Bhd24gdHlwZSBpcyBcImJ1cnN0XCIgb3IgXCJhcmNcIi5cblx0ICovXG5cdHB1YmxpYyBtYXhTdGFydFJvdGF0aW9uOiBudW1iZXI7XG5cdC8qKlxuXHQgKiBJZiBubyBwYXJ0aWNsZSByb3RhdGlvbiBzaG91bGQgb2NjdXIuIFN0YXJ0aW5nIHJvdGF0aW9uIHdpbGwgc3RpbGxcblx0ICogYWZmZWN0IHRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggcGFydGljbGVzIG1vdmUuIElmIHRoZSByb3RhdGlvbiBzcGVlZFxuXHQgKiBpcyBzZXQsIHRoZW4gdGhpcyB3aWxsIGJlIGlnbm9yZWQuXG5cdCAqL1xuXHRwdWJsaWMgbm9Sb3RhdGlvbjogYm9vbGVhbjtcblx0LyoqXG5cdCAqIFRoZSBtaW5pbXVtIHJvdGF0aW9uIHNwZWVkIGZvciBhIHBhcnRpY2xlLCBpbiBkZWdyZWVzIHBlciBzZWNvbmQuXG5cdCAqIFRoaXMgb25seSB2aXN1YWxseSBzcGlucyB0aGUgcGFydGljbGUsIGl0IGRvZXMgbm90IGNoYW5nZSBkaXJlY3Rpb25cblx0ICogb2YgbW92ZW1lbnQuXG5cdCAqL1xuXHRwdWJsaWMgbWluUm90YXRpb25TcGVlZDogbnVtYmVyO1xuXHQvKipcblx0ICogVGhlIG1heGltdW0gcm90YXRpb24gc3BlZWQgZm9yIGEgcGFydGljbGUsIGluIGRlZ3JlZXMgcGVyIHNlY29uZC5cblx0ICogVGhpcyBvbmx5IHZpc3VhbGx5IHNwaW5zIHRoZSBwYXJ0aWNsZSwgaXQgZG9lcyBub3QgY2hhbmdlIGRpcmVjdGlvblxuXHQgKiBvZiBtb3ZlbWVudC5cblx0ICovXG5cdHB1YmxpYyBtYXhSb3RhdGlvblNwZWVkOiBudW1iZXI7XG5cdC8qKlxuXHQqIFRoZSBBY2NlbGVyYXRpb24gb2Ygcm90YXRpb24gKGFuZ3VsYXIgYWNjZWxlcmF0aW9uKSBmb3IgYSBwYXJ0aWNsZSwgaW4gZGVncmVlcyBwZXIgc2Vjb25kLlxuXHQqL1xuXHRwdWJsaWMgcm90YXRpb25BY2NlbGVyYXRpb246IG51bWJlcjtcblx0LyoqXG5cdCAqIFRoZSBibGVuZCBtb2RlIGZvciBhbGwgcGFydGljbGVzLCBhcyBuYW1lZCBieSBQSVhJLmJsZW5kTW9kZXMuXG5cdCAqL1xuXHRwdWJsaWMgcGFydGljbGVCbGVuZE1vZGU6IG51bWJlcjtcblx0LyoqXG5cdCAqIEFuIGVhc2luZyBmdW5jdGlvbiBmb3Igbm9ubGluZWFyIGludGVycG9sYXRpb24gb2YgdmFsdWVzLiBBY2NlcHRzIGEgc2luZ2xlXG5cdCAqIHBhcmFtZXRlciBvZiB0aW1lIGFzIGEgdmFsdWUgZnJvbSAwLTEsIGluY2x1c2l2ZS4gRXhwZWN0ZWQgb3V0cHV0cyBhcmUgdmFsdWVzXG5cdCAqIGZyb20gMC0xLCBpbmNsdXNpdmUuXG5cdCAqL1xuXHRwdWJsaWMgY3VzdG9tRWFzZTogU2ltcGxlRWFzZTtcblx0LyoqXG5cdCAqXHRFeHRyYSBkYXRhIGZvciB1c2UgaW4gY3VzdG9tIHBhcnRpY2xlcy4gVGhlIGVtaXR0ZXIgZG9lc24ndCBsb29rIGluc2lkZSwgYnV0XG5cdCAqXHRwYXNzZXMgaXQgb24gdG8gdGhlIHBhcnRpY2xlIHRvIHVzZSBpbiBpbml0KCkuXG5cdCAqL1xuXHRwdWJsaWMgZXh0cmFEYXRhOiBhbnk7XG5cdC8vcHJvcGVydGllcyBmb3Igc3Bhd25pbmcgcGFydGljbGVzXG5cdC8qKlxuXHQgKiBUaW1lIGJldHdlZW4gcGFydGljbGUgc3Bhd25zIGluIHNlY29uZHMuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgX2ZyZXF1ZW5jeTogbnVtYmVyO1xuXHQvKipcblx0ICogQ2hhbmNlIHRoYXQgYSBwYXJ0aWNsZSB3aWxsIGJlIHNwYXduZWQgb24gZWFjaCBvcHBvcnR1bml0eSB0byBzcGF3biBvbmUuXG5cdCAqIDAgaXMgMCUsIDEgaXMgMTAwJS5cblx0ICovXG5cdHB1YmxpYyBzcGF3bkNoYW5jZTogbnVtYmVyO1xuXHQvKipcblx0ICogTWF4aW11bSBudW1iZXIgb2YgcGFydGljbGVzIHRvIGtlZXAgYWxpdmUgYXQgYSB0aW1lLiBJZiB0aGlzIGxpbWl0XG5cdCAqIGlzIHJlYWNoZWQsIG5vIG1vcmUgcGFydGljbGVzIHdpbGwgc3Bhd24gdW50aWwgc29tZSBoYXZlIGRpZWQuXG5cdCAqL1xuXHRwdWJsaWMgbWF4UGFydGljbGVzOiBudW1iZXI7XG5cdC8qKlxuXHQgKiBUaGUgYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyB0byBlbWl0IGZvciBiZWZvcmUgc2V0dGluZyBlbWl0IHRvIGZhbHNlLlxuXHQgKiBBIHZhbHVlIG9mIC0xIGlzIGFuIHVubGltaXRlZCBhbW91bnQgb2YgdGltZS5cblx0ICovXG5cdHB1YmxpYyBlbWl0dGVyTGlmZXRpbWU6IG51bWJlcjtcblx0LyoqXG5cdCAqIFBvc2l0aW9uIGF0IHdoaWNoIHRvIHNwYXduIHBhcnRpY2xlcywgcmVsYXRpdmUgdG8gdGhlIGVtaXR0ZXIncyBvd25lcidzIG9yaWdpbi5cblx0ICogRm9yIGV4YW1wbGUsIHRoZSBmbGFtZXMgb2YgYSByb2NrZXQgdHJhdmVsbGluZyByaWdodCBtaWdodCBoYXZlIGEgc3Bhd25Qb3Ncblx0ICogb2Yge3g6LTUwLCB5OjB9LlxuXHQgKiB0byBzcGF3biBhdCB0aGUgcmVhciBvZiB0aGUgcm9ja2V0LlxuXHQgKiBUbyBjaGFuZ2UgdGhpcywgdXNlIHVwZGF0ZVNwYXduUG9zKCkuXG5cdCAqL1xuXHRwdWJsaWMgc3Bhd25Qb3M6IFBvaW50O1xuXHQvKipcblx0ICogSG93IHRoZSBwYXJ0aWNsZXMgd2lsbCBiZSBzcGF3bmVkLiBWYWxpZCB0eXBlcyBhcmUgXCJwb2ludFwiLCBcInJlY3RhbmdsZVwiLFxuXHQgKiBcImNpcmNsZVwiLCBcImJ1cnN0XCIsIFwicmluZ1wiLlxuXHQgKi9cblx0cHVibGljIHNwYXduVHlwZTogc3RyaW5nO1xuXHQvKipcblx0ICogQSByZWZlcmVuY2UgdG8gdGhlIGVtaXR0ZXIgZnVuY3Rpb24gc3BlY2lmaWMgdG8gdGhlIHNwYXduIHR5cGUuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgX3NwYXduRnVuYzogKHA6IFBhcnRpY2xlLCBlbWl0UG9zWDogbnVtYmVyLCBlbWl0UG9zWTogbnVtYmVyLCBpPzogbnVtYmVyKSA9PiB2b2lkO1xuXHQvKipcblx0ICogQSByZWN0YW5nbGUgcmVsYXRpdmUgdG8gc3Bhd25Qb3MgdG8gc3Bhd24gcGFydGljbGVzIGluc2lkZSBpZiB0aGUgc3Bhd24gdHlwZSBpcyBcInJlY3RcIi5cblx0ICovXG5cdHB1YmxpYyBzcGF3blJlY3Q6IFJlY3RhbmdsZTtcblx0LyoqXG5cdCAqIEEgcG9seWdvbiByZWxhdGl2ZSB0byBzcGF3blBvcyB0byBzcGF3biBwYXJ0aWNsZXMgb24gdGhlIGNoYWluIGlmIHRoZSBzcGF3biB0eXBlIGlzIFwicG9seWdvbmFsQ2hhaW5cIi5cblx0ICovXG5cdHB1YmxpYyBzcGF3blBvbHlnb25hbENoYWluOiBQb2x5Z29uYWxDaGFpbjtcblx0LyoqXG5cdCAqIEEgY2lyY2xlIHJlbGF0aXZlIHRvIHNwYXduUG9zIHRvIHNwYXduIHBhcnRpY2xlcyBpbnNpZGUgaWYgdGhlIHNwYXduIHR5cGUgaXMgXCJjaXJjbGVcIi5cblx0ICovXG5cdHB1YmxpYyBzcGF3bkNpcmNsZTogQ2lyY2xlICYge21pblJhZGl1czogbnVtYmVyfTtcblx0LyoqXG5cdCAqIE51bWJlciBvZiBwYXJ0aWNsZXMgdG8gc3Bhd24gdGltZSB0aGF0IHRoZSBmcmVxdWVuY3kgYWxsb3dzIGZvciBwYXJ0aWNsZXMgdG8gc3Bhd24uXG5cdCAqL1xuXHRwdWJsaWMgcGFydGljbGVzUGVyV2F2ZTogbnVtYmVyO1xuXHQvKipcblx0ICogU3BhY2luZyBiZXR3ZWVuIHBhcnRpY2xlcyBpbiBhIGJ1cnN0LiAwIGdpdmVzIGEgcmFuZG9tIGFuZ2xlIGZvciBlYWNoIHBhcnRpY2xlLlxuXHQgKi9cblx0cHVibGljIHBhcnRpY2xlU3BhY2luZzogbnVtYmVyO1xuXHQvKipcblx0ICogQW5nbGUgYXQgd2hpY2ggdG8gc3RhcnQgc3Bhd25pbmcgcGFydGljbGVzIGluIGEgYnVyc3QuXG5cdCAqL1xuXHRwdWJsaWMgYW5nbGVTdGFydDogbnVtYmVyO1xuXHQvKipcblx0ICogUm90YXRpb24gb2YgdGhlIGVtaXR0ZXIgb3IgZW1pdHRlcidzIG93bmVyIGluIGRlZ3JlZXMuIFRoaXMgaXMgYWRkZWQgdG9cblx0ICogdGhlIGNhbGN1bGF0ZWQgc3Bhd24gYW5nbGUuXG5cdCAqIFRvIGNoYW5nZSB0aGlzLCB1c2Ugcm90YXRlKCkuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgcm90YXRpb246IG51bWJlcjtcblx0LyoqXG5cdCAqIFRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgZW1pdHRlcidzIG93bmVyLCB0byBhZGQgc3Bhd25Qb3MgdG8gd2hlblxuXHQgKiBzcGF3bmluZyBwYXJ0aWNsZXMuIFRvIGNoYW5nZSB0aGlzLCB1c2UgdXBkYXRlT3duZXJQb3MoKS5cblx0ICovXG5cdHByb3RlY3RlZCBvd25lclBvczogUG9pbnQ7XG5cdC8qKlxuXHQgKiBUaGUgb3JpZ2luICsgc3Bhd25Qb3MgaW4gdGhlIHByZXZpb3VzIHVwZGF0ZSwgc28gdGhhdCB0aGUgc3Bhd24gcG9zaXRpb25cblx0ICogY2FuIGJlIGludGVycG9sYXRlZCB0byBzcGFjZSBvdXQgcGFydGljbGVzIGJldHRlci5cblx0ICovXG5cdHByb3RlY3RlZCBfcHJldkVtaXR0ZXJQb3M6IFBvaW50O1xuXHQvKipcblx0ICogSWYgX3ByZXZFbWl0dGVyUG9zIGlzIHZhbGlkLCB0byBwcmV2ZW50IGludGVycG9sYXRpb24gb24gdGhlIGZpcnN0IHVwZGF0ZVxuXHQgKi9cblx0cHJvdGVjdGVkIF9wcmV2UG9zSXNWYWxpZDogYm9vbGVhbjtcblx0LyoqXG5cdCAqIElmIGVpdGhlciBvd25lclBvcyBvciBzcGF3blBvcyBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgcHJldmlvdXMgdXBkYXRlLlxuXHQgKi9cblx0cHJvdGVjdGVkIF9wb3NDaGFuZ2VkOiBib29sZWFuO1xuXHQvKipcblx0ICogVGhlIGNvbnRhaW5lciB0byBhZGQgcGFydGljbGVzIHRvLlxuXHQgKi9cblx0cHJvdGVjdGVkIF9wYXJlbnQ6IENvbnRhaW5lcjtcblx0LyoqXG5cdCAqIElmIHBhcnRpY2xlcyBzaG91bGQgYmUgYWRkZWQgYXQgdGhlIGJhY2sgb2YgdGhlIGRpc3BsYXkgbGlzdCBpbnN0ZWFkIG9mIHRoZSBmcm9udC5cblx0ICovXG5cdHB1YmxpYyBhZGRBdEJhY2s6IGJvb2xlYW47XG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudCBudW1iZXIgb2YgYWN0aXZlIHBhcnRpY2xlcy5cblx0ICovXG5cdHB1YmxpYyBwYXJ0aWNsZUNvdW50OiBudW1iZXI7XG5cdC8qKlxuXHQgKiBJZiBwYXJ0aWNsZXMgc2hvdWxkIGJlIGVtaXR0ZWQgZHVyaW5nIHVwZGF0ZSgpIGNhbGxzLiBTZXR0aW5nIHRoaXMgdG8gZmFsc2Vcblx0ICogc3RvcHMgbmV3IHBhcnRpY2xlcyBmcm9tIGJlaW5nIGNyZWF0ZWQsIGJ1dCBhbGxvd3MgZXhpc3Rpbmcgb25lcyB0byBkaWUgb3V0LlxuXHQgKi9cblx0cHJvdGVjdGVkIF9lbWl0OiBib29sZWFuO1xuXHQvKipcblx0ICogVGhlIHRpbWVyIGZvciB3aGVuIHRvIHNwYXduIHBhcnRpY2xlcyBpbiBzZWNvbmRzLCB3aGVyZSBudW1iZXJzIGxlc3Ncblx0ICogdGhhbiAwIG1lYW4gdGhhdCBwYXJ0aWNsZXMgc2hvdWxkIGJlIHNwYXduZWQuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgX3NwYXduVGltZXI6IG51bWJlcjtcblx0LyoqXG5cdCAqIFRoZSBsaWZlIG9mIHRoZSBlbWl0dGVyIGluIHNlY29uZHMuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgX2VtaXR0ZXJMaWZlOiBudW1iZXI7XG5cdC8qKlxuXHQgKiBUaGUgcGFydGljbGVzIHRoYXQgYXJlIGFjdGl2ZSBhbmQgb24gdGhlIGRpc3BsYXkgbGlzdC4gVGhpcyBpcyB0aGUgZmlyc3QgcGFydGljbGUgaW4gYVxuXHQgKiBsaW5rZWQgbGlzdC5cblx0ICovXG5cdHByb3RlY3RlZCBfYWN0aXZlUGFydGljbGVzRmlyc3Q6IFBhcnRpY2xlO1xuXHQvKipcblx0ICogVGhlIHBhcnRpY2xlcyB0aGF0IGFyZSBhY3RpdmUgYW5kIG9uIHRoZSBkaXNwbGF5IGxpc3QuIFRoaXMgaXMgdGhlIGxhc3QgcGFydGljbGUgaW4gYVxuXHQgKiBsaW5rZWQgbGlzdC5cblx0ICovXG5cdHByb3RlY3RlZCBfYWN0aXZlUGFydGljbGVzTGFzdDogUGFydGljbGU7XG5cdC8qKlxuXHQgKiBUaGUgcGFydGljbGVzIHRoYXQgYXJlIG5vdCBjdXJyZW50bHkgYmVpbmcgdXNlZC4gVGhpcyBpcyB0aGUgZmlyc3QgcGFydGljbGUgaW4gYVxuXHQgKiBsaW5rZWQgbGlzdC5cblx0ICovXG5cdHByb3RlY3RlZCBfcG9vbEZpcnN0OiBQYXJ0aWNsZTtcblx0LyoqXG5cdCAqIFRoZSBvcmlnaW5hbCBjb25maWcgb2JqZWN0IHRoYXQgdGhpcyBlbWl0dGVyIHdhcyBpbml0aWFsaXplZCB3aXRoLlxuXHQgKi9cblx0cHJvdGVjdGVkIF9vcmlnQ29uZmlnOiBhbnk7XG5cdC8qKlxuXHQgKiBUaGUgb3JpZ2luYWwgcGFydGljbGUgaW1hZ2UgZGF0YSB0aGF0IHRoaXMgZW1pdHRlciB3YXMgaW5pdGlhbGl6ZWQgd2l0aC5cblx0ICovXG5cdHByb3RlY3RlZCBfb3JpZ0FydDogYW55O1xuXHQvKipcblx0ICogSWYgdGhlIHVwZGF0ZSBmdW5jdGlvbiBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBmcm9tIHRoZSBzaGFyZWQgdGlja2VyLlxuXHQgKiBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgcmVxdWlyZXMgY2FsbGluZyB0aGUgdXBkYXRlIGZ1bmN0aW9uIG1hbnVhbGx5LlxuXHQgKi9cblx0cHJvdGVjdGVkIF9hdXRvVXBkYXRlOiBib29sZWFuO1xuICAgIC8qKlxuXHQgKiBBIG51bWJlciBrZWVwaW5nIGluZGV4IG9mIGN1cnJlbnRseSBhcHBsaWVkIGltYWdlLiBVc2VkIHRvIGVtaXQgYXJ0cyBpbiBvcmRlci5cblx0ICovXG5cdHByb3RlY3RlZCBfY3VycmVudEltYWdlSW5kZXg6IG51bWJlciA9IC0xO1xuXHQvKipcblx0ICogSWYgdGhlIGVtaXR0ZXIgc2hvdWxkIGRlc3Ryb3kgaXRzZWxmIHdoZW4gYWxsIHBhcnRpY2xlcyBoYXZlIGRpZWQgb3V0LiBUaGlzIGlzIHNldCBieVxuXHQgKiBwbGF5T25jZUFuZERlc3Ryb3koKTtcblx0ICovXG5cdHByb3RlY3RlZCBfZGVzdHJveVdoZW5Db21wbGV0ZTogYm9vbGVhbjtcblx0LyoqXG5cdCAqIEEgY2FsbGJhY2sgZm9yIHdoZW4gYWxsIHBhcnRpY2xlcyBoYXZlIGRpZWQgb3V0LiBUaGlzIGlzIHNldCBieVxuXHQgKiBwbGF5T25jZUFuZERlc3Ryb3koKSBvciBwbGF5T25jZSgpO1xuXHQgKi9cblx0cHJvdGVjdGVkIF9jb21wbGV0ZUNhbGxiYWNrOiAoKSA9PiB2b2lkO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gcGFydGljbGVQYXJlbnQgVGhlIGNvbnRhaW5lciB0byBhZGQgdGhlIHBhcnRpY2xlcyB0by5cblx0ICogQHBhcmFtIHBhcnRpY2xlSW1hZ2VzIEEgdGV4dHVyZSBvciBhcnJheSBvZiB0ZXh0dXJlcyB0byB1c2Vcblx0ICogICAgICAgICAgICAgICAgICAgICAgIGZvciB0aGUgcGFydGljbGVzLiBTdHJpbmdzIHdpbGwgYmUgdHVybmVkXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICBpbnRvIHRleHR1cmVzIHZpYSBUZXh0dXJlLmZyb21JbWFnZSgpLlxuXHQgKiBAcGFyYW0gY29uZmlnIEEgY29uZmlndXJhdGlvbiBvYmplY3QgY29udGFpbmluZyBzZXR0aW5ncyBmb3IgdGhlIGVtaXR0ZXIuXG5cdCAqIEBwYXJhbSBjb25maWcuZW1pdCBJZiBjb25maWcuZW1pdCBpcyBleHBsaWNpdGx5IHBhc3NlZCBhcyBmYWxzZSwgdGhlXG5cdCAqICAgICAgICAgICAgICAgICAgICBFbWl0dGVyIHdpbGwgc3RhcnQgZGlzYWJsZWQuXG5cdCAqIEBwYXJhbSBjb25maWcuYXV0b1VwZGF0ZSBJZiBjb25maWcuYXV0b1VwZGF0ZSBpcyBleHBsaWNpdGx5IHBhc3NlZCBhc1xuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgdGhlIEVtaXR0ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGNhbGxcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSB2aWEgdGhlIFBJWEkgc2hhcmVkIHRpY2tlci5cblx0ICovXG5cdGNvbnN0cnVjdG9yKHBhcnRpY2xlUGFyZW50OiBDb250YWluZXIsIHBhcnRpY2xlSW1hZ2VzOiBhbnksIGNvbmZpZzogRW1pdHRlckNvbmZpZ3xPbGRFbWl0dGVyQ29uZmlnKVxuXHR7XG5cdFx0dGhpcy5fcGFydGljbGVDb25zdHJ1Y3RvciA9IFBhcnRpY2xlO1xuXHRcdC8vcHJvcGVydGllcyBmb3IgaW5kaXZpZHVhbCBwYXJ0aWNsZXNcblx0XHR0aGlzLnBhcnRpY2xlSW1hZ2VzID0gbnVsbDtcblx0XHR0aGlzLnN0YXJ0QWxwaGEgPSBudWxsO1xuXHRcdHRoaXMuc3RhcnRTcGVlZCA9IG51bGw7XG5cdFx0dGhpcy5taW5pbXVtU3BlZWRNdWx0aXBsaWVyID0gMTtcblx0XHR0aGlzLmFjY2VsZXJhdGlvbiA9IG51bGw7XG5cdFx0dGhpcy5tYXhTcGVlZCA9IE5hTjtcblx0XHR0aGlzLnN0YXJ0U2NhbGUgPSBudWxsO1xuXHRcdHRoaXMubWluaW11bVNjYWxlTXVsdGlwbGllciA9IDE7XG5cdFx0dGhpcy5zdGFydENvbG9yID0gbnVsbDtcblx0XHR0aGlzLm1pbkxpZmV0aW1lID0gMDtcblx0XHR0aGlzLm1heExpZmV0aW1lID0gMDtcblx0XHR0aGlzLm1pblN0YXJ0Um90YXRpb24gPSAwO1xuXHRcdHRoaXMubWF4U3RhcnRSb3RhdGlvbiA9IDA7XG5cdFx0dGhpcy5ub1JvdGF0aW9uID0gZmFsc2U7XG5cdFx0dGhpcy5taW5Sb3RhdGlvblNwZWVkID0gMDtcblx0XHR0aGlzLm1heFJvdGF0aW9uU3BlZWQgPSAwO1xuXHRcdHRoaXMucGFydGljbGVCbGVuZE1vZGUgPSAwO1xuXHRcdHRoaXMuY3VzdG9tRWFzZSA9IG51bGw7XG5cdFx0dGhpcy5leHRyYURhdGEgPSBudWxsO1xuXHRcdC8vcHJvcGVydGllcyBmb3Igc3Bhd25pbmcgcGFydGljbGVzXG5cdFx0dGhpcy5fZnJlcXVlbmN5ID0gMTtcblx0XHR0aGlzLnNwYXduQ2hhbmNlID0gMTtcblx0XHR0aGlzLm1heFBhcnRpY2xlcyA9IDEwMDA7XG5cdFx0dGhpcy5lbWl0dGVyTGlmZXRpbWUgPSAtMTtcblx0XHR0aGlzLnNwYXduUG9zID0gbnVsbDtcblx0XHR0aGlzLnNwYXduVHlwZSA9IG51bGw7XG5cdFx0dGhpcy5fc3Bhd25GdW5jID0gbnVsbDtcblx0XHR0aGlzLnNwYXduUmVjdCA9IG51bGw7XG5cdFx0dGhpcy5zcGF3bkNpcmNsZSA9IG51bGw7XG5cdFx0dGhpcy5zcGF3blBvbHlnb25hbENoYWluID0gbnVsbDtcblx0XHR0aGlzLnBhcnRpY2xlc1BlcldhdmUgPSAxO1xuXHRcdHRoaXMucGFydGljbGVTcGFjaW5nID0gMDtcblx0XHR0aGlzLmFuZ2xlU3RhcnQgPSAwO1xuXHRcdC8vZW1pdHRlciBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yb3RhdGlvbiA9IDA7XG5cdFx0dGhpcy5vd25lclBvcyA9IG51bGw7XG5cdFx0dGhpcy5fcHJldkVtaXR0ZXJQb3MgPSBudWxsO1xuXHRcdHRoaXMuX3ByZXZQb3NJc1ZhbGlkID0gZmFsc2U7XG5cdFx0dGhpcy5fcG9zQ2hhbmdlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3BhcmVudCA9IG51bGw7XG5cdFx0dGhpcy5hZGRBdEJhY2sgPSBmYWxzZTtcblx0XHR0aGlzLnBhcnRpY2xlQ291bnQgPSAwO1xuXHRcdHRoaXMuX2VtaXQgPSBmYWxzZTtcblx0XHR0aGlzLl9zcGF3blRpbWVyID0gMDtcblx0XHR0aGlzLl9lbWl0dGVyTGlmZSA9IC0xO1xuXHRcdHRoaXMuX2FjdGl2ZVBhcnRpY2xlc0ZpcnN0ID0gbnVsbDtcblx0XHR0aGlzLl9hY3RpdmVQYXJ0aWNsZXNMYXN0ID0gbnVsbDtcblx0XHR0aGlzLl9wb29sRmlyc3QgPSBudWxsO1xuXHRcdHRoaXMuX29yaWdDb25maWcgPSBudWxsO1xuXHRcdHRoaXMuX29yaWdBcnQgPSBudWxsO1xuXHRcdHRoaXMuX2F1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLl9jdXJyZW50SW1hZ2VJbmRleCA9IC0xO1xuXHRcdHRoaXMuX2Rlc3Ryb3lXaGVuQ29tcGxldGUgPSBmYWxzZTtcblx0XHR0aGlzLl9jb21wbGV0ZUNhbGxiYWNrID0gbnVsbDtcblxuXHRcdC8vc2V0IHRoZSBpbml0aWFsIHBhcmVudFxuXHRcdHRoaXMucGFyZW50ID0gcGFydGljbGVQYXJlbnQ7XG5cblx0XHRpZihwYXJ0aWNsZUltYWdlcyAmJiBjb25maWcpXG5cdFx0XHR0aGlzLmluaXQocGFydGljbGVJbWFnZXMsIGNvbmZpZyk7XG5cblx0XHQvL3NhdmUgb2Z0ZW4gdXNlZCBmdW5jdGlvbnMgb24gdGhlIGluc3RhbmNlIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZSBmb3IgYmV0dGVyIHNwZWVkXG5cdFx0dGhpcy5yZWN5Y2xlID0gdGhpcy5yZWN5Y2xlO1xuXHRcdHRoaXMudXBkYXRlID0gdGhpcy51cGRhdGU7XG5cdFx0dGhpcy5yb3RhdGUgPSB0aGlzLnJvdGF0ZTtcblx0XHR0aGlzLnVwZGF0ZVNwYXduUG9zID0gdGhpcy51cGRhdGVTcGF3blBvcztcblx0XHR0aGlzLnVwZGF0ZU93bmVyUG9zID0gdGhpcy51cGRhdGVPd25lclBvcztcblx0fVxuXG5cdC8qKlxuXHQgKiBJZiB0aGUgZW1pdHRlciBpcyB1c2luZyBwYXJ0aWNsZSBhcnQgaW4gb3JkZXIgYXMgcHJvdmlkZWQgaW4gYHBhcnRpY2xlSW1hZ2VzYC5cblx0ICogRWZmZWN0aXZlIG9ubHkgd2hlbiBgcGFydGljbGVJbWFnZXNgIGhhcyBtdWx0aXBsZSBhcnQgb3B0aW9ucy5cblx0ICogVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGVuc3VyaW5nIHRoYXQgZWFjaCBhcnQgc2hvd3MgdXAgb25jZSwgaW4gY2FzZSB5b3UgbmVlZCB0byBlbWl0IGEgYm9keSBpbiBhbiBvcmRlci5cblx0ICogRm9yIGV4YW1wbGU6IGRyYWdvbiAtIFtIZWFkLCBib2R5MSwgYm9keTIsIC4uLiwgdGFpbF1cblx0ICovXG5cdHB1YmxpYyBnZXQgb3JkZXJlZEFydCgpIHsgcmV0dXJuIHRoaXMuX2N1cnJlbnRJbWFnZUluZGV4ICE9PSAtMTsgfVxuXHRwdWJsaWMgc2V0IG9yZGVyZWRBcnQodmFsdWUpIHtcblx0XHR0aGlzLl9jdXJyZW50SW1hZ2VJbmRleCA9IHZhbHVlID8gMCA6IC0xO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRpbWUgYmV0d2VlbiBwYXJ0aWNsZSBzcGF3bnMgaW4gc2Vjb25kcy4gSWYgdGhpcyB2YWx1ZSBpcyBub3QgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAsXG5cdCAqIGl0IHdpbGwgYmUgc2V0IHRvIDEgKHBhcnRpY2xlIHBlciBzZWNvbmQpIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXG5cdCAqL1xuXHRwdWJsaWMgZ2V0IGZyZXF1ZW5jeSgpIHsgcmV0dXJuIHRoaXMuX2ZyZXF1ZW5jeTsgfVxuXHRwdWJsaWMgc2V0IGZyZXF1ZW5jeSh2YWx1ZSlcblx0e1xuXHRcdC8vZG8gc29tZSBlcnJvciBjaGVja2luZyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG5cdFx0aWYodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgJiYgdmFsdWUgPiAwKVxuXHRcdFx0dGhpcy5fZnJlcXVlbmN5ID0gdmFsdWU7XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5fZnJlcXVlbmN5ID0gMTtcblx0fVxuXHQvKipcblx0ICogVGhlIGNvbnN0cnVjdG9yIHVzZWQgdG8gY3JlYXRlIG5ldyBwYXJ0aWNsZXMuIFRoZSBkZWZhdWx0IGlzXG5cdCAqIHRoZSBidWlsdCBpbiBQYXJ0aWNsZSBjbGFzcy4gU2V0dGluZyB0aGlzIHdpbGwgZHVtcCBhbnkgYWN0aXZlIG9yXG5cdCAqIHBvb2xlZCBwYXJ0aWNsZXMsIGlmIHRoZSBlbWl0dGVyIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cblx0ICovXG5cdHB1YmxpYyBnZXQgcGFydGljbGVDb25zdHJ1Y3RvcigpIHsgcmV0dXJuIHRoaXMuX3BhcnRpY2xlQ29uc3RydWN0b3I7IH1cblx0cHVibGljIHNldCBwYXJ0aWNsZUNvbnN0cnVjdG9yKHZhbHVlKVxuXHR7XG5cdFx0aWYodmFsdWUgIT0gdGhpcy5fcGFydGljbGVDb25zdHJ1Y3Rvcilcblx0XHR7XG5cdFx0XHR0aGlzLl9wYXJ0aWNsZUNvbnN0cnVjdG9yID0gdmFsdWU7XG5cdFx0XHQvL2NsZWFuIHVwIGV4aXN0aW5nIHBhcnRpY2xlc1xuXHRcdFx0dGhpcy5jbGVhbnVwKCk7XG5cdFx0XHQvL3NjcmFwIGFsbCB0aGUgcGFydGljbGVzXG5cdFx0XHRmb3IgKGxldCBwYXJ0aWNsZSA9IHRoaXMuX3Bvb2xGaXJzdDsgcGFydGljbGU7IHBhcnRpY2xlID0gcGFydGljbGUubmV4dClcblx0XHRcdHtcblx0XHRcdFx0cGFydGljbGUuZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcG9vbEZpcnN0ID0gbnVsbDtcblx0XHRcdC8vcmUtaW5pdGlhbGl6ZSB0aGUgZW1pdHRlciBzbyB0aGF0IHRoZSBuZXcgY29uc3RydWN0b3IgY2FuIGRvIGFueXRoaW5nIGl0IG5lZWRzIHRvXG5cdFx0XHRpZih0aGlzLl9vcmlnQ29uZmlnICYmIHRoaXMuX29yaWdBcnQpXG5cdFx0XHRcdHRoaXMuaW5pdCh0aGlzLl9vcmlnQXJ0LCB0aGlzLl9vcmlnQ29uZmlnKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBUaGUgY29udGFpbmVyIHRvIGFkZCBwYXJ0aWNsZXMgdG8uIFNldHRpbmdzIHRoaXMgd2lsbCBkdW1wIGFueSBhY3RpdmUgcGFydGljbGVzLlxuXHQqL1xuXHRwdWJsaWMgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudDsgfVxuXHRwdWJsaWMgc2V0IHBhcmVudCh2YWx1ZSlcblx0e1xuXHRcdHRoaXMuY2xlYW51cCgpO1xuXHRcdHRoaXMuX3BhcmVudCA9IHZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdXAgdGhlIGVtaXR0ZXIgYmFzZWQgb24gdGhlIGNvbmZpZyBzZXR0aW5ncy5cblx0ICogQHBhcmFtIGFydCBBIHRleHR1cmUgb3IgYXJyYXkgb2YgdGV4dHVyZXMgdG8gdXNlIGZvciB0aGUgcGFydGljbGVzLlxuXHQgKiBAcGFyYW0gY29uZmlnIEEgY29uZmlndXJhdGlvbiBvYmplY3QgY29udGFpbmluZyBzZXR0aW5ncyBmb3IgdGhlIGVtaXR0ZXIuXG5cdCAqL1xuXHRwdWJsaWMgaW5pdChhcnQ6IGFueSwgY29uZmlnOiBFbWl0dGVyQ29uZmlnfE9sZEVtaXR0ZXJDb25maWcpXG5cdHtcblx0XHRpZighYXJ0IHx8ICFjb25maWcpXG5cdFx0XHRyZXR1cm47XG5cdFx0Ly9jbGVhbiB1cCBhbnkgZXhpc3RpbmcgcGFydGljbGVzXG5cdFx0dGhpcy5jbGVhbnVwKCk7XG5cblx0XHQvL3N0b3JlIHRoZSBvcmlnaW5hbCBjb25maWcgYW5kIHBhcnRpY2xlIGltYWdlcywgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlLWluaXRpYWxpemVcblx0XHQvL3doZW4gdGhlIHBhcnRpY2xlIGNvbnN0cnVjdG9yIGlzIGNoYW5nZWRcblx0XHR0aGlzLl9vcmlnQ29uZmlnID0gY29uZmlnO1xuXHRcdHRoaXMuX29yaWdBcnQgPSBhcnQ7XG5cblx0XHQvL3NldCB1cCB0aGUgYXJyYXkgb2YgZGF0YSwgYWxzbyBlbnN1cmluZyB0aGF0IGl0IGlzIGFuIGFycmF5XG5cdFx0YXJ0ID0gQXJyYXkuaXNBcnJheShhcnQpID8gYXJ0LnNsaWNlKCkgOiBbYXJ0XTtcblx0XHQvL3J1biB0aGUgYXJ0IHRocm91Z2ggdGhlIHBhcnRpY2xlIGNsYXNzJ3MgcGFyc2luZyBmdW5jdGlvblxuXHRcdGNvbnN0IHBhcnRDbGFzcyA9IHRoaXMuX3BhcnRpY2xlQ29uc3RydWN0b3I7XG5cdFx0dGhpcy5wYXJ0aWNsZUltYWdlcyA9IHBhcnRDbGFzcy5wYXJzZUFydCA/IHBhcnRDbGFzcy5wYXJzZUFydChhcnQpIDogYXJ0O1xuXHRcdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHRcdC8vIFBhcnRpY2xlIFByb3BlcnRpZXMgICAvL1xuXHRcdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHRcdC8vc2V0IHVwIHRoZSBhbHBoYVxuXHRcdGlmIChjb25maWcuYWxwaGEpXG5cdFx0e1xuXHRcdFx0dGhpcy5zdGFydEFscGhhID0gUHJvcGVydHlOb2RlLmNyZWF0ZUxpc3QoY29uZmlnLmFscGhhKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5zdGFydEFscGhhID0gbmV3IFByb3BlcnR5Tm9kZSgxLCAwKTtcblx0XHQvL3NldCB1cCB0aGUgc3BlZWRcblx0XHRpZiAoY29uZmlnLnNwZWVkKVxuXHRcdHtcblx0XHRcdHRoaXMuc3RhcnRTcGVlZCA9IFByb3BlcnR5Tm9kZS5jcmVhdGVMaXN0KGNvbmZpZy5zcGVlZCk7XG5cdFx0XHR0aGlzLm1pbmltdW1TcGVlZE11bHRpcGxpZXIgPSAoJ21pbmltdW1TcGVlZE11bHRpcGxpZXInIGluIGNvbmZpZyA/IGNvbmZpZy5taW5pbXVtU3BlZWRNdWx0aXBsaWVyIDogKGNvbmZpZy5zcGVlZCBhcyBhbnkpLm1pbmltdW1TcGVlZE11bHRpcGxpZXIpIHx8IDE7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aGlzLm1pbmltdW1TcGVlZE11bHRpcGxpZXIgPSAxO1xuXHRcdFx0dGhpcy5zdGFydFNwZWVkID0gbmV3IFByb3BlcnR5Tm9kZSgwLCAwKTtcblx0XHR9XG5cdFx0Ly9zZXQgdXAgYWNjZWxlcmF0aW9uXG5cdFx0bGV0IGFjY2VsZXJhdGlvbiA9IGNvbmZpZy5hY2NlbGVyYXRpb247XG5cdFx0aWYoYWNjZWxlcmF0aW9uICYmIChhY2NlbGVyYXRpb24ueCB8fCBhY2NlbGVyYXRpb24ueSkpXG5cdFx0e1xuXHRcdFx0Ly9tYWtlIHN1cmUgd2UgZGlzYWJsZSBzcGVlZCBpbnRlcnBvbGF0aW9uXG5cdFx0XHR0aGlzLnN0YXJ0U3BlZWQubmV4dCA9IG51bGw7XG5cdFx0XHR0aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBQb2ludChhY2NlbGVyYXRpb24ueCwgYWNjZWxlcmF0aW9uLnkpO1xuXHRcdFx0dGhpcy5tYXhTcGVlZCA9IGNvbmZpZy5tYXhTcGVlZCB8fCBOYU47XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHRcdHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IFBvaW50KCk7XG5cdFx0Ly9zZXQgdXAgdGhlIHNjYWxlXG5cdFx0aWYgKGNvbmZpZy5zY2FsZSlcblx0XHR7XG5cdFx0XHR0aGlzLnN0YXJ0U2NhbGUgPSBQcm9wZXJ0eU5vZGUuY3JlYXRlTGlzdChjb25maWcuc2NhbGUpO1xuXHRcdFx0dGhpcy5taW5pbXVtU2NhbGVNdWx0aXBsaWVyID0gKCdtaW5pbXVtU2NhbGVNdWx0aXBsaWVyJyBpbiBjb25maWcgPyBjb25maWcubWluaW11bVNjYWxlTXVsdGlwbGllciA6IChjb25maWcuc2NhbGUgYXMgYW55KS5taW5pbXVtU2NhbGVNdWx0aXBsaWVyKSB8fCAxO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhpcy5zdGFydFNjYWxlID0gbmV3IFByb3BlcnR5Tm9kZSgxLCAwKTtcblx0XHRcdHRoaXMubWluaW11bVNjYWxlTXVsdGlwbGllciA9IDE7XG5cdFx0fVxuXHRcdC8vc2V0IHVwIHRoZSBjb2xvclxuXHRcdGlmIChjb25maWcuY29sb3IpXG5cdFx0e1xuXHRcdFx0dGhpcy5zdGFydENvbG9yID0gUHJvcGVydHlOb2RlLmNyZWF0ZUxpc3QoY29uZmlnLmNvbG9yKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuc3RhcnRDb2xvciA9IG5ldyBQcm9wZXJ0eU5vZGUoe3I6MHhGRiwgZzoweEZGLCBiOjB4RkZ9LCAwKTtcblx0XHR9XG5cdFx0Ly9zZXQgdXAgdGhlIHN0YXJ0IHJvdGF0aW9uXG5cdFx0aWYgKGNvbmZpZy5zdGFydFJvdGF0aW9uKVxuXHRcdHtcblx0XHRcdHRoaXMubWluU3RhcnRSb3RhdGlvbiA9IGNvbmZpZy5zdGFydFJvdGF0aW9uLm1pbjtcblx0XHRcdHRoaXMubWF4U3RhcnRSb3RhdGlvbiA9IGNvbmZpZy5zdGFydFJvdGF0aW9uLm1heDtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5taW5TdGFydFJvdGF0aW9uID0gdGhpcy5tYXhTdGFydFJvdGF0aW9uID0gMDtcblx0XHRpZiAoY29uZmlnLm5vUm90YXRpb24gJiZcblx0XHRcdCh0aGlzLm1pblN0YXJ0Um90YXRpb24gfHwgdGhpcy5tYXhTdGFydFJvdGF0aW9uKSlcblx0XHR7XG5cdFx0XHR0aGlzLm5vUm90YXRpb24gPSAhIWNvbmZpZy5ub1JvdGF0aW9uO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0XHR0aGlzLm5vUm90YXRpb24gPSBmYWxzZTtcblx0XHQvL3NldCB1cCB0aGUgcm90YXRpb24gc3BlZWRcblx0XHRpZiAoY29uZmlnLnJvdGF0aW9uU3BlZWQpXG5cdFx0e1xuXHRcdFx0dGhpcy5taW5Sb3RhdGlvblNwZWVkID0gY29uZmlnLnJvdGF0aW9uU3BlZWQubWluO1xuXHRcdFx0dGhpcy5tYXhSb3RhdGlvblNwZWVkID0gY29uZmlnLnJvdGF0aW9uU3BlZWQubWF4O1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0XHR0aGlzLm1pblJvdGF0aW9uU3BlZWQgPSB0aGlzLm1heFJvdGF0aW9uU3BlZWQgPSAwO1xuXG5cdFx0dGhpcy5yb3RhdGlvbkFjY2VsZXJhdGlvbiA9IGNvbmZpZy5yb3RhdGlvbkFjY2VsZXJhdGlvbiB8fCAwO1xuXHRcdC8vc2V0IHVwIHRoZSBsaWZldGltZVxuXHRcdHRoaXMubWluTGlmZXRpbWUgPSBjb25maWcubGlmZXRpbWUubWluO1xuXHRcdHRoaXMubWF4TGlmZXRpbWUgPSBjb25maWcubGlmZXRpbWUubWF4O1xuXHRcdC8vZ2V0IHRoZSBibGVuZCBtb2RlXG5cdFx0dGhpcy5wYXJ0aWNsZUJsZW5kTW9kZSA9IFBhcnRpY2xlVXRpbHMuZ2V0QmxlbmRNb2RlKGNvbmZpZy5ibGVuZE1vZGUpO1xuXHRcdC8vdXNlIHRoZSBjdXN0b20gZWFzZSBpZiBwcm92aWRlZFxuXHRcdGlmIChjb25maWcuZWFzZSlcblx0XHR7XG5cdFx0XHR0aGlzLmN1c3RvbUVhc2UgPSB0eXBlb2YgY29uZmlnLmVhc2UgPT0gXCJmdW5jdGlvblwiID9cblx0XHRcdFx0Y29uZmlnLmVhc2UgOiBQYXJ0aWNsZVV0aWxzLmdlbmVyYXRlRWFzZShjb25maWcuZWFzZSk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHRcdHRoaXMuY3VzdG9tRWFzZSA9IG51bGw7XG5cdFx0Ly9zZXQgdXAgdGhlIGV4dHJhIGRhdGEsIHJ1bm5pbmcgaXQgdGhyb3VnaCB0aGUgcGFydGljbGUgY2xhc3MncyBwYXJzZURhdGEgZnVuY3Rpb24uXG5cdFx0aWYocGFydENsYXNzLnBhcnNlRGF0YSlcblx0XHRcdHRoaXMuZXh0cmFEYXRhID0gcGFydENsYXNzLnBhcnNlRGF0YShjb25maWcuZXh0cmFEYXRhKTtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLmV4dHJhRGF0YSA9IGNvbmZpZy5leHRyYURhdGEgfHwgbnVsbDtcblx0XHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHRcdC8vIEVtaXR0ZXIgUHJvcGVydGllcyAgIC8vXG5cdFx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0XHQvL3Jlc2V0IHNwYXduIHR5cGUgc3BlY2lmaWMgc2V0dGluZ3Ncblx0XHR0aGlzLnNwYXduUmVjdCA9IHRoaXMuc3Bhd25DaXJjbGUgPSBudWxsO1xuXHRcdHRoaXMucGFydGljbGVzUGVyV2F2ZSA9IDE7XG5cdFx0aWYgKGNvbmZpZy5wYXJ0aWNsZXNQZXJXYXZlICYmIGNvbmZpZy5wYXJ0aWNsZXNQZXJXYXZlID4gMSlcblx0XHRcdHRoaXMucGFydGljbGVzUGVyV2F2ZSA9IGNvbmZpZy5wYXJ0aWNsZXNQZXJXYXZlO1xuXHRcdHRoaXMucGFydGljbGVTcGFjaW5nID0gMDtcblx0XHR0aGlzLmFuZ2xlU3RhcnQgPSAwO1xuXHRcdC8vZGV0ZXJtaW5lIHRoZSBzcGF3biBmdW5jdGlvbiB0byB1c2Vcblx0XHR0aGlzLnBhcnNlU3Bhd25UeXBlKGNvbmZpZyk7XG5cdFx0Ly9zZXQgdGhlIHNwYXduaW5nIGZyZXF1ZW5jeVxuXHRcdHRoaXMuZnJlcXVlbmN5ID0gY29uZmlnLmZyZXF1ZW5jeTtcblx0XHR0aGlzLnNwYXduQ2hhbmNlID0gKHR5cGVvZiBjb25maWcuc3Bhd25DaGFuY2UgPT09ICdudW1iZXInICYmIGNvbmZpZy5zcGF3bkNoYW5jZSA+IDApID8gY29uZmlnLnNwYXduQ2hhbmNlIDogMTtcblx0XHQvL3NldCB0aGUgZW1pdHRlciBsaWZldGltZVxuXHRcdHRoaXMuZW1pdHRlckxpZmV0aW1lID0gY29uZmlnLmVtaXR0ZXJMaWZldGltZSB8fCAtMTtcblx0XHQvL3NldCB0aGUgbWF4IHBhcnRpY2xlc1xuXHRcdHRoaXMubWF4UGFydGljbGVzID0gY29uZmlnLm1heFBhcnRpY2xlcyA+IDAgPyBjb25maWcubWF4UGFydGljbGVzIDogMTAwMDtcblx0XHQvL2RldGVybWluZSBpZiB3ZSBzaG91bGQgYWRkIHRoZSBwYXJ0aWNsZSBhdCB0aGUgYmFjayBvZiB0aGUgbGlzdCBvciBub3Rcblx0XHR0aGlzLmFkZEF0QmFjayA9ICEhY29uZmlnLmFkZEF0QmFjaztcblx0XHQvL3Jlc2V0IHRoZSBlbWl0dGVyIHBvc2l0aW9uIGFuZCByb3RhdGlvbiB2YXJpYWJsZXNcblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcblx0XHR0aGlzLm93bmVyUG9zID0gbmV3IFBvaW50KCk7XG5cdFx0dGhpcy5zcGF3blBvcyA9IG5ldyBQb2ludChjb25maWcucG9zLngsIGNvbmZpZy5wb3MueSk7XG5cblx0XHR0aGlzLmluaXRBZGRpdGlvbmFsKGFydCwgY29uZmlnKTtcblxuXHRcdHRoaXMuX3ByZXZFbWl0dGVyUG9zID0gdGhpcy5zcGF3blBvcy5jbG9uZSgpO1xuXHRcdC8vcHJldmlvdXMgZW1pdHRlciBwb3NpdGlvbiBpcyBpbnZhbGlkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgZm9yIGludGVycG9sYXRpb25cblx0XHR0aGlzLl9wcmV2UG9zSXNWYWxpZCA9IGZhbHNlO1xuXHRcdC8vc3RhcnQgZW1pdHRpbmdcblx0XHR0aGlzLl9zcGF3blRpbWVyID0gMDtcblx0XHR0aGlzLmVtaXQgPSBjb25maWcuZW1pdCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhY29uZmlnLmVtaXQ7XG5cdFx0dGhpcy5hdXRvVXBkYXRlID0gISFjb25maWcuYXV0b1VwZGF0ZTtcblx0XHR0aGlzLm9yZGVyZWRBcnQgPSAhIWNvbmZpZy5vcmRlcmVkQXJ0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdXAgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHRoZSBlbWl0dGVyIGZyb20gY29uZmlnIHNldHRpbmdzLlxuXHQgKiBVc2luZyBmb3IgcGFyc2luZyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgb24gY2xhc3NlcyB0aGF0IGV4dGVuZCBmcm9tIEVtaXR0ZXJcblx0ICogQHBhcmFtIGFydCBBIHRleHR1cmUgb3IgYXJyYXkgb2YgdGV4dHVyZXMgdG8gdXNlIGZvciB0aGUgcGFydGljbGVzLlxuXHQgKiBAcGFyYW0gY29uZmlnIEEgY29uZmlndXJhdGlvbiBvYmplY3QgY29udGFpbmluZyBzZXR0aW5ncyBmb3IgdGhlIGVtaXR0ZXIuXG5cdCAqL1xuXHRwcm90ZWN0ZWQgaW5pdEFkZGl0aW9uYWwoYXJ0OiBhbnksIGNvbmZpZzogRW1pdHRlckNvbmZpZ3xPbGRFbWl0dGVyQ29uZmlnKVxuXHR7XG5cdH1cblxuXHQvKipcblx0ICogUGFyc2luZyBlbWl0dGVyIHNwYXduIHR5cGUgZnJvbSBjb25maWcgc2V0dGluZ3MuXG5cdCAqIFBsYWNlIGZvciBvdmVycmlkZSBhbmQgYWRkIG5ldyBraW5kIG9mIHNwYXduIHR5cGVcblx0ICogQHBhcmFtIGNvbmZpZyBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgc2V0dGluZ3MgZm9yIHRoZSBlbWl0dGVyLlxuXHQgKi9cblx0cHJvdGVjdGVkIHBhcnNlU3Bhd25UeXBlKGNvbmZpZzogRW1pdHRlckNvbmZpZ3xPbGRFbWl0dGVyQ29uZmlnKSB7XG5cdFx0bGV0IHNwYXduQ2lyY2xlO1xuXG5cdFx0c3dpdGNoKGNvbmZpZy5zcGF3blR5cGUpXG5cdFx0e1xuXHRcdFx0Y2FzZSBcInJlY3RcIjpcblx0XHRcdFx0dGhpcy5zcGF3blR5cGUgPSBcInJlY3RcIjtcblx0XHRcdFx0dGhpcy5fc3Bhd25GdW5jID0gdGhpcy5fc3Bhd25SZWN0O1xuXHRcdFx0XHRsZXQgc3Bhd25SZWN0ID0gY29uZmlnLnNwYXduUmVjdDtcblx0XHRcdFx0dGhpcy5zcGF3blJlY3QgPSBuZXcgUmVjdGFuZ2xlKHNwYXduUmVjdC54LCBzcGF3blJlY3QueSwgc3Bhd25SZWN0LncsIHNwYXduUmVjdC5oKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiY2lyY2xlXCI6XG5cdFx0XHRcdHRoaXMuc3Bhd25UeXBlID0gXCJjaXJjbGVcIjtcblx0XHRcdFx0dGhpcy5fc3Bhd25GdW5jID0gdGhpcy5fc3Bhd25DaXJjbGU7XG5cdFx0XHRcdHNwYXduQ2lyY2xlID0gY29uZmlnLnNwYXduQ2lyY2xlO1xuXHRcdFx0XHR0aGlzLnNwYXduQ2lyY2xlID0gbmV3IENpcmNsZShzcGF3bkNpcmNsZS54LCBzcGF3bkNpcmNsZS55LCBzcGF3bkNpcmNsZS5yKSBhcyBhbnk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInJpbmdcIjpcblx0XHRcdFx0dGhpcy5zcGF3blR5cGUgPSBcInJpbmdcIjtcblx0XHRcdFx0dGhpcy5fc3Bhd25GdW5jID0gdGhpcy5fc3Bhd25SaW5nO1xuXHRcdFx0XHRzcGF3bkNpcmNsZSA9IGNvbmZpZy5zcGF3bkNpcmNsZTtcblx0XHRcdFx0dGhpcy5zcGF3bkNpcmNsZSA9IG5ldyBDaXJjbGUoc3Bhd25DaXJjbGUueCwgc3Bhd25DaXJjbGUueSwgc3Bhd25DaXJjbGUucikgYXMgYW55O1xuXHRcdFx0XHR0aGlzLnNwYXduQ2lyY2xlLm1pblJhZGl1cyA9IHNwYXduQ2lyY2xlLm1pblI7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImJ1cnN0XCI6XG5cdFx0XHRcdHRoaXMuc3Bhd25UeXBlID0gXCJidXJzdFwiO1xuXHRcdFx0XHR0aGlzLl9zcGF3bkZ1bmMgPSB0aGlzLl9zcGF3bkJ1cnN0O1xuXHRcdFx0XHR0aGlzLnBhcnRpY2xlU3BhY2luZyA9IGNvbmZpZy5wYXJ0aWNsZVNwYWNpbmc7XG5cdFx0XHRcdHRoaXMuYW5nbGVTdGFydCA9IGNvbmZpZy5hbmdsZVN0YXJ0ID8gY29uZmlnLmFuZ2xlU3RhcnQgOiAwO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJwb2ludFwiOlxuXHRcdFx0XHR0aGlzLnNwYXduVHlwZSA9IFwicG9pbnRcIjtcblx0XHRcdFx0dGhpcy5fc3Bhd25GdW5jID0gdGhpcy5fc3Bhd25Qb2ludDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwicG9seWdvbmFsQ2hhaW5cIjpcblx0XHRcdFx0dGhpcy5zcGF3blR5cGUgPSBcInBvbHlnb25hbENoYWluXCI7XG5cdFx0XHRcdHRoaXMuX3NwYXduRnVuYyA9IHRoaXMuX3NwYXduUG9seWdvbmFsQ2hhaW47XG5cdFx0XHRcdHRoaXMuc3Bhd25Qb2x5Z29uYWxDaGFpbiA9IG5ldyBQb2x5Z29uYWxDaGFpbihjb25maWcuc3Bhd25Qb2x5Z29uKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aGlzLnNwYXduVHlwZSA9IFwicG9pbnRcIjtcblx0XHRcdFx0dGhpcy5fc3Bhd25GdW5jID0gdGhpcy5fc3Bhd25Qb2ludDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlY3ljbGVzIGFuIGluZGl2aWR1YWwgcGFydGljbGUuIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0ICogQHBhcmFtIHBhcnRpY2xlIFRoZSBwYXJ0aWNsZSB0byByZWN5Y2xlLlxuXHQgKiBAaW50ZXJuYWxcblx0ICovXG5cdHB1YmxpYyByZWN5Y2xlKHBhcnRpY2xlOiBQYXJ0aWNsZSlcblx0e1xuXHRcdGlmKHBhcnRpY2xlLm5leHQpXG5cdFx0XHRwYXJ0aWNsZS5uZXh0LnByZXYgPSBwYXJ0aWNsZS5wcmV2O1xuXHRcdGlmKHBhcnRpY2xlLnByZXYpXG5cdFx0XHRwYXJ0aWNsZS5wcmV2Lm5leHQgPSBwYXJ0aWNsZS5uZXh0O1xuXHRcdGlmKHBhcnRpY2xlID09IHRoaXMuX2FjdGl2ZVBhcnRpY2xlc0xhc3QpXG5cdFx0XHR0aGlzLl9hY3RpdmVQYXJ0aWNsZXNMYXN0ID0gcGFydGljbGUucHJldjtcblx0XHRpZihwYXJ0aWNsZSA9PSB0aGlzLl9hY3RpdmVQYXJ0aWNsZXNGaXJzdClcblx0XHRcdHRoaXMuX2FjdGl2ZVBhcnRpY2xlc0ZpcnN0ID0gcGFydGljbGUubmV4dDtcblx0XHQvL2FkZCB0byBwb29sXG5cdFx0cGFydGljbGUucHJldiA9IG51bGw7XG5cdFx0cGFydGljbGUubmV4dCA9IHRoaXMuX3Bvb2xGaXJzdDtcblx0XHR0aGlzLl9wb29sRmlyc3QgPSBwYXJ0aWNsZTtcblx0XHQvL3JlbW92ZSBjaGlsZCBmcm9tIGRpc3BsYXksIG9yIG1ha2UgaXQgaW52aXNpYmxlIGlmIGl0IGlzIGluIGEgUGFydGljbGVDb250YWluZXJcblx0XHRpZihwYXJ0aWNsZS5wYXJlbnQpXG5cdFx0XHRwYXJ0aWNsZS5wYXJlbnQucmVtb3ZlQ2hpbGQocGFydGljbGUpO1xuXHRcdC8vZGVjcmVhc2UgY291bnRcblx0XHQtLXRoaXMucGFydGljbGVDb3VudDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSByb3RhdGlvbiBvZiB0aGUgZW1pdHRlciB0byBhIG5ldyB2YWx1ZS5cblx0ICogQHBhcmFtIG5ld1JvdCBUaGUgbmV3IHJvdGF0aW9uLCBpbiBkZWdyZWVzLlxuXHQgKi9cblx0cHVibGljIHJvdGF0ZShuZXdSb3Q6IG51bWJlcilcblx0e1xuXHRcdGlmICh0aGlzLnJvdGF0aW9uID09IG5ld1JvdCkgcmV0dXJuO1xuXHRcdC8vY2FjbHVsYXRlIHRoZSBkaWZmZXJlbmNlIGluIHJvdGF0aW9uIGZvciByb3RhdGluZyBzcGF3blBvc1xuXHRcdGxldCBkaWZmID0gbmV3Um90IC0gdGhpcy5yb3RhdGlvbjtcblx0XHR0aGlzLnJvdGF0aW9uID0gbmV3Um90O1xuXHRcdC8vcm90YXRlIHNwYXduUG9zXG5cdFx0UGFydGljbGVVdGlscy5yb3RhdGVQb2ludChkaWZmLCB0aGlzLnNwYXduUG9zKTtcblx0XHQvL21hcmsgdGhlIHBvc2l0aW9uIGFzIGhhdmluZyBjaGFuZ2VkXG5cdFx0dGhpcy5fcG9zQ2hhbmdlZCA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQ2hhbmdlcyB0aGUgc3Bhd24gcG9zaXRpb24gb2YgdGhlIGVtaXR0ZXIuXG5cdCAqIEBwYXJhbSB4IFRoZSBuZXcgeCB2YWx1ZSBvZiB0aGUgc3Bhd24gcG9zaXRpb24gZm9yIHRoZSBlbWl0dGVyLlxuXHQgKiBAcGFyYW0geSBUaGUgbmV3IHkgdmFsdWUgb2YgdGhlIHNwYXduIHBvc2l0aW9uIGZvciB0aGUgZW1pdHRlci5cblx0ICovXG5cdHB1YmxpYyB1cGRhdGVTcGF3blBvcyh4OiBudW1iZXIsIHk6IG51bWJlcilcblx0e1xuXHRcdHRoaXMuX3Bvc0NoYW5nZWQgPSB0cnVlO1xuXHRcdHRoaXMuc3Bhd25Qb3MueCA9IHg7XG5cdFx0dGhpcy5zcGF3blBvcy55ID0geTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGFuZ2VzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZW1pdHRlcidzIG93bmVyLiBZb3Ugc2hvdWxkIGNhbGwgdGhpcyBpZiB5b3UgYXJlIGFkZGluZ1xuXHQgKiBwYXJ0aWNsZXMgdG8gdGhlIHdvcmxkIGNvbnRhaW5lciB0aGF0IHlvdXIgZW1pdHRlcidzIG93bmVyIGlzIG1vdmluZyBhcm91bmQgaW4uXG5cdCAqIEBwYXJhbSB4IFRoZSBuZXcgeCB2YWx1ZSBvZiB0aGUgZW1pdHRlcidzIG93bmVyLlxuXHQgKiBAcGFyYW0geSBUaGUgbmV3IHkgdmFsdWUgb2YgdGhlIGVtaXR0ZXIncyBvd25lci5cblx0ICovXG5cdHB1YmxpYyB1cGRhdGVPd25lclBvcyh4OiBudW1iZXIsIHk6IG51bWJlcilcblx0e1xuXHRcdHRoaXMuX3Bvc0NoYW5nZWQgPSB0cnVlO1xuXHRcdHRoaXMub3duZXJQb3MueCA9IHg7XG5cdFx0dGhpcy5vd25lclBvcy55ID0geTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQcmV2ZW50cyBlbWl0dGVyIHBvc2l0aW9uIGludGVycG9sYXRpb24gaW4gdGhlIG5leHQgdXBkYXRlLlxuXHQgKiBUaGlzIHNob3VsZCBiZSB1c2VkIGlmIHlvdSBtYWRlIGEgbWFqb3IgcG9zaXRpb24gY2hhbmdlIG9mIHlvdXIgZW1pdHRlcidzIG93bmVyXG5cdCAqIHRoYXQgd2FzIG5vdCBub3JtYWwgbW92ZW1lbnQuXG5cdCAqL1xuXHRwdWJsaWMgcmVzZXRQb3NpdGlvblRyYWNraW5nKClcblx0e1xuXHRcdHRoaXMuX3ByZXZQb3NJc1ZhbGlkID0gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogSWYgcGFydGljbGVzIHNob3VsZCBiZSBlbWl0dGVkIGR1cmluZyB1cGRhdGUoKSBjYWxscy4gU2V0dGluZyB0aGlzIHRvIGZhbHNlXG5cdCAqIHN0b3BzIG5ldyBwYXJ0aWNsZXMgZnJvbSBiZWluZyBjcmVhdGVkLCBidXQgYWxsb3dzIGV4aXN0aW5nIG9uZXMgdG8gZGllIG91dC5cblx0ICovXG5cdHB1YmxpYyBnZXQgZW1pdCgpIHsgcmV0dXJuIHRoaXMuX2VtaXQ7IH07XG5cdHB1YmxpYyBzZXQgZW1pdCh2YWx1ZSlcblx0e1xuXHRcdHRoaXMuX2VtaXQgPSAhIXZhbHVlO1xuXHRcdHRoaXMuX2VtaXR0ZXJMaWZlID0gdGhpcy5lbWl0dGVyTGlmZXRpbWU7XG5cdH1cblxuXHQvKipcblx0ICogSWYgdGhlIHVwZGF0ZSBmdW5jdGlvbiBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBmcm9tIHRoZSBzaGFyZWQgdGlja2VyLlxuXHQgKiBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgcmVxdWlyZXMgY2FsbGluZyB0aGUgdXBkYXRlIGZ1bmN0aW9uIG1hbnVhbGx5LlxuXHQgKi9cblx0cHVibGljIGdldCBhdXRvVXBkYXRlKCkgeyByZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTsgfVxuXHRwdWJsaWMgc2V0IGF1dG9VcGRhdGUodmFsdWUpXG5cdHtcblx0XHRpZiAodGhpcy5fYXV0b1VwZGF0ZSAmJiAhdmFsdWUpXG5cdFx0e1xuXHRcdFx0dGlja2VyLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCF0aGlzLl9hdXRvVXBkYXRlICYmIHZhbHVlKVxuXHRcdHtcblx0XHRcdHRpY2tlci5hZGQodGhpcy51cGRhdGUsIHRoaXMpO1xuXHRcdH1cblx0XHR0aGlzLl9hdXRvVXBkYXRlID0gISF2YWx1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdGFydHMgZW1pdHRpbmcgcGFydGljbGVzLCBzZXRzIGF1dG9VcGRhdGUgdG8gdHJ1ZSwgYW5kIHNldHMgdXAgdGhlIEVtaXR0ZXIgdG8gZGVzdHJveSBpdHNlbGZcblx0ICogd2hlbiBwYXJ0aWNsZSBlbWlzc2lvbiBpcyBjb21wbGV0ZS5cblx0ICogQHBhcmFtIGNhbGxiYWNrIENhbGxiYWNrIGZvciB3aGVuIGVtaXNzaW9uIGlzIGNvbXBsZXRlIChhbGwgcGFydGljbGVzIGhhdmUgZGllZCBvZmYpXG5cdCAqL1xuXHRwdWJsaWMgcGxheU9uY2VBbmREZXN0cm95KGNhbGxiYWNrPzogKCkgPT4gdm9pZClcblx0e1xuXHRcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5lbWl0ID0gdHJ1ZTtcblx0XHR0aGlzLl9kZXN0cm95V2hlbkNvbXBsZXRlID0gdHJ1ZTtcblx0XHR0aGlzLl9jb21wbGV0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdH1cblxuXHQvKipcblx0ICogU3RhcnRzIGVtaXR0aW5nIHBhcnRpY2xlcyBhbmQgb3B0aW9uYWxseSBjYWxscyBhIGNhbGxiYWNrIHdoZW4gcGFydGljbGUgZW1pc3Npb24gaXMgY29tcGxldGUuXG5cdCAqIEBwYXJhbSBjYWxsYmFjayBDYWxsYmFjayBmb3Igd2hlbiBlbWlzc2lvbiBpcyBjb21wbGV0ZSAoYWxsIHBhcnRpY2xlcyBoYXZlIGRpZWQgb2ZmKVxuXHQgKi9cblx0cHVibGljIHBsYXlPbmNlKGNhbGxiYWNrPzogKCkgPT4gdm9pZClcblx0e1xuXHRcdHRoaXMuZW1pdCA9IHRydWU7XG5cdFx0dGhpcy5fY29tcGxldGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgYWxsIHBhcnRpY2xlcyBzcGF3bmVkIGJ5IHRoaXMgZW1pdHRlciBhbmQgZW1pdHMgbmV3IG9uZXMuXG5cdCAqIEBwYXJhbSBkZWx0YSBUaW1lIGVsYXBzZWQgc2luY2UgdGhlIHByZXZpb3VzIGZyYW1lLCBpbiBfX3NlY29uZHNfXy5cblx0ICovXG5cdHB1YmxpYyB1cGRhdGUoZGVsdGE6IG51bWJlcilcblx0e1xuXHRcdGlmICh0aGlzLl9hdXRvVXBkYXRlKVxuXHRcdHtcblx0XHRcdGRlbHRhID0gZGVsdGEgLyBzZXR0aW5ncy5UQVJHRVRfRlBNUyAvIDEwMDA7XG5cdFx0fVxuXG5cdFx0Ly9pZiB3ZSBkb24ndCBoYXZlIGEgcGFyZW50IHRvIGFkZCBwYXJ0aWNsZXMgdG8sIHRoZW4gZG9uJ3QgZG8gYW55dGhpbmcuXG5cdFx0Ly90aGlzIGFsc28gd29ya3MgYXMgYSBpc0Rlc3Ryb3llZCBjaGVja1xuXHRcdGlmICghdGhpcy5fcGFyZW50KSByZXR1cm47XG5cdFx0Ly91cGRhdGUgZXhpc3RpbmcgcGFydGljbGVzXG5cdFx0bGV0IGksIHBhcnRpY2xlLCBuZXh0O1xuXHRcdGZvciAocGFydGljbGUgPSB0aGlzLl9hY3RpdmVQYXJ0aWNsZXNGaXJzdDsgcGFydGljbGU7IHBhcnRpY2xlID0gbmV4dClcblx0XHR7XG5cdFx0XHRuZXh0ID0gcGFydGljbGUubmV4dDtcblx0XHRcdHBhcnRpY2xlLnVwZGF0ZShkZWx0YSk7XG5cdFx0fVxuXHRcdGxldCBwcmV2WCwgcHJldlk7XG5cdFx0Ly9pZiB0aGUgcHJldmlvdXMgcG9zaXRpb24gaXMgdmFsaWQsIHN0b3JlIHRoZXNlIGZvciBsYXRlciBpbnRlcnBvbGF0aW9uXG5cdFx0aWYodGhpcy5fcHJldlBvc0lzVmFsaWQpXG5cdFx0e1xuXHRcdFx0cHJldlggPSB0aGlzLl9wcmV2RW1pdHRlclBvcy54O1xuXHRcdFx0cHJldlkgPSB0aGlzLl9wcmV2RW1pdHRlclBvcy55O1xuXHRcdH1cblx0XHQvL3N0b3JlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGVtaXR0ZXIgYXMgbG9jYWwgdmFyaWFibGVzXG5cdFx0bGV0IGN1clggPSB0aGlzLm93bmVyUG9zLnggKyB0aGlzLnNwYXduUG9zLng7XG5cdFx0bGV0IGN1clkgPSB0aGlzLm93bmVyUG9zLnkgKyB0aGlzLnNwYXduUG9zLnk7XG5cdFx0Ly9zcGF3biBuZXcgcGFydGljbGVzXG5cdFx0aWYgKHRoaXMuX2VtaXQpXG5cdFx0e1xuXHRcdFx0Ly9kZWNyZWFzZSBzcGF3biB0aW1lclxuXHRcdFx0dGhpcy5fc3Bhd25UaW1lciAtPSAgZGVsdGEgPCAwID8gMCA6IGRlbHRhO1xuXHRcdFx0Ly93aGlsZSBfc3Bhd25UaW1lciA8IDAsIHdlIGhhdmUgcGFydGljbGVzIHRvIHNwYXduXG5cdFx0XHR3aGlsZSh0aGlzLl9zcGF3blRpbWVyIDw9IDApXG5cdFx0XHR7XG5cdFx0XHRcdC8vZGV0ZXJtaW5lIGlmIHRoZSBlbWl0dGVyIHNob3VsZCBzdG9wIHNwYXduaW5nXG5cdFx0XHRcdGlmKHRoaXMuX2VtaXR0ZXJMaWZlID4gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuX2VtaXR0ZXJMaWZlIC09IHRoaXMuX2ZyZXF1ZW5jeTtcblx0XHRcdFx0XHRpZih0aGlzLl9lbWl0dGVyTGlmZSA8PSAwKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHRoaXMuX3NwYXduVGltZXIgPSAwO1xuXHRcdFx0XHRcdFx0dGhpcy5fZW1pdHRlckxpZmUgPSAwO1xuXHRcdFx0XHRcdFx0dGhpcy5lbWl0ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9kZXRlcm1pbmUgaWYgd2UgaGF2ZSBoaXQgdGhlIHBhcnRpY2xlIGxpbWl0XG5cdFx0XHRcdGlmKHRoaXMucGFydGljbGVDb3VudCA+PSB0aGlzLm1heFBhcnRpY2xlcylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuX3NwYXduVGltZXIgKz0gdGhpcy5fZnJlcXVlbmN5O1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vZGV0ZXJtaW5lIHRoZSBwYXJ0aWNsZSBsaWZldGltZVxuXHRcdFx0XHRsZXQgbGlmZXRpbWU7XG5cdFx0XHRcdGlmICh0aGlzLm1pbkxpZmV0aW1lID09IHRoaXMubWF4TGlmZXRpbWUpXG5cdFx0XHRcdFx0bGlmZXRpbWUgPSB0aGlzLm1pbkxpZmV0aW1lO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0bGlmZXRpbWUgPSBNYXRoLnJhbmRvbSgpICogKHRoaXMubWF4TGlmZXRpbWUgLSB0aGlzLm1pbkxpZmV0aW1lKSArIHRoaXMubWluTGlmZXRpbWU7XG5cdFx0XHRcdC8vb25seSBtYWtlIHRoZSBwYXJ0aWNsZSBpZiBpdCB3b3VsZG4ndCBpbW1lZGlhdGVseSBkZXN0cm95IGl0c2VsZlxuXHRcdFx0XHRpZigtdGhpcy5fc3Bhd25UaW1lciA8IGxpZmV0aW1lKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly9JZiB0aGUgcG9zaXRpb24gaGFzIGNoYW5nZWQgYW5kIHRoaXMgaXNuJ3QgdGhlIGZpcnN0IHNwYXduLFxuXHRcdFx0XHRcdC8vaW50ZXJwb2xhdGUgdGhlIHNwYXduIHBvc2l0aW9uXG5cdFx0XHRcdFx0bGV0IGVtaXRQb3NYLCBlbWl0UG9zWTtcblx0XHRcdFx0XHRpZiAodGhpcy5fcHJldlBvc0lzVmFsaWQgJiYgdGhpcy5fcG9zQ2hhbmdlZClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvLzEgLSBfc3Bhd25UaW1lciAvIGRlbHRhLCBidXQgX3NwYXduVGltZXIgaXMgbmVnYXRpdmVcblx0XHRcdFx0XHRcdGxldCBsZXJwID0gMSArIHRoaXMuX3NwYXduVGltZXIgLyBkZWx0YTtcblx0XHRcdFx0XHRcdGVtaXRQb3NYID0gKGN1clggLSBwcmV2WCkgKiBsZXJwICsgcHJldlg7XG5cdFx0XHRcdFx0XHRlbWl0UG9zWSA9IChjdXJZIC0gcHJldlkpICogbGVycCArIHByZXZZO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlLy9vdGhlcndpc2UganVzdCBzZXQgdG8gdGhlIHNwYXduIHBvc2l0aW9uXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZW1pdFBvc1ggPSBjdXJYO1xuXHRcdFx0XHRcdFx0ZW1pdFBvc1kgPSBjdXJZO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL2NyZWF0ZSBlbm91Z2ggcGFydGljbGVzIHRvIGZpbGwgdGhlIHdhdmUgKG5vbi1idXJzdCB0eXBlcyBoYXZlIGEgd2F2ZSBvZiAxKVxuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdGZvcihsZXQgbGVuID0gTWF0aC5taW4odGhpcy5wYXJ0aWNsZXNQZXJXYXZlLCB0aGlzLm1heFBhcnRpY2xlcyAtIHRoaXMucGFydGljbGVDb3VudCk7IGkgPCBsZW47ICsraSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvL3NlZSBpZiB3ZSBhY3R1YWxseSBzcGF3biBvbmVcblx0XHRcdFx0XHRcdGlmICh0aGlzLnNwYXduQ2hhbmNlIDwgMSAmJiBNYXRoLnJhbmRvbSgpID49IHRoaXMuc3Bhd25DaGFuY2UpXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0Ly9jcmVhdGUgcGFydGljbGVcblx0XHRcdFx0XHRcdGxldCBwO1xuXHRcdFx0XHRcdFx0aWYodGhpcy5fcG9vbEZpcnN0KVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRwID0gdGhpcy5fcG9vbEZpcnN0O1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9wb29sRmlyc3QgPSB0aGlzLl9wb29sRmlyc3QubmV4dDtcblx0XHRcdFx0XHRcdFx0cC5uZXh0ID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cCA9IG5ldyB0aGlzLnBhcnRpY2xlQ29uc3RydWN0b3IodGhpcyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vc2V0IGEgcmFuZG9tIHRleHR1cmUgaWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lXG5cdFx0XHRcdFx0XHRpZih0aGlzLnBhcnRpY2xlSW1hZ2VzLmxlbmd0aCA+IDEpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdC8vIGlmIHVzaW5nIG9yZGVyZWQgYXJ0XG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuX2N1cnJlbnRJbWFnZUluZGV4ICE9PSAtMSlcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdC8vIGdldCBjdXJyZW50IGFydCBpbmRleCwgdGhlbiBpbmNyZW1lbnQgZm9yIHRoZSBuZXh0IHBhcnRpY2xlXG5cdFx0XHRcdFx0XHRcdFx0cC5hcHBseUFydCh0aGlzLnBhcnRpY2xlSW1hZ2VzW3RoaXMuX2N1cnJlbnRJbWFnZUluZGV4KytdKTtcblx0XHRcdFx0XHRcdFx0XHQvLyBsb29wIGFyb3VuZCBpZiBuZWVkZWRcblx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLl9jdXJyZW50SW1hZ2VJbmRleCA8IDAgfHwgdGhpcy5fY3VycmVudEltYWdlSW5kZXggPj0gdGhpcy5wYXJ0aWNsZUltYWdlcy5sZW5ndGgpXG5cdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fY3VycmVudEltYWdlSW5kZXggPSAwO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvLyBvdGhlcndpc2UgZ3JhYiBhIHJhbmRvbSBvbmVcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0cC5hcHBseUFydCh0aGlzLnBhcnRpY2xlSW1hZ2VzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMucGFydGljbGVJbWFnZXMubGVuZ3RoKV0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Ly9pZiB0aGV5IGFyZSBhY3R1YWxseSB0aGUgc2FtZSB0ZXh0dXJlLCBhIHN0YW5kYXJkIHBhcnRpY2xlXG5cdFx0XHRcdFx0XHRcdC8vd2lsbCBxdWl0IGVhcmx5IGZyb20gdGhlIHRleHR1cmUgc2V0dGluZyBpbiBzZXRUZXh0dXJlKCkuXG5cdFx0XHRcdFx0XHRcdHAuYXBwbHlBcnQodGhpcy5wYXJ0aWNsZUltYWdlc1swXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL3NldCB1cCB0aGUgc3RhcnQgYW5kIGVuZCB2YWx1ZXNcblx0XHRcdFx0XHRcdHAuYWxwaGFMaXN0LnJlc2V0KHRoaXMuc3RhcnRBbHBoYSk7XG5cdFx0XHRcdFx0XHRpZih0aGlzLm1pbmltdW1TcGVlZE11bHRpcGxpZXIgIT0gMSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cC5zcGVlZE11bHRpcGxpZXIgPSBNYXRoLnJhbmRvbSgpICogKDEgLSB0aGlzLm1pbmltdW1TcGVlZE11bHRpcGxpZXIpICsgdGhpcy5taW5pbXVtU3BlZWRNdWx0aXBsaWVyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cC5zcGVlZExpc3QucmVzZXQodGhpcy5zdGFydFNwZWVkKTtcblx0XHRcdFx0XHRcdHAuYWNjZWxlcmF0aW9uLnggPSB0aGlzLmFjY2VsZXJhdGlvbi54O1xuXHRcdFx0XHRcdFx0cC5hY2NlbGVyYXRpb24ueSA9IHRoaXMuYWNjZWxlcmF0aW9uLnk7XG5cdFx0XHRcdFx0XHRwLm1heFNwZWVkID0gdGhpcy5tYXhTcGVlZDtcblx0XHRcdFx0XHRcdGlmKHRoaXMubWluaW11bVNjYWxlTXVsdGlwbGllciAhPSAxKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRwLnNjYWxlTXVsdGlwbGllciA9IE1hdGgucmFuZG9tKCkgKiAoMSAtIHRoaXMubWluaW11bVNjYWxlTXVsdGlwbGllcikgKyB0aGlzLm1pbmltdW1TY2FsZU11bHRpcGxpZXI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwLnNjYWxlTGlzdC5yZXNldCh0aGlzLnN0YXJ0U2NhbGUpO1xuXHRcdFx0XHRcdFx0cC5jb2xvckxpc3QucmVzZXQodGhpcy5zdGFydENvbG9yKTtcblx0XHRcdFx0XHRcdC8vcmFuZG9taXplIHRoZSByb3RhdGlvbiBzcGVlZFxuXHRcdFx0XHRcdFx0aWYodGhpcy5taW5Sb3RhdGlvblNwZWVkID09IHRoaXMubWF4Um90YXRpb25TcGVlZClcblx0XHRcdFx0XHRcdFx0cC5yb3RhdGlvblNwZWVkID0gdGhpcy5taW5Sb3RhdGlvblNwZWVkO1xuXHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRwLnJvdGF0aW9uU3BlZWQgPSBNYXRoLnJhbmRvbSgpICogKHRoaXMubWF4Um90YXRpb25TcGVlZCAtIHRoaXMubWluUm90YXRpb25TcGVlZCkgKyB0aGlzLm1pblJvdGF0aW9uU3BlZWQ7XG5cdFx0XHRcdFx0XHRwLnJvdGF0aW9uQWNjZWxlcmF0aW9uID0gdGhpcy5yb3RhdGlvbkFjY2VsZXJhdGlvbjtcblx0XHRcdFx0XHRcdHAubm9Sb3RhdGlvbiA9IHRoaXMubm9Sb3RhdGlvbjtcblx0XHRcdFx0XHRcdC8vc2V0IHVwIHRoZSBsaWZldGltZVxuXHRcdFx0XHRcdFx0cC5tYXhMaWZlID0gbGlmZXRpbWU7XG5cdFx0XHRcdFx0XHQvL3NldCB0aGUgYmxlbmQgbW9kZVxuXHRcdFx0XHRcdFx0cC5ibGVuZE1vZGUgPSB0aGlzLnBhcnRpY2xlQmxlbmRNb2RlO1xuXHRcdFx0XHRcdFx0Ly9zZXQgdGhlIGN1c3RvbSBlYXNlLCBpZiBhbnlcblx0XHRcdFx0XHRcdHAuZWFzZSA9IHRoaXMuY3VzdG9tRWFzZTtcblx0XHRcdFx0XHRcdC8vc2V0IHRoZSBleHRyYSBkYXRhLCBpZiBhbnlcblx0XHRcdFx0XHRcdHAuZXh0cmFEYXRhID0gdGhpcy5leHRyYURhdGE7XG5cdFx0XHRcdFx0XHQvL3NldCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gcGFydGljbGVcblx0XHRcdFx0XHRcdHRoaXMuYXBwbHlBZGRpdGlvbmFsUHJvcGVydGllcyhwKTtcblx0XHRcdFx0XHRcdC8vY2FsbCB0aGUgcHJvcGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSByb3RhdGlvbiBhbmQgcG9zaXRpb24gb2YgcGFydGljbGVcblx0XHRcdFx0XHRcdHRoaXMuX3NwYXduRnVuYyhwLCBlbWl0UG9zWCwgZW1pdFBvc1ksIGkpO1xuXHRcdFx0XHRcdFx0Ly9pbml0aWFsaXplIHBhcnRpY2xlXG5cdFx0XHRcdFx0XHRwLmluaXQoKTtcblx0XHRcdFx0XHRcdC8vdXBkYXRlIHRoZSBwYXJ0aWNsZSBieSB0aGUgdGltZSBwYXNzZWQsIHNvIHRoZSBwYXJ0aWNsZXMgYXJlIHNwcmVhZCBvdXQgcHJvcGVybHlcblx0XHRcdFx0XHRcdHAudXBkYXRlKC10aGlzLl9zcGF3blRpbWVyKTsvL3dlIHdhbnQgYSBwb3NpdGl2ZSBkZWx0YSwgYmVjYXVzZSBhIG5lZ2F0aXZlIGRlbHRhIG1lc3NlcyB0aGluZ3MgdXBcblx0XHRcdFx0XHRcdC8vYWRkIHRoZSBwYXJ0aWNsZSB0byB0aGUgZGlzcGxheSBsaXN0XG5cdFx0XHRcdFx0XHRpZighcC5wYXJlbnQpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLmFkZEF0QmFjaylcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9wYXJlbnQuYWRkQ2hpbGRBdChwLCAwKTtcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3BhcmVudC5hZGRDaGlsZChwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Ly9raW5kIG9mIGhhY2t5LCBidXQgcGVyZm9ybWFuY2UgZnJpZW5kbHlcblx0XHRcdFx0XHRcdFx0Ly9zaHVmZmxlIGNoaWxkcmVuIHRvIGNvcnJlY3QgcGxhY2Vcblx0XHRcdFx0XHRcdFx0bGV0IGNoaWxkcmVuID0gdGhpcy5fcGFyZW50LmNoaWxkcmVuO1xuXHRcdFx0XHRcdFx0XHQvL2F2b2lkIHVzaW5nIHNwbGljZSBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZihjaGlsZHJlblswXSA9PSBwKVxuXHRcdFx0XHRcdFx0XHRcdGNoaWxkcmVuLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYoY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoLTFdID09IHApXG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW4ucG9wKCk7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdGxldCBpbmRleCA9IGNoaWxkcmVuLmluZGV4T2YocCk7XG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZih0aGlzLmFkZEF0QmFjaylcblx0XHRcdFx0XHRcdFx0XHRjaGlsZHJlbi51bnNoaWZ0KHApO1xuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW4ucHVzaChwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vYWRkIHBhcnRpY2xlIHRvIGxpc3Qgb2YgYWN0aXZlIHBhcnRpY2xlc1xuXHRcdFx0XHRcdFx0aWYodGhpcy5fYWN0aXZlUGFydGljbGVzTGFzdClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fYWN0aXZlUGFydGljbGVzTGFzdC5uZXh0ID0gcDtcblx0XHRcdFx0XHRcdFx0cC5wcmV2ID0gdGhpcy5fYWN0aXZlUGFydGljbGVzTGFzdDtcblx0XHRcdFx0XHRcdFx0dGhpcy5fYWN0aXZlUGFydGljbGVzTGFzdCA9IHA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2FjdGl2ZVBhcnRpY2xlc0xhc3QgPSB0aGlzLl9hY3RpdmVQYXJ0aWNsZXNGaXJzdCA9IHA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQrK3RoaXMucGFydGljbGVDb3VudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9pbmNyZWFzZSB0aW1lciBhbmQgY29udGludWUgb24gdG8gYW55IG90aGVyIHBhcnRpY2xlcyB0aGF0IG5lZWQgdG8gYmUgY3JlYXRlZFxuXHRcdFx0XHR0aGlzLl9zcGF3blRpbWVyICs9IHRoaXMuX2ZyZXF1ZW5jeTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly9pZiB0aGUgcG9zaXRpb24gY2hhbmdlZCBiZWZvcmUgdGhpcyB1cGRhdGUsIHRoZW4ga2VlcCB0cmFjayBvZiB0aGF0XG5cdFx0aWYodGhpcy5fcG9zQ2hhbmdlZClcblx0XHR7XG5cdFx0XHR0aGlzLl9wcmV2RW1pdHRlclBvcy54ID0gY3VyWDtcblx0XHRcdHRoaXMuX3ByZXZFbWl0dGVyUG9zLnkgPSBjdXJZO1xuXHRcdFx0dGhpcy5fcHJldlBvc0lzVmFsaWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5fcG9zQ2hhbmdlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vaWYgd2UgYXJlIGFsbCBkb25lIGFuZCBzaG91bGQgZGVzdHJveSBvdXJzZWx2ZXMsIHRha2UgY2FyZSBvZiB0aGF0XG5cdFx0aWYgKCF0aGlzLl9lbWl0ICYmICF0aGlzLl9hY3RpdmVQYXJ0aWNsZXNGaXJzdClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fY29tcGxldGVDYWxsYmFjaylcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgY2IgPSB0aGlzLl9jb21wbGV0ZUNhbGxiYWNrO1xuXHRcdFx0XHR0aGlzLl9jb21wbGV0ZUNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0Y2IoKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9kZXN0cm95V2hlbkNvbXBsZXRlKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2V0IGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBuZXcgcGFydGljbGUuXG5cdCAqIFVzaW5nIG9uIGNsYXNzZXMgdGhhdCBleHRlbmQgZnJvbSBFbWl0dGVyXG5cdCAqIEBwYXJhbSBwIFRoZSBwYXJ0aWNsZVxuXHQgKi9cblx0cHJvdGVjdGVkIGFwcGx5QWRkaXRpb25hbFByb3BlcnRpZXMocDogUGFydGljbGUpIHtcblx0fVxuXG5cdC8qKlxuXHQgKiBQb3NpdGlvbnMgYSBwYXJ0aWNsZSBmb3IgYSBwb2ludCB0eXBlIGVtaXR0ZXIuXG5cdCAqIEBwYXJhbSBwIFRoZSBwYXJ0aWNsZSB0byBwb3NpdGlvbiBhbmQgcm90YXRlLlxuXHQgKiBAcGFyYW0gZW1pdFBvc1ggVGhlIGVtaXR0ZXIncyB4IHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBlbWl0UG9zWSBUaGUgZW1pdHRlcidzIHkgcG9zaXRpb25cblx0ICogQHBhcmFtIGkgVGhlIHBhcnRpY2xlIG51bWJlciBpbiB0aGUgY3VycmVudCB3YXZlLiBOb3QgdXNlZCBmb3IgdGhpcyBmdW5jdGlvbi5cblx0ICovXG5cdHByb3RlY3RlZCBfc3Bhd25Qb2ludChwOiBQYXJ0aWNsZSwgZW1pdFBvc1g6IG51bWJlciwgZW1pdFBvc1k6IG51bWJlcilcblx0e1xuXHRcdC8vc2V0IHRoZSBpbml0aWFsIHJvdGF0aW9uL2RpcmVjdGlvbiBvZiB0aGUgcGFydGljbGUgYmFzZWQgb25cblx0XHQvL3N0YXJ0aW5nIHBhcnRpY2xlIGFuZ2xlIGFuZCByb3RhdGlvbiBvZiBlbWl0dGVyXG5cdFx0aWYgKHRoaXMubWluU3RhcnRSb3RhdGlvbiA9PSB0aGlzLm1heFN0YXJ0Um90YXRpb24pXG5cdFx0XHRwLnJvdGF0aW9uID0gdGhpcy5taW5TdGFydFJvdGF0aW9uICsgdGhpcy5yb3RhdGlvbjtcblx0XHRlbHNlXG5cdFx0XHRwLnJvdGF0aW9uID0gTWF0aC5yYW5kb20oKSAqICh0aGlzLm1heFN0YXJ0Um90YXRpb24gLSB0aGlzLm1pblN0YXJ0Um90YXRpb24pICsgdGhpcy5taW5TdGFydFJvdGF0aW9uICsgdGhpcy5yb3RhdGlvbjtcblx0XHQvL2Ryb3AgdGhlIHBhcnRpY2xlIGF0IHRoZSBlbWl0dGVyJ3MgcG9zaXRpb25cblx0XHRwLnBvc2l0aW9uLnggPSBlbWl0UG9zWDtcblx0XHRwLnBvc2l0aW9uLnkgPSBlbWl0UG9zWTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQb3NpdGlvbnMgYSBwYXJ0aWNsZSBmb3IgYSByZWN0YW5nbGUgdHlwZSBlbWl0dGVyLlxuXHQgKiBAcGFyYW0gcCBUaGUgcGFydGljbGUgdG8gcG9zaXRpb24gYW5kIHJvdGF0ZS5cblx0ICogQHBhcmFtIGVtaXRQb3NYIFRoZSBlbWl0dGVyJ3MgeCBwb3NpdGlvblxuXHQgKiBAcGFyYW0gZW1pdFBvc1kgVGhlIGVtaXR0ZXIncyB5IHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBpIFRoZSBwYXJ0aWNsZSBudW1iZXIgaW4gdGhlIGN1cnJlbnQgd2F2ZS4gTm90IHVzZWQgZm9yIHRoaXMgZnVuY3Rpb24uXG5cdCAqL1xuXHRwcm90ZWN0ZWQgX3NwYXduUmVjdChwOiBQYXJ0aWNsZSwgZW1pdFBvc1g6IG51bWJlciwgZW1pdFBvc1k6IG51bWJlcilcblx0e1xuXHRcdC8vc2V0IHRoZSBpbml0aWFsIHJvdGF0aW9uL2RpcmVjdGlvbiBvZiB0aGUgcGFydGljbGUgYmFzZWQgb24gc3RhcnRpbmdcblx0XHQvL3BhcnRpY2xlIGFuZ2xlIGFuZCByb3RhdGlvbiBvZiBlbWl0dGVyXG5cdFx0aWYgKHRoaXMubWluU3RhcnRSb3RhdGlvbiA9PSB0aGlzLm1heFN0YXJ0Um90YXRpb24pXG5cdFx0XHRwLnJvdGF0aW9uID0gdGhpcy5taW5TdGFydFJvdGF0aW9uICsgdGhpcy5yb3RhdGlvbjtcblx0XHRlbHNlXG5cdFx0XHRwLnJvdGF0aW9uID0gTWF0aC5yYW5kb20oKSAqICh0aGlzLm1heFN0YXJ0Um90YXRpb24gLSB0aGlzLm1pblN0YXJ0Um90YXRpb24pICsgdGhpcy5taW5TdGFydFJvdGF0aW9uICsgdGhpcy5yb3RhdGlvbjtcblx0XHQvL3BsYWNlIHRoZSBwYXJ0aWNsZSBhdCBhIHJhbmRvbSBwb2ludCBpbiB0aGUgcmVjdGFuZ2xlXG5cdFx0aGVscGVyUG9pbnQueCA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLnNwYXduUmVjdC53aWR0aCArIHRoaXMuc3Bhd25SZWN0Lng7XG5cdFx0aGVscGVyUG9pbnQueSA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLnNwYXduUmVjdC5oZWlnaHQgKyB0aGlzLnNwYXduUmVjdC55O1xuXHRcdGlmKHRoaXMucm90YXRpb24gIT09IDApXG5cdFx0XHRQYXJ0aWNsZVV0aWxzLnJvdGF0ZVBvaW50KHRoaXMucm90YXRpb24sIGhlbHBlclBvaW50KTtcblx0XHRwLnBvc2l0aW9uLnggPSBlbWl0UG9zWCArIGhlbHBlclBvaW50Lng7XG5cdFx0cC5wb3NpdGlvbi55ID0gZW1pdFBvc1kgKyBoZWxwZXJQb2ludC55O1xuXHR9XG5cblx0LyoqXG5cdCAqIFBvc2l0aW9ucyBhIHBhcnRpY2xlIGZvciBhIGNpcmNsZSB0eXBlIGVtaXR0ZXIuXG5cdCAqIEBwYXJhbSBwIFRoZSBwYXJ0aWNsZSB0byBwb3NpdGlvbiBhbmQgcm90YXRlLlxuXHQgKiBAcGFyYW0gZW1pdFBvc1ggVGhlIGVtaXR0ZXIncyB4IHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBlbWl0UG9zWSBUaGUgZW1pdHRlcidzIHkgcG9zaXRpb25cblx0ICogQHBhcmFtIGkgVGhlIHBhcnRpY2xlIG51bWJlciBpbiB0aGUgY3VycmVudCB3YXZlLiBOb3QgdXNlZCBmb3IgdGhpcyBmdW5jdGlvbi5cblx0ICovXG5cdHByb3RlY3RlZCBfc3Bhd25DaXJjbGUocDogUGFydGljbGUsIGVtaXRQb3NYOiBudW1iZXIsIGVtaXRQb3NZOiBudW1iZXIpXG5cdHtcblx0XHQvL3NldCB0aGUgaW5pdGlhbCByb3RhdGlvbi9kaXJlY3Rpb24gb2YgdGhlIHBhcnRpY2xlIGJhc2VkIG9uIHN0YXJ0aW5nXG5cdFx0Ly9wYXJ0aWNsZSBhbmdsZSBhbmQgcm90YXRpb24gb2YgZW1pdHRlclxuXHRcdGlmICh0aGlzLm1pblN0YXJ0Um90YXRpb24gPT0gdGhpcy5tYXhTdGFydFJvdGF0aW9uKVxuXHRcdFx0cC5yb3RhdGlvbiA9IHRoaXMubWluU3RhcnRSb3RhdGlvbiArIHRoaXMucm90YXRpb247XG5cdFx0ZWxzZVxuXHRcdFx0cC5yb3RhdGlvbiA9IE1hdGgucmFuZG9tKCkgKiAodGhpcy5tYXhTdGFydFJvdGF0aW9uIC0gdGhpcy5taW5TdGFydFJvdGF0aW9uKSArXG5cdFx0XHRcdFx0XHR0aGlzLm1pblN0YXJ0Um90YXRpb24gKyB0aGlzLnJvdGF0aW9uO1xuXHRcdC8vcGxhY2UgdGhlIHBhcnRpY2xlIGF0IGEgcmFuZG9tIHJhZGl1cyBpbiB0aGUgY2lyY2xlXG5cdFx0aGVscGVyUG9pbnQueCA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLnNwYXduQ2lyY2xlLnJhZGl1cztcblx0XHRoZWxwZXJQb2ludC55ID0gMDtcblx0XHQvL3JvdGF0ZSB0aGUgcG9pbnQgdG8gYSByYW5kb20gYW5nbGUgaW4gdGhlIGNpcmNsZVxuXHRcdFBhcnRpY2xlVXRpbHMucm90YXRlUG9pbnQoTWF0aC5yYW5kb20oKSAqIDM2MCwgaGVscGVyUG9pbnQpO1xuXHRcdC8vb2Zmc2V0IGJ5IHRoZSBjaXJjbGUncyBjZW50ZXJcblx0XHRoZWxwZXJQb2ludC54ICs9IHRoaXMuc3Bhd25DaXJjbGUueDtcblx0XHRoZWxwZXJQb2ludC55ICs9IHRoaXMuc3Bhd25DaXJjbGUueTtcblx0XHQvL3JvdGF0ZSB0aGUgcG9pbnQgYnkgdGhlIGVtaXR0ZXIncyByb3RhdGlvblxuXHRcdGlmKHRoaXMucm90YXRpb24gIT09IDApXG5cdFx0XHRQYXJ0aWNsZVV0aWxzLnJvdGF0ZVBvaW50KHRoaXMucm90YXRpb24sIGhlbHBlclBvaW50KTtcblx0XHQvL3NldCB0aGUgcG9zaXRpb24sIG9mZnNldCBieSB0aGUgZW1pdHRlcidzIHBvc2l0aW9uXG5cdFx0cC5wb3NpdGlvbi54ID0gZW1pdFBvc1ggKyBoZWxwZXJQb2ludC54O1xuXHRcdHAucG9zaXRpb24ueSA9IGVtaXRQb3NZICsgaGVscGVyUG9pbnQueTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQb3NpdGlvbnMgYSBwYXJ0aWNsZSBmb3IgYSByaW5nIHR5cGUgZW1pdHRlci5cblx0ICogQHBhcmFtIHAgVGhlIHBhcnRpY2xlIHRvIHBvc2l0aW9uIGFuZCByb3RhdGUuXG5cdCAqIEBwYXJhbSBlbWl0UG9zWCBUaGUgZW1pdHRlcidzIHggcG9zaXRpb25cblx0ICogQHBhcmFtIGVtaXRQb3NZIFRoZSBlbWl0dGVyJ3MgeSBwb3NpdGlvblxuXHQgKiBAcGFyYW0gaSBUaGUgcGFydGljbGUgbnVtYmVyIGluIHRoZSBjdXJyZW50IHdhdmUuIE5vdCB1c2VkIGZvciB0aGlzIGZ1bmN0aW9uLlxuXHQgKi9cblx0cHJvdGVjdGVkIF9zcGF3blJpbmcocDogUGFydGljbGUsIGVtaXRQb3NYOiBudW1iZXIsIGVtaXRQb3NZOiBudW1iZXIpXG5cdHtcblx0XHRsZXQgc3Bhd25DaXJjbGUgPSB0aGlzLnNwYXduQ2lyY2xlO1xuXHRcdC8vc2V0IHRoZSBpbml0aWFsIHJvdGF0aW9uL2RpcmVjdGlvbiBvZiB0aGUgcGFydGljbGUgYmFzZWQgb24gc3RhcnRpbmdcblx0XHQvL3BhcnRpY2xlIGFuZ2xlIGFuZCByb3RhdGlvbiBvZiBlbWl0dGVyXG5cdFx0aWYgKHRoaXMubWluU3RhcnRSb3RhdGlvbiA9PSB0aGlzLm1heFN0YXJ0Um90YXRpb24pXG5cdFx0XHRwLnJvdGF0aW9uID0gdGhpcy5taW5TdGFydFJvdGF0aW9uICsgdGhpcy5yb3RhdGlvbjtcblx0XHRlbHNlXG5cdFx0XHRwLnJvdGF0aW9uID0gTWF0aC5yYW5kb20oKSAqICh0aGlzLm1heFN0YXJ0Um90YXRpb24gLSB0aGlzLm1pblN0YXJ0Um90YXRpb24pICtcblx0XHRcdFx0XHRcdHRoaXMubWluU3RhcnRSb3RhdGlvbiArIHRoaXMucm90YXRpb247XG5cdFx0Ly9wbGFjZSB0aGUgcGFydGljbGUgYXQgYSByYW5kb20gcmFkaXVzIGluIHRoZSByaW5nXG5cdFx0aWYoc3Bhd25DaXJjbGUubWluUmFkaXVzICE9PSBzcGF3bkNpcmNsZS5yYWRpdXMpXG5cdFx0e1xuXHRcdFx0aGVscGVyUG9pbnQueCA9IE1hdGgucmFuZG9tKCkgKiAoc3Bhd25DaXJjbGUucmFkaXVzIC0gc3Bhd25DaXJjbGUubWluUmFkaXVzKSArXG5cdFx0XHRcdFx0XHRcdHNwYXduQ2lyY2xlLm1pblJhZGl1cztcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdFx0aGVscGVyUG9pbnQueCA9IHNwYXduQ2lyY2xlLnJhZGl1cztcblx0XHRoZWxwZXJQb2ludC55ID0gMDtcblx0XHQvL3JvdGF0ZSB0aGUgcG9pbnQgdG8gYSByYW5kb20gYW5nbGUgaW4gdGhlIGNpcmNsZVxuXHRcdGxldCBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAzNjA7XG5cdFx0cC5yb3RhdGlvbiArPSBhbmdsZTtcblx0XHRQYXJ0aWNsZVV0aWxzLnJvdGF0ZVBvaW50KGFuZ2xlLCBoZWxwZXJQb2ludCk7XG5cdFx0Ly9vZmZzZXQgYnkgdGhlIGNpcmNsZSdzIGNlbnRlclxuXHRcdGhlbHBlclBvaW50LnggKz0gdGhpcy5zcGF3bkNpcmNsZS54O1xuXHRcdGhlbHBlclBvaW50LnkgKz0gdGhpcy5zcGF3bkNpcmNsZS55O1xuXHRcdC8vcm90YXRlIHRoZSBwb2ludCBieSB0aGUgZW1pdHRlcidzIHJvdGF0aW9uXG5cdFx0aWYodGhpcy5yb3RhdGlvbiAhPT0gMClcblx0XHRcdFBhcnRpY2xlVXRpbHMucm90YXRlUG9pbnQodGhpcy5yb3RhdGlvbiwgaGVscGVyUG9pbnQpO1xuXHRcdC8vc2V0IHRoZSBwb3NpdGlvbiwgb2Zmc2V0IGJ5IHRoZSBlbWl0dGVyJ3MgcG9zaXRpb25cblx0XHRwLnBvc2l0aW9uLnggPSBlbWl0UG9zWCArIGhlbHBlclBvaW50Lng7XG5cdFx0cC5wb3NpdGlvbi55ID0gZW1pdFBvc1kgKyBoZWxwZXJQb2ludC55O1xuXHR9XG5cblx0LyoqXG5cdCAqIFBvc2l0aW9ucyBhIHBhcnRpY2xlIGZvciBwb2x5Z29uYWwgY2hhaW4uXG5cdCAqIEBwYXJhbSBwIFRoZSBwYXJ0aWNsZSB0byBwb3NpdGlvbiBhbmQgcm90YXRlLlxuXHQgKiBAcGFyYW0gZW1pdFBvc1ggVGhlIGVtaXR0ZXIncyB4IHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBlbWl0UG9zWSBUaGUgZW1pdHRlcidzIHkgcG9zaXRpb25cblx0ICogQHBhcmFtIGkgVGhlIHBhcnRpY2xlIG51bWJlciBpbiB0aGUgY3VycmVudCB3YXZlLiBOb3QgdXNlZCBmb3IgdGhpcyBmdW5jdGlvbi5cblx0ICovXG5cdHByb3RlY3RlZCBfc3Bhd25Qb2x5Z29uYWxDaGFpbihwOiBQYXJ0aWNsZSwgZW1pdFBvc1g6IG51bWJlciwgZW1pdFBvc1k6IG51bWJlcilcblx0e1xuXHRcdC8vc2V0IHRoZSBpbml0aWFsIHJvdGF0aW9uL2RpcmVjdGlvbiBvZiB0aGUgcGFydGljbGUgYmFzZWQgb24gc3RhcnRpbmdcblx0XHQvL3BhcnRpY2xlIGFuZ2xlIGFuZCByb3RhdGlvbiBvZiBlbWl0dGVyXG5cdFx0aWYgKHRoaXMubWluU3RhcnRSb3RhdGlvbiA9PSB0aGlzLm1heFN0YXJ0Um90YXRpb24pXG5cdFx0XHRwLnJvdGF0aW9uID0gdGhpcy5taW5TdGFydFJvdGF0aW9uICsgdGhpcy5yb3RhdGlvbjtcblx0XHRlbHNlXG5cdFx0XHRwLnJvdGF0aW9uID0gTWF0aC5yYW5kb20oKSAqICh0aGlzLm1heFN0YXJ0Um90YXRpb24gLSB0aGlzLm1pblN0YXJ0Um90YXRpb24pICtcblx0XHRcdFx0dGhpcy5taW5TdGFydFJvdGF0aW9uICsgdGhpcy5yb3RhdGlvbjtcblx0XHQvLyBnZXQgcmFuZG9tIHBvaW50IG9uIHRoZSBwb2x5Z29uIGNoYWluXG5cdFx0dGhpcy5zcGF3blBvbHlnb25hbENoYWluLmdldFJhbmRvbVBvaW50KGhlbHBlclBvaW50KTtcblx0XHQvL3JvdGF0ZSB0aGUgcG9pbnQgYnkgdGhlIGVtaXR0ZXIncyByb3RhdGlvblxuXHRcdGlmKHRoaXMucm90YXRpb24gIT09IDApXG5cdFx0XHRQYXJ0aWNsZVV0aWxzLnJvdGF0ZVBvaW50KHRoaXMucm90YXRpb24sIGhlbHBlclBvaW50KTtcblx0XHQvL3NldCB0aGUgcG9zaXRpb24sIG9mZnNldCBieSB0aGUgZW1pdHRlcidzIHBvc2l0aW9uXG5cdFx0cC5wb3NpdGlvbi54ID0gZW1pdFBvc1ggKyBoZWxwZXJQb2ludC54O1xuXHRcdHAucG9zaXRpb24ueSA9IGVtaXRQb3NZICsgaGVscGVyUG9pbnQueTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQb3NpdGlvbnMgYSBwYXJ0aWNsZSBmb3IgYSBidXJzdCB0eXBlIGVtaXR0ZXIuXG5cdCAqIEBwYXJhbSBwIFRoZSBwYXJ0aWNsZSB0byBwb3NpdGlvbiBhbmQgcm90YXRlLlxuXHQgKiBAcGFyYW0gZW1pdFBvc1ggVGhlIGVtaXR0ZXIncyB4IHBvc2l0aW9uXG5cdCAqIEBwYXJhbSBlbWl0UG9zWSBUaGUgZW1pdHRlcidzIHkgcG9zaXRpb25cblx0ICogQHBhcmFtIGkgVGhlIHBhcnRpY2xlIG51bWJlciBpbiB0aGUgY3VycmVudCB3YXZlLlxuXHQgKi9cblx0cHJvdGVjdGVkIF9zcGF3bkJ1cnN0KHA6IFBhcnRpY2xlLCBlbWl0UG9zWDogbnVtYmVyLCBlbWl0UG9zWTogbnVtYmVyLCBpOiBudW1iZXIpXG5cdHtcblx0XHQvL3NldCB0aGUgaW5pdGlhbCByb3RhdGlvbi9kaXJlY3Rpb24gb2YgdGhlIHBhcnRpY2xlIGJhc2VkIG9uIHNwYXduXG5cdFx0Ly9hbmdsZSBhbmQgcm90YXRpb24gb2YgZW1pdHRlclxuXHRcdGlmKHRoaXMucGFydGljbGVTcGFjaW5nID09PSAwKVxuXHRcdFx0cC5yb3RhdGlvbiA9IE1hdGgucmFuZG9tKCkgKiAzNjA7XG5cdFx0ZWxzZVxuXHRcdFx0cC5yb3RhdGlvbiA9IHRoaXMuYW5nbGVTdGFydCArICh0aGlzLnBhcnRpY2xlU3BhY2luZyAqIGkpICsgdGhpcy5yb3RhdGlvbjtcblx0XHQvL2Ryb3AgdGhlIHBhcnRpY2xlIGF0IHRoZSBlbWl0dGVyJ3MgcG9zaXRpb25cblx0XHRwLnBvc2l0aW9uLnggPSBlbWl0UG9zWDtcblx0XHRwLnBvc2l0aW9uLnkgPSBlbWl0UG9zWTtcblx0fVxuXG5cdC8qKlxuXHQgKiBLaWxscyBhbGwgYWN0aXZlIHBhcnRpY2xlcyBpbW1lZGlhdGVseS5cblx0ICovXG5cdHB1YmxpYyBjbGVhbnVwKClcblx0e1xuXHRcdGxldCBwYXJ0aWNsZSwgbmV4dDtcblx0XHRmb3IgKHBhcnRpY2xlID0gdGhpcy5fYWN0aXZlUGFydGljbGVzRmlyc3Q7IHBhcnRpY2xlOyBwYXJ0aWNsZSA9IG5leHQpXG5cdFx0e1xuXHRcdFx0bmV4dCA9IHBhcnRpY2xlLm5leHQ7XG5cdFx0XHR0aGlzLnJlY3ljbGUocGFydGljbGUpO1xuXHRcdFx0aWYocGFydGljbGUucGFyZW50KVxuXHRcdFx0XHRwYXJ0aWNsZS5wYXJlbnQucmVtb3ZlQ2hpbGQocGFydGljbGUpO1xuXHRcdH1cblx0XHR0aGlzLl9hY3RpdmVQYXJ0aWNsZXNGaXJzdCA9IHRoaXMuX2FjdGl2ZVBhcnRpY2xlc0xhc3QgPSBudWxsO1xuXHRcdHRoaXMucGFydGljbGVDb3VudCA9IDA7XG5cdH1cblxuXHQvKipcblx0ICogRGVzdHJveXMgdGhlIGVtaXR0ZXIgYW5kIGFsbCBvZiBpdHMgcGFydGljbGVzLlxuXHQgKi9cblx0cHVibGljIGRlc3Ryb3koKVxuXHR7XG5cdFx0Ly9tYWtlIHN1cmUgd2UgYXJlbid0IHN0aWxsIGxpc3RlbmluZyB0byBhbnkgdGlja2Vyc1xuXHRcdHRoaXMuYXV0b1VwZGF0ZSA9IGZhbHNlO1xuXHRcdC8vcHV0cyBhbGwgYWN0aXZlIHBhcnRpY2xlcyBpbiB0aGUgcG9vbCwgYW5kIHJlbW92ZXMgdGhlbSBmcm9tIHRoZSBwYXJ0aWNsZSBwYXJlbnRcblx0XHR0aGlzLmNsZWFudXAoKTtcblx0XHQvL3dpcGUgdGhlIHBvb2wgY2xlYW5cblx0XHRsZXQgbmV4dDtcblx0XHRmb3IgKGxldCBwYXJ0aWNsZSA9IHRoaXMuX3Bvb2xGaXJzdDsgcGFydGljbGU7IHBhcnRpY2xlID0gbmV4dClcblx0XHR7XG5cdFx0XHQvL3N0b3JlIG5leHQgdmFsdWUgc28gd2UgZG9uJ3QgbG9zZSBpdCBpbiBvdXIgZGVzdHJveSBjYWxsXG5cdFx0XHRuZXh0ID0gcGFydGljbGUubmV4dDtcblx0XHRcdHBhcnRpY2xlLmRlc3Ryb3koKTtcblx0XHR9XG5cdFx0dGhpcy5fcG9vbEZpcnN0ID0gdGhpcy5fcGFyZW50ID0gdGhpcy5wYXJ0aWNsZUltYWdlcyA9IHRoaXMuc3Bhd25Qb3MgPSB0aGlzLm93bmVyUG9zID1cblx0XHRcdHRoaXMuc3RhcnRDb2xvciA9IHRoaXMuc3RhcnRTY2FsZSA9IHRoaXMuc3RhcnRBbHBoYSA9IHRoaXMuc3RhcnRTcGVlZCA9XG5cdFx0XHR0aGlzLmN1c3RvbUVhc2UgPSB0aGlzLl9jb21wbGV0ZUNhbGxiYWNrID0gbnVsbDtcblx0fVxufVxuIiwiaW1wb3J0IHtQYXJ0aWNsZVV0aWxzfSBmcm9tIFwiLi9QYXJ0aWNsZVV0aWxzXCI7XG5pbXBvcnQge1BhcnRpY2xlfSBmcm9tIFwiLi9QYXJ0aWNsZVwiO1xuaW1wb3J0IHtFbWl0dGVyfSBmcm9tIFwiLi9FbWl0dGVyXCI7XG5pbXBvcnQge1BvaW50LCBUZXh0dXJlfSBmcm9tIFwicGl4aS5qc1wiO1xuXG4vKipcbiAqIEEgaGVscGVyIHBvaW50IGZvciBtYXRoIHRoaW5ncy5cbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgaGVscGVyUG9pbnQgPSBuZXcgUG9pbnQoKTtcblxuLyoqXG4gKiBBIGhhbmQgcGlja2VkIGxpc3Qgb2YgTWF0aCBmdW5jdGlvbnMgKGFuZCBhIGNvdXBsZSBwcm9wZXJ0aWVzKSB0aGF0IGFyZVxuICogYWxsb3dhYmxlLiBUaGV5IHNob3VsZCBiZSB1c2VkIHdpdGhvdXQgdGhlIHByZWNlZGluZyBcIk1hdGguXCJcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgTUFUSF9GVU5DUyA9XG5bXG5cdFwicG93XCIsXG5cdFwic3FydFwiLFxuXHRcImFic1wiLFxuXHRcImZsb29yXCIsXG5cdFwicm91bmRcIixcblx0XCJjZWlsXCIsXG5cdFwiRVwiLFxuXHRcIlBJXCIsXG5cdFwic2luXCIsXG5cdFwiY29zXCIsXG5cdFwidGFuXCIsXG5cdFwiYXNpblwiLFxuXHRcImFjb3NcIixcblx0XCJhdGFuXCIsXG5cdFwiYXRhbjJcIixcblx0XCJsb2dcIlxuXTtcbi8qKlxuICogY3JlYXRlIGFuIGFjdHVhbCByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZyb20gdGhlIHN0cmluZ1xuICogQGhpZGRlblxuICovXG5jb25zdCBXSElURUxJU1RFUiA9IG5ldyBSZWdFeHAoXG5cdFtcblx0XHQvL0FsbG93IHRoZSA0IGJhc2ljIG9wZXJhdGlvbnMsIHBhcmVudGhlc2VzIGFuZCBhbGwgbnVtYmVycy9kZWNpbWFscywgYXMgd2VsbFxuXHRcdC8vYXMgJ3gnLCBmb3IgdGhlIHZhcmlhYmxlIHVzYWdlLlxuXHRcdFwiWzAxMjM0NTY3ODkwXFxcXC5cXFxcKlxcXFwtXFxcXCtcXFxcL1xcXFwoXFxcXCl4ICxdXCIsXG5cdF0uY29uY2F0KE1BVEhfRlVOQ1MpLmpvaW4oXCJ8XCIpLFxuXHRcImdcIlxuKTtcblxuLyoqXG4gKiBQYXJzZXMgYSBzdHJpbmcgaW50byBhIGZ1bmN0aW9uIGZvciBwYXRoIGZvbGxvd2luZy5cbiAqIFRoaXMgaW52b2x2ZXMgd2hpdGVsaXN0aW5nIHRoZSBzdHJpbmcgZm9yIHNhZmV0eSwgaW5zZXJ0aW5nIFwiTWF0aC5cIiB0byBtYXRoIGZ1bmN0aW9uXG4gKiBuYW1lcywgYW5kIHVzaW5nIGBuZXcgRnVuY3Rpb24oKWAgdG8gZ2VuZXJhdGUgYSBmdW5jdGlvbi5cbiAqIEBoaWRkZW5cbiAqIEBwYXJhbSBwYXRoU3RyaW5nIFRoZSBzdHJpbmcgdG8gcGFyc2UuXG4gKiBAcmV0dXJuIFRoZSBwYXRoIGZ1bmN0aW9uIC0gdGFrZXMgeCwgb3V0cHV0cyB5LlxuICovXG5jb25zdCBwYXJzZVBhdGggPSBmdW5jdGlvbihwYXRoU3RyaW5nOiBzdHJpbmcpXG57XG5cdGxldCBtYXRjaGVzID0gcGF0aFN0cmluZy5tYXRjaChXSElURUxJU1RFUik7XG5cdGZvcihsZXQgaSA9IG1hdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXG5cdHtcblx0XHRpZihNQVRIX0ZVTkNTLmluZGV4T2YobWF0Y2hlc1tpXSkgPj0gMClcblx0XHRcdG1hdGNoZXNbaV0gPSBcIk1hdGguXCIgKyBtYXRjaGVzW2ldO1xuXHR9XG5cdHBhdGhTdHJpbmcgPSBtYXRjaGVzLmpvaW4oXCJcIik7XG5cdHJldHVybiBuZXcgRnVuY3Rpb24oXCJ4XCIsIFwicmV0dXJuIFwiKyBwYXRoU3RyaW5nICsgXCI7XCIpO1xufTtcblxuLyoqXG4gKiBBbiBwYXJ0aWNsZSB0aGF0IGZvbGxvd3MgYSBwYXRoIGRlZmluZWQgYnkgYW4gYWxnZWJyYWljIGV4cHJlc3Npb24sIGUuZy4gXCJzaW4oeClcIiBvclxuICogXCI1eCArIDNcIi5cbiAqIFRvIHVzZSB0aGlzIGNsYXNzLCB0aGUgcGFydGljbGUgY29uZmlnIG11c3QgaGF2ZSBhIFwicGF0aFwiIHN0cmluZyBpbiB0aGVcbiAqIFwiZXh0cmFEYXRhXCIgcGFyYW1ldGVyLiBUaGlzIHN0cmluZyBzaG91bGQgaGF2ZSBcInhcIiBpbiBpdCB0byByZXByZXNlbnQgbW92ZW1lbnQgKGZyb20gdGhlXG4gKiBzcGVlZCBzZXR0aW5ncyBvZiB0aGUgcGFydGljbGUpLiBJdCBtYXkgaGF2ZSBudW1iZXJzLCBwYXJlbnRoZXNlcywgdGhlIGZvdXIgYmFzaWNcbiAqIG9wZXJhdGlvbnMsIGFuZCB0aGUgZm9sbG93aW5nIE1hdGggZnVuY3Rpb25zIG9yIHByb3BlcnRpZXMgKHdpdGhvdXQgdGhlIHByZWNlZGluZyBcIk1hdGguXCIpOlxuICogXCJwb3dcIiwgXCJzcXJ0XCIsIFwiYWJzXCIsIFwiZmxvb3JcIiwgXCJyb3VuZFwiLCBcImNlaWxcIiwgXCJFXCIsIFwiUElcIiwgXCJzaW5cIiwgXCJjb3NcIiwgXCJ0YW5cIiwgXCJhc2luXCIsXG4gKiBcImFjb3NcIiwgXCJhdGFuXCIsIFwiYXRhbjJcIiwgXCJsb2dcIi5cbiAqIFRoZSBvdmVyYWxsIG1vdmVtZW50IG9mIHRoZSBwYXJ0aWNsZSBhbmQgdGhlIGV4cHJlc3Npb24gdmFsdWUgYmVjb21lIHggYW5kIHkgcG9zaXRpb25zIGZvclxuICogdGhlIHBhcnRpY2xlLCByZXNwZWN0aXZlbHkuIFRoZSBmaW5hbCBwb3NpdGlvbiBpcyByb3RhdGVkIGJ5IHRoZSBzcGF3biByb3RhdGlvbi9hbmdsZSBvZlxuICogdGhlIHBhcnRpY2xlLlxuICpcbiAqIFNvbWUgZXhhbXBsZSBwYXRoczpcbiAqXG4gKiBcdFwic2luKHgvMTApICogMjBcIiAvLyBBIHNpbmUgd2F2ZSBwYXRoLlxuICogXHRcImNvcyh4LzEwMCkgKiAzMFwiIC8vIFBhcnRpY2xlcyBjdXJ2ZSBjb3VudGVyY2xvY2t3aXNlIChmb3IgbWVkaXVtIHNwZWVkL2xvdyBsaWZldGltZSBwYXJ0aWNsZXMpXG4gKiBcdFwicG93KHgvMTAsIDIpIC8gMlwiIC8vIFBhcnRpY2xlcyBjdXJ2ZSBjbG9ja3dpc2UgKHJlbWVtYmVyLCAreSBpcyBkb3duKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhdGhQYXJ0aWNsZSBleHRlbmRzIFBhcnRpY2xlXG57XG5cdC8qKlxuXHQgKiBUaGUgZnVuY3Rpb24gcmVwcmVzZW50aW5nIHRoZSBwYXRoIHRoZSBwYXJ0aWNsZSBzaG91bGQgdGFrZS5cblx0ICovXG5cdHB1YmxpYyBwYXRoOiBGdW5jdGlvbjtcblx0LyoqXG5cdCAqIFRoZSBpbml0aWFsIHJvdGF0aW9uIGluIGRlZ3JlZXMgb2YgdGhlIHBhcnRpY2xlLCBiZWNhdXNlIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHBhdGhcblx0ICogaXMgYmFzZWQgb24gdGhhdC5cblx0ICovXG5cdHB1YmxpYyBpbml0aWFsUm90YXRpb246IG51bWJlcjtcblx0LyoqXG5cdCAqIFRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBwYXJ0aWNsZSwgYXMgYWxsIHBhdGggbW92ZW1lbnQgaXMgYWRkZWQgdG8gdGhhdC5cblx0ICovXG5cdHB1YmxpYyBpbml0aWFsUG9zaXRpb246IFBvaW50O1xuXHQvKipcblx0ICogVG90YWwgc2luZ2xlIGRpcmVjdGlvbmFsIG1vdmVtZW50LCBkdWUgdG8gc3BlZWQuXG5cdCAqL1xuXHRwdWJsaWMgbW92ZW1lbnQ6IG51bWJlcjtcblx0XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1BJWEkucGFydGljbGVzLkVtaXR0ZXJ9IGVtaXR0ZXIgVGhlIGVtaXR0ZXIgdGhhdCBjb250cm9scyB0aGlzIFBhdGhQYXJ0aWNsZS5cblx0ICovXG5cdGNvbnN0cnVjdG9yKGVtaXR0ZXI6IEVtaXR0ZXIpXG5cdHtcblx0XHRzdXBlcihlbWl0dGVyKTtcblx0XHR0aGlzLnBhdGggPSBudWxsO1xuXHRcdHRoaXMuaW5pdGlhbFJvdGF0aW9uID0gMDtcblx0XHR0aGlzLmluaXRpYWxQb3NpdGlvbiA9IG5ldyBQb2ludCgpO1xuXHRcdHRoaXMubW92ZW1lbnQgPSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRoZSBwYXJ0aWNsZSBmb3IgdXNlLCBiYXNlZCBvbiB0aGUgcHJvcGVydGllcyB0aGF0IGhhdmUgdG9cblx0ICogaGF2ZSBiZWVuIHNldCBhbHJlYWR5IG9uIHRoZSBwYXJ0aWNsZS5cblx0ICovXG5cdHB1YmxpYyBpbml0KClcblx0e1xuXHRcdC8vZ2V0IGluaXRpYWwgcm90YXRpb24gYmVmb3JlIGl0IGlzIGNvbnZlcnRlZCB0byByYWRpYW5zXG5cdFx0dGhpcy5pbml0aWFsUm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuXHRcdC8vc3RhbmRhcmQgaW5pdFxuXHRcdHRoaXMuUGFydGljbGVfaW5pdCgpO1xuXG5cdFx0Ly9zZXQgdGhlIHBhdGggZm9yIHRoZSBwYXJ0aWNsZVxuXHRcdHRoaXMucGF0aCA9IHRoaXMuZXh0cmFEYXRhLnBhdGg7XG5cdFx0Ly9jYW5jZWwgdGhlIG5vcm1hbCBtb3ZlbWVudCBiZWhhdmlvclxuXHRcdHRoaXMuX2RvTm9ybWFsTW92ZW1lbnQgPSAhdGhpcy5wYXRoO1xuXHRcdC8vcmVzZXQgbW92ZW1lbnRcblx0XHR0aGlzLm1vdmVtZW50ID0gMDtcblx0XHQvL2dyYWIgcG9zaXRpb25cblx0XHR0aGlzLmluaXRpYWxQb3NpdGlvbi54ID0gdGhpcy5wb3NpdGlvbi54O1xuXHRcdHRoaXMuaW5pdGlhbFBvc2l0aW9uLnkgPSB0aGlzLnBvc2l0aW9uLnk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgcGFydGljbGUuXG5cdCAqIEBwYXJhbSBkZWx0YSBUaW1lIGVsYXBzZWQgc2luY2UgdGhlIHByZXZpb3VzIGZyYW1lLCBpbiBfX3NlY29uZHNfXy5cblx0ICovXG5cdHB1YmxpYyB1cGRhdGUoZGVsdGE6IG51bWJlcik6IG51bWJlclxuXHR7XG5cdFx0Y29uc3QgbGVycCA9IHRoaXMuUGFydGljbGVfdXBkYXRlKGRlbHRhKTtcblx0XHQvL2lmIHRoZSBwYXJ0aWNsZSBkaWVkIGR1cmluZyB0aGUgdXBkYXRlLCB0aGVuIGRvbid0IGJvdGhlclxuXHRcdGlmKGxlcnAgPj0gMCAmJiB0aGlzLnBhdGgpXG5cdFx0e1xuXHRcdFx0Ly9pbmNyZWFzZSBsaW5lYXIgbW92ZW1lbnQgYmFzZWQgb24gc3BlZWRcblx0XHRcdGNvbnN0IHNwZWVkID0gdGhpcy5zcGVlZExpc3QuaW50ZXJwb2xhdGUobGVycCkgKiB0aGlzLnNwZWVkTXVsdGlwbGllcjtcblx0XHRcdHRoaXMubW92ZW1lbnQgKz0gc3BlZWQgKiBkZWx0YTtcblx0XHRcdC8vc2V0IHVwIHRoZSBoZWxwZXIgcG9pbnQgZm9yIHJvdGF0aW9uXG5cdFx0XHRoZWxwZXJQb2ludC54ID0gdGhpcy5tb3ZlbWVudDtcblx0XHRcdGhlbHBlclBvaW50LnkgPSB0aGlzLnBhdGgodGhpcy5tb3ZlbWVudCk7XG5cdFx0XHRQYXJ0aWNsZVV0aWxzLnJvdGF0ZVBvaW50KHRoaXMuaW5pdGlhbFJvdGF0aW9uLCBoZWxwZXJQb2ludCk7XG5cdFx0XHR0aGlzLnBvc2l0aW9uLnggPSB0aGlzLmluaXRpYWxQb3NpdGlvbi54ICsgaGVscGVyUG9pbnQueDtcblx0XHRcdHRoaXMucG9zaXRpb24ueSA9IHRoaXMuaW5pdGlhbFBvc2l0aW9uLnkgKyBoZWxwZXJQb2ludC55O1xuXHRcdH1cblx0XHRyZXR1cm4gbGVycDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIERlc3Ryb3lzIHRoZSBwYXJ0aWNsZSwgcmVtb3ZpbmcgcmVmZXJlbmNlcyBhbmQgcHJldmVudGluZyBmdXR1cmUgdXNlLlxuXHQgKi9cblx0cHVibGljIGRlc3Ryb3koKVxuXHR7XG5cdFx0dGhpcy5QYXJ0aWNsZV9kZXN0cm95KCk7XG5cdFx0dGhpcy5wYXRoID0gdGhpcy5pbml0aWFsUG9zaXRpb24gPSBudWxsO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBvdmVyIHRoZSBhcnQgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSBFbWl0dGVyJ3MgaW5pdCgpIGZ1bmN0aW9uLCB0byBkbyBhbnkgc3BlY2lhbFxuXHQgKiBtb2RpZmljYXRpb25zIHRvIHByZXBhcmUgaXQgYWhlYWQgb2YgdGltZS4gVGhpcyBqdXN0IHJ1bnMgUGFydGljbGUucGFyc2VBcnQoKS5cblx0ICogQHBhcmFtIGFydCBUaGUgYXJyYXkgb2YgYXJ0IGRhdGEuIEZvciBQYXJ0aWNsZSwgaXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mXG5cdCAqICAgICAgICAgICAgVGV4dHVyZXMuIEFueSBzdHJpbmdzIGluIHRoZSBhcnJheSB3aWxsIGJlIGNvbnZlcnRlZCB0b1xuXHQgKiAgICAgICAgICAgIFRleHR1cmVzIHZpYSBUZXh0dXJlLmZyb21JbWFnZSgpLlxuXHQgKiBAcmV0dXJuIFRoZSBhcnQsIGFmdGVyIGFueSBuZWVkZWQgbW9kaWZpY2F0aW9ucy5cblx0ICovXG5cdHB1YmxpYyBzdGF0aWMgcGFyc2VBcnQoYXJ0OiAoVGV4dHVyZXxzdHJpbmcpW10pOlRleHR1cmVbXVxuXHR7XG5cdFx0cmV0dXJuIFBhcnRpY2xlLnBhcnNlQXJ0KGFydCk7XG5cdH1cblxuXHQvKipcblx0ICogUGFyc2VzIGV4dHJhIGVtaXR0ZXIgZGF0YSB0byBlbnN1cmUgaXQgaXMgc2V0IHVwIGZvciB0aGlzIHBhcnRpY2xlIGNsYXNzLlxuXHQgKiBQYXRoUGFydGljbGUgY2hlY2tzIGZvciB0aGUgZXhpc3RlbmNlIG9mIHBhdGggZGF0YSwgYW5kIHBhcnNlcyB0aGUgcGF0aCBkYXRhIGZvciB1c2Vcblx0ICogYnkgcGFydGljbGUgaW5zdGFuY2VzLlxuXHQgKiBAcGFyYW0gZXh0cmFEYXRhIFRoZSBleHRyYSBkYXRhIGZyb20gdGhlIHBhcnRpY2xlIGNvbmZpZy5cblx0ICogQHJldHVybiBUaGUgcGFyc2VkIGV4dHJhIGRhdGEuXG5cdCAqL1xuXHRwdWJsaWMgc3RhdGljIHBhcnNlRGF0YShleHRyYURhdGE6IHtwYXRoOnN0cmluZ30pXG5cdHtcblx0XHRsZXQgb3V0cHV0OiBhbnkgPSB7fTtcblx0XHRpZihleHRyYURhdGEgJiYgZXh0cmFEYXRhLnBhdGgpXG5cdFx0e1xuXHRcdFx0dHJ5XG5cdFx0XHR7XG5cdFx0XHRcdG91dHB1dC5wYXRoID0gcGFyc2VQYXRoKGV4dHJhRGF0YS5wYXRoKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoKGUpXG5cdFx0XHR7XG5cdFx0XHRcdGlmKFBhcnRpY2xlVXRpbHMudmVyYm9zZSlcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiUGF0aFBhcnRpY2xlOiBlcnJvciBpbiBwYXJzaW5nIHBhdGggZXhwcmVzc2lvblwiKTtcblx0XHRcdFx0b3V0cHV0LnBhdGggPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0aWYoUGFydGljbGVVdGlscy52ZXJib3NlKVxuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiUGF0aFBhcnRpY2xlIHJlcXVpcmVzIGEgcGF0aCBzdHJpbmcgaW4gZXh0cmFEYXRhIVwiKTtcblx0XHRcdG91dHB1dC5wYXRoID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxufSIsImltcG9ydCB7UGFydGljbGV9IGZyb20gXCIuL1BhcnRpY2xlXCI7XG5pbXBvcnQge0VtaXR0ZXJ9IGZyb20gXCIuL0VtaXR0ZXJcIjtcbmltcG9ydCB7R2V0VGV4dHVyZUZyb21TdHJpbmd9IGZyb20gXCIuL1BhcnRpY2xlVXRpbHNcIjtcbmltcG9ydCB7VGV4dHVyZX0gZnJvbSBcInBpeGkuanNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRBbmltYXRlZFBhcnRpY2xlQXJ0XG57XG5cdHRleHR1cmVzOiBUZXh0dXJlW107XG5cdGR1cmF0aW9uOiBudW1iZXI7XG5cdGZyYW1lcmF0ZTogbnVtYmVyO1xuXHRsb29wOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFuaW1hdGVkUGFydGljbGVBcnRcbntcblx0ZnJhbWVyYXRlOiBcIm1hdGNoTGlmZVwifG51bWJlcjtcblx0bG9vcD86IGJvb2xlYW47XG5cdHRleHR1cmVzOiAoc3RyaW5nfFRleHR1cmV8e3RleHR1cmU6c3RyaW5nfFRleHR1cmUsY291bnQ6bnVtYmVyfSlbXTtcbn1cblxuLyoqXG4gKiBBbiBpbmRpdmlkdWFsIHBhcnRpY2xlIGltYWdlIHdpdGggYW4gYW5pbWF0aW9uLiBBcnQgZGF0YSBwYXNzZWQgdG8gdGhlIGVtaXR0ZXIgbXVzdCBiZVxuICogZm9ybWF0dGVkIGluIGEgcGFydGljdWxhciB3YXkgZm9yIEFuaW1hdGVkUGFydGljbGUgdG8gYmUgYWJsZSB0byBoYW5kbGUgaXQ6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICoge1xuICogICAgIC8vZnJhbWVyYXRlIGlzIHJlcXVpcmVkLiBJdCBpcyB0aGUgYW5pbWF0aW9uIHNwZWVkIG9mIHRoZSBwYXJ0aWNsZSBpbiBmcmFtZXMgcGVyXG4gKiAgICAgLy9zZWNvbmQuXG4gKiAgICAgLy9BIHZhbHVlIG9mIFwibWF0Y2hMaWZlXCIgY2F1c2VzIHRoZSBhbmltYXRpb24gdG8gbWF0Y2ggdGhlIGxpZmV0aW1lIG9mIGFuIGluZGl2aWR1YWxcbiAqICAgICAvL3BhcnRpY2xlLCBpbnN0ZWFkIG9mIGF0IGEgY29uc3RhbnQgZnJhbWVyYXRlLiBUaGlzIGNhdXNlcyB0aGUgYW5pbWF0aW9uIHRvIHBsYXlcbiAqICAgICAvL3Rocm91Z2ggb25lIHRpbWUsIGNvbXBsZXRpbmcgd2hlbiB0aGUgcGFydGljbGUgZXhwaXJlcy5cbiAqICAgICBmcmFtZXJhdGU6IDYsXG4gKiAgICAgLy9sb29wIGlzIG9wdGlvbmFsLCBhbmQgZGVmYXVsdHMgdG8gZmFsc2UuXG4gKiAgICAgbG9vcDogdHJ1ZSxcbiAqICAgICAvL3RleHR1cmVzIGlzIHJlcXVpcmVkLCBhbmQgY2FuIGJlIGFuIGFycmF5IG9mIGFueSAobm9uLXplcm8pIGxlbmd0aC5cbiAqICAgICB0ZXh0dXJlczogW1xuICogICAgICAgICAvL2VhY2ggZW50cnkgcmVwcmVzZW50cyBhIHNpbmdsZSB0ZXh0dXJlIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIG9uZSBvciBtb3JlXG4gKiAgICAgICAgIC8vZnJhbWVzLiBBbnkgc3RyaW5ncyB3aWxsIGJlIGNvbnZlcnRlZCB0byBUZXh0dXJlcyB3aXRoIFRleHR1cmUuZnJvbSgpLlxuICogICAgICAgICAvL0luc3RhbmNlcyBvZiBQSVhJLlRleHR1cmUgd2lsbCBiZSB1c2VkIGRpcmVjdGx5LlxuICogICAgICAgICBcImFuaW1GcmFtZTEucG5nXCIsXG4gKiAgICAgICAgIC8vZW50cmllcyBjYW4gYmUgYW4gb2JqZWN0IHdpdGggYSAnY291bnQnIHByb3BlcnR5LCB0ZWxsaW5nIEFuaW1hdGVkUGFydGljbGUgdG9cbiAqICAgICAgICAgLy91c2UgdGhhdCB0ZXh0dXJlIGZvciAnY291bnQnIGZyYW1lcyBzZXF1ZW50aWFsbHkuXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICAgIHRleHR1cmU6IFwiYW5pbUZyYW1lMi5wbmdcIixcbiAqICAgICAgICAgICAgIGNvdW50OiAzXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIFwiYW5pbUZyYW1lMy5wbmdcIlxuICogICAgIF1cbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQW5pbWF0ZWRQYXJ0aWNsZSBleHRlbmRzIFBhcnRpY2xlXG57XG5cdC8qKlxuXHQgKiBUZXh0dXJlIGFycmF5IHVzZWQgYXMgZWFjaCBmcmFtZSBvZiBhbmltYXRpb24sIHNpbWlsYXJseSB0byBob3cgTW92aWVDbGlwIHdvcmtzLlxuXHQgKi9cblx0cHJpdmF0ZSB0ZXh0dXJlczogVGV4dHVyZVtdO1xuXG5cdC8qKlxuXHQgKiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLCBpbiBzZWNvbmRzLlxuXHQgKi9cblx0cHJpdmF0ZSBkdXJhdGlvbjogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBBbmltYXRpb24gZnJhbWVyYXRlLCBpbiBmcmFtZXMgcGVyIHNlY29uZC5cblx0ICovXG5cdHByaXZhdGUgZnJhbWVyYXRlOiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIEFuaW1hdGlvbiB0aW1lIGVsYXBzZWQsIGluIHNlY29uZHMuXG5cdCAqL1xuXHRwcml2YXRlIGVsYXBzZWQ6IG51bWJlcjtcblxuXHQvKipcblx0ICogSWYgdGhpcyBwYXJ0aWNsZSBhbmltYXRpb24gc2hvdWxkIGxvb3AuXG5cdCAqL1xuXHRwcml2YXRlIGxvb3A6IGJvb2xlYW47XG5cdFxuXHQvKipcblx0ICogQHBhcmFtIGVtaXR0ZXIgVGhlIGVtaXR0ZXIgdGhhdCBjb250cm9scyB0aGlzIEFuaW1hdGVkUGFydGljbGUuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihlbWl0dGVyOiBFbWl0dGVyKVxuXHR7XG5cdFx0c3VwZXIoZW1pdHRlcik7XG5cblx0XHR0aGlzLnRleHR1cmVzID0gbnVsbDtcblx0XHR0aGlzLmR1cmF0aW9uID0gMDtcblx0XHR0aGlzLmZyYW1lcmF0ZSA9IDA7XG5cdFx0dGhpcy5lbGFwc2VkID0gMDtcblx0XHR0aGlzLmxvb3AgPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgcGFydGljbGUgZm9yIHVzZSwgYmFzZWQgb24gdGhlIHByb3BlcnRpZXMgdGhhdCBoYXZlIHRvXG5cdCAqIGhhdmUgYmVlbiBzZXQgYWxyZWFkeSBvbiB0aGUgcGFydGljbGUuXG5cdCAqL1xuXHRwdWJsaWMgaW5pdCgpXG5cdHtcblx0XHR0aGlzLlBhcnRpY2xlX2luaXQoKTtcblxuXHRcdHRoaXMuZWxhcHNlZCA9IDA7XG5cblx0XHQvL2lmIHRoZSBhbmltYXRpb24gbmVlZHMgdG8gbWF0Y2ggdGhlIHBhcnRpY2xlJ3MgbGlmZSwgdGhlbiBjYWNsdWF0ZSB2YXJpYWJsZXNcblx0XHRpZih0aGlzLmZyYW1lcmF0ZSA8IDApXG5cdFx0e1xuXHRcdFx0dGhpcy5kdXJhdGlvbiA9IHRoaXMubWF4TGlmZTtcblx0XHRcdHRoaXMuZnJhbWVyYXRlID0gdGhpcy50ZXh0dXJlcy5sZW5ndGggLyB0aGlzLmR1cmF0aW9uO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB0ZXh0dXJlcyBmb3IgdGhlIHBhcnRpY2xlLlxuXHQgKiBAcGFyYW0gYXJ0IEFuIGFycmF5IG9mIFBJWEkuVGV4dHVyZSBvYmplY3RzIGZvciB0aGlzIGFuaW1hdGVkIHBhcnRpY2xlLlxuXHQgKi9cblx0cHVibGljIGFwcGx5QXJ0KGFydDogUGFyc2VkQW5pbWF0ZWRQYXJ0aWNsZUFydClcblx0e1xuXHRcdHRoaXMudGV4dHVyZXMgPSBhcnQudGV4dHVyZXM7XG5cdFx0dGhpcy5mcmFtZXJhdGUgPSBhcnQuZnJhbWVyYXRlO1xuXHRcdHRoaXMuZHVyYXRpb24gPSBhcnQuZHVyYXRpb247XG5cdFx0dGhpcy5sb29wID0gYXJ0Lmxvb3A7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgcGFydGljbGUuXG5cdCAqIEBwYXJhbSBkZWx0YSBUaW1lIGVsYXBzZWQgc2luY2UgdGhlIHByZXZpb3VzIGZyYW1lLCBpbiBfX3NlY29uZHNfXy5cblx0ICovXG5cdHB1YmxpYyB1cGRhdGUoZGVsdGE6IG51bWJlcik6IG51bWJlclxuXHR7XG5cdFx0Y29uc3QgbGVycCA9IHRoaXMuUGFydGljbGVfdXBkYXRlKGRlbHRhKTtcblx0XHQvL29ubHkgYW5pbWF0ZSB0aGUgcGFydGljbGUgaWYgaXQgaXMgc3RpbGwgYWxpdmVcblx0XHRpZihsZXJwID49IDApXG5cdFx0e1xuXHRcdFx0dGhpcy5lbGFwc2VkICs9IGRlbHRhO1xuXHRcdFx0aWYodGhpcy5lbGFwc2VkID4gdGhpcy5kdXJhdGlvbilcblx0XHRcdHtcblx0XHRcdFx0Ly9sb29wIGVsYXBzZWQgYmFjayBhcm91bmRcblx0XHRcdFx0aWYodGhpcy5sb29wKVxuXHRcdFx0XHRcdHRoaXMuZWxhcHNlZCA9IHRoaXMuZWxhcHNlZCAlIHRoaXMuZHVyYXRpb247XG5cdFx0XHRcdC8vc3VidHJhY3QgYSBzbWFsbCBhbW91bnQgdG8gcHJldmVudCBhdHRlbXB0aW5nIHRvIGdvIHBhc3QgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHR0aGlzLmVsYXBzZWQgPSB0aGlzLmR1cmF0aW9uIC0gMC4wMDAwMDE7XG5cdFx0XHR9XG5cdFx0XHQvLyBhZGQgYSB2ZXJ5IHNtYWxsIG51bWJlciB0byB0aGUgZnJhbWUgYW5kIHRoZW4gZmxvb3IgaXQgdG8gYXZvaWRcblx0XHRcdC8vIHRoZSBmcmFtZSBiZWluZyBvbmUgc2hvcnQgZHVlIHRvIGZsb2F0aW5nIHBvaW50IGVycm9ycy5cblx0XHRcdGxldCBmcmFtZSA9ICh0aGlzLmVsYXBzZWQgKiB0aGlzLmZyYW1lcmF0ZSArIDAuMDAwMDAwMSkgfCAwO1xuXHRcdFx0dGhpcy50ZXh0dXJlID0gdGhpcy50ZXh0dXJlc1tmcmFtZV0gfHwgVGV4dHVyZS5FTVBUWTtcblx0XHR9XG5cdFx0cmV0dXJuIGxlcnA7XG5cdH1cblxuXHQvKipcblx0ICogRGVzdHJveXMgdGhlIHBhcnRpY2xlLCByZW1vdmluZyByZWZlcmVuY2VzIGFuZCBwcmV2ZW50aW5nIGZ1dHVyZSB1c2UuXG5cdCAqL1xuXHRwdWJsaWMgZGVzdHJveSgpXG5cdHtcblx0XHR0aGlzLlBhcnRpY2xlX2Rlc3Ryb3koKTtcblx0XHR0aGlzLnRleHR1cmVzID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3Mgb3ZlciB0aGUgYXJ0IHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgRW1pdHRlcidzIGluaXQoKSBmdW5jdGlvbiwgdG8gZG8gYW55IHNwZWNpYWxcblx0ICogbW9kaWZpY2F0aW9ucyB0byBwcmVwYXJlIGl0IGFoZWFkIG9mIHRpbWUuXG5cdCAqIEBwYXJhbSBhcnQgVGhlIGFycmF5IG9mIGFydCBkYXRhLCBwcm9wZXJseSBmb3JtYXR0ZWQgZm9yIEFuaW1hdGVkUGFydGljbGUuXG5cdCAqIEByZXR1cm4gVGhlIGFydCwgYWZ0ZXIgYW55IG5lZWRlZCBtb2RpZmljYXRpb25zLlxuXHQgKi9cblx0cHVibGljIHN0YXRpYyBwYXJzZUFydChhcnQ6IEFuaW1hdGVkUGFydGljbGVBcnRbXSlcblx0e1xuXHRcdGxldCBkYXRhLCBvdXRwdXQ6IGFueSwgdGV4dHVyZXMsIHRleCwgb3V0VGV4dHVyZXM7XG5cdFx0bGV0IG91dEFycjpQYXJzZWRBbmltYXRlZFBhcnRpY2xlQXJ0W10gPSBbXTtcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgYXJ0Lmxlbmd0aDsgKytpKVxuXHRcdHtcblx0XHRcdGRhdGEgPSBhcnRbaV07XG5cdFx0XHRvdXRBcnJbaV0gPSBvdXRwdXQgPSB7fSBhcyBQYXJzZWRBbmltYXRlZFBhcnRpY2xlQXJ0O1xuXHRcdFx0b3V0cHV0LnRleHR1cmVzID0gb3V0VGV4dHVyZXMgPSBbXTtcblx0XHRcdHRleHR1cmVzID0gZGF0YS50ZXh0dXJlcztcblx0XHRcdGZvcihsZXQgaiA9IDA7IGogPCB0ZXh0dXJlcy5sZW5ndGg7ICsrailcblx0XHRcdHtcblx0XHRcdFx0dGV4ID0gdGV4dHVyZXNbal07XG5cdFx0XHRcdGlmKHR5cGVvZiB0ZXggPT0gXCJzdHJpbmdcIilcblx0XHRcdFx0XHRvdXRUZXh0dXJlcy5wdXNoKEdldFRleHR1cmVGcm9tU3RyaW5nKHRleCkpO1xuXHRcdFx0XHRlbHNlIGlmKHRleCBpbnN0YW5jZW9mIFRleHR1cmUpXG5cdFx0XHRcdFx0b3V0VGV4dHVyZXMucHVzaCh0ZXgpO1xuXHRcdFx0XHQvL2Fzc3VtZSBhbiBvYmplY3Qgd2l0aCBleHRyYSBkYXRhIGRldGVybWluaW5nIGR1cGxpY2F0ZSBmcmFtZSBkYXRhXG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxldCBkdXBlID0gdGV4LmNvdW50IHx8IDE7XG5cdFx0XHRcdFx0aWYodHlwZW9mIHRleC50ZXh0dXJlID09IFwic3RyaW5nXCIpXG5cdFx0XHRcdFx0XHR0ZXggPSBHZXRUZXh0dXJlRnJvbVN0cmluZyh0ZXgudGV4dHVyZSk7XG5cdFx0XHRcdFx0ZWxzZS8vIGlmKHRleC50ZXh0dXJlIGluc3RhbmNlb2YgVGV4dHVyZSlcblx0XHRcdFx0XHRcdHRleCA9IHRleC50ZXh0dXJlO1xuXHRcdFx0XHRcdGZvcig7IGR1cGUgPiAwOyAtLWR1cGUpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0b3V0VGV4dHVyZXMucHVzaCh0ZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL3VzZSB0aGVzZSB2YWx1ZXMgdG8gc2lnbmlmeSB0aGF0IHRoZSBhbmltYXRpb24gc2hvdWxkIG1hdGNoIHRoZSBwYXJ0aWNsZSBsaWZlIHRpbWUuXG5cdFx0XHRpZihkYXRhLmZyYW1lcmF0ZSA9PSBcIm1hdGNoTGlmZVwiKVxuXHRcdFx0e1xuXHRcdFx0XHQvLy0xIG1lYW5zIHRoYXQgaXQgc2hvdWxkIGJlIGNhbGN1bGF0ZWRcblx0XHRcdFx0b3V0cHV0LmZyYW1lcmF0ZSA9IC0xO1xuXHRcdFx0XHRvdXRwdXQuZHVyYXRpb24gPSAwO1xuXHRcdFx0XHRvdXRwdXQubG9vcCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHQvL2RldGVybWluZSBpZiB0aGUgYW5pbWF0aW9uIHNob3VsZCBsb29wXG5cdFx0XHRcdG91dHB1dC5sb29wID0gISFkYXRhLmxvb3A7XG5cdFx0XHRcdC8vZ2V0IHRoZSBmcmFtZXJhdGUsIGRlZmF1bHQgdG8gNjBcblx0XHRcdFx0b3V0cHV0LmZyYW1lcmF0ZSA9IGRhdGEuZnJhbWVyYXRlID4gMCA/IGRhdGEuZnJhbWVyYXRlIDogNjA7XG5cdFx0XHRcdC8vZGV0ZXJtaW5lIHRoZSBkdXJhdGlvblxuXHRcdFx0XHRvdXRwdXQuZHVyYXRpb24gPSBvdXRUZXh0dXJlcy5sZW5ndGggLyBvdXRwdXQuZnJhbWVyYXRlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvdXRBcnI7XG5cdH1cbn0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWFBOzs7QUFHQTs7Ozs7O0FBeUJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFZQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FDaEdBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFvQkE7QUFBQTs7OztBQUlBO0FBRUE7Ozs7OztBQU9BO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTs7Ozs7Ozs7QUFtQkE7QUFFQTtBQUNBO0FBSEE7Ozs7O0FBU0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOzs7Ozs7QUFZQTtBQUVBO0FBQ0E7QUFDQTtBQUpBOzs7Ozs7QUFXQTtBQUVBO0FBQ0E7QUFIQTs7Ozs7Ozs7O0FBYUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7Ozs7Ozs7OztBQThCQTtBQUVBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBOzs7Ozs7QUF5QkE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBOzs7Ozs7Ozs7QUFpQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFqQ0E7QUFrQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOU5BOzs7O0FBSUE7Ozs7QUFnQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbkpBOzs7QUFHQTtBQUFBOzs7O0FBcUlBO0FBQUE7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7Ozs7QUFNQTs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7OztBQU9BO0FBRUE7QUFDQTs7Ozs7Ozs7QUFTQTs7QUFHQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBRUE7OztBQUlBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFFQTtBQUNBOzs7O0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVVBOztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQTNaQTtBQUNBO0FDTUE7OztBQUdBOzs7O0FBbUJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUtBOztBQUdBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBR0E7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQU1BOztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQ2pJQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7O0FBVUE7Ozs7QUFLQTs7Ozs7Ozs7Ozs7OztBQWdSQTs7OztBQXhCQTtBQTBCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFIQTtBQVNBOzs7OztBQUFBO0FBQ0E7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFSQTtBQWNBOzs7Ozs7QUFBQTtBQUNBO0FBRUE7QUFFQTs7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBbEJBO0FBdUJBOzs7O0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBTEE7Ozs7OztBQVlBO0FBRUE7QUFDQTs7QUFFQTs7O0FBSUE7QUFDQTs7QUFHQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUVBOzs7Ozs7QUFPQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBTUE7QUFFQTtBQUFBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7O0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU9BO0FBRUE7QUFDQTtBQU1BOzs7OztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUxBO0FBV0E7Ozs7O0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQVpBOzs7Ozs7QUFtQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQU1BO0FBRUE7QUFDQTtBQUNBOzs7OztBQU1BO0FBRUE7QUFFQTtBQUNBOzs7QUFJQTtBQUFBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUdBOztBQUVBOztBQUdBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUlBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFHQTs7QUFHQTs7QUFHQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7Ozs7Ozs7O0FBU0E7OztBQUlBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQVNBOzs7QUFJQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBOzs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQVNBOzs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBU0E7OztBQUlBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBS0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUtBOztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUM1c0NBOzs7O0FBSUE7Ozs7OztBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7O0FBSUE7QUFDQTs7Ozs7Ozs7O0FBWUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUFBOzs7O0FBdUJBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7Ozs7QUFNQTs7QUFHQTs7QUFFQTs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFFQTs7QUFFQTs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBVUE7QUFFQTtBQUNBOzs7Ozs7OztBQVNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsSUE7QUFDQTtBQ3BFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQTtBQUFBOzs7O0FBOEJBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOzs7OztBQU1BO0FBRUE7QUFFQTs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFNQTtBQUVBOztBQUVBO0FBRUE7QUFDQTs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBS0E7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQXZLQTtBQUNBOzsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pixi-particles/lib/pixi-particles.es.js\n");

/***/ }),

/***/ "./node_modules/pixi-scenegraph/dist/index.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/pixi-scenegraph/dist/index.es.js ***!
  \*******************************************************/
/*! exports provided: DefaultScreenSizeCalculator, Scene, SceneManager, VERSION */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DefaultScreenSizeCalculator\", function() { return DefaultScreenSizeCalculator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SceneManager\", function() { return SceneManager; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return VERSION; });\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/lib/pixi.es.js\");\n\n\nvar DefaultScreenSizeCalculator = (function () {\r\n    function DefaultScreenSizeCalculator(designedWidth, designedHeight) {\r\n        this.designedWidth = designedWidth;\r\n        this.designedHeight = designedHeight;\r\n    }\r\n    DefaultScreenSizeCalculator.prototype.GetAvailableSize = function () {\r\n        return { x: window.innerWidth, y: window.innerHeight };\r\n    };\r\n    DefaultScreenSizeCalculator.prototype.GetAspectRatio = function () {\r\n        return this.designedWidth / this.designedHeight;\r\n    };\r\n    DefaultScreenSizeCalculator.prototype.CalculateSize = function (availableSize, aspect) {\r\n        var maxWidth = Math.floor(aspect * availableSize.y);\r\n        var maxHeight = Math.floor(window.innerHeight);\r\n        return { x: Math.min(maxWidth, availableSize.x), y: Math.min(maxHeight, availableSize.y) };\r\n    };\r\n    DefaultScreenSizeCalculator.prototype.CalculateScale = function (calculatedSize) {\r\n        return {\r\n            x: calculatedSize.x / this.designedWidth,\r\n            y: calculatedSize.x / this.designedWidth,\r\n        };\r\n    };\r\n    return DefaultScreenSizeCalculator;\r\n}());\n\nvar VERSION = '1.6.3';\n\nvar SceneManager = (function () {\r\n    function SceneManager(options, screenSizeCalculator) {\r\n        var _this = this;\r\n        this.currentScene = null;\r\n        this.scenes = [];\r\n        this.controllers = [];\r\n        this.animationFrameHandle = -1;\r\n        this.Destroy = function () {\r\n            cancelAnimationFrame(_this.animationFrameHandle);\r\n            if (_this.currentScene) {\r\n                _this.currentScene.pause();\r\n            }\r\n            _this.scenes.forEach(function (scene) {\r\n                _this.RemoveScene(scene);\r\n            });\r\n            _this.app.destroy(true, {\r\n                children: true,\r\n                texture: true,\r\n                baseTexture: true,\r\n            });\r\n        };\r\n        this.resizeHandler = function () {\r\n            _this.onResize(_this.screenSizeCalculator);\r\n        };\r\n        this.onRender = function (time) {\r\n            if (!_this.startTime) {\r\n                _this.startTime = Date.now();\r\n            }\r\n            _this.timeStamp = Date.now();\r\n            var dt = _this.timeStamp - _this.startTime;\r\n            if (dt > 50) {\r\n                dt = 50;\r\n            }\r\n            _this.controllers.forEach(function (ctrl) {\r\n                if (!ctrl.scope || (_this.currentScene && _this.currentScene.name === ctrl.scope)) {\r\n                    ctrl.update(dt, _this.currentScene);\r\n                }\r\n            });\r\n            if (!_this.currentScene || _this.currentScene.isPaused()) {\r\n                return;\r\n            }\r\n            _this.currentScene.onUpdate(dt, _this.timeStamp);\r\n            _this.startTime = _this.timeStamp;\r\n        };\r\n        SceneManager.logVersion();\r\n        this.masterContainer = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]();\r\n        this.app = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Application\"](options);\r\n        this.app.ticker.add(this.onRender, this);\r\n        this.app.stage = this.masterContainer;\r\n        this.designWidth = options.width || window.innerWidth;\r\n        this.designHeight = options.height || window.innerHeight;\r\n        this.screenSizeCalculator = screenSizeCalculator || new DefaultScreenSizeCalculator(this.designWidth, this.designHeight);\r\n        window.removeEventListener('resize', this.resizeHandler);\r\n        window.addEventListener('resize', this.resizeHandler, true);\r\n    }\r\n    SceneManager.logVersion = function () {\r\n        if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {\r\n            var fmtPurp = 'color:#fa1;background:#ff66a5;padding:5px 0;';\r\n            var fmtTxt = 'color:#fa1;background:#000;padding:5px 0;';\r\n            var fmtHearts = 'color:#f55;background:#ffc3dc;padding:5px 0;';\r\n            var args = [\r\n                \" %c  %c pixi-scenegraph: \" + VERSION + \" \\u2730  %c  %c https://github.com/enriko-riba/pixi-scenegraph#readme \\u2764\\u2764\\u2764\\t\",\r\n                fmtPurp,\r\n                fmtTxt,\r\n                fmtPurp,\r\n                fmtHearts,\r\n            ];\r\n            console.info.apply(console, args);\r\n        }\r\n        else if (window.console) {\r\n            console.info(\"pixi-scenegraph: \" + VERSION + \" \\u2730 https://github.com/enriko-riba/pixi-scenegraph#readme  \\u2764\\u2764\\u2764\");\r\n        }\r\n    };\r\n    Object.defineProperty(SceneManager.prototype, \"Renderer\", {\r\n        get: function () {\r\n            return this.app.renderer;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SceneManager.prototype, \"Application\", {\r\n        get: function () {\r\n            return this.app;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    SceneManager.prototype.AddController = function (controller) {\r\n        this.controllers.push(controller);\r\n    };\r\n    SceneManager.prototype.RemoveController = function (controllerOrId) {\r\n        var id = typeof controllerOrId !== 'string' ? controllerOrId.id : controllerOrId;\r\n        this.controllers = this.controllers.filter(function (ctrl) { return ctrl.id !== id; });\r\n    };\r\n    Object.defineProperty(SceneManager.prototype, \"CurrentScene\", {\r\n        get: function () {\r\n            return this.currentScene;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    SceneManager.prototype.AddScene = function (scene) {\r\n        this.scenes.push(scene);\r\n    };\r\n    SceneManager.prototype.RemoveAllScenes = function () {\r\n        this.scenes.forEach(function (scene) {\r\n            scene.onDestroy();\r\n            scene.destroy({ children: true, texture: true, baseTexture: true });\r\n        });\r\n        this.scenes = [];\r\n        this.currentScene = null;\r\n    };\r\n    SceneManager.prototype.RemoveScene = function (scene) {\r\n        this.scenes = this.scenes.filter(function (item, index, arr) {\r\n            return item !== scene;\r\n        });\r\n        scene.onDestroy();\r\n        scene.destroy({ children: true, texture: true, baseTexture: true });\r\n    };\r\n    SceneManager.prototype.HasScene = function (name) {\r\n        var found = this.scenes.filter(function (item) { return item.Name === name; });\r\n        return found && found.length > 0;\r\n    };\r\n    SceneManager.prototype.GetScene = function (name) {\r\n        var found = this.scenes.filter(function (item) { return item.Name === name; });\r\n        if (!found || found.length === 0) {\r\n            throw Error(\"Scene: '\" + name + \"' not found\");\r\n        }\r\n        if (found.length > 1) {\r\n            throw Error(\"Multiple scenes: '\" + name + \"' found\");\r\n        }\r\n        return found[0];\r\n    };\r\n    SceneManager.prototype.ActivateScene = function (sceneOrName) {\r\n        var scene;\r\n        if (typeof sceneOrName === 'string') {\r\n            var found = this.scenes.filter(function (item) { return item.Name === sceneOrName; });\r\n            if (!found || found.length === 0) {\r\n                throw Error(\"Scene: '\" + sceneOrName + \"' not found\");\r\n            }\r\n            if (found.length > 1) {\r\n                throw Error(\"Multiple scenes: '\" + sceneOrName + \"' found\");\r\n            }\r\n            scene = found[0];\r\n        }\r\n        else {\r\n            scene = sceneOrName;\r\n        }\r\n        if (this.currentScene && this.currentScene !== scene) {\r\n            console.log('DeactivateScene ' + this.currentScene.Name);\r\n            this.currentScene.onDeactivate();\r\n        }\r\n        console.log('ActivateScene ' + scene.Name);\r\n        this.startTime = 0;\r\n        this.lastScene = (this.currentScene !== scene ? this.currentScene : this.lastScene);\r\n        this.currentScene = scene;\r\n        this.app.renderer.backgroundColor = scene.BackGroundColor;\r\n        this.resizeHandler();\r\n        scene.onActivate();\r\n        this.masterContainer.removeChildren();\r\n        this.masterContainer.addChild(this.currentScene);\r\n        if (this.masterHudOverlay) {\r\n            this.masterContainer.addChild(this.masterHudOverlay);\r\n        }\r\n        pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"settings\"].RESOLUTION = window.devicePixelRatio;\r\n    };\r\n    SceneManager.prototype.ActivatePreviousScene = function () {\r\n        this.ActivateScene(this.lastScene);\r\n    };\r\n    Object.defineProperty(SceneManager.prototype, \"MasterHudOverlay\", {\r\n        get: function () {\r\n            return this.masterHudOverlay;\r\n        },\r\n        set: function (hud) {\r\n            this.masterHudOverlay = hud;\r\n            if (!!hud) {\r\n                this.masterContainer.removeChildren();\r\n                this.masterContainer.addChild(this.currentScene);\r\n                if (this.masterHudOverlay) {\r\n                    this.masterContainer.addChild(this.masterHudOverlay);\r\n                }\r\n                this.resizeHandler();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    SceneManager.prototype.CaptureScene = function () {\r\n        console.log(\"Capturing scene, width: \" + this.app.renderer.width + \", height: \" + this.app.renderer.height);\r\n        var renderTexture = pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"RenderTexture\"].create({ width: this.app.renderer.width, height: this.app.renderer.height });\r\n        this.app.renderer.render(this.currentScene, renderTexture);\r\n        return renderTexture;\r\n    };\r\n    SceneManager.prototype.onResize = function (screenSizeCalculator) {\r\n        var avlSize = this.screenSizeCalculator.GetAvailableSize();\r\n        var aspect = this.screenSizeCalculator.GetAspectRatio();\r\n        var size = this.screenSizeCalculator.CalculateSize(avlSize, aspect);\r\n        this.app.renderer.resize(size.x, size.y);\r\n        var scale = this.screenSizeCalculator.CalculateScale(size);\r\n        if (this.currentScene) {\r\n            this.currentScene.scale.set(scale.x, scale.y);\r\n            this.currentScene.onResize();\r\n        }\r\n        if (this.masterHudOverlay) {\r\n            this.masterHudOverlay.scale.set(scale.x, scale.y);\r\n        }\r\n    };\r\n    return SceneManager;\r\n}());\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\nvar Scene = (function (_super) {\r\n    __extends(Scene, _super);\r\n    function Scene(name) {\r\n        var _this = _super.call(this) || this;\r\n        _this.paused = false;\r\n        _this.hudScene = null;\r\n        _this.clearValue = true;\r\n        _this.backgroundColor = 0x0;\r\n        _this.Name = name;\r\n        return _this;\r\n    }\r\n    Scene.prototype.onActivate = function () {\r\n    };\r\n    Scene.prototype.onDeactivate = function () {\r\n    };\r\n    Scene.prototype.onResize = function () {\r\n    };\r\n    Scene.prototype.onUpdate = function (dt, timestamp) {\r\n    };\r\n    Scene.prototype.onDestroy = function () {\r\n    };\r\n    Object.defineProperty(Scene.prototype, \"BackGroundColor\", {\r\n        get: function () {\r\n            return this.backgroundColor;\r\n        },\r\n        set: function (color) {\r\n            this.backgroundColor = color;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Scene.prototype, \"HudOverlay\", {\r\n        get: function () {\r\n            return this.hudScene;\r\n        },\r\n        set: function (hud) {\r\n            if (this.hudScene) {\r\n                this.removeChild(this.hudScene);\r\n            }\r\n            this.hudScene = hud;\r\n            if (this.hudScene) {\r\n                var maxIndex = this.children.length;\r\n                this.addChildAt(this.hudScene, maxIndex);\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Scene.prototype.addChild = function () {\r\n        var child = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            child[_i] = arguments[_i];\r\n        }\r\n        var dispObj = _super.prototype.addChild.apply(this, child);\r\n        if (this.hudScene) {\r\n            var maxIndex = this.children.length - 1;\r\n            this.setChildIndex(this.hudScene, maxIndex);\r\n        }\r\n        return dispObj;\r\n    };\r\n    Scene.prototype.addChildAt = function (child, index) {\r\n        var dispObj = _super.prototype.addChildAt.call(this, child, index);\r\n        if (this.hudScene) {\r\n            var maxIndex = this.children.length - 1;\r\n            this.setChildIndex(this.hudScene, maxIndex);\r\n        }\r\n        return dispObj;\r\n    };\r\n    Scene.prototype.pause = function () {\r\n        this.paused = true;\r\n    };\r\n    Scene.prototype.resume = function () {\r\n        this.paused = false;\r\n    };\r\n    Scene.prototype.isPaused = function () {\r\n        return this.paused;\r\n    };\r\n    Object.defineProperty(Scene.prototype, \"clear\", {\r\n        get: function () {\r\n            return this.clearValue;\r\n        },\r\n        set: function (clearFlag) {\r\n            this.clearValue = clearFlag;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Scene;\r\n}(pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Container\"]));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGl4aS1zY2VuZWdyYXBoL2Rpc3QvaW5kZXguZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGl4aS1zY2VuZWdyYXBoL2Rpc3QvaW5kZXguZXMuanM/NGQxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZXR0aW5ncywgUmVuZGVyVGV4dHVyZSwgQ29udGFpbmVyLCBBcHBsaWNhdGlvbiB9IGZyb20gJ3BpeGkuanMnO1xuXG52YXIgRGVmYXVsdFNjcmVlblNpemVDYWxjdWxhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlZmF1bHRTY3JlZW5TaXplQ2FsY3VsYXRvcihkZXNpZ25lZFdpZHRoLCBkZXNpZ25lZEhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuZGVzaWduZWRXaWR0aCA9IGRlc2lnbmVkV2lkdGg7XHJcbiAgICAgICAgdGhpcy5kZXNpZ25lZEhlaWdodCA9IGRlc2lnbmVkSGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgRGVmYXVsdFNjcmVlblNpemVDYWxjdWxhdG9yLnByb3RvdHlwZS5HZXRBdmFpbGFibGVTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHdpbmRvdy5pbm5lcldpZHRoLCB5OiB3aW5kb3cuaW5uZXJIZWlnaHQgfTtcclxuICAgIH07XHJcbiAgICBEZWZhdWx0U2NyZWVuU2l6ZUNhbGN1bGF0b3IucHJvdG90eXBlLkdldEFzcGVjdFJhdGlvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2lnbmVkV2lkdGggLyB0aGlzLmRlc2lnbmVkSGVpZ2h0O1xyXG4gICAgfTtcclxuICAgIERlZmF1bHRTY3JlZW5TaXplQ2FsY3VsYXRvci5wcm90b3R5cGUuQ2FsY3VsYXRlU2l6ZSA9IGZ1bmN0aW9uIChhdmFpbGFibGVTaXplLCBhc3BlY3QpIHtcclxuICAgICAgICB2YXIgbWF4V2lkdGggPSBNYXRoLmZsb29yKGFzcGVjdCAqIGF2YWlsYWJsZVNpemUueSk7XHJcbiAgICAgICAgdmFyIG1heEhlaWdodCA9IE1hdGguZmxvb3Iod2luZG93LmlubmVySGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4geyB4OiBNYXRoLm1pbihtYXhXaWR0aCwgYXZhaWxhYmxlU2l6ZS54KSwgeTogTWF0aC5taW4obWF4SGVpZ2h0LCBhdmFpbGFibGVTaXplLnkpIH07XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdFNjcmVlblNpemVDYWxjdWxhdG9yLnByb3RvdHlwZS5DYWxjdWxhdGVTY2FsZSA9IGZ1bmN0aW9uIChjYWxjdWxhdGVkU2l6ZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IGNhbGN1bGF0ZWRTaXplLnggLyB0aGlzLmRlc2lnbmVkV2lkdGgsXHJcbiAgICAgICAgICAgIHk6IGNhbGN1bGF0ZWRTaXplLnggLyB0aGlzLmRlc2lnbmVkV2lkdGgsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGVmYXVsdFNjcmVlblNpemVDYWxjdWxhdG9yO1xyXG59KCkpO1xuXG52YXIgVkVSU0lPTiA9ICcxLjYuMyc7XG5cbnZhciBTY2VuZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2NlbmVNYW5hZ2VyKG9wdGlvbnMsIHNjcmVlblNpemVDYWxjdWxhdG9yKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zY2VuZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZSA9IC0xO1xyXG4gICAgICAgIHRoaXMuRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoX3RoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGUpO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuY3VycmVudFNjZW5lKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50U2NlbmUucGF1c2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5zY2VuZXMuZm9yRWFjaChmdW5jdGlvbiAoc2NlbmUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLlJlbW92ZVNjZW5lKHNjZW5lKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIF90aGlzLmFwcC5kZXN0cm95KHRydWUsIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGJhc2VUZXh0dXJlOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMub25SZXNpemUoX3RoaXMuc2NyZWVuU2l6ZUNhbGN1bGF0b3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vblJlbmRlciA9IGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghX3RoaXMuc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLnRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHZhciBkdCA9IF90aGlzLnRpbWVTdGFtcCAtIF90aGlzLnN0YXJ0VGltZTtcclxuICAgICAgICAgICAgaWYgKGR0ID4gNTApIHtcclxuICAgICAgICAgICAgICAgIGR0ID0gNTA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMuY29udHJvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoY3RybCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdHJsLnNjb3BlIHx8IChfdGhpcy5jdXJyZW50U2NlbmUgJiYgX3RoaXMuY3VycmVudFNjZW5lLm5hbWUgPT09IGN0cmwuc2NvcGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3RybC51cGRhdGUoZHQsIF90aGlzLmN1cnJlbnRTY2VuZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIV90aGlzLmN1cnJlbnRTY2VuZSB8fCBfdGhpcy5jdXJyZW50U2NlbmUuaXNQYXVzZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnRTY2VuZS5vblVwZGF0ZShkdCwgX3RoaXMudGltZVN0YW1wKTtcclxuICAgICAgICAgICAgX3RoaXMuc3RhcnRUaW1lID0gX3RoaXMudGltZVN0YW1wO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2NlbmVNYW5hZ2VyLmxvZ1ZlcnNpb24oKTtcclxuICAgICAgICB0aGlzLm1hc3RlckNvbnRhaW5lciA9IG5ldyBDb250YWluZXIoKTtcclxuICAgICAgICB0aGlzLmFwcCA9IG5ldyBBcHBsaWNhdGlvbihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMub25SZW5kZXIsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYXBwLnN0YWdlID0gdGhpcy5tYXN0ZXJDb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5kZXNpZ25XaWR0aCA9IG9wdGlvbnMud2lkdGggfHwgd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgICAgdGhpcy5kZXNpZ25IZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5zY3JlZW5TaXplQ2FsY3VsYXRvciA9IHNjcmVlblNpemVDYWxjdWxhdG9yIHx8IG5ldyBEZWZhdWx0U2NyZWVuU2l6ZUNhbGN1bGF0b3IodGhpcy5kZXNpZ25XaWR0aCwgdGhpcy5kZXNpZ25IZWlnaHQpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZUhhbmRsZXIpO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZUhhbmRsZXIsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgU2NlbmVNYW5hZ2VyLmxvZ1ZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjaHJvbWUnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIHZhciBmbXRQdXJwID0gJ2NvbG9yOiNmYTE7YmFja2dyb3VuZDojZmY2NmE1O3BhZGRpbmc6NXB4IDA7JztcclxuICAgICAgICAgICAgdmFyIGZtdFR4dCA9ICdjb2xvcjojZmExO2JhY2tncm91bmQ6IzAwMDtwYWRkaW5nOjVweCAwOyc7XHJcbiAgICAgICAgICAgIHZhciBmbXRIZWFydHMgPSAnY29sb3I6I2Y1NTtiYWNrZ3JvdW5kOiNmZmMzZGM7cGFkZGluZzo1cHggMDsnO1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtcclxuICAgICAgICAgICAgICAgIFwiICVjICAlYyBwaXhpLXNjZW5lZ3JhcGg6IFwiICsgVkVSU0lPTiArIFwiIFxcdTI3MzAgICVjICAlYyBodHRwczovL2dpdGh1Yi5jb20vZW5yaWtvLXJpYmEvcGl4aS1zY2VuZWdyYXBoI3JlYWRtZSBcXHUyNzY0XFx1Mjc2NFxcdTI3NjRcXHRcIixcclxuICAgICAgICAgICAgICAgIGZtdFB1cnAsXHJcbiAgICAgICAgICAgICAgICBmbXRUeHQsXHJcbiAgICAgICAgICAgICAgICBmbXRQdXJwLFxyXG4gICAgICAgICAgICAgICAgZm10SGVhcnRzLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8uYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHdpbmRvdy5jb25zb2xlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInBpeGktc2NlbmVncmFwaDogXCIgKyBWRVJTSU9OICsgXCIgXFx1MjczMCBodHRwczovL2dpdGh1Yi5jb20vZW5yaWtvLXJpYmEvcGl4aS1zY2VuZWdyYXBoI3JlYWRtZSAgXFx1Mjc2NFxcdTI3NjRcXHUyNzY0XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NlbmVNYW5hZ2VyLnByb3RvdHlwZSwgXCJSZW5kZXJlclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcC5yZW5kZXJlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2VuZU1hbmFnZXIucHJvdG90eXBlLCBcIkFwcGxpY2F0aW9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU2NlbmVNYW5hZ2VyLnByb3RvdHlwZS5BZGRDb250cm9sbGVyID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XHJcbiAgICB9O1xyXG4gICAgU2NlbmVNYW5hZ2VyLnByb3RvdHlwZS5SZW1vdmVDb250cm9sbGVyID0gZnVuY3Rpb24gKGNvbnRyb2xsZXJPcklkKSB7XHJcbiAgICAgICAgdmFyIGlkID0gdHlwZW9mIGNvbnRyb2xsZXJPcklkICE9PSAnc3RyaW5nJyA/IGNvbnRyb2xsZXJPcklkLmlkIDogY29udHJvbGxlck9ySWQ7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVycyA9IHRoaXMuY29udHJvbGxlcnMuZmlsdGVyKGZ1bmN0aW9uIChjdHJsKSB7IHJldHVybiBjdHJsLmlkICE9PSBpZDsgfSk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjZW5lTWFuYWdlci5wcm90b3R5cGUsIFwiQ3VycmVudFNjZW5lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNjZW5lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU2NlbmVNYW5hZ2VyLnByb3RvdHlwZS5BZGRTY2VuZSA9IGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgICAgIHRoaXMuc2NlbmVzLnB1c2goc2NlbmUpO1xyXG4gICAgfTtcclxuICAgIFNjZW5lTWFuYWdlci5wcm90b3R5cGUuUmVtb3ZlQWxsU2NlbmVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2NlbmVzLmZvckVhY2goZnVuY3Rpb24gKHNjZW5lKSB7XHJcbiAgICAgICAgICAgIHNjZW5lLm9uRGVzdHJveSgpO1xyXG4gICAgICAgICAgICBzY2VuZS5kZXN0cm95KHsgY2hpbGRyZW46IHRydWUsIHRleHR1cmU6IHRydWUsIGJhc2VUZXh0dXJlOiB0cnVlIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2NlbmVzID0gW107XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIFNjZW5lTWFuYWdlci5wcm90b3R5cGUuUmVtb3ZlU2NlbmUgPSBmdW5jdGlvbiAoc2NlbmUpIHtcclxuICAgICAgICB0aGlzLnNjZW5lcyA9IHRoaXMuc2NlbmVzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaW5kZXgsIGFycikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbSAhPT0gc2NlbmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2NlbmUub25EZXN0cm95KCk7XHJcbiAgICAgICAgc2NlbmUuZGVzdHJveSh7IGNoaWxkcmVuOiB0cnVlLCB0ZXh0dXJlOiB0cnVlLCBiYXNlVGV4dHVyZTogdHJ1ZSB9KTtcclxuICAgIH07XHJcbiAgICBTY2VuZU1hbmFnZXIucHJvdG90eXBlLkhhc1NjZW5lID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgZm91bmQgPSB0aGlzLnNjZW5lcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uTmFtZSA9PT0gbmFtZTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZvdW5kICYmIGZvdW5kLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgU2NlbmVNYW5hZ2VyLnByb3RvdHlwZS5HZXRTY2VuZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGZvdW5kID0gdGhpcy5zY2VuZXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLk5hbWUgPT09IG5hbWU7IH0pO1xyXG4gICAgICAgIGlmICghZm91bmQgfHwgZm91bmQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2NlbmU6ICdcIiArIG5hbWUgKyBcIicgbm90IGZvdW5kXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm91bmQubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIk11bHRpcGxlIHNjZW5lczogJ1wiICsgbmFtZSArIFwiJyBmb3VuZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvdW5kWzBdO1xyXG4gICAgfTtcclxuICAgIFNjZW5lTWFuYWdlci5wcm90b3R5cGUuQWN0aXZhdGVTY2VuZSA9IGZ1bmN0aW9uIChzY2VuZU9yTmFtZSkge1xyXG4gICAgICAgIHZhciBzY2VuZTtcclxuICAgICAgICBpZiAodHlwZW9mIHNjZW5lT3JOYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB2YXIgZm91bmQgPSB0aGlzLnNjZW5lcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uTmFtZSA9PT0gc2NlbmVPck5hbWU7IH0pO1xyXG4gICAgICAgICAgICBpZiAoIWZvdW5kIHx8IGZvdW5kLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTY2VuZTogJ1wiICsgc2NlbmVPck5hbWUgKyBcIicgbm90IGZvdW5kXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb3VuZC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk11bHRpcGxlIHNjZW5lczogJ1wiICsgc2NlbmVPck5hbWUgKyBcIicgZm91bmRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2NlbmUgPSBmb3VuZFswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNjZW5lID0gc2NlbmVPck5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZSAmJiB0aGlzLmN1cnJlbnRTY2VuZSAhPT0gc2NlbmUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0RlYWN0aXZhdGVTY2VuZSAnICsgdGhpcy5jdXJyZW50U2NlbmUuTmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uRGVhY3RpdmF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZygnQWN0aXZhdGVTY2VuZSAnICsgc2NlbmUuTmFtZSk7XHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMubGFzdFNjZW5lID0gKHRoaXMuY3VycmVudFNjZW5lICE9PSBzY2VuZSA/IHRoaXMuY3VycmVudFNjZW5lIDogdGhpcy5sYXN0U2NlbmUpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNjZW5lID0gc2NlbmU7XHJcbiAgICAgICAgdGhpcy5hcHAucmVuZGVyZXIuYmFja2dyb3VuZENvbG9yID0gc2NlbmUuQmFja0dyb3VuZENvbG9yO1xyXG4gICAgICAgIHRoaXMucmVzaXplSGFuZGxlcigpO1xyXG4gICAgICAgIHNjZW5lLm9uQWN0aXZhdGUoKTtcclxuICAgICAgICB0aGlzLm1hc3RlckNvbnRhaW5lci5yZW1vdmVDaGlsZHJlbigpO1xyXG4gICAgICAgIHRoaXMubWFzdGVyQ29udGFpbmVyLmFkZENoaWxkKHRoaXMuY3VycmVudFNjZW5lKTtcclxuICAgICAgICBpZiAodGhpcy5tYXN0ZXJIdWRPdmVybGF5KSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFzdGVyQ29udGFpbmVyLmFkZENoaWxkKHRoaXMubWFzdGVySHVkT3ZlcmxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldHRpbmdzLlJFU09MVVRJT04gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgIH07XHJcbiAgICBTY2VuZU1hbmFnZXIucHJvdG90eXBlLkFjdGl2YXRlUHJldmlvdXNTY2VuZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLkFjdGl2YXRlU2NlbmUodGhpcy5sYXN0U2NlbmUpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2VuZU1hbmFnZXIucHJvdG90eXBlLCBcIk1hc3Rlckh1ZE92ZXJsYXlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXN0ZXJIdWRPdmVybGF5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaHVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFzdGVySHVkT3ZlcmxheSA9IGh1ZDtcclxuICAgICAgICAgICAgaWYgKCEhaHVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hc3RlckNvbnRhaW5lci5yZW1vdmVDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXN0ZXJDb250YWluZXIuYWRkQ2hpbGQodGhpcy5jdXJyZW50U2NlbmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWFzdGVySHVkT3ZlcmxheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFzdGVyQ29udGFpbmVyLmFkZENoaWxkKHRoaXMubWFzdGVySHVkT3ZlcmxheSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUhhbmRsZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU2NlbmVNYW5hZ2VyLnByb3RvdHlwZS5DYXB0dXJlU2NlbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJDYXB0dXJpbmcgc2NlbmUsIHdpZHRoOiBcIiArIHRoaXMuYXBwLnJlbmRlcmVyLndpZHRoICsgXCIsIGhlaWdodDogXCIgKyB0aGlzLmFwcC5yZW5kZXJlci5oZWlnaHQpO1xyXG4gICAgICAgIHZhciByZW5kZXJUZXh0dXJlID0gUmVuZGVyVGV4dHVyZS5jcmVhdGUoeyB3aWR0aDogdGhpcy5hcHAucmVuZGVyZXIud2lkdGgsIGhlaWdodDogdGhpcy5hcHAucmVuZGVyZXIuaGVpZ2h0IH0pO1xyXG4gICAgICAgIHRoaXMuYXBwLnJlbmRlcmVyLnJlbmRlcih0aGlzLmN1cnJlbnRTY2VuZSwgcmVuZGVyVGV4dHVyZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XHJcbiAgICB9O1xyXG4gICAgU2NlbmVNYW5hZ2VyLnByb3RvdHlwZS5vblJlc2l6ZSA9IGZ1bmN0aW9uIChzY3JlZW5TaXplQ2FsY3VsYXRvcikge1xyXG4gICAgICAgIHZhciBhdmxTaXplID0gdGhpcy5zY3JlZW5TaXplQ2FsY3VsYXRvci5HZXRBdmFpbGFibGVTaXplKCk7XHJcbiAgICAgICAgdmFyIGFzcGVjdCA9IHRoaXMuc2NyZWVuU2l6ZUNhbGN1bGF0b3IuR2V0QXNwZWN0UmF0aW8oKTtcclxuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2NyZWVuU2l6ZUNhbGN1bGF0b3IuQ2FsY3VsYXRlU2l6ZShhdmxTaXplLCBhc3BlY3QpO1xyXG4gICAgICAgIHRoaXMuYXBwLnJlbmRlcmVyLnJlc2l6ZShzaXplLngsIHNpemUueSk7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY3JlZW5TaXplQ2FsY3VsYXRvci5DYWxjdWxhdGVTY2FsZShzaXplKTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U2NlbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuc2NhbGUuc2V0KHNjYWxlLngsIHNjYWxlLnkpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5vblJlc2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tYXN0ZXJIdWRPdmVybGF5KSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFzdGVySHVkT3ZlcmxheS5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBTY2VuZU1hbmFnZXI7XHJcbn0oKSk7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cblxudmFyIFNjZW5lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTY2VuZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNjZW5lKG5hbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmh1ZFNjZW5lID0gbnVsbDtcclxuICAgICAgICBfdGhpcy5jbGVhclZhbHVlID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAweDA7XHJcbiAgICAgICAgX3RoaXMuTmFtZSA9IG5hbWU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgU2NlbmUucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB9O1xyXG4gICAgU2NlbmUucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIH07XHJcbiAgICBTY2VuZS5wcm90b3R5cGUub25SZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB9O1xyXG4gICAgU2NlbmUucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24gKGR0LCB0aW1lc3RhbXApIHtcclxuICAgIH07XHJcbiAgICBTY2VuZS5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2VuZS5wcm90b3R5cGUsIFwiQmFja0dyb3VuZENvbG9yXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2VuZS5wcm90b3R5cGUsIFwiSHVkT3ZlcmxheVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh1ZFNjZW5lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaHVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmh1ZFNjZW5lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuaHVkU2NlbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaHVkU2NlbmUgPSBodWQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmh1ZFNjZW5lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4SW5kZXggPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGRBdCh0aGlzLmh1ZFNjZW5lLCBtYXhJbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFNjZW5lLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBjaGlsZFtfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGlzcE9iaiA9IF9zdXBlci5wcm90b3R5cGUuYWRkQ2hpbGQuYXBwbHkodGhpcywgY2hpbGQpO1xyXG4gICAgICAgIGlmICh0aGlzLmh1ZFNjZW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXhJbmRleCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgdGhpcy5zZXRDaGlsZEluZGV4KHRoaXMuaHVkU2NlbmUsIG1heEluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpc3BPYmo7XHJcbiAgICB9O1xyXG4gICAgU2NlbmUucHJvdG90eXBlLmFkZENoaWxkQXQgPSBmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGRpc3BPYmogPSBfc3VwZXIucHJvdG90eXBlLmFkZENoaWxkQXQuY2FsbCh0aGlzLCBjaGlsZCwgaW5kZXgpO1xyXG4gICAgICAgIGlmICh0aGlzLmh1ZFNjZW5lKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXhJbmRleCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgdGhpcy5zZXRDaGlsZEluZGV4KHRoaXMuaHVkU2NlbmUsIG1heEluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpc3BPYmo7XHJcbiAgICB9O1xyXG4gICAgU2NlbmUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBTY2VuZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgU2NlbmUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdXNlZDtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NlbmUucHJvdG90eXBlLCBcImNsZWFyXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXJWYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGNsZWFyRmxhZykge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVmFsdWUgPSBjbGVhckZsYWc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gU2NlbmU7XHJcbn0oQ29udGFpbmVyKSk7XG5cbmV4cG9ydCB7IERlZmF1bHRTY3JlZW5TaXplQ2FsY3VsYXRvciwgU2NlbmUsIFNjZW5lTWFuYWdlciwgVkVSU0lPTiB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pixi-scenegraph/dist/index.es.js\n");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__extends\", function() { return __extends; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__assign\", function() { return __assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__rest\", function() { return __rest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__decorate\", function() { return __decorate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__param\", function() { return __param; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__metadata\", function() { return __metadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__awaiter\", function() { return __awaiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__generator\", function() { return __generator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__exportStar\", function() { return __exportStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__values\", function() { return __values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__read\", function() { return __read; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__spread\", function() { return __spread; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__spreadArrays\", function() { return __spreadArrays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__await\", function() { return __await; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncGenerator\", function() { return __asyncGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncDelegator\", function() { return __asyncDelegator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncValues\", function() { return __asyncValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__makeTemplateObject\", function() { return __makeTemplateObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importStar\", function() { return __importStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importDefault\", function() { return __importDefault; });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nfunction __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz9hN2Y0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tslib/tslib.es6.js\n");

/***/ })

}]);