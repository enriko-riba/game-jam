(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~common~main"],{

/***/ "./node_modules/@tweenjs/tween.js/dist/tween.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tweenjs/tween.js/dist/tween.esm.js ***!
  \**********************************************************/
/*! exports provided: default */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(process) {var version = '18.5.0';\n\n/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\n\n\nvar _Group = function () {\n\tthis._tweens = {};\n\tthis._tweensAddedDuringUpdate = {};\n};\n\n_Group.prototype = {\n\tgetAll: function () {\n\n\t\treturn Object.keys(this._tweens).map(function (tweenId) {\n\t\t\treturn this._tweens[tweenId];\n\t\t}.bind(this));\n\n\t},\n\n\tremoveAll: function () {\n\n\t\tthis._tweens = {};\n\n\t},\n\n\tadd: function (tween) {\n\n\t\tthis._tweens[tween.getId()] = tween;\n\t\tthis._tweensAddedDuringUpdate[tween.getId()] = tween;\n\n\t},\n\n\tremove: function (tween) {\n\n\t\tdelete this._tweens[tween.getId()];\n\t\tdelete this._tweensAddedDuringUpdate[tween.getId()];\n\n\t},\n\n\tupdate: function (time, preserve) {\n\n\t\tvar tweenIds = Object.keys(this._tweens);\n\n\t\tif (tweenIds.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttime = time !== undefined ? time : TWEEN.now();\n\n\t\t// Tweens are updated in \"batches\". If you add a new tween during an\n\t\t// update, then the new tween will be updated in the next batch.\n\t\t// If you remove a tween during an update, it may or may not be updated.\n\t\t// However, if the removed tween was added during the current batch,\n\t\t// then it will not be updated.\n\t\twhile (tweenIds.length > 0) {\n\t\t\tthis._tweensAddedDuringUpdate = {};\n\n\t\t\tfor (var i = 0; i < tweenIds.length; i++) {\n\n\t\t\t\tvar tween = this._tweens[tweenIds[i]];\n\n\t\t\t\tif (tween && tween.update(time) === false) {\n\t\t\t\t\ttween._isPlaying = false;\n\n\t\t\t\t\tif (!preserve) {\n\t\t\t\t\t\tdelete this._tweens[tweenIds[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttweenIds = Object.keys(this._tweensAddedDuringUpdate);\n\t\t}\n\n\t\treturn true;\n\n\t}\n};\n\nvar TWEEN = new _Group();\n\nTWEEN.Group = _Group;\nTWEEN._nextId = 0;\nTWEEN.nextId = function () {\n\treturn TWEEN._nextId++;\n};\n\n\n// Include a performance.now polyfill.\n// In node.js, use process.hrtime.\nif (typeof (self) === 'undefined' && typeof (process) !== 'undefined' && process.hrtime) {\n\tTWEEN.now = function () {\n\t\tvar time = process.hrtime();\n\n\t\t// Convert [seconds, nanoseconds] to milliseconds.\n\t\treturn time[0] * 1000 + time[1] / 1000000;\n\t};\n}\n// In a browser, use self.performance.now if it is available.\nelse if (typeof (self) !== 'undefined' &&\n         self.performance !== undefined &&\n\t\t self.performance.now !== undefined) {\n\t// This must be bound, because directly assigning this function\n\t// leads to an invocation exception in Chrome.\n\tTWEEN.now = self.performance.now.bind(self.performance);\n}\n// Use Date.now if it is available.\nelse if (Date.now !== undefined) {\n\tTWEEN.now = Date.now;\n}\n// Otherwise, use 'new Date().getTime()'.\nelse {\n\tTWEEN.now = function () {\n\t\treturn new Date().getTime();\n\t};\n}\n\n\nTWEEN.Tween = function (object, group) {\n\tthis._isPaused = false;\n\tthis._pauseStart = null;\n\tthis._object = object;\n\tthis._valuesStart = {};\n\tthis._valuesEnd = {};\n\tthis._valuesStartRepeat = {};\n\tthis._duration = 1000;\n\tthis._repeat = 0;\n\tthis._repeatDelayTime = undefined;\n\tthis._yoyo = false;\n\tthis._isPlaying = false;\n\tthis._reversed = false;\n\tthis._delayTime = 0;\n\tthis._startTime = null;\n\tthis._easingFunction = TWEEN.Easing.Linear.None;\n\tthis._interpolationFunction = TWEEN.Interpolation.Linear;\n\tthis._chainedTweens = [];\n\tthis._onStartCallback = null;\n\tthis._onStartCallbackFired = false;\n\tthis._onUpdateCallback = null;\n\tthis._onRepeatCallback = null;\n\tthis._onCompleteCallback = null;\n\tthis._onStopCallback = null;\n\tthis._group = group || TWEEN;\n\tthis._id = TWEEN.nextId();\n\n};\n\nTWEEN.Tween.prototype = {\n\tgetId: function () {\n\t\treturn this._id;\n\t},\n\n\tisPlaying: function () {\n\t\treturn this._isPlaying;\n\t},\n\n\tisPaused: function () {\n\t\treturn this._isPaused;\n\t},\n\n\tto: function (properties, duration) {\n\n\t\tthis._valuesEnd = Object.create(properties);\n\n\t\tif (duration !== undefined) {\n\t\t\tthis._duration = duration;\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tduration: function duration(d) {\n\t\tthis._duration = d;\n\t\treturn this;\n\t},\n\n\tstart: function (time) {\n\n\t\tthis._group.add(this);\n\n\t\tthis._isPlaying = true;\n\n\t\tthis._isPaused = false;\n\n\t\tthis._onStartCallbackFired = false;\n\n\t\tthis._startTime = time !== undefined ? typeof time === 'string' ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();\n\t\tthis._startTime += this._delayTime;\n\n\t\tfor (var property in this._valuesEnd) {\n\n\t\t\t// Check if an Array was provided as property value\n\t\t\tif (this._valuesEnd[property] instanceof Array) {\n\n\t\t\t\tif (this._valuesEnd[property].length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Create a local copy of the Array with the start value at the front\n\t\t\t\tthis._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);\n\n\t\t\t}\n\n\t\t\t// If `to()` specifies a property that doesn't exist in the source object,\n\t\t\t// we should not set that property in the object\n\t\t\tif (this._object[property] === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Save the starting value, but only once.\n\t\t\tif (typeof(this._valuesStart[property]) === 'undefined') {\n\t\t\t\tthis._valuesStart[property] = this._object[property];\n\t\t\t}\n\n\t\t\tif ((this._valuesStart[property] instanceof Array) === false) {\n\t\t\t\tthis._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n\t\t\t}\n\n\t\t\tthis._valuesStartRepeat[property] = this._valuesStart[property] || 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tif (!this._isPlaying) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis._group.remove(this);\n\n\t\tthis._isPlaying = false;\n\n\t\tthis._isPaused = false;\n\n\t\tif (this._onStopCallback !== null) {\n\t\t\tthis._onStopCallback(this._object);\n\t\t}\n\n\t\tthis.stopChainedTweens();\n\t\treturn this;\n\n\t},\n\n\tend: function () {\n\n\t\tthis.update(Infinity);\n\t\treturn this;\n\n\t},\n\n\tpause: function(time) {\n\n\t\tif (this._isPaused || !this._isPlaying) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis._isPaused = true;\n\n\t\tthis._pauseStart = time === undefined ? TWEEN.now() : time;\n\n\t\tthis._group.remove(this);\n\n\t\treturn this;\n\n\t},\n\n\tresume: function(time) {\n\n\t\tif (!this._isPaused || !this._isPlaying) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis._isPaused = false;\n\n\t\tthis._startTime += (time === undefined ? TWEEN.now() : time)\n\t\t\t- this._pauseStart;\n\n\t\tthis._pauseStart = 0;\n\n\t\tthis._group.add(this);\n\n\t\treturn this;\n\n\t},\n\n\tstopChainedTweens: function () {\n\n\t\tfor (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\tthis._chainedTweens[i].stop();\n\t\t}\n\n\t},\n\n\tgroup: function (group) {\n\t\tthis._group = group;\n\t\treturn this;\n\t},\n\n\tdelay: function (amount) {\n\n\t\tthis._delayTime = amount;\n\t\treturn this;\n\n\t},\n\n\trepeat: function (times) {\n\n\t\tthis._repeat = times;\n\t\treturn this;\n\n\t},\n\n\trepeatDelay: function (amount) {\n\n\t\tthis._repeatDelayTime = amount;\n\t\treturn this;\n\n\t},\n\n\tyoyo: function (yoyo) {\n\n\t\tthis._yoyo = yoyo;\n\t\treturn this;\n\n\t},\n\n\teasing: function (easingFunction) {\n\n\t\tthis._easingFunction = easingFunction;\n\t\treturn this;\n\n\t},\n\n\tinterpolation: function (interpolationFunction) {\n\n\t\tthis._interpolationFunction = interpolationFunction;\n\t\treturn this;\n\n\t},\n\n\tchain: function () {\n\n\t\tthis._chainedTweens = arguments;\n\t\treturn this;\n\n\t},\n\n\tonStart: function (callback) {\n\n\t\tthis._onStartCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonUpdate: function (callback) {\n\n\t\tthis._onUpdateCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonRepeat: function onRepeat(callback) {\n\n\t\tthis._onRepeatCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonComplete: function (callback) {\n\n\t\tthis._onCompleteCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonStop: function (callback) {\n\n\t\tthis._onStopCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tupdate: function (time) {\n\n\t\tvar property;\n\t\tvar elapsed;\n\t\tvar value;\n\n\t\tif (time < this._startTime) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this._onStartCallbackFired === false) {\n\n\t\t\tif (this._onStartCallback !== null) {\n\t\t\t\tthis._onStartCallback(this._object);\n\t\t\t}\n\n\t\t\tthis._onStartCallbackFired = true;\n\t\t}\n\n\t\telapsed = (time - this._startTime) / this._duration;\n\t\telapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;\n\n\t\tvalue = this._easingFunction(elapsed);\n\n\t\tfor (property in this._valuesEnd) {\n\n\t\t\t// Don't update properties that do not exist in the source object\n\t\t\tif (this._valuesStart[property] === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar start = this._valuesStart[property] || 0;\n\t\t\tvar end = this._valuesEnd[property];\n\n\t\t\tif (end instanceof Array) {\n\n\t\t\t\tthis._object[property] = this._interpolationFunction(end, value);\n\n\t\t\t} else {\n\n\t\t\t\t// Parses relative end values with start as base (e.g.: +10, -3)\n\t\t\t\tif (typeof (end) === 'string') {\n\n\t\t\t\t\tif (end.charAt(0) === '+' || end.charAt(0) === '-') {\n\t\t\t\t\t\tend = start + parseFloat(end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tend = parseFloat(end);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Protect against non numeric properties.\n\t\t\t\tif (typeof (end) === 'number') {\n\t\t\t\t\tthis._object[property] = start + (end - start) * value;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (this._onUpdateCallback !== null) {\n\t\t\tthis._onUpdateCallback(this._object, elapsed);\n\t\t}\n\n\t\tif (elapsed === 1) {\n\n\t\t\tif (this._repeat > 0) {\n\n\t\t\t\tif (isFinite(this._repeat)) {\n\t\t\t\t\tthis._repeat--;\n\t\t\t\t}\n\n\t\t\t\t// Reassign starting values, restart by making startTime = now\n\t\t\t\tfor (property in this._valuesStartRepeat) {\n\n\t\t\t\t\tif (typeof (this._valuesEnd[property]) === 'string') {\n\t\t\t\t\t\tthis._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._yoyo) {\n\t\t\t\t\t\tvar tmp = this._valuesStartRepeat[property];\n\n\t\t\t\t\t\tthis._valuesStartRepeat[property] = this._valuesEnd[property];\n\t\t\t\t\t\tthis._valuesEnd[property] = tmp;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._valuesStart[property] = this._valuesStartRepeat[property];\n\n\t\t\t\t}\n\n\t\t\t\tif (this._yoyo) {\n\t\t\t\t\tthis._reversed = !this._reversed;\n\t\t\t\t}\n\n\t\t\t\tif (this._repeatDelayTime !== undefined) {\n\t\t\t\t\tthis._startTime = time + this._repeatDelayTime;\n\t\t\t\t} else {\n\t\t\t\t\tthis._startTime = time + this._delayTime;\n\t\t\t\t}\n\n\t\t\t\tif (this._onRepeatCallback !== null) {\n\t\t\t\t\tthis._onRepeatCallback(this._object);\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\tif (this._onCompleteCallback !== null) {\n\n\t\t\t\t\tthis._onCompleteCallback(this._object);\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\t\t\t// Make the chained tweens start exactly at the time they should,\n\t\t\t\t\t// even if the `update()` method was called way past the duration of the tween\n\t\t\t\t\tthis._chainedTweens[i].start(this._startTime + this._duration);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n};\n\n\nTWEEN.Easing = {\n\n\tLinear: {\n\n\t\tNone: function (k) {\n\n\t\t\treturn k;\n\n\t\t}\n\n\t},\n\n\tQuadratic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn k * (2 - k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k;\n\t\t\t}\n\n\t\t\treturn - 0.5 * (--k * (k - 2) - 1);\n\n\t\t}\n\n\t},\n\n\tCubic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn --k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k + 2);\n\n\t\t}\n\n\t},\n\n\tQuartic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn 1 - (--k * k * k * k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn - 0.5 * ((k -= 2) * k * k * k - 2);\n\n\t\t}\n\n\t},\n\n\tQuintic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn --k * k * k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k * k * k + 2);\n\n\t\t}\n\n\t},\n\n\tSinusoidal: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - Math.cos(k * Math.PI / 2);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn Math.sin(k * Math.PI / 2);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\treturn 0.5 * (1 - Math.cos(Math.PI * k));\n\n\t\t}\n\n\t},\n\n\tExponential: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k === 0 ? 0 : Math.pow(1024, k - 1);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * Math.pow(1024, k - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);\n\n\t\t}\n\n\t},\n\n\tCircular: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - Math.sqrt(1 - k * k);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn Math.sqrt(1 - (--k * k));\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn - 0.5 * (Math.sqrt(1 - k * k) - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\n\t\t}\n\n\t},\n\n\tElastic: {\n\n\t\tIn: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tk *= 2;\n\n\t\t\tif (k < 1) {\n\t\t\t\treturn -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\t\t\t}\n\n\t\t\treturn 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\n\n\t\t}\n\n\t},\n\n\tBack: {\n\n\t\tIn: function (k) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn k * k * ((s + 1) * k - s);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn --k * k * ((s + 1) * k + s) + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tvar s = 1.70158 * 1.525;\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * (k * k * ((s + 1) * k - s));\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\n\t\t}\n\n\t},\n\n\tBounce: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - TWEEN.Easing.Bounce.Out(1 - k);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tif (k < (1 / 2.75)) {\n\t\t\t\treturn 7.5625 * k * k;\n\t\t\t} else if (k < (2 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t\t\t} else if (k < (2.5 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t\t\t} else {\n\t\t\t\treturn 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t\t\t}\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k < 0.5) {\n\t\t\t\treturn TWEEN.Easing.Bounce.In(k * 2) * 0.5;\n\t\t\t}\n\n\t\t\treturn TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n\n\t\t}\n\n\t}\n\n};\n\nTWEEN.Interpolation = {\n\n\tLinear: function (v, k) {\n\n\t\tvar m = v.length - 1;\n\t\tvar f = m * k;\n\t\tvar i = Math.floor(f);\n\t\tvar fn = TWEEN.Interpolation.Utils.Linear;\n\n\t\tif (k < 0) {\n\t\t\treturn fn(v[0], v[1], f);\n\t\t}\n\n\t\tif (k > 1) {\n\t\t\treturn fn(v[m], v[m - 1], m - f);\n\t\t}\n\n\t\treturn fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n\n\t},\n\n\tBezier: function (v, k) {\n\n\t\tvar b = 0;\n\t\tvar n = v.length - 1;\n\t\tvar pw = Math.pow;\n\t\tvar bn = TWEEN.Interpolation.Utils.Bernstein;\n\n\t\tfor (var i = 0; i <= n; i++) {\n\t\t\tb += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n\t\t}\n\n\t\treturn b;\n\n\t},\n\n\tCatmullRom: function (v, k) {\n\n\t\tvar m = v.length - 1;\n\t\tvar f = m * k;\n\t\tvar i = Math.floor(f);\n\t\tvar fn = TWEEN.Interpolation.Utils.CatmullRom;\n\n\t\tif (v[0] === v[m]) {\n\n\t\t\tif (k < 0) {\n\t\t\t\ti = Math.floor(f = m * (1 + k));\n\t\t\t}\n\n\t\t\treturn fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n\n\t\t} else {\n\n\t\t\tif (k < 0) {\n\t\t\t\treturn v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n\t\t\t}\n\n\t\t\tif (k > 1) {\n\t\t\t\treturn v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n\t\t\t}\n\n\t\t\treturn fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n\n\t\t}\n\n\t},\n\n\tUtils: {\n\n\t\tLinear: function (p0, p1, t) {\n\n\t\t\treturn (p1 - p0) * t + p0;\n\n\t\t},\n\n\t\tBernstein: function (n, i) {\n\n\t\t\tvar fc = TWEEN.Interpolation.Utils.Factorial;\n\n\t\t\treturn fc(n) / fc(i) / fc(n - i);\n\n\t\t},\n\n\t\tFactorial: (function () {\n\n\t\t\tvar a = [1];\n\n\t\t\treturn function (n) {\n\n\t\t\t\tvar s = 1;\n\n\t\t\t\tif (a[n]) {\n\t\t\t\t\treturn a[n];\n\t\t\t\t}\n\n\t\t\t\tfor (var i = n; i > 1; i--) {\n\t\t\t\t\ts *= i;\n\t\t\t\t}\n\n\t\t\t\ta[n] = s;\n\t\t\t\treturn s;\n\n\t\t\t};\n\n\t\t})(),\n\n\t\tCatmullRom: function (p0, p1, p2, p3, t) {\n\n\t\t\tvar v0 = (p2 - p0) * 0.5;\n\t\t\tvar v1 = (p3 - p1) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\n\t\t\treturn (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t}\n\n};\nTWEEN.version = version;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (TWEEN);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHR3ZWVuanMvdHdlZW4uanMvZGlzdC90d2Vlbi5lc20uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHR3ZWVuanMvdHdlZW4uanMvZGlzdC90d2Vlbi5lc20uanM/NzQ2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdmVyc2lvbiA9ICcxOC41LjAnO1xuXG4vKipcbiAqIFR3ZWVuLmpzIC0gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qcy9ncmFwaHMvY29udHJpYnV0b3JzIGZvciB0aGUgZnVsbCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cbiAqIFRoYW5rIHlvdSBhbGwsIHlvdSdyZSBhd2Vzb21lIVxuICovXG5cblxudmFyIF9Hcm91cCA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5fdHdlZW5zID0ge307XG5cdHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlID0ge307XG59O1xuXG5fR3JvdXAucHJvdG90eXBlID0ge1xuXHRnZXRBbGw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl90d2VlbnMpLm1hcChmdW5jdGlvbiAodHdlZW5JZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3R3ZWVuc1t0d2VlbklkXTtcblx0XHR9LmJpbmQodGhpcykpO1xuXG5cdH0sXG5cblx0cmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLl90d2VlbnMgPSB7fTtcblxuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24gKHR3ZWVuKSB7XG5cblx0XHR0aGlzLl90d2VlbnNbdHdlZW4uZ2V0SWQoKV0gPSB0d2Vlbjtcblx0XHR0aGlzLl90d2VlbnNBZGRlZER1cmluZ1VwZGF0ZVt0d2Vlbi5nZXRJZCgpXSA9IHR3ZWVuO1xuXG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiAodHdlZW4pIHtcblxuXHRcdGRlbGV0ZSB0aGlzLl90d2VlbnNbdHdlZW4uZ2V0SWQoKV07XG5cdFx0ZGVsZXRlIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlW3R3ZWVuLmdldElkKCldO1xuXG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbiAodGltZSwgcHJlc2VydmUpIHtcblxuXHRcdHZhciB0d2VlbklkcyA9IE9iamVjdC5rZXlzKHRoaXMuX3R3ZWVucyk7XG5cblx0XHRpZiAodHdlZW5JZHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGltZSA9IHRpbWUgIT09IHVuZGVmaW5lZCA/IHRpbWUgOiBUV0VFTi5ub3coKTtcblxuXHRcdC8vIFR3ZWVucyBhcmUgdXBkYXRlZCBpbiBcImJhdGNoZXNcIi4gSWYgeW91IGFkZCBhIG5ldyB0d2VlbiBkdXJpbmcgYW5cblx0XHQvLyB1cGRhdGUsIHRoZW4gdGhlIG5ldyB0d2VlbiB3aWxsIGJlIHVwZGF0ZWQgaW4gdGhlIG5leHQgYmF0Y2guXG5cdFx0Ly8gSWYgeW91IHJlbW92ZSBhIHR3ZWVuIGR1cmluZyBhbiB1cGRhdGUsIGl0IG1heSBvciBtYXkgbm90IGJlIHVwZGF0ZWQuXG5cdFx0Ly8gSG93ZXZlciwgaWYgdGhlIHJlbW92ZWQgdHdlZW4gd2FzIGFkZGVkIGR1cmluZyB0aGUgY3VycmVudCBiYXRjaCxcblx0XHQvLyB0aGVuIGl0IHdpbGwgbm90IGJlIHVwZGF0ZWQuXG5cdFx0d2hpbGUgKHR3ZWVuSWRzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlID0ge307XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdHdlZW5JZHMubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl90d2VlbnNbdHdlZW5JZHNbaV1dO1xuXG5cdFx0XHRcdGlmICh0d2VlbiAmJiB0d2Vlbi51cGRhdGUodGltZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dHdlZW4uX2lzUGxheWluZyA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCFwcmVzZXJ2ZSkge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3R3ZWVuc1t0d2Vlbklkc1tpXV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHR3ZWVuSWRzID0gT2JqZWN0LmtleXModGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGUpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cbn07XG5cbnZhciBUV0VFTiA9IG5ldyBfR3JvdXAoKTtcblxuVFdFRU4uR3JvdXAgPSBfR3JvdXA7XG5UV0VFTi5fbmV4dElkID0gMDtcblRXRUVOLm5leHRJZCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIFRXRUVOLl9uZXh0SWQrKztcbn07XG5cblxuLy8gSW5jbHVkZSBhIHBlcmZvcm1hbmNlLm5vdyBwb2x5ZmlsbC5cbi8vIEluIG5vZGUuanMsIHVzZSBwcm9jZXNzLmhydGltZS5cbmlmICh0eXBlb2YgKHNlbGYpID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgKHByb2Nlc3MpICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmhydGltZSkge1xuXHRUV0VFTi5ub3cgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRpbWUgPSBwcm9jZXNzLmhydGltZSgpO1xuXG5cdFx0Ly8gQ29udmVydCBbc2Vjb25kcywgbmFub3NlY29uZHNdIHRvIG1pbGxpc2Vjb25kcy5cblx0XHRyZXR1cm4gdGltZVswXSAqIDEwMDAgKyB0aW1lWzFdIC8gMTAwMDAwMDtcblx0fTtcbn1cbi8vIEluIGEgYnJvd3NlciwgdXNlIHNlbGYucGVyZm9ybWFuY2Uubm93IGlmIGl0IGlzIGF2YWlsYWJsZS5cbmVsc2UgaWYgKHR5cGVvZiAoc2VsZikgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICBzZWxmLnBlcmZvcm1hbmNlICE9PSB1bmRlZmluZWQgJiZcblx0XHQgc2VsZi5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZCkge1xuXHQvLyBUaGlzIG11c3QgYmUgYm91bmQsIGJlY2F1c2UgZGlyZWN0bHkgYXNzaWduaW5nIHRoaXMgZnVuY3Rpb25cblx0Ly8gbGVhZHMgdG8gYW4gaW52b2NhdGlvbiBleGNlcHRpb24gaW4gQ2hyb21lLlxuXHRUV0VFTi5ub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdy5iaW5kKHNlbGYucGVyZm9ybWFuY2UpO1xufVxuLy8gVXNlIERhdGUubm93IGlmIGl0IGlzIGF2YWlsYWJsZS5cbmVsc2UgaWYgKERhdGUubm93ICE9PSB1bmRlZmluZWQpIHtcblx0VFdFRU4ubm93ID0gRGF0ZS5ub3c7XG59XG4vLyBPdGhlcndpc2UsIHVzZSAnbmV3IERhdGUoKS5nZXRUaW1lKCknLlxuZWxzZSB7XG5cdFRXRUVOLm5vdyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdH07XG59XG5cblxuVFdFRU4uVHdlZW4gPSBmdW5jdGlvbiAob2JqZWN0LCBncm91cCkge1xuXHR0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuXHR0aGlzLl9wYXVzZVN0YXJ0ID0gbnVsbDtcblx0dGhpcy5fb2JqZWN0ID0gb2JqZWN0O1xuXHR0aGlzLl92YWx1ZXNTdGFydCA9IHt9O1xuXHR0aGlzLl92YWx1ZXNFbmQgPSB7fTtcblx0dGhpcy5fdmFsdWVzU3RhcnRSZXBlYXQgPSB7fTtcblx0dGhpcy5fZHVyYXRpb24gPSAxMDAwO1xuXHR0aGlzLl9yZXBlYXQgPSAwO1xuXHR0aGlzLl9yZXBlYXREZWxheVRpbWUgPSB1bmRlZmluZWQ7XG5cdHRoaXMuX3lveW8gPSBmYWxzZTtcblx0dGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG5cdHRoaXMuX3JldmVyc2VkID0gZmFsc2U7XG5cdHRoaXMuX2RlbGF5VGltZSA9IDA7XG5cdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cdHRoaXMuX2Vhc2luZ0Z1bmN0aW9uID0gVFdFRU4uRWFzaW5nLkxpbmVhci5Ob25lO1xuXHR0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLkxpbmVhcjtcblx0dGhpcy5fY2hhaW5lZFR3ZWVucyA9IFtdO1xuXHR0aGlzLl9vblN0YXJ0Q2FsbGJhY2sgPSBudWxsO1xuXHR0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuXHR0aGlzLl9vblVwZGF0ZUNhbGxiYWNrID0gbnVsbDtcblx0dGhpcy5fb25SZXBlYXRDYWxsYmFjayA9IG51bGw7XG5cdHRoaXMuX29uQ29tcGxldGVDYWxsYmFjayA9IG51bGw7XG5cdHRoaXMuX29uU3RvcENhbGxiYWNrID0gbnVsbDtcblx0dGhpcy5fZ3JvdXAgPSBncm91cCB8fCBUV0VFTjtcblx0dGhpcy5faWQgPSBUV0VFTi5uZXh0SWQoKTtcblxufTtcblxuVFdFRU4uVHdlZW4ucHJvdG90eXBlID0ge1xuXHRnZXRJZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9pZDtcblx0fSxcblxuXHRpc1BsYXlpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5faXNQbGF5aW5nO1xuXHR9LFxuXG5cdGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzUGF1c2VkO1xuXHR9LFxuXG5cdHRvOiBmdW5jdGlvbiAocHJvcGVydGllcywgZHVyYXRpb24pIHtcblxuXHRcdHRoaXMuX3ZhbHVlc0VuZCA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcyk7XG5cblx0XHRpZiAoZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGR1cmF0aW9uOiBmdW5jdGlvbiBkdXJhdGlvbihkKSB7XG5cdFx0dGhpcy5fZHVyYXRpb24gPSBkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHN0YXJ0OiBmdW5jdGlvbiAodGltZSkge1xuXG5cdFx0dGhpcy5fZ3JvdXAuYWRkKHRoaXMpO1xuXG5cdFx0dGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcblxuXHRcdHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG5cblx0XHR0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gdGltZSAhPT0gdW5kZWZpbmVkID8gdHlwZW9mIHRpbWUgPT09ICdzdHJpbmcnID8gVFdFRU4ubm93KCkgKyBwYXJzZUZsb2F0KHRpbWUpIDogdGltZSA6IFRXRUVOLm5vdygpO1xuXHRcdHRoaXMuX3N0YXJ0VGltZSArPSB0aGlzLl9kZWxheVRpbWU7XG5cblx0XHRmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzLl92YWx1ZXNFbmQpIHtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYW4gQXJyYXkgd2FzIHByb3ZpZGVkIGFzIHByb3BlcnR5IHZhbHVlXG5cdFx0XHRpZiAodGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cblx0XHRcdFx0aWYgKHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV0ubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgYSBsb2NhbCBjb3B5IG9mIHRoZSBBcnJheSB3aXRoIHRoZSBzdGFydCB2YWx1ZSBhdCB0aGUgZnJvbnRcblx0XHRcdFx0dGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XSA9IFt0aGlzLl9vYmplY3RbcHJvcGVydHldXS5jb25jYXQodGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XSk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYHRvKClgIHNwZWNpZmllcyBhIHByb3BlcnR5IHRoYXQgZG9lc24ndCBleGlzdCBpbiB0aGUgc291cmNlIG9iamVjdCxcblx0XHRcdC8vIHdlIHNob3VsZCBub3Qgc2V0IHRoYXQgcHJvcGVydHkgaW4gdGhlIG9iamVjdFxuXHRcdFx0aWYgKHRoaXMuX29iamVjdFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSB0aGUgc3RhcnRpbmcgdmFsdWUsIGJ1dCBvbmx5IG9uY2UuXG5cdFx0XHRpZiAodHlwZW9mKHRoaXMuX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSkgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRoaXMuX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9IHRoaXMuX29iamVjdFtwcm9wZXJ0eV07XG5cdFx0XHR9XG5cblx0XHRcdGlmICgodGhpcy5fdmFsdWVzU3RhcnRbcHJvcGVydHldIGluc3RhbmNlb2YgQXJyYXkpID09PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gKj0gMS4wOyAvLyBFbnN1cmVzIHdlJ3JlIHVzaW5nIG51bWJlcnMsIG5vdCBzdHJpbmdzXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XSA9IHRoaXMuX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSB8fCAwO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIXRoaXMuX2lzUGxheWluZykge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZ3JvdXAucmVtb3ZlKHRoaXMpO1xuXG5cdFx0dGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuXG5cdFx0aWYgKHRoaXMuX29uU3RvcENhbGxiYWNrICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9vblN0b3BDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcENoYWluZWRUd2VlbnMoKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy51cGRhdGUoSW5maW5pdHkpO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cGF1c2U6IGZ1bmN0aW9uKHRpbWUpIHtcblxuXHRcdGlmICh0aGlzLl9pc1BhdXNlZCB8fCAhdGhpcy5faXNQbGF5aW5nKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG5cblx0XHR0aGlzLl9wYXVzZVN0YXJ0ID0gdGltZSA9PT0gdW5kZWZpbmVkID8gVFdFRU4ubm93KCkgOiB0aW1lO1xuXG5cdFx0dGhpcy5fZ3JvdXAucmVtb3ZlKHRoaXMpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyZXN1bWU6IGZ1bmN0aW9uKHRpbWUpIHtcblxuXHRcdGlmICghdGhpcy5faXNQYXVzZWQgfHwgIXRoaXMuX2lzUGxheWluZykge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcblxuXHRcdHRoaXMuX3N0YXJ0VGltZSArPSAodGltZSA9PT0gdW5kZWZpbmVkID8gVFdFRU4ubm93KCkgOiB0aW1lKVxuXHRcdFx0LSB0aGlzLl9wYXVzZVN0YXJ0O1xuXG5cdFx0dGhpcy5fcGF1c2VTdGFydCA9IDA7XG5cblx0XHR0aGlzLl9ncm91cC5hZGQodGhpcyk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHN0b3BDaGFpbmVkVHdlZW5zOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbnVtQ2hhaW5lZFR3ZWVucyA9IHRoaXMuX2NoYWluZWRUd2VlbnMubGVuZ3RoOyBpIDwgbnVtQ2hhaW5lZFR3ZWVuczsgaSsrKSB7XG5cdFx0XHR0aGlzLl9jaGFpbmVkVHdlZW5zW2ldLnN0b3AoKTtcblx0XHR9XG5cblx0fSxcblxuXHRncm91cDogZnVuY3Rpb24gKGdyb3VwKSB7XG5cdFx0dGhpcy5fZ3JvdXAgPSBncm91cDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRkZWxheTogZnVuY3Rpb24gKGFtb3VudCkge1xuXG5cdFx0dGhpcy5fZGVsYXlUaW1lID0gYW1vdW50O1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cmVwZWF0OiBmdW5jdGlvbiAodGltZXMpIHtcblxuXHRcdHRoaXMuX3JlcGVhdCA9IHRpbWVzO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cmVwZWF0RGVsYXk6IGZ1bmN0aW9uIChhbW91bnQpIHtcblxuXHRcdHRoaXMuX3JlcGVhdERlbGF5VGltZSA9IGFtb3VudDtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHlveW86IGZ1bmN0aW9uICh5b3lvKSB7XG5cblx0XHR0aGlzLl95b3lvID0geW95bztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVhc2luZzogZnVuY3Rpb24gKGVhc2luZ0Z1bmN0aW9uKSB7XG5cblx0XHR0aGlzLl9lYXNpbmdGdW5jdGlvbiA9IGVhc2luZ0Z1bmN0aW9uO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0aW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKGludGVycG9sYXRpb25GdW5jdGlvbikge1xuXG5cdFx0dGhpcy5faW50ZXJwb2xhdGlvbkZ1bmN0aW9uID0gaW50ZXJwb2xhdGlvbkZ1bmN0aW9uO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2hhaW46IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuX2NoYWluZWRUd2VlbnMgPSBhcmd1bWVudHM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRvblN0YXJ0OiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblxuXHRcdHRoaXMuX29uU3RhcnRDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0b25VcGRhdGU6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXG5cdFx0dGhpcy5fb25VcGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0b25SZXBlYXQ6IGZ1bmN0aW9uIG9uUmVwZWF0KGNhbGxiYWNrKSB7XG5cblx0XHR0aGlzLl9vblJlcGVhdENhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRvbkNvbXBsZXRlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblxuXHRcdHRoaXMuX29uQ29tcGxldGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0b25TdG9wOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblxuXHRcdHRoaXMuX29uU3RvcENhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uICh0aW1lKSB7XG5cblx0XHR2YXIgcHJvcGVydHk7XG5cdFx0dmFyIGVsYXBzZWQ7XG5cdFx0dmFyIHZhbHVlO1xuXG5cdFx0aWYgKHRpbWUgPCB0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9PT0gZmFsc2UpIHtcblxuXHRcdFx0aWYgKHRoaXMuX29uU3RhcnRDYWxsYmFjayAhPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9vblN0YXJ0Q2FsbGJhY2sodGhpcy5fb2JqZWN0KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGVsYXBzZWQgPSAodGltZSAtIHRoaXMuX3N0YXJ0VGltZSkgLyB0aGlzLl9kdXJhdGlvbjtcblx0XHRlbGFwc2VkID0gKHRoaXMuX2R1cmF0aW9uID09PSAwIHx8IGVsYXBzZWQgPiAxKSA/IDEgOiBlbGFwc2VkO1xuXG5cdFx0dmFsdWUgPSB0aGlzLl9lYXNpbmdGdW5jdGlvbihlbGFwc2VkKTtcblxuXHRcdGZvciAocHJvcGVydHkgaW4gdGhpcy5fdmFsdWVzRW5kKSB7XG5cblx0XHRcdC8vIERvbid0IHVwZGF0ZSBwcm9wZXJ0aWVzIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBzb3VyY2Ugb2JqZWN0XG5cdFx0XHRpZiAodGhpcy5fdmFsdWVzU3RhcnRbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzdGFydCA9IHRoaXMuX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSB8fCAwO1xuXHRcdFx0dmFyIGVuZCA9IHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV07XG5cblx0XHRcdGlmIChlbmQgaW5zdGFuY2VvZiBBcnJheSkge1xuXG5cdFx0XHRcdHRoaXMuX29iamVjdFtwcm9wZXJ0eV0gPSB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24oZW5kLCB2YWx1ZSk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gUGFyc2VzIHJlbGF0aXZlIGVuZCB2YWx1ZXMgd2l0aCBzdGFydCBhcyBiYXNlIChlLmcuOiArMTAsIC0zKVxuXHRcdFx0XHRpZiAodHlwZW9mIChlbmQpID09PSAnc3RyaW5nJykge1xuXG5cdFx0XHRcdFx0aWYgKGVuZC5jaGFyQXQoMCkgPT09ICcrJyB8fCBlbmQuY2hhckF0KDApID09PSAnLScpIHtcblx0XHRcdFx0XHRcdGVuZCA9IHN0YXJ0ICsgcGFyc2VGbG9hdChlbmQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlbmQgPSBwYXJzZUZsb2F0KGVuZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvdGVjdCBhZ2FpbnN0IG5vbiBudW1lcmljIHByb3BlcnRpZXMuXG5cdFx0XHRcdGlmICh0eXBlb2YgKGVuZCkgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0dGhpcy5fb2JqZWN0W3Byb3BlcnR5XSA9IHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9vblVwZGF0ZUNhbGxiYWNrICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9vblVwZGF0ZUNhbGxiYWNrKHRoaXMuX29iamVjdCwgZWxhcHNlZCk7XG5cdFx0fVxuXG5cdFx0aWYgKGVsYXBzZWQgPT09IDEpIHtcblxuXHRcdFx0aWYgKHRoaXMuX3JlcGVhdCA+IDApIHtcblxuXHRcdFx0XHRpZiAoaXNGaW5pdGUodGhpcy5fcmVwZWF0KSkge1xuXHRcdFx0XHRcdHRoaXMuX3JlcGVhdC0tO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVhc3NpZ24gc3RhcnRpbmcgdmFsdWVzLCByZXN0YXJ0IGJ5IG1ha2luZyBzdGFydFRpbWUgPSBub3dcblx0XHRcdFx0Zm9yIChwcm9wZXJ0eSBpbiB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdCkge1xuXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiAodGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gKyBwYXJzZUZsb2F0KHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0aGlzLl95b3lvKSB7XG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xuXG5cdFx0XHRcdFx0XHR0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldO1xuXHRcdFx0XHRcdFx0dGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLl92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSB0aGlzLl92YWx1ZXNTdGFydFJlcGVhdFtwcm9wZXJ0eV07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLl95b3lvKSB7XG5cdFx0XHRcdFx0dGhpcy5fcmV2ZXJzZWQgPSAhdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fcmVwZWF0RGVsYXlUaW1lICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSB0aW1lICsgdGhpcy5fcmVwZWF0RGVsYXlUaW1lO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHRpbWUgKyB0aGlzLl9kZWxheVRpbWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fb25SZXBlYXRDYWxsYmFjayAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuX29uUmVwZWF0Q2FsbGJhY2sodGhpcy5fb2JqZWN0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICh0aGlzLl9vbkNvbXBsZXRlQ2FsbGJhY2sgIT09IG51bGwpIHtcblxuXHRcdFx0XHRcdHRoaXMuX29uQ29tcGxldGVDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIG51bUNoYWluZWRUd2VlbnMgPSB0aGlzLl9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKykge1xuXHRcdFx0XHRcdC8vIE1ha2UgdGhlIGNoYWluZWQgdHdlZW5zIHN0YXJ0IGV4YWN0bHkgYXQgdGhlIHRpbWUgdGhleSBzaG91bGQsXG5cdFx0XHRcdFx0Ly8gZXZlbiBpZiB0aGUgYHVwZGF0ZSgpYCBtZXRob2Qgd2FzIGNhbGxlZCB3YXkgcGFzdCB0aGUgZHVyYXRpb24gb2YgdGhlIHR3ZWVuXG5cdFx0XHRcdFx0dGhpcy5fY2hhaW5lZFR3ZWVuc1tpXS5zdGFydCh0aGlzLl9zdGFydFRpbWUgKyB0aGlzLl9kdXJhdGlvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cbn07XG5cblxuVFdFRU4uRWFzaW5nID0ge1xuXG5cdExpbmVhcjoge1xuXG5cdFx0Tm9uZTogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIGs7XG5cblx0XHR9XG5cblx0fSxcblxuXHRRdWFkcmF0aWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gayAqIGs7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gayAqICgyIC0gayk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIGsgKiBrO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gLSAwLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Q3ViaWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIC0tayAqIGsgKiBrICsgMTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGsgKiBrO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdFF1YXJ0aWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrICogaztcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiAxIC0gKC0tayAqIGsgKiBrICogayk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAtIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0UXVpbnRpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiBrICogayAqIGsgKiBrICogaztcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG5cblx0XHR9XG5cblx0fSxcblxuXHRTaW51c29pZGFsOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIDEgLSBNYXRoLmNvcyhrICogTWF0aC5QSSAvIDIpO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguc2luKGsgKiBNYXRoLlBJIC8gMik7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRFeHBvbmVudGlhbDoge1xuXG5cdFx0SW46IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiBrID09PSAwID8gMCA6IE1hdGgucG93KDEwMjQsIGsgLSAxKTtcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtIDEwICogayk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdGlmIChrID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoayA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMC41ICogKC0gTWF0aC5wb3coMiwgLSAxMCAqIChrIC0gMSkpICsgMik7XG5cblx0XHR9XG5cblx0fSxcblxuXHRDaXJjdWxhcjoge1xuXG5cdFx0SW46IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBrICogayk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS1rICogaykpO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRpZiAoKGsgKj0gMikgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAtIDAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0RWxhc3RpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uIChrKSB7XG5cblx0XHRcdGlmIChrID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoayA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIC1NYXRoLnBvdygyLCAxMCAqIChrIC0gMSkpICogTWF0aC5zaW4oKGsgLSAxLjEpICogNSAqIE1hdGguUEkpO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0aWYgKGsgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChrID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coMiwgLTEwICogaykgKiBNYXRoLnNpbigoayAtIDAuMSkgKiA1ICogTWF0aC5QSSkgKyAxO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRpZiAoayA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGsgPT09IDEpIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGsgKj0gMjtcblxuXHRcdFx0aWYgKGsgPCAxKSB7XG5cdFx0XHRcdHJldHVybiAtMC41ICogTWF0aC5wb3coMiwgMTAgKiAoayAtIDEpKSAqIE1hdGguc2luKChrIC0gMS4xKSAqIDUgKiBNYXRoLlBJKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIC0xMCAqIChrIC0gMSkpICogTWF0aC5zaW4oKGsgLSAxLjEpICogNSAqIE1hdGguUEkpICsgMTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdEJhY2s6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cblx0XHRcdHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0dmFyIHMgPSAxLjcwMTU4O1xuXG5cdFx0XHRyZXR1cm4gLS1rICogayAqICgocyArIDEpICogayArIHMpICsgMTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0dmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG5cblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDIpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Qm91bmNlOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKGspIHtcblxuXHRcdFx0cmV0dXJuIDEgLSBUV0VFTi5FYXNpbmcuQm91bmNlLk91dCgxIC0gayk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRpZiAoayA8ICgxIC8gMi43NSkpIHtcblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuXHRcdFx0fSBlbHNlIGlmIChrIDwgKDIgLyAyLjc1KSkge1xuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKGsgLT0gKDEuNSAvIDIuNzUpKSAqIGsgKyAwLjc1O1xuXHRcdFx0fSBlbHNlIGlmIChrIDwgKDIuNSAvIDIuNzUpKSB7XG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi4yNSAvIDIuNzUpKSAqIGsgKyAwLjkzNzU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuNjI1IC8gMi43NSkpICogayArIDAuOTg0Mzc1O1xuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoaykge1xuXG5cdFx0XHRpZiAoayA8IDAuNSkge1xuXHRcdFx0XHRyZXR1cm4gVFdFRU4uRWFzaW5nLkJvdW5jZS5JbihrICogMikgKiAwLjU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBUV0VFTi5FYXNpbmcuQm91bmNlLk91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuVFdFRU4uSW50ZXJwb2xhdGlvbiA9IHtcblxuXHRMaW5lYXI6IGZ1bmN0aW9uICh2LCBrKSB7XG5cblx0XHR2YXIgbSA9IHYubGVuZ3RoIC0gMTtcblx0XHR2YXIgZiA9IG0gKiBrO1xuXHRcdHZhciBpID0gTWF0aC5mbG9vcihmKTtcblx0XHR2YXIgZm4gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLlV0aWxzLkxpbmVhcjtcblxuXHRcdGlmIChrIDwgMCkge1xuXHRcdFx0cmV0dXJuIGZuKHZbMF0sIHZbMV0sIGYpO1xuXHRcdH1cblxuXHRcdGlmIChrID4gMSkge1xuXHRcdFx0cmV0dXJuIGZuKHZbbV0sIHZbbSAtIDFdLCBtIC0gZik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZuKHZbaV0sIHZbaSArIDEgPiBtID8gbSA6IGkgKyAxXSwgZiAtIGkpO1xuXG5cdH0sXG5cblx0QmV6aWVyOiBmdW5jdGlvbiAodiwgaykge1xuXG5cdFx0dmFyIGIgPSAwO1xuXHRcdHZhciBuID0gdi5sZW5ndGggLSAxO1xuXHRcdHZhciBwdyA9IE1hdGgucG93O1xuXHRcdHZhciBibiA9IFRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuQmVybnN0ZWluO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG5cdFx0XHRiICs9IHB3KDEgLSBrLCBuIC0gaSkgKiBwdyhrLCBpKSAqIHZbaV0gKiBibihuLCBpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYjtcblxuXHR9LFxuXG5cdENhdG11bGxSb206IGZ1bmN0aW9uICh2LCBrKSB7XG5cblx0XHR2YXIgbSA9IHYubGVuZ3RoIC0gMTtcblx0XHR2YXIgZiA9IG0gKiBrO1xuXHRcdHZhciBpID0gTWF0aC5mbG9vcihmKTtcblx0XHR2YXIgZm4gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLlV0aWxzLkNhdG11bGxSb207XG5cblx0XHRpZiAodlswXSA9PT0gdlttXSkge1xuXG5cdFx0XHRpZiAoayA8IDApIHtcblx0XHRcdFx0aSA9IE1hdGguZmxvb3IoZiA9IG0gKiAoMSArIGspKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuKHZbKGkgLSAxICsgbSkgJSBtXSwgdltpXSwgdlsoaSArIDEpICUgbV0sIHZbKGkgKyAyKSAlIG1dLCBmIC0gaSk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoayA8IDApIHtcblx0XHRcdFx0cmV0dXJuIHZbMF0gLSAoZm4odlswXSwgdlswXSwgdlsxXSwgdlsxXSwgLWYpIC0gdlswXSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChrID4gMSkge1xuXHRcdFx0XHRyZXR1cm4gdlttXSAtIChmbih2W21dLCB2W21dLCB2W20gLSAxXSwgdlttIC0gMV0sIGYgLSBtKSAtIHZbbV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm4odltpID8gaSAtIDEgOiAwXSwgdltpXSwgdlttIDwgaSArIDEgPyBtIDogaSArIDFdLCB2W20gPCBpICsgMiA/IG0gOiBpICsgMl0sIGYgLSBpKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdFV0aWxzOiB7XG5cblx0XHRMaW5lYXI6IGZ1bmN0aW9uIChwMCwgcDEsIHQpIHtcblxuXHRcdFx0cmV0dXJuIChwMSAtIHAwKSAqIHQgKyBwMDtcblxuXHRcdH0sXG5cblx0XHRCZXJuc3RlaW46IGZ1bmN0aW9uIChuLCBpKSB7XG5cblx0XHRcdHZhciBmYyA9IFRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuRmFjdG9yaWFsO1xuXG5cdFx0XHRyZXR1cm4gZmMobikgLyBmYyhpKSAvIGZjKG4gLSBpKTtcblxuXHRcdH0sXG5cblx0XHRGYWN0b3JpYWw6IChmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBhID0gWzFdO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKG4pIHtcblxuXHRcdFx0XHR2YXIgcyA9IDE7XG5cblx0XHRcdFx0aWYgKGFbbl0pIHtcblx0XHRcdFx0XHRyZXR1cm4gYVtuXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAodmFyIGkgPSBuOyBpID4gMTsgaS0tKSB7XG5cdFx0XHRcdFx0cyAqPSBpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YVtuXSA9IHM7XG5cdFx0XHRcdHJldHVybiBzO1xuXG5cdFx0XHR9O1xuXG5cdFx0fSkoKSxcblxuXHRcdENhdG11bGxSb206IGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMywgdCkge1xuXG5cdFx0XHR2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG5cdFx0XHR2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG5cdFx0XHR2YXIgdDIgPSB0ICogdDtcblx0XHRcdHZhciB0MyA9IHQgKiB0MjtcblxuXHRcdFx0cmV0dXJuICgyICogcDEgLSAyICogcDIgKyB2MCArIHYxKSAqIHQzICsgKC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEpICogdDIgKyB2MCAqIHQgKyBwMTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5UV0VFTi52ZXJzaW9uID0gdmVyc2lvbjtcblxuZXhwb3J0IGRlZmF1bHQgVFdFRU47XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tweenjs/tween.js/dist/tween.esm.js\n");

/***/ }),

/***/ "./node_modules/howler/dist/howler.js":
/*!********************************************!*\
  !*** ./node_modules/howler/dist/howler.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n *  howler.js v2.1.3\n *  howlerjs.com\n *\n *  (c) 2013-2019, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create the global controller. All contained methods and properties apply\n   * to all sounds that are currently playing or will be in the future.\n   */\n  var HowlerGlobal = function() {\n    this.init();\n  };\n  HowlerGlobal.prototype = {\n    /**\n     * Initialize the global Howler object.\n     * @return {Howler}\n     */\n    init: function() {\n      var self = this || Howler;\n\n      // Create a global ID counter.\n      self._counter = 1000;\n\n      // Pool of unlocked HTML5 Audio objects.\n      self._html5AudioPool = [];\n      self.html5PoolSize = 10;\n\n      // Internal properties.\n      self._codecs = {};\n      self._howls = [];\n      self._muted = false;\n      self._volume = 1;\n      self._canPlayEvent = 'canplaythrough';\n      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;\n\n      // Public properties.\n      self.masterGain = null;\n      self.noAudio = false;\n      self.usingWebAudio = true;\n      self.autoSuspend = true;\n      self.ctx = null;\n\n      // Set to false to disable the auto audio unlocker.\n      self.autoUnlock = true;\n\n      // Setup the various state values for global tracking.\n      self._setup();\n\n      return self;\n    },\n\n    /**\n     * Get/set the global volume for all sounds.\n     * @param  {Float} vol Volume from 0.0 to 1.0.\n     * @return {Howler/Float}     Returns self or current volume.\n     */\n    volume: function(vol) {\n      var self = this || Howler;\n      vol = parseFloat(vol);\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        self._volume = vol;\n\n        // Don't update any of the nodes if we are muted.\n        if (self._muted) {\n          return self;\n        }\n\n        // When using Web Audio, we just need to adjust the master gain.\n        if (self.usingWebAudio) {\n          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n        }\n\n        // Loop through and change volume for all HTML5 audio nodes.\n        for (var i=0; i<self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and change the volumes.\n            for (var j=0; j<ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n\n              if (sound && sound._node) {\n                sound._node.volume = sound._volume * vol;\n              }\n            }\n          }\n        }\n\n        return self;\n      }\n\n      return self._volume;\n    },\n\n    /**\n     * Handle muting and unmuting globally.\n     * @param  {Boolean} muted Is muted or not.\n     */\n    mute: function(muted) {\n      var self = this || Howler;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      self._muted = muted;\n\n      // With Web Audio, we just need to mute the master gain.\n      if (self.usingWebAudio) {\n        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);\n      }\n\n      // Loop through and mute all HTML5 Audio nodes.\n      for (var i=0; i<self._howls.length; i++) {\n        if (!self._howls[i]._webAudio) {\n          // Get all of the sounds in this Howl group.\n          var ids = self._howls[i]._getSoundIds();\n\n          // Loop through all sounds and mark the audio node as muted.\n          for (var j=0; j<ids.length; j++) {\n            var sound = self._howls[i]._soundById(ids[j]);\n\n            if (sound && sound._node) {\n              sound._node.muted = (muted) ? true : sound._muted;\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Unload and destroy all currently loaded Howl objects.\n     * @return {Howler}\n     */\n    unload: function() {\n      var self = this || Howler;\n\n      for (var i=self._howls.length-1; i>=0; i--) {\n        self._howls[i].unload();\n      }\n\n      // Create a new AudioContext to make sure it is fully reset.\n      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {\n        self.ctx.close();\n        self.ctx = null;\n        setupAudioContext();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for codec support of specific extension.\n     * @param  {String} ext Audio file extention.\n     * @return {Boolean}\n     */\n    codecs: function(ext) {\n      return (this || Howler)._codecs[ext.replace(/^x-/, '')];\n    },\n\n    /**\n     * Setup various state values for global tracking.\n     * @return {Howler}\n     */\n    _setup: function() {\n      var self = this || Howler;\n\n      // Keeps track of the suspend/resume state of the AudioContext.\n      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';\n\n      // Automatically begin the 30-second suspend process\n      self._autoSuspend();\n\n      // Check if audio is available.\n      if (!self.usingWebAudio) {\n        // No audio is available on this system if noAudio is set to true.\n        if (typeof Audio !== 'undefined') {\n          try {\n            var test = new Audio();\n\n            // Check if the canplaythrough event is available.\n            if (typeof test.oncanplaythrough === 'undefined') {\n              self._canPlayEvent = 'canplay';\n            }\n          } catch(e) {\n            self.noAudio = true;\n          }\n        } else {\n          self.noAudio = true;\n        }\n      }\n\n      // Test to make sure audio isn't disabled in Internet Explorer.\n      try {\n        var test = new Audio();\n        if (test.muted) {\n          self.noAudio = true;\n        }\n      } catch (e) {}\n\n      // Check for supported codecs.\n      if (!self.noAudio) {\n        self._setupCodecs();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for browser support for various codecs and cache the results.\n     * @return {Howler}\n     */\n    _setupCodecs: function() {\n      var self = this || Howler;\n      var audioTest = null;\n\n      // Must wrap in a try/catch because IE11 in server mode throws an error.\n      try {\n        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;\n      } catch (err) {\n        return self;\n      }\n\n      if (!audioTest || typeof audioTest.canPlayType !== 'function') {\n        return self;\n      }\n\n      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');\n\n      // Opera version <33 has mixed MP3 support, so we need to check for and block it.\n      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\\/([0-6].)/g);\n      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);\n\n      self._codecs = {\n        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),\n        mpeg: !!mpegTest,\n        opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, ''),\n        ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        wav: !!audioTest.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, ''),\n        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),\n        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),\n        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        weba: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n        webm: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n        dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, ''),\n        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')\n      };\n\n      return self;\n    },\n\n    /**\n     * Some browsers/devices will only allow audio to be played after a user interaction.\n     * Attempt to automatically unlock audio on the first user interaction.\n     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/\n     * @return {Howler}\n     */\n    _unlockAudio: function() {\n      var self = this || Howler;\n\n      // Only run this if Web Audio is supported and it hasn't already been unlocked.\n      if (self._audioUnlocked || !self.ctx) {\n        return;\n      }\n\n      self._audioUnlocked = false;\n      self.autoUnlock = false;\n\n      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.\n      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.\n      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.\n      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {\n        self._mobileUnloaded = true;\n        self.unload();\n      }\n\n      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:\n      // http://stackoverflow.com/questions/24119684\n      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);\n\n      // Call this method on touch start to create and play a buffer,\n      // then check if the audio actually played to determine if\n      // audio has now been unlocked on iOS, Android, etc.\n      var unlock = function(e) {\n        // Create a pool of unlocked HTML5 Audio objects that can\n        // be used for playing sounds without user interaction. HTML5\n        // Audio objects must be individually unlocked, as opposed\n        // to the WebAudio API which only needs a single activation.\n        // This must occur before WebAudio setup or the source.onended\n        // event will not fire.\n        for (var i=0; i<self.html5PoolSize; i++) {\n          try {\n            var audioNode = new Audio();\n\n            // Mark this Audio object as unlocked to ensure it can get returned\n            // to the unlocked pool when released.\n            audioNode._unlocked = true;\n\n            // Add the audio node to the pool.\n            self._releaseHtml5Audio(audioNode);\n          } catch (e) {\n            self.noAudio = true;\n          }\n        }\n\n        // Loop through any assigned audio nodes and unlock them.\n        for (var i=0; i<self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and unlock the audio nodes.\n            for (var j=0; j<ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n\n              if (sound && sound._node && !sound._node._unlocked) {\n                sound._node._unlocked = true;\n                sound._node.load();\n              }\n            }\n          }\n        }\n\n        // Fix Android can not play in suspend state.\n        self._autoResume();\n\n        // Create an empty buffer.\n        var source = self.ctx.createBufferSource();\n        source.buffer = self._scratchBuffer;\n        source.connect(self.ctx.destination);\n\n        // Play the empty buffer.\n        if (typeof source.start === 'undefined') {\n          source.noteOn(0);\n        } else {\n          source.start(0);\n        }\n\n        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.\n        if (typeof self.ctx.resume === 'function') {\n          self.ctx.resume();\n        }\n\n        // Setup a timeout to check that we are unlocked on the next event loop.\n        source.onended = function() {\n          source.disconnect(0);\n\n          // Update the unlocked state and prevent this check from happening again.\n          self._audioUnlocked = true;\n\n          // Remove the touch start listener.\n          document.removeEventListener('touchstart', unlock, true);\n          document.removeEventListener('touchend', unlock, true);\n          document.removeEventListener('click', unlock, true);\n\n          // Let all sounds know that audio has been unlocked.\n          for (var i=0; i<self._howls.length; i++) {\n            self._howls[i]._emit('unlock');\n          }\n        };\n      };\n\n      // Setup a touch start listener to attempt an unlock in.\n      document.addEventListener('touchstart', unlock, true);\n      document.addEventListener('touchend', unlock, true);\n      document.addEventListener('click', unlock, true);\n\n      return self;\n    },\n\n    /**\n     * Get an unlocked HTML5 Audio object from the pool. If none are left,\n     * return a new Audio object and throw a warning.\n     * @return {Audio} HTML5 Audio object.\n     */\n    _obtainHtml5Audio: function() {\n      var self = this || Howler;\n\n      // Return the next object from the pool if one exists.\n      if (self._html5AudioPool.length) {\n        return self._html5AudioPool.pop();\n      }\n\n      //.Check if the audio is locked and throw a warning.\n      var testPlay = new Audio().play();\n      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {\n        testPlay.catch(function() {\n          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');\n        });\n      }\n\n      return new Audio();\n    },\n\n    /**\n     * Return an activated HTML5 Audio object to the pool.\n     * @return {Howler}\n     */\n    _releaseHtml5Audio: function(audio) {\n      var self = this || Howler;\n\n      // Don't add audio to the pool if we don't know if it has been unlocked.\n      if (audio._unlocked) {\n        self._html5AudioPool.push(audio);\n      }\n\n      return self;\n    },\n\n    /**\n     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.\n     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.\n     * @return {Howler}\n     */\n    _autoSuspend: function() {\n      var self = this;\n\n      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      // Check if any sounds are playing.\n      for (var i=0; i<self._howls.length; i++) {\n        if (self._howls[i]._webAudio) {\n          for (var j=0; j<self._howls[i]._sounds.length; j++) {\n            if (!self._howls[i]._sounds[j]._paused) {\n              return self;\n            }\n          }\n        }\n      }\n\n      if (self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n      }\n\n      // If no sound has played after 30 seconds, suspend the context.\n      self._suspendTimer = setTimeout(function() {\n        if (!self.autoSuspend) {\n          return;\n        }\n\n        self._suspendTimer = null;\n        self.state = 'suspending';\n        self.ctx.suspend().then(function() {\n          self.state = 'suspended';\n\n          if (self._resumeAfterSuspend) {\n            delete self._resumeAfterSuspend;\n            self._autoResume();\n          }\n        });\n      }, 30000);\n\n      return self;\n    },\n\n    /**\n     * Automatically resume the Web Audio AudioContext when a new sound is played.\n     * @return {Howler}\n     */\n    _autoResume: function() {\n      var self = this;\n\n      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      if (self.state === 'running' && self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n        self._suspendTimer = null;\n      } else if (self.state === 'suspended') {\n        self.ctx.resume().then(function() {\n          self.state = 'running';\n\n          // Emit to all Howls that the audio has resumed.\n          for (var i=0; i<self._howls.length; i++) {\n            self._howls[i]._emit('resume');\n          }\n        });\n\n        if (self._suspendTimer) {\n          clearTimeout(self._suspendTimer);\n          self._suspendTimer = null;\n        }\n      } else if (self.state === 'suspending') {\n        self._resumeAfterSuspend = true;\n      }\n\n      return self;\n    }\n  };\n\n  // Setup the global audio controller.\n  var Howler = new HowlerGlobal();\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create an audio group controller.\n   * @param {Object} o Passed in properties for this group.\n   */\n  var Howl = function(o) {\n    var self = this;\n\n    // Throw an error if no source is provided.\n    if (!o.src || o.src.length === 0) {\n      console.error('An array of source files must be passed with any new Howl.');\n      return;\n    }\n\n    self.init(o);\n  };\n  Howl.prototype = {\n    /**\n     * Initialize a new Howl group object.\n     * @param  {Object} o Passed in properties for this group.\n     * @return {Howl}\n     */\n    init: function(o) {\n      var self = this;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!Howler.ctx) {\n        setupAudioContext();\n      }\n\n      // Setup user-defined default properties.\n      self._autoplay = o.autoplay || false;\n      self._format = (typeof o.format !== 'string') ? o.format : [o.format];\n      self._html5 = o.html5 || false;\n      self._muted = o.mute || false;\n      self._loop = o.loop || false;\n      self._pool = o.pool || 5;\n      self._preload = (typeof o.preload === 'boolean') ? o.preload : true;\n      self._rate = o.rate || 1;\n      self._sprite = o.sprite || {};\n      self._src = (typeof o.src !== 'string') ? o.src : [o.src];\n      self._volume = o.volume !== undefined ? o.volume : 1;\n      self._xhrWithCredentials = o.xhrWithCredentials || false;\n\n      // Setup all other default properties.\n      self._duration = 0;\n      self._state = 'unloaded';\n      self._sounds = [];\n      self._endTimers = {};\n      self._queue = [];\n      self._playLock = false;\n\n      // Setup event listeners.\n      self._onend = o.onend ? [{fn: o.onend}] : [];\n      self._onfade = o.onfade ? [{fn: o.onfade}] : [];\n      self._onload = o.onload ? [{fn: o.onload}] : [];\n      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];\n      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];\n      self._onpause = o.onpause ? [{fn: o.onpause}] : [];\n      self._onplay = o.onplay ? [{fn: o.onplay}] : [];\n      self._onstop = o.onstop ? [{fn: o.onstop}] : [];\n      self._onmute = o.onmute ? [{fn: o.onmute}] : [];\n      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];\n      self._onrate = o.onrate ? [{fn: o.onrate}] : [];\n      self._onseek = o.onseek ? [{fn: o.onseek}] : [];\n      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];\n      self._onresume = [];\n\n      // Web Audio or HTML5 Audio?\n      self._webAudio = Howler.usingWebAudio && !self._html5;\n\n      // Automatically try to enable audio.\n      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {\n        Howler._unlockAudio();\n      }\n\n      // Keep track of this Howl group in the global controller.\n      Howler._howls.push(self);\n\n      // If they selected autoplay, add a play event to the load queue.\n      if (self._autoplay) {\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play();\n          }\n        });\n      }\n\n      // Load the source file unless otherwise specified.\n      if (self._preload) {\n        self.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Load the audio file.\n     * @return {Howler}\n     */\n    load: function() {\n      var self = this;\n      var url = null;\n\n      // If no audio is available, quit immediately.\n      if (Howler.noAudio) {\n        self._emit('loaderror', null, 'No audio support.');\n        return;\n      }\n\n      // Make sure our source is in an array.\n      if (typeof self._src === 'string') {\n        self._src = [self._src];\n      }\n\n      // Loop through the sources and pick the first one that is compatible.\n      for (var i=0; i<self._src.length; i++) {\n        var ext, str;\n\n        if (self._format && self._format[i]) {\n          // If an extension was specified, use that instead.\n          ext = self._format[i];\n        } else {\n          // Make sure the source is a string.\n          str = self._src[i];\n          if (typeof str !== 'string') {\n            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');\n            continue;\n          }\n\n          // Extract the file extension from the URL or base64 data URI.\n          ext = /^data:audio\\/([^;,]+);/i.exec(str);\n          if (!ext) {\n            ext = /\\.([^.]+)$/.exec(str.split('?', 1)[0]);\n          }\n\n          if (ext) {\n            ext = ext[1].toLowerCase();\n          }\n        }\n\n        // Log a warning if no extension was found.\n        if (!ext) {\n          console.warn('No file extension was found. Consider using the \"format\" property or specify an extension.');\n        }\n\n        // Check if this extension is available.\n        if (ext && Howler.codecs(ext)) {\n          url = self._src[i];\n          break;\n        }\n      }\n\n      if (!url) {\n        self._emit('loaderror', null, 'No codec support for selected audio sources.');\n        return;\n      }\n\n      self._src = url;\n      self._state = 'loading';\n\n      // If the hosting page is HTTPS and the source isn't,\n      // drop down to HTML5 Audio to avoid Mixed Content errors.\n      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {\n        self._html5 = true;\n        self._webAudio = false;\n      }\n\n      // Create a new sound object and add it to the pool.\n      new Sound(self);\n\n      // Load and decode the audio data for playback.\n      if (self._webAudio) {\n        loadBuffer(self);\n      }\n\n      return self;\n    },\n\n    /**\n     * Play a sound or resume previous playback.\n     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Number}          Sound ID.\n     */\n    play: function(sprite, internal) {\n      var self = this;\n      var id = null;\n\n      // Determine if a sprite, sound id or nothing was passed\n      if (typeof sprite === 'number') {\n        id = sprite;\n        sprite = null;\n      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {\n        // If the passed sprite doesn't exist, do nothing.\n        return null;\n      } else if (typeof sprite === 'undefined') {\n        // Use the default sound sprite (plays the full audio length).\n        sprite = '__default';\n\n        // Check if there is a single paused sound that isn't ended. \n        // If there is, play that sound. If not, continue as usual.  \n        if (!self._playLock) {\n          var num = 0;\n          for (var i=0; i<self._sounds.length; i++) {\n            if (self._sounds[i]._paused && !self._sounds[i]._ended) {\n              num++;\n              id = self._sounds[i]._id;\n            }\n          }\n\n          if (num === 1) {\n            sprite = null;\n          } else {\n            id = null;\n          }\n        }\n      }\n\n      // Get the selected node, or get one from the pool.\n      var sound = id ? self._soundById(id) : self._inactiveSound();\n\n      // If the sound doesn't exist, do nothing.\n      if (!sound) {\n        return null;\n      }\n\n      // Select the sprite definition.\n      if (id && !sprite) {\n        sprite = sound._sprite || '__default';\n      }\n\n      // If the sound hasn't loaded, we must wait to get the audio's duration.\n      // We also need to wait to make sure we don't run into race conditions with\n      // the order of function calls.\n      if (self._state !== 'loaded') {\n        // Set the sprite value on this sound.\n        sound._sprite = sprite;\n\n        // Mark this sound as not ended in case another sound is played before this one loads.\n        sound._ended = false;\n\n        // Add the sound to the queue to be played on load.\n        var soundId = sound._id;\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play(soundId);\n          }\n        });\n\n        return soundId;\n      }\n\n      // Don't play the sound if an id was passed and it is already playing.\n      if (id && !sound._paused) {\n        // Trigger the play event, in order to keep iterating through queue.\n        if (!internal) {\n          self._loadQueue('play');\n        }\n\n        return sound._id;\n      }\n\n      // Make sure the AudioContext isn't suspended, and resume it if it is.\n      if (self._webAudio) {\n        Howler._autoResume();\n      }\n\n      // Determine how long to play for and where to start playing.\n      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);\n      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);\n      var timeout = (duration * 1000) / Math.abs(sound._rate);\n      var start = self._sprite[sprite][0] / 1000;\n      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;\n      sound._sprite = sprite;\n\n      // Mark the sound as ended instantly so that this async playback\n      // doesn't get grabbed by another call to play while this one waits to start.\n      sound._ended = false;\n\n      // Update the parameters of the sound.\n      var setParams = function() {\n        sound._paused = false;\n        sound._seek = seek;\n        sound._start = start;\n        sound._stop = stop;\n        sound._loop = !!(sound._loop || self._sprite[sprite][2]);\n      };\n\n      // End the sound instantly if seek is at the end.\n      if (seek >= stop) {\n        self._ended(sound);\n        return;\n      }\n\n      // Begin the actual playback.\n      var node = sound._node;\n      if (self._webAudio) {\n        // Fire this when the sound is ready to play to begin Web Audio playback.\n        var playWebAudio = function() {\n          self._playLock = false;\n          setParams();\n          self._refreshBuffer(sound);\n\n          // Setup the playback params.\n          var vol = (sound._muted || self._muted) ? 0 : sound._volume;\n          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n          sound._playStart = Howler.ctx.currentTime;\n\n          // Play the sound using the supported method.\n          if (typeof node.bufferSource.start === 'undefined') {\n            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);\n          } else {\n            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);\n          }\n\n          // Start a new timer if none is present.\n          if (timeout !== Infinity) {\n            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n          }\n\n          if (!internal) {\n            setTimeout(function() {\n              self._emit('play', sound._id);\n              self._loadQueue();\n            }, 0);\n          }\n        };\n\n        if (Howler.state === 'running') {\n          playWebAudio();\n        } else {\n          self._playLock = true;\n\n          // Wait for the audio context to resume before playing.\n          self.once('resume', playWebAudio);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      } else {\n        // Fire this when the sound is ready to play to begin HTML5 Audio playback.\n        var playHtml5 = function() {\n          node.currentTime = seek;\n          node.muted = sound._muted || self._muted || Howler._muted || node.muted;\n          node.volume = sound._volume * Howler.volume();\n          node.playbackRate = sound._rate;\n\n          // Some browsers will throw an error if this is called without user interaction.\n          try {\n            var play = node.play();\n\n            // Support older browsers that don't support promises, and thus don't have this issue.\n            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {\n              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().\n              self._playLock = true;\n\n              // Set param values immediately.\n              setParams();\n\n              // Releases the lock and executes queued actions.\n              play\n                .then(function() {\n                  self._playLock = false;\n                  node._unlocked = true;\n                  if (!internal) {\n                    self._emit('play', sound._id);\n                    self._loadQueue();\n                  }\n                })\n                .catch(function() {\n                  self._playLock = false;\n                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +\n                    'on mobile devices and Chrome where playback was not within a user interaction.');\n\n                  // Reset the ended and paused values.\n                  sound._ended = true;\n                  sound._paused = true;\n                });\n            } else if (!internal) {\n              self._playLock = false;\n              setParams();\n              self._emit('play', sound._id);\n              self._loadQueue();\n            }\n\n            // Setting rate before playing won't work in IE, so we set it again here.\n            node.playbackRate = sound._rate;\n\n            // If the node is still paused, then we can assume there was a playback issue.\n            if (node.paused) {\n              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +\n                'on mobile devices and Chrome where playback was not within a user interaction.');\n              return;\n            }\n\n            // Setup the end timer on sprites or listen for the ended event.\n            if (sprite !== '__default' || sound._loop) {\n              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n            } else {\n              self._endTimers[sound._id] = function() {\n                // Fire ended on this audio node.\n                self._ended(sound);\n\n                // Clear this listener.\n                node.removeEventListener('ended', self._endTimers[sound._id], false);\n              };\n              node.addEventListener('ended', self._endTimers[sound._id], false);\n            }\n          } catch (err) {\n            self._emit('playerror', sound._id, err);\n          }\n        };\n\n        // If this is streaming audio, make sure the src is set and load again.\n        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {\n          node.src = self._src;\n          node.load();\n        }\n\n        // Play immediately if ready, or wait for the 'canplaythrough'e vent.\n        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);\n        if (node.readyState >= 3 || loadedNoReadyState) {\n          playHtml5();\n        } else {\n          self._playLock = true;\n\n          var listener = function() {\n            // Begin playback.\n            playHtml5();\n\n            // Clear this listener.\n            node.removeEventListener(Howler._canPlayEvent, listener, false);\n          };\n          node.addEventListener(Howler._canPlayEvent, listener, false);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      }\n\n      return sound._id;\n    },\n\n    /**\n     * Pause playback and save current position.\n     * @param  {Number} id The sound ID (empty to pause all in group).\n     * @return {Howl}\n     */\n    pause: function(id) {\n      var self = this;\n\n      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'pause',\n          action: function() {\n            self.pause(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be paused.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound && !sound._paused) {\n          // Reset the seek position.\n          sound._seek = self.seek(ids[i]);\n          sound._rateSeek = 0;\n          sound._paused = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound has been created.\n              if (!sound._node.bufferSource) {\n                continue;\n              }\n\n              if (typeof sound._node.bufferSource.stop === 'undefined') {\n                sound._node.bufferSource.noteOff(0);\n              } else {\n                sound._node.bufferSource.stop(0);\n              }\n\n              // Clean up the buffer source.\n              self._cleanBuffer(sound._node);\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.pause();\n            }\n          }\n        }\n\n        // Fire the pause event, unless `true` is passed as the 2nd argument.\n        if (!arguments[1]) {\n          self._emit('pause', sound ? sound._id : null);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Stop playback and reset to start.\n     * @param  {Number} id The sound ID (empty to stop all in group).\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Howl}\n     */\n    stop: function(id, internal) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to stop when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'stop',\n          action: function() {\n            self.stop(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be stopped.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          // Reset the seek position.\n          sound._seek = sound._start || 0;\n          sound._rateSeek = 0;\n          sound._paused = true;\n          sound._ended = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound's AudioBufferSourceNode has been created.\n              if (sound._node.bufferSource) {\n                if (typeof sound._node.bufferSource.stop === 'undefined') {\n                  sound._node.bufferSource.noteOff(0);\n                } else {\n                  sound._node.bufferSource.stop(0);\n                }\n\n                // Clean up the buffer source.\n                self._cleanBuffer(sound._node);\n              }\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.currentTime = sound._start || 0;\n              sound._node.pause();\n\n              // If this is a live stream, stop download once the audio is stopped.\n              if (sound._node.duration === Infinity) {\n                self._clearSound(sound._node);\n              }\n            }\n          }\n\n          if (!internal) {\n            self._emit('stop', sound._id);\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Mute/unmute a single sound or all sounds in this Howl group.\n     * @param  {Boolean} muted Set to true to mute and false to unmute.\n     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).\n     * @return {Howl}\n     */\n    mute: function(muted, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to mute when capable.\n      if (self._state !== 'loaded'|| self._playLock) {\n        self._queue.push({\n          event: 'mute',\n          action: function() {\n            self.mute(muted, id);\n          }\n        });\n\n        return self;\n      }\n\n      // If applying mute/unmute to all sounds, update the group's value.\n      if (typeof id === 'undefined') {\n        if (typeof muted === 'boolean') {\n          self._muted = muted;\n        } else {\n          return self._muted;\n        }\n      }\n\n      // If no id is passed, get all ID's to be muted.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._muted = muted;\n\n          // Cancel active fade and set the volume to the end value.\n          if (sound._interval) {\n            self._stopFade(sound._id);\n          }\n\n          if (self._webAudio && sound._node) {\n            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);\n          } else if (sound._node) {\n            sound._node.muted = Howler._muted ? true : muted;\n          }\n\n          self._emit('mute', sound._id);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.\n     *   volume() -> Returns the group's volume value.\n     *   volume(id) -> Returns the sound id's current volume.\n     *   volume(vol) -> Sets the volume of all sounds in this Howl group.\n     *   volume(vol, id) -> Sets the volume of passed sound id.\n     * @return {Howl/Number} Returns self or current volume.\n     */\n    volume: function() {\n      var self = this;\n      var args = arguments;\n      var vol, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // Return the value of the groups' volume.\n        return self._volume;\n      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {\n        // First check if this is an ID, and if not, assume it is a new volume.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          vol = parseFloat(args[0]);\n        }\n      } else if (args.length >= 2) {\n        vol = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the volume or return the current volume.\n      var sound;\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        // If the sound hasn't loaded, add it to the load queue to change volume when capable.\n        if (self._state !== 'loaded'|| self._playLock) {\n          self._queue.push({\n            event: 'volume',\n            action: function() {\n              self.volume.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group volume.\n        if (typeof id === 'undefined') {\n          self._volume = vol;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            sound._volume = vol;\n\n            // Stop currently running fades.\n            if (!args[2]) {\n              self._stopFade(id[i]);\n            }\n\n            if (self._webAudio && sound._node && !sound._muted) {\n              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n            } else if (sound._node && !sound._muted) {\n              sound._node.volume = vol * Howler.volume();\n            }\n\n            self._emit('volume', sound._id);\n          }\n        }\n      } else {\n        sound = id ? self._soundById(id) : self._sounds[0];\n        return sound ? sound._volume : 0;\n      }\n\n      return self;\n    },\n\n    /**\n     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id (omit to fade all sounds).\n     * @return {Howl}\n     */\n    fade: function(from, to, len, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to fade when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'fade',\n          action: function() {\n            self.fade(from, to, len, id);\n          }\n        });\n\n        return self;\n      }\n\n      // Make sure the to/from/len values are numbers.\n      from = parseFloat(from);\n      to = parseFloat(to);\n      len = parseFloat(len);\n\n      // Set the volume to the start position.\n      self.volume(from, id);\n\n      // Fade the volume of one or all sounds.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        // Create a linear fade or fall back to timeouts with HTML5 Audio.\n        if (sound) {\n          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).\n          if (!id) {\n            self._stopFade(ids[i]);\n          }\n\n          // If we are using Web Audio, let the native methods do the actual fade.\n          if (self._webAudio && !sound._muted) {\n            var currentTime = Howler.ctx.currentTime;\n            var end = currentTime + (len / 1000);\n            sound._volume = from;\n            sound._node.gain.setValueAtTime(from, currentTime);\n            sound._node.gain.linearRampToValueAtTime(to, end);\n          }\n\n          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Starts the internal interval to fade a sound.\n     * @param  {Object} sound Reference to sound to fade.\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id to fade.\n     * @param  {Boolean} isGroup   If true, set the volume on the group.\n     */\n    _startFadeInterval: function(sound, from, to, len, id, isGroup) {\n      var self = this;\n      var vol = from;\n      var diff = to - from;\n      var steps = Math.abs(diff / 0.01);\n      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);\n      var lastTick = Date.now();\n\n      // Store the value being faded to.\n      sound._fadeTo = to;\n\n      // Update the volume value on each interval tick.\n      sound._interval = setInterval(function() {\n        // Update the volume based on the time since the last tick.\n        var tick = (Date.now() - lastTick) / len;\n        lastTick = Date.now();\n        vol += diff * tick;\n\n        // Make sure the volume is in the right bounds.\n        vol = Math.max(0, vol);\n        vol = Math.min(1, vol);\n\n        // Round to within 2 decimal points.\n        vol = Math.round(vol * 100) / 100;\n\n        // Change the volume.\n        if (self._webAudio) {\n          sound._volume = vol;\n        } else {\n          self.volume(vol, sound._id, true);\n        }\n\n        // Set the group's volume.\n        if (isGroup) {\n          self._volume = vol;\n        }\n\n        // When the fade is complete, stop it and fire event.\n        if ((to < from && vol <= to) || (to > from && vol >= to)) {\n          clearInterval(sound._interval);\n          sound._interval = null;\n          sound._fadeTo = null;\n          self.volume(to, sound._id);\n          self._emit('fade', sound._id);\n        }\n      }, stepLen);\n    },\n\n    /**\n     * Internal method that stops the currently playing fade when\n     * a new fade starts, volume is changed or the sound is stopped.\n     * @param  {Number} id The sound id.\n     * @return {Howl}\n     */\n    _stopFade: function(id) {\n      var self = this;\n      var sound = self._soundById(id);\n\n      if (sound && sound._interval) {\n        if (self._webAudio) {\n          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);\n        }\n\n        clearInterval(sound._interval);\n        sound._interval = null;\n        self.volume(sound._fadeTo, id);\n        sound._fadeTo = null;\n        self._emit('fade', id);\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   loop() -> Returns the group's loop value.\n     *   loop(id) -> Returns the sound id's loop value.\n     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.\n     *   loop(loop, id) -> Sets the loop value of passed sound id.\n     * @return {Howl/Boolean} Returns self or current loop value.\n     */\n    loop: function() {\n      var self = this;\n      var args = arguments;\n      var loop, id, sound;\n\n      // Determine the values for loop and id.\n      if (args.length === 0) {\n        // Return the grou's loop value.\n        return self._loop;\n      } else if (args.length === 1) {\n        if (typeof args[0] === 'boolean') {\n          loop = args[0];\n          self._loop = loop;\n        } else {\n          // Return this sound's loop value.\n          sound = self._soundById(parseInt(args[0], 10));\n          return sound ? sound._loop : false;\n        }\n      } else if (args.length === 2) {\n        loop = args[0];\n        id = parseInt(args[1], 10);\n      }\n\n      // If no id is passed, get all ID's to be looped.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._loop = loop;\n          if (self._webAudio && sound._node && sound._node.bufferSource) {\n            sound._node.bufferSource.loop = loop;\n            if (loop) {\n              sound._node.bufferSource.loopStart = sound._start || 0;\n              sound._node.bufferSource.loopEnd = sound._stop;\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   rate() -> Returns the first sound node's current playback rate.\n     *   rate(id) -> Returns the sound id's current playback rate.\n     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.\n     *   rate(rate, id) -> Sets the playback rate of passed sound id.\n     * @return {Howl/Number} Returns self or the current playback rate.\n     */\n    rate: function() {\n      var self = this;\n      var args = arguments;\n      var rate, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current rate of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new rate value.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          rate = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        rate = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the playback rate or return the current value.\n      var sound;\n      if (typeof rate === 'number') {\n        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.\n        if (self._state !== 'loaded' || self._playLock) {\n          self._queue.push({\n            event: 'rate',\n            action: function() {\n              self.rate.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group rate.\n        if (typeof id === 'undefined') {\n          self._rate = rate;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            // Keep track of our position when the rate changed and update the playback\n            // start position so we can properly adjust the seek position for time elapsed.\n            if (self.playing(id[i])) {\n              sound._rateSeek = self.seek(id[i]);\n              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;\n            }\n            sound._rate = rate;\n\n            // Change the playback rate.\n            if (self._webAudio && sound._node && sound._node.bufferSource) {\n              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);\n            } else if (sound._node) {\n              sound._node.playbackRate = rate;\n            }\n\n            // Reset the timers.\n            var seek = self.seek(id[i]);\n            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;\n            var timeout = (duration * 1000) / Math.abs(sound._rate);\n\n            // Start a new end timer if sound is already playing.\n            if (self._endTimers[id[i]] || !sound._paused) {\n              self._clearTimer(id[i]);\n              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);\n            }\n\n            self._emit('rate', sound._id);\n          }\n        }\n      } else {\n        sound = self._soundById(id);\n        return sound ? sound._rate : self._rate;\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   seek() -> Returns the first sound node's current seek position.\n     *   seek(id) -> Returns the sound id's current seek position.\n     *   seek(seek) -> Sets the seek position of the first sound node.\n     *   seek(seek, id) -> Sets the seek position of passed sound id.\n     * @return {Howl/Number} Returns self or the current seek position.\n     */\n    seek: function() {\n      var self = this;\n      var args = arguments;\n      var seek, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current position of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new seek position.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else if (self._sounds.length) {\n          id = self._sounds[0]._id;\n          seek = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        seek = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // If there is no ID, bail out.\n      if (typeof id === 'undefined') {\n        return self;\n      }\n\n      // If the sound hasn't loaded, add it to the load queue to seek when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'seek',\n          action: function() {\n            self.seek.apply(self, args);\n          }\n        });\n\n        return self;\n      }\n\n      // Get the sound.\n      var sound = self._soundById(id);\n\n      if (sound) {\n        if (typeof seek === 'number' && seek >= 0) {\n          // Pause the sound and update position for restarting playback.\n          var playing = self.playing(id);\n          if (playing) {\n            self.pause(id, true);\n          }\n\n          // Move the position of the track and cancel timer.\n          sound._seek = seek;\n          sound._ended = false;\n          self._clearTimer(id);\n\n          // Update the seek position for HTML5 Audio.\n          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {\n            sound._node.currentTime = seek;\n          }\n\n          // Seek and emit when ready.\n          var seekAndEmit = function() {\n            self._emit('seek', id);\n\n            // Restart the playback if the sound was playing.\n            if (playing) {\n              self.play(id, true);\n            }\n          };\n\n          // Wait for the play lock to be unset before emitting (HTML5 Audio).\n          if (playing && !self._webAudio) {\n            var emitSeek = function() {\n              if (!self._playLock) {\n                seekAndEmit();\n              } else {\n                setTimeout(emitSeek, 0);\n              }\n            };\n            setTimeout(emitSeek, 0);\n          } else {\n            seekAndEmit();\n          }\n        } else {\n          if (self._webAudio) {\n            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;\n            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;\n            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));\n          } else {\n            return sound._node.currentTime;\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.\n     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.\n     * @return {Boolean} True if playing and false if not.\n     */\n    playing: function(id) {\n      var self = this;\n\n      // Check the passed sound ID (if any).\n      if (typeof id === 'number') {\n        var sound = self._soundById(id);\n        return sound ? !sound._paused : false;\n      }\n\n      // Otherwise, loop through all sounds and check if any are playing.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (!self._sounds[i]._paused) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Get the duration of this sound. Passing a sound id will return the sprite duration.\n     * @param  {Number} id The sound id to check. If none is passed, return full source duration.\n     * @return {Number} Audio duration in seconds.\n     */\n    duration: function(id) {\n      var self = this;\n      var duration = self._duration;\n\n      // If we pass an ID, get the sound and return the sprite length.\n      var sound = self._soundById(id);\n      if (sound) {\n        duration = self._sprite[sound._sprite][1] / 1000;\n      }\n\n      return duration;\n    },\n\n    /**\n     * Returns the current loaded state of this Howl.\n     * @return {String} 'unloaded', 'loading', 'loaded'\n     */\n    state: function() {\n      return this._state;\n    },\n\n    /**\n     * Unload and destroy the current Howl object.\n     * This will immediately stop all sound instances attached to this group.\n     */\n    unload: function() {\n      var self = this;\n\n      // Stop playing any active sounds.\n      var sounds = self._sounds;\n      for (var i=0; i<sounds.length; i++) {\n        // Stop the sound if it is currently playing.\n        if (!sounds[i]._paused) {\n          self.stop(sounds[i]._id);\n        }\n\n        // Remove the source or disconnect.\n        if (!self._webAudio) {\n          // Set the source to 0-second silence to stop any downloading (except in IE).\n          self._clearSound(sounds[i]._node);\n\n          // Remove any event listeners.\n          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);\n          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);\n\n          // Release the Audio object back to the pool.\n          Howler._releaseHtml5Audio(sounds[i]._node);\n        }\n\n        // Empty out all of the nodes.\n        delete sounds[i]._node;\n\n        // Make sure all timers are cleared out.\n        self._clearTimer(sounds[i]._id);\n      }\n\n      // Remove the references in the global Howler object.\n      var index = Howler._howls.indexOf(self);\n      if (index >= 0) {\n        Howler._howls.splice(index, 1);\n      }\n\n      // Delete this sound from the cache (if no other Howl is using it).\n      var remCache = true;\n      for (i=0; i<Howler._howls.length; i++) {\n        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {\n          remCache = false;\n          break;\n        }\n      }\n\n      if (cache && remCache) {\n        delete cache[self._src];\n      }\n\n      // Clear global errors.\n      Howler.noAudio = false;\n\n      // Clear out `self`.\n      self._state = 'unloaded';\n      self._sounds = [];\n      self = null;\n\n      return null;\n    },\n\n    /**\n     * Listen to a custom event.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.\n     * @return {Howl}\n     */\n    on: function(event, fn, id, once) {\n      var self = this;\n      var events = self['_on' + event];\n\n      if (typeof fn === 'function') {\n        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});\n      }\n\n      return self;\n    },\n\n    /**\n     * Remove a custom event. Call without parameters to remove all events.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to remove. Leave empty to remove all.\n     * @param  {Number}   id    (optional) Only remove events for this sound.\n     * @return {Howl}\n     */\n    off: function(event, fn, id) {\n      var self = this;\n      var events = self['_on' + event];\n      var i = 0;\n\n      // Allow passing just an event and ID.\n      if (typeof fn === 'number') {\n        id = fn;\n        fn = null;\n      }\n\n      if (fn || id) {\n        // Loop through event store and remove the passed function.\n        for (i=0; i<events.length; i++) {\n          var isId = (id === events[i].id);\n          if (fn === events[i].fn && isId || !fn && isId) {\n            events.splice(i, 1);\n            break;\n          }\n        }\n      } else if (event) {\n        // Clear out all events of this type.\n        self['_on' + event] = [];\n      } else {\n        // Clear out all events of every type.\n        var keys = Object.keys(self);\n        for (i=0; i<keys.length; i++) {\n          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {\n            self[keys[i]] = [];\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Listen to a custom event and remove it once fired.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @return {Howl}\n     */\n    once: function(event, fn, id) {\n      var self = this;\n\n      // Setup the event listener.\n      self.on(event, fn, id, 1);\n\n      return self;\n    },\n\n    /**\n     * Emit all events of a specific type and pass the sound id.\n     * @param  {String} event Event name.\n     * @param  {Number} id    Sound ID.\n     * @param  {Number} msg   Message to go with event.\n     * @return {Howl}\n     */\n    _emit: function(event, id, msg) {\n      var self = this;\n      var events = self['_on' + event];\n\n      // Loop through event store and fire all functions.\n      for (var i=events.length-1; i>=0; i--) {\n        // Only fire the listener if the correct ID is used.\n        if (!events[i].id || events[i].id === id || event === 'load') {\n          setTimeout(function(fn) {\n            fn.call(this, id, msg);\n          }.bind(self, events[i].fn), 0);\n\n          // If this event was setup with `once`, remove it.\n          if (events[i].once) {\n            self.off(event, events[i].fn, events[i].id);\n          }\n        }\n      }\n\n      // Pass the event type into load queue so that it can continue stepping.\n      self._loadQueue(event);\n\n      return self;\n    },\n\n    /**\n     * Queue of actions initiated before the sound has loaded.\n     * These will be called in sequence, with the next only firing\n     * after the previous has finished executing (even if async like play).\n     * @return {Howl}\n     */\n    _loadQueue: function(event) {\n      var self = this;\n\n      if (self._queue.length > 0) {\n        var task = self._queue[0];\n\n        // Remove this task if a matching event was passed.\n        if (task.event === event) {\n          self._queue.shift();\n          self._loadQueue();\n        }\n\n        // Run the task if no event type is passed.\n        if (!event) {\n          task.action();\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Fired when playback ends at the end of the duration.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _ended: function(sound) {\n      var self = this;\n      var sprite = sound._sprite;\n\n      // If we are using IE and there was network latency we may be clipping\n      // audio before it completes playing. Lets check the node to make sure it\n      // believes it has completed, before ending the playback.\n      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {\n        setTimeout(self._ended.bind(self, sound), 100);\n        return self;\n      }\n\n      // Should this sound loop?\n      var loop = !!(sound._loop || self._sprite[sprite][2]);\n\n      // Fire the ended event.\n      self._emit('end', sound._id);\n\n      // Restart the playback for HTML5 Audio loop.\n      if (!self._webAudio && loop) {\n        self.stop(sound._id, true).play(sound._id);\n      }\n\n      // Restart this timer if on a Web Audio loop.\n      if (self._webAudio && loop) {\n        self._emit('play', sound._id);\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        sound._playStart = Howler.ctx.currentTime;\n\n        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);\n        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n      }\n\n      // Mark the node as paused.\n      if (self._webAudio && !loop) {\n        sound._paused = true;\n        sound._ended = true;\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        self._clearTimer(sound._id);\n\n        // Clean up the buffer source.\n        self._cleanBuffer(sound._node);\n\n        // Attempt to auto-suspend AudioContext if no sounds are still playing.\n        Howler._autoSuspend();\n      }\n\n      // When using a sprite, end the track.\n      if (!self._webAudio && !loop) {\n        self.stop(sound._id, true);\n      }\n\n      return self;\n    },\n\n    /**\n     * Clear the end timer for a sound playback.\n     * @param  {Number} id The sound ID.\n     * @return {Howl}\n     */\n    _clearTimer: function(id) {\n      var self = this;\n\n      if (self._endTimers[id]) {\n        // Clear the timeout or remove the ended listener.\n        if (typeof self._endTimers[id] !== 'function') {\n          clearTimeout(self._endTimers[id]);\n        } else {\n          var sound = self._soundById(id);\n          if (sound && sound._node) {\n            sound._node.removeEventListener('ended', self._endTimers[id], false);\n          }\n        }\n\n        delete self._endTimers[id];\n      }\n\n      return self;\n    },\n\n    /**\n     * Return the sound identified by this ID, or return null.\n     * @param  {Number} id Sound ID\n     * @return {Object}    Sound object or null.\n     */\n    _soundById: function(id) {\n      var self = this;\n\n      // Loop through all sounds and find the one with this ID.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (id === self._sounds[i]._id) {\n          return self._sounds[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Return an inactive sound from the pool or create a new one.\n     * @return {Sound} Sound playback object.\n     */\n    _inactiveSound: function() {\n      var self = this;\n\n      self._drain();\n\n      // Find the first inactive node to recycle.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          return self._sounds[i].reset();\n        }\n      }\n\n      // If no inactive node was found, create a new one.\n      return new Sound(self);\n    },\n\n    /**\n     * Drain excess inactive sounds from the pool.\n     */\n    _drain: function() {\n      var self = this;\n      var limit = self._pool;\n      var cnt = 0;\n      var i = 0;\n\n      // If there are less sounds than the max pool size, we are done.\n      if (self._sounds.length < limit) {\n        return;\n      }\n\n      // Count the number of inactive sounds.\n      for (i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          cnt++;\n        }\n      }\n\n      // Remove excess inactive sounds, going in reverse order.\n      for (i=self._sounds.length - 1; i>=0; i--) {\n        if (cnt <= limit) {\n          return;\n        }\n\n        if (self._sounds[i]._ended) {\n          // Disconnect the audio source when using Web Audio.\n          if (self._webAudio && self._sounds[i]._node) {\n            self._sounds[i]._node.disconnect(0);\n          }\n\n          // Remove sounds until we have the pool size.\n          self._sounds.splice(i, 1);\n          cnt--;\n        }\n      }\n    },\n\n    /**\n     * Get all ID's from the sounds pool.\n     * @param  {Number} id Only return one ID if one is passed.\n     * @return {Array}    Array of IDs.\n     */\n    _getSoundIds: function(id) {\n      var self = this;\n\n      if (typeof id === 'undefined') {\n        var ids = [];\n        for (var i=0; i<self._sounds.length; i++) {\n          ids.push(self._sounds[i]._id);\n        }\n\n        return ids;\n      } else {\n        return [id];\n      }\n    },\n\n    /**\n     * Load the sound back into the buffer source.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _refreshBuffer: function(sound) {\n      var self = this;\n\n      // Setup the buffer source for playback.\n      sound._node.bufferSource = Howler.ctx.createBufferSource();\n      sound._node.bufferSource.buffer = cache[self._src];\n\n      // Connect to the correct node.\n      if (sound._panner) {\n        sound._node.bufferSource.connect(sound._panner);\n      } else {\n        sound._node.bufferSource.connect(sound._node);\n      }\n\n      // Setup looping and playback rate.\n      sound._node.bufferSource.loop = sound._loop;\n      if (sound._loop) {\n        sound._node.bufferSource.loopStart = sound._start || 0;\n        sound._node.bufferSource.loopEnd = sound._stop || 0;\n      }\n      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);\n\n      return self;\n    },\n\n    /**\n     * Prevent memory leaks by cleaning up the buffer source after playback.\n     * @param  {Object} node Sound's audio node containing the buffer source.\n     * @return {Howl}\n     */\n    _cleanBuffer: function(node) {\n      var self = this;\n      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;\n\n      if (Howler._scratchBuffer && node.bufferSource) {\n        node.bufferSource.onended = null;\n        node.bufferSource.disconnect(0);\n        if (isIOS) {\n          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}\n        }\n      }\n      node.bufferSource = null;\n\n      return self;\n    },\n\n    /**\n     * Set the source to a 0-second silence to stop any downloading (except in IE).\n     * @param  {Object} node Audio node to clear.\n     */\n    _clearSound: function(node) {\n      var checkIE = /MSIE |Trident\\//.test(Howler._navigator && Howler._navigator.userAgent);\n      if (!checkIE) {\n        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';\n      }\n    }\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Setup the sound object, which each node attached to a Howl group is contained in.\n   * @param {Object} howl The Howl parent group.\n   */\n  var Sound = function(howl) {\n    this._parent = howl;\n    this.init();\n  };\n  Sound.prototype = {\n    /**\n     * Initialize a new Sound object.\n     * @return {Sound}\n     */\n    init: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup the default parameters.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a unique ID for this sound.\n      self._id = ++Howler._counter;\n\n      // Add itself to the parent's pool.\n      parent._sounds.push(self);\n\n      // Create the new node.\n      self.create();\n\n      return self;\n    },\n\n    /**\n     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.\n     * @return {Sound}\n     */\n    create: function() {\n      var self = this;\n      var parent = self._parent;\n      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;\n\n      if (parent._webAudio) {\n        // Create the gain node for controlling volume (the source will connect to this).\n        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);\n        self._node.paused = true;\n        self._node.connect(Howler.masterGain);\n      } else if (!Howler.noAudio) {\n        // Get an unlocked Audio object from the pool.\n        self._node = Howler._obtainHtml5Audio();\n\n        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).\n        self._errorFn = self._errorListener.bind(self);\n        self._node.addEventListener('error', self._errorFn, false);\n\n        // Listen for 'canplaythrough' event to let us know the sound is ready.\n        self._loadFn = self._loadListener.bind(self);\n        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);\n\n        // Setup the new audio node.\n        self._node.src = parent._src;\n        self._node.preload = 'auto';\n        self._node.volume = volume * Howler.volume();\n\n        // Begin loading the source.\n        self._node.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Reset the parameters of this sound to the original state (for recycle).\n     * @return {Sound}\n     */\n    reset: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all of the parameters of this sound.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._rateSeek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a new ID so that it isn't confused with the previous sound.\n      self._id = ++Howler._counter;\n\n      return self;\n    },\n\n    /**\n     * HTML5 Audio error listener callback.\n     */\n    _errorListener: function() {\n      var self = this;\n\n      // Fire an error event and pass back the code.\n      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);\n\n      // Clear the event listener.\n      self._node.removeEventListener('error', self._errorFn, false);\n    },\n\n    /**\n     * HTML5 Audio canplaythrough listener callback.\n     */\n    _loadListener: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Round up the duration to account for the lower precision in HTML5 Audio.\n      parent._duration = Math.ceil(self._node.duration * 10) / 10;\n\n      // Setup a sprite if none is defined.\n      if (Object.keys(parent._sprite).length === 0) {\n        parent._sprite = {__default: [0, parent._duration * 1000]};\n      }\n\n      if (parent._state !== 'loaded') {\n        parent._state = 'loaded';\n        parent._emit('load');\n        parent._loadQueue();\n      }\n\n      // Clear the event listener.\n      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);\n    }\n  };\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  var cache = {};\n\n  /**\n   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).\n   * @param  {Howl} self\n   */\n  var loadBuffer = function(self) {\n    var url = self._src;\n\n    // Check if the buffer has already been cached and use it instead.\n    if (cache[url]) {\n      // Set the duration from the cache.\n      self._duration = cache[url].duration;\n\n      // Load the sound into this Howl.\n      loadSound(self);\n\n      return;\n    }\n\n    if (/^data:[^;]+;base64,/.test(url)) {\n      // Decode the base64 data URI without XHR, since some browsers don't support it.\n      var data = atob(url.split(',')[1]);\n      var dataView = new Uint8Array(data.length);\n      for (var i=0; i<data.length; ++i) {\n        dataView[i] = data.charCodeAt(i);\n      }\n\n      decodeAudioData(dataView.buffer, self);\n    } else {\n      // Load the buffer from the URL.\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, true);\n      xhr.withCredentials = self._xhrWithCredentials;\n      xhr.responseType = 'arraybuffer';\n      xhr.onload = function() {\n        // Make sure we get a successful response back.\n        var code = (xhr.status + '')[0];\n        if (code !== '0' && code !== '2' && code !== '3') {\n          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');\n          return;\n        }\n\n        decodeAudioData(xhr.response, self);\n      };\n      xhr.onerror = function() {\n        // If there is an error, switch to HTML5 Audio.\n        if (self._webAudio) {\n          self._html5 = true;\n          self._webAudio = false;\n          self._sounds = [];\n          delete cache[url];\n          self.load();\n        }\n      };\n      safeXhrSend(xhr);\n    }\n  };\n\n  /**\n   * Send the XHR request wrapped in a try/catch.\n   * @param  {Object} xhr XHR to send.\n   */\n  var safeXhrSend = function(xhr) {\n    try {\n      xhr.send();\n    } catch (e) {\n      xhr.onerror();\n    }\n  };\n\n  /**\n   * Decode audio data from an array buffer.\n   * @param  {ArrayBuffer} arraybuffer The audio data.\n   * @param  {Howl}        self\n   */\n  var decodeAudioData = function(arraybuffer, self) {\n    // Fire a load error if something broke.\n    var error = function() {\n      self._emit('loaderror', null, 'Decoding audio data failed.');\n    };\n\n    // Load the sound on success.\n    var success = function(buffer) {\n      if (buffer && self._sounds.length > 0) {\n        cache[self._src] = buffer;\n        loadSound(self, buffer);\n      } else {\n        error();\n      }\n    };\n\n    // Decode the buffer into an audio source.\n    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {\n      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);\n    } else {\n      Howler.ctx.decodeAudioData(arraybuffer, success, error);\n    }\n  }\n\n  /**\n   * Sound is now loaded, so finish setting everything up and fire the loaded event.\n   * @param  {Howl} self\n   * @param  {Object} buffer The decoded buffer sound source.\n   */\n  var loadSound = function(self, buffer) {\n    // Set the duration.\n    if (buffer && !self._duration) {\n      self._duration = buffer.duration;\n    }\n\n    // Setup a sprite if none is defined.\n    if (Object.keys(self._sprite).length === 0) {\n      self._sprite = {__default: [0, self._duration * 1000]};\n    }\n\n    // Fire the loaded event.\n    if (self._state !== 'loaded') {\n      self._state = 'loaded';\n      self._emit('load');\n      self._loadQueue();\n    }\n  };\n\n  /**\n   * Setup the audio context when available, or switch to HTML5 Audio mode.\n   */\n  var setupAudioContext = function() {\n    // If we have already detected that Web Audio isn't supported, don't run this step again.\n    if (!Howler.usingWebAudio) {\n      return;\n    }\n\n    // Check if we are using Web Audio and setup the AudioContext if we are.\n    try {\n      if (typeof AudioContext !== 'undefined') {\n        Howler.ctx = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Howler.ctx = new webkitAudioContext();\n      } else {\n        Howler.usingWebAudio = false;\n      }\n    } catch(e) {\n      Howler.usingWebAudio = false;\n    }\n\n    // If the audio context creation still failed, set using web audio to false.\n    if (!Howler.ctx) {\n      Howler.usingWebAudio = false;\n    }\n\n    // Check if a webview is being used on iOS8 or earlier (rather than the browser).\n    // If it is, disable Web Audio as it causes crashing.\n    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));\n    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n    var version = appVersion ? parseInt(appVersion[1], 10) : null;\n    if (iOS && version && version < 9) {\n      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());\n      if (Howler._navigator && Howler._navigator.standalone && !safari || Howler._navigator && !Howler._navigator.standalone && !safari) {\n        Howler.usingWebAudio = false;\n      }\n    }\n\n    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).\n    if (Howler.usingWebAudio) {\n      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);\n      Howler.masterGain.connect(Howler.ctx.destination);\n    }\n\n    // Re-run the setup on Howler.\n    Howler._setup();\n  };\n\n  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return {\n        Howler: Howler,\n        Howl: Howl\n      };\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  // Add support for CommonJS libraries such as browserify.\n  if (true) {\n    exports.Howler = Howler;\n    exports.Howl = Howl;\n  }\n\n  // Define globally in case AMD is not available or unused.\n  if (typeof window !== 'undefined') {\n    window.HowlerGlobal = HowlerGlobal;\n    window.Howler = Howler;\n    window.Howl = Howl;\n    window.Sound = Sound;\n  } else if (typeof global !== 'undefined') { // Add to global in Node.js (for testing, etc).\n    global.HowlerGlobal = HowlerGlobal;\n    global.Howler = Howler;\n    global.Howl = Howl;\n    global.Sound = Sound;\n  }\n})();\n\n\n/*!\n *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.\n *  \n *  howler.js v2.1.3\n *  howlerjs.com\n *\n *  (c) 2013-2019, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  // Setup default properties.\n  HowlerGlobal.prototype._pos = [0, 0, 0];\n  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Helper method to update the stereo panning position of all current Howls.\n   * Future Howls will not use this value unless explicitly set.\n   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @return {Howler/Number}     Self or current stereo panning value.\n   */\n  HowlerGlobal.prototype.stereo = function(pan) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Loop through all Howls and update their stereo panning.\n    for (var i=self._howls.length-1; i>=0; i--) {\n      self._howls[i].stereo(pan);\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the position of the listener in 3D cartesian space. Sounds using\n   * 3D position will be relative to the listener's position.\n   * @param  {Number} x The x-position of the listener.\n   * @param  {Number} y The y-position of the listener.\n   * @param  {Number} z The z-position of the listener.\n   * @return {Howler/Array}   Self or current listener position.\n   */\n  HowlerGlobal.prototype.pos = function(x, y, z) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._pos[1] : y;\n    z = (typeof z !== 'number') ? self._pos[2] : z;\n\n    if (typeof x === 'number') {\n      self._pos = [x, y, z];\n\n      if (typeof self.ctx.listener.positionX !== 'undefined') {\n        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);\n      } else {\n        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);\n      }\n    } else {\n      return self._pos;\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the listener is pointing in the 3D cartesian space.\n   * A front and up vector must be provided. The front is the direction the\n   * face of the listener is pointing, and up is the direction the top of the\n   * listener is pointing. Thus, these values are expected to be at right angles\n   * from each other.\n   * @param  {Number} x   The x-orientation of the listener.\n   * @param  {Number} y   The y-orientation of the listener.\n   * @param  {Number} z   The z-orientation of the listener.\n   * @param  {Number} xUp The x-orientation of the top of the listener.\n   * @param  {Number} yUp The y-orientation of the top of the listener.\n   * @param  {Number} zUp The z-orientation of the top of the listener.\n   * @return {Howler/Array}     Returns self or the current orientation vectors.\n   */\n  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    var or = self._orientation;\n    y = (typeof y !== 'number') ? or[1] : y;\n    z = (typeof z !== 'number') ? or[2] : z;\n    xUp = (typeof xUp !== 'number') ? or[3] : xUp;\n    yUp = (typeof yUp !== 'number') ? or[4] : yUp;\n    zUp = (typeof zUp !== 'number') ? or[5] : zUp;\n\n    if (typeof x === 'number') {\n      self._orientation = [x, y, z, xUp, yUp, zUp];\n\n      if (typeof self.ctx.listener.forwardX !== 'undefined') {\n        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);\n      } else {\n        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);\n      }\n    } else {\n      return or;\n    }\n\n    return self;\n  };\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core init.\n   * @param  {Function} _super Core init method.\n   * @return {Howl}\n   */\n  Howl.prototype.init = (function(_super) {\n    return function(o) {\n      var self = this;\n\n      // Setup user-defined default properties.\n      self._orientation = o.orientation || [1, 0, 0];\n      self._stereo = o.stereo || null;\n      self._pos = o.pos || null;\n      self._pannerAttr = {\n        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,\n        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,\n        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,\n        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',\n        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,\n        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',\n        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,\n        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1\n      };\n\n      // Setup event listeners.\n      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];\n      self._onpos = o.onpos ? [{fn: o.onpos}] : [];\n      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];\n\n      // Complete initilization with howler.js core's init function.\n      return _super.call(this, o);\n    };\n  })(Howl.prototype.init);\n\n  /**\n   * Get/set the stereo panning of the audio source for this sound or all in the group.\n   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Number}    Returns self or the current stereo panning value.\n   */\n  Howl.prototype.stereo = function(pan, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'stereo',\n        action: function() {\n          self.stereo(pan, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.\n    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';\n\n    // Setup the group's stereo panning if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's stereo panning if no parameters are passed.\n      if (typeof pan === 'number') {\n        self._stereo = pan;\n        self._pos = [pan, 0, 0];\n      } else {\n        return self._stereo;\n      }\n    }\n\n    // Change the streo panning of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof pan === 'number') {\n          sound._stereo = pan;\n          sound._pos = [pan, 0, 0];\n\n          if (sound._node) {\n            // If we are falling back, make sure the panningModel is equalpower.\n            sound._pannerAttr.panningModel = 'equalpower';\n\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || !sound._panner.pan) {\n              setupPanner(sound, pannerType);\n            }\n\n            if (pannerType === 'spatial') {\n              if (typeof sound._panner.positionX !== 'undefined') {\n                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);\n                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);\n                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);\n              } else {\n                sound._panner.setPosition(pan, 0, 0);\n              }\n            } else {\n              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);\n            }\n          }\n\n          self._emit('stereo', sound._id);\n        } else {\n          return sound._stereo;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.\n   * @param  {Number} x  The x-position of the audio source.\n   * @param  {Number} y  The y-position of the audio source.\n   * @param  {Number} z  The z-position of the audio source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].\n   */\n  Howl.prototype.pos = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change position when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'pos',\n        action: function() {\n          self.pos(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? 0 : y;\n    z = (typeof z !== 'number') ? -0.5 : z;\n\n    // Setup the group's spatial position if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial position if no parameters are passed.\n      if (typeof x === 'number') {\n        self._pos = [x, y, z];\n      } else {\n        return self._pos;\n      }\n    }\n\n    // Change the spatial position of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._pos = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || sound._panner.pan) {\n              setupPanner(sound, 'spatial');\n            }\n\n            if (typeof sound._panner.positionX !== 'undefined') {\n              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);\n              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);\n              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);\n            } else {\n              sound._panner.setPosition(x, y, z);\n            }\n          }\n\n          self._emit('pos', sound._id);\n        } else {\n          return sound._pos;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate\n   * space. Depending on how direction the sound is, based on the `cone` attributes,\n   * a sound pointing away from the listener can be quiet or silent.\n   * @param  {Number} x  The x-orientation of the source.\n   * @param  {Number} y  The y-orientation of the source.\n   * @param  {Number} z  The z-orientation of the source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].\n   */\n  Howl.prototype.orientation = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'orientation',\n        action: function() {\n          self.orientation(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._orientation[1] : y;\n    z = (typeof z !== 'number') ? self._orientation[2] : z;\n\n    // Setup the group's spatial orientation if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial orientation if no parameters are passed.\n      if (typeof x === 'number') {\n        self._orientation = [x, y, z];\n      } else {\n        return self._orientation;\n      }\n    }\n\n    // Change the spatial orientation of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._orientation = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner) {\n              // Make sure we have a position to setup the node with.\n              if (!sound._pos) {\n                sound._pos = self._pos || [0, 0, -0.5];\n              }\n\n              setupPanner(sound, 'spatial');\n            }\n\n            if (typeof sound._panner.orientationX !== 'undefined') {\n              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);\n              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);\n              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);\n            } else {\n              sound._panner.setOrientation(x, y, z);\n            }\n          }\n\n          self._emit('orientation', sound._id);\n        } else {\n          return sound._orientation;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the panner node's attributes for a sound or group of sounds.\n   * This method can optionall take 0, 1 or 2 arguments.\n   *   pannerAttr() -> Returns the group's values.\n   *   pannerAttr(id) -> Returns the sound id's values.\n   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.\n   *   pannerAttr(o, id) -> Set's the values of passed sound id.\n   *\n   *   Attributes:\n   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      inside of which there will be no volume reduction.\n   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.\n   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the\n   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.\n   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from\n   *                     listener. Can be `linear`, `inverse` or `exponential.\n   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume\n   *                   will not be reduced any further.\n   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.\n   *                   This is simply a variable of the distance model and has a different effect depending on which model\n   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.\n   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a\n   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ]`\n   *                     with `inverse` and `exponential`.\n   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.\n   *                     Can be `HRTF` or `equalpower`.\n   *\n   * @return {Howl/Object} Returns self or current panner attributes.\n   */\n  Howl.prototype.pannerAttr = function() {\n    var self = this;\n    var args = arguments;\n    var o, id, sound;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // Determine the values based on arguments.\n    if (args.length === 0) {\n      // Return the group's panner attribute values.\n      return self._pannerAttr;\n    } else if (args.length === 1) {\n      if (typeof args[0] === 'object') {\n        o = args[0];\n\n        // Set the grou's panner attribute values.\n        if (typeof id === 'undefined') {\n          if (!o.pannerAttr) {\n            o.pannerAttr = {\n              coneInnerAngle: o.coneInnerAngle,\n              coneOuterAngle: o.coneOuterAngle,\n              coneOuterGain: o.coneOuterGain,\n              distanceModel: o.distanceModel,\n              maxDistance: o.maxDistance,\n              refDistance: o.refDistance,\n              rolloffFactor: o.rolloffFactor,\n              panningModel: o.panningModel\n            };\n          }\n\n          self._pannerAttr = {\n            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,\n            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,\n            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,\n            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,\n            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,\n            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,\n            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,\n            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel\n          };\n        }\n      } else {\n        // Return this sound's panner attribute values.\n        sound = self._soundById(parseInt(args[0], 10));\n        return sound ? sound._pannerAttr : self._pannerAttr;\n      }\n    } else if (args.length === 2) {\n      o = args[0];\n      id = parseInt(args[1], 10);\n    }\n\n    // Update the values of the specified sounds.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      sound = self._soundById(ids[i]);\n\n      if (sound) {\n        // Merge the new values into the sound.\n        var pa = sound._pannerAttr;\n        pa = {\n          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,\n          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,\n          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,\n          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,\n          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,\n          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,\n          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,\n          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel\n        };\n\n        // Update the panner values or create a new panner if none exists.\n        var panner = sound._panner;\n        if (panner) {\n          panner.coneInnerAngle = pa.coneInnerAngle;\n          panner.coneOuterAngle = pa.coneOuterAngle;\n          panner.coneOuterGain = pa.coneOuterGain;\n          panner.distanceModel = pa.distanceModel;\n          panner.maxDistance = pa.maxDistance;\n          panner.refDistance = pa.refDistance;\n          panner.rolloffFactor = pa.rolloffFactor;\n          panner.panningModel = pa.panningModel;\n        } else {\n          // Make sure we have a position to setup the node with.\n          if (!sound._pos) {\n            sound._pos = self._pos || [0, 0, -0.5];\n          }\n\n          // Create a new panner node.\n          setupPanner(sound, 'spatial');\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core Sound init.\n   * @param  {Function} _super Core Sound init method.\n   * @return {Sound}\n   */\n  Sound.prototype.init = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup user-defined default properties.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // Complete initilization with howler.js core Sound's init function.\n      _super.call(this);\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      }\n    };\n  })(Sound.prototype.init);\n\n  /**\n   * Override the Sound.reset method to clean up properties from the spatial plugin.\n   * @param  {Function} _super Sound reset method.\n   * @return {Sound}\n   */\n  Sound.prototype.reset = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all spatial plugin properties on this sound.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      } else if (self._panner) {\n        // Disconnect the panner.\n        self._panner.disconnect(0);\n        self._panner = undefined;\n        parent._refreshBuffer(self);\n      }\n\n      // Complete resetting of the sound.\n      return _super.call(this);\n    };\n  })(Sound.prototype.reset);\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create a new panner node and save it on the sound.\n   * @param  {Sound} sound Specific sound to setup panning on.\n   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.\n   */\n  var setupPanner = function(sound, type) {\n    type = type || 'spatial';\n\n    // Create the new panner node.\n    if (type === 'spatial') {\n      sound._panner = Howler.ctx.createPanner();\n      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;\n      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;\n      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;\n      sound._panner.distanceModel = sound._pannerAttr.distanceModel;\n      sound._panner.maxDistance = sound._pannerAttr.maxDistance;\n      sound._panner.refDistance = sound._pannerAttr.refDistance;\n      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;\n      sound._panner.panningModel = sound._pannerAttr.panningModel;\n\n      if (typeof sound._panner.positionX !== 'undefined') {\n        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);\n        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);\n        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);\n      } else {\n        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);\n      }\n\n      if (typeof sound._panner.orientationX !== 'undefined') {\n        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);\n        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);\n        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);\n      } else {\n        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);\n      }\n    } else {\n      sound._panner = Howler.ctx.createStereoPanner();\n      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);\n    }\n\n    sound._panner.connect(sound._node);\n\n    // Update the connections.\n    if (!sound._paused) {\n      sound._parent.pause(sound._id, true).play(sound._id, true);\n    }\n  };\n})();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaG93bGVyL2Rpc3QvaG93bGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hvd2xlci9kaXN0L2hvd2xlci5qcz83ZGY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogIGhvd2xlci5qcyB2Mi4xLjNcbiAqICBob3dsZXJqcy5jb21cbiAqXG4gKiAgKGMpIDIwMTMtMjAxOSwgSmFtZXMgU2ltcHNvbiBvZiBHb2xkRmlyZSBTdHVkaW9zXG4gKiAgZ29sZGZpcmVzdHVkaW9zLmNvbVxuICpcbiAqICBNSVQgTGljZW5zZVxuICovXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqIEdsb2JhbCBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGdsb2JhbCBjb250cm9sbGVyLiBBbGwgY29udGFpbmVkIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgYXBwbHlcbiAgICogdG8gYWxsIHNvdW5kcyB0aGF0IGFyZSBjdXJyZW50bHkgcGxheWluZyBvciB3aWxsIGJlIGluIHRoZSBmdXR1cmUuXG4gICAqL1xuICB2YXIgSG93bGVyR2xvYmFsID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gIH07XG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgZ2xvYmFsIEhvd2xlciBvYmplY3QuXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgLy8gQ3JlYXRlIGEgZ2xvYmFsIElEIGNvdW50ZXIuXG4gICAgICBzZWxmLl9jb3VudGVyID0gMTAwMDtcblxuICAgICAgLy8gUG9vbCBvZiB1bmxvY2tlZCBIVE1MNSBBdWRpbyBvYmplY3RzLlxuICAgICAgc2VsZi5faHRtbDVBdWRpb1Bvb2wgPSBbXTtcbiAgICAgIHNlbGYuaHRtbDVQb29sU2l6ZSA9IDEwO1xuXG4gICAgICAvLyBJbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5fY29kZWNzID0ge307XG4gICAgICBzZWxmLl9ob3dscyA9IFtdO1xuICAgICAgc2VsZi5fbXV0ZWQgPSBmYWxzZTtcbiAgICAgIHNlbGYuX3ZvbHVtZSA9IDE7XG4gICAgICBzZWxmLl9jYW5QbGF5RXZlbnQgPSAnY2FucGxheXRocm91Z2gnO1xuICAgICAgc2VsZi5fbmF2aWdhdG9yID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IpID8gd2luZG93Lm5hdmlnYXRvciA6IG51bGw7XG5cbiAgICAgIC8vIFB1YmxpYyBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5tYXN0ZXJHYWluID0gbnVsbDtcbiAgICAgIHNlbGYubm9BdWRpbyA9IGZhbHNlO1xuICAgICAgc2VsZi51c2luZ1dlYkF1ZGlvID0gdHJ1ZTtcbiAgICAgIHNlbGYuYXV0b1N1c3BlbmQgPSB0cnVlO1xuICAgICAgc2VsZi5jdHggPSBudWxsO1xuXG4gICAgICAvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGUgYXV0byBhdWRpbyB1bmxvY2tlci5cbiAgICAgIHNlbGYuYXV0b1VubG9jayA9IHRydWU7XG5cbiAgICAgIC8vIFNldHVwIHRoZSB2YXJpb3VzIHN0YXRlIHZhbHVlcyBmb3IgZ2xvYmFsIHRyYWNraW5nLlxuICAgICAgc2VsZi5fc2V0dXAoKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldC9zZXQgdGhlIGdsb2JhbCB2b2x1bWUgZm9yIGFsbCBzb3VuZHMuXG4gICAgICogQHBhcmFtICB7RmxvYXR9IHZvbCBWb2x1bWUgZnJvbSAwLjAgdG8gMS4wLlxuICAgICAqIEByZXR1cm4ge0hvd2xlci9GbG9hdH0gICAgIFJldHVybnMgc2VsZiBvciBjdXJyZW50IHZvbHVtZS5cbiAgICAgKi9cbiAgICB2b2x1bWU6IGZ1bmN0aW9uKHZvbCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcbiAgICAgIHZvbCA9IHBhcnNlRmxvYXQodm9sKTtcblxuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBBdWRpb0NvbnRleHQgY3JlYXRlZCB5ZXQsIHJ1biB0aGUgc2V0dXAuXG4gICAgICBpZiAoIXNlbGYuY3R4KSB7XG4gICAgICAgIHNldHVwQXVkaW9Db250ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygdm9sICE9PSAndW5kZWZpbmVkJyAmJiB2b2wgPj0gMCAmJiB2b2wgPD0gMSkge1xuICAgICAgICBzZWxmLl92b2x1bWUgPSB2b2w7XG5cbiAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIGFueSBvZiB0aGUgbm9kZXMgaWYgd2UgYXJlIG11dGVkLlxuICAgICAgICBpZiAoc2VsZi5fbXV0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gdXNpbmcgV2ViIEF1ZGlvLCB3ZSBqdXN0IG5lZWQgdG8gYWRqdXN0IHRoZSBtYXN0ZXIgZ2Fpbi5cbiAgICAgICAgaWYgKHNlbGYudXNpbmdXZWJBdWRpbykge1xuICAgICAgICAgIHNlbGYubWFzdGVyR2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKHZvbCwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggYW5kIGNoYW5nZSB2b2x1bWUgZm9yIGFsbCBIVE1MNSBhdWRpbyBub2Rlcy5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX2hvd2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLl9ob3dsc1tpXS5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAgIC8vIEdldCBhbGwgb2YgdGhlIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICAgICAgICB2YXIgaWRzID0gc2VsZi5faG93bHNbaV0uX2dldFNvdW5kSWRzKCk7XG5cbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgc291bmRzIGFuZCBjaGFuZ2UgdGhlIHZvbHVtZXMuXG4gICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8aWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX2hvd2xzW2ldLl9zb3VuZEJ5SWQoaWRzW2pdKTtcblxuICAgICAgICAgICAgICBpZiAoc291bmQgJiYgc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS52b2x1bWUgPSBzb3VuZC5fdm9sdW1lICogdm9sO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLl92b2x1bWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBtdXRpbmcgYW5kIHVubXV0aW5nIGdsb2JhbGx5LlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IG11dGVkIElzIG11dGVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICBtdXRlOiBmdW5jdGlvbihtdXRlZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBBdWRpb0NvbnRleHQgY3JlYXRlZCB5ZXQsIHJ1biB0aGUgc2V0dXAuXG4gICAgICBpZiAoIXNlbGYuY3R4KSB7XG4gICAgICAgIHNldHVwQXVkaW9Db250ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX211dGVkID0gbXV0ZWQ7XG5cbiAgICAgIC8vIFdpdGggV2ViIEF1ZGlvLCB3ZSBqdXN0IG5lZWQgdG8gbXV0ZSB0aGUgbWFzdGVyIGdhaW4uXG4gICAgICBpZiAoc2VsZi51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICAgIHNlbGYubWFzdGVyR2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKG11dGVkID8gMCA6IHNlbGYuX3ZvbHVtZSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIExvb3AgdGhyb3VnaCBhbmQgbXV0ZSBhbGwgSFRNTDUgQXVkaW8gbm9kZXMuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5faG93bHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFzZWxmLl9ob3dsc1tpXS5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAvLyBHZXQgYWxsIG9mIHRoZSBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAgICAgIHZhciBpZHMgPSBzZWxmLl9ob3dsc1tpXS5fZ2V0U291bmRJZHMoKTtcblxuICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgc291bmRzIGFuZCBtYXJrIHRoZSBhdWRpbyBub2RlIGFzIG11dGVkLlxuICAgICAgICAgIGZvciAodmFyIGo9MDsgajxpZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX2hvd2xzW2ldLl9zb3VuZEJ5SWQoaWRzW2pdKTtcblxuICAgICAgICAgICAgaWYgKHNvdW5kICYmIHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLm11dGVkID0gKG11dGVkKSA/IHRydWUgOiBzb3VuZC5fbXV0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmxvYWQgYW5kIGRlc3Ryb3kgYWxsIGN1cnJlbnRseSBsb2FkZWQgSG93bCBvYmplY3RzLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICB1bmxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgZm9yICh2YXIgaT1zZWxmLl9ob3dscy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgIHNlbGYuX2hvd2xzW2ldLnVubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgQXVkaW9Db250ZXh0IHRvIG1ha2Ugc3VyZSBpdCBpcyBmdWxseSByZXNldC5cbiAgICAgIGlmIChzZWxmLnVzaW5nV2ViQXVkaW8gJiYgc2VsZi5jdHggJiYgdHlwZW9mIHNlbGYuY3R4LmNsb3NlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWxmLmN0eC5jbG9zZSgpO1xuICAgICAgICBzZWxmLmN0eCA9IG51bGw7XG4gICAgICAgIHNldHVwQXVkaW9Db250ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3IgY29kZWMgc3VwcG9ydCBvZiBzcGVjaWZpYyBleHRlbnNpb24uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBleHQgQXVkaW8gZmlsZSBleHRlbnRpb24uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjb2RlY3M6IGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuICh0aGlzIHx8IEhvd2xlcikuX2NvZGVjc1tleHQucmVwbGFjZSgvXngtLywgJycpXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dXAgdmFyaW91cyBzdGF0ZSB2YWx1ZXMgZm9yIGdsb2JhbCB0cmFja2luZy5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgX3NldHVwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyB8fCBIb3dsZXI7XG5cbiAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBzdXNwZW5kL3Jlc3VtZSBzdGF0ZSBvZiB0aGUgQXVkaW9Db250ZXh0LlxuICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuY3R4ID8gc2VsZi5jdHguc3RhdGUgfHwgJ3N1c3BlbmRlZCcgOiAnc3VzcGVuZGVkJztcblxuICAgICAgLy8gQXV0b21hdGljYWxseSBiZWdpbiB0aGUgMzAtc2Vjb25kIHN1c3BlbmQgcHJvY2Vzc1xuICAgICAgc2VsZi5fYXV0b1N1c3BlbmQoKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgYXVkaW8gaXMgYXZhaWxhYmxlLlxuICAgICAgaWYgKCFzZWxmLnVzaW5nV2ViQXVkaW8pIHtcbiAgICAgICAgLy8gTm8gYXVkaW8gaXMgYXZhaWxhYmxlIG9uIHRoaXMgc3lzdGVtIGlmIG5vQXVkaW8gaXMgc2V0IHRvIHRydWUuXG4gICAgICAgIGlmICh0eXBlb2YgQXVkaW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gbmV3IEF1ZGlvKCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjYW5wbGF5dGhyb3VnaCBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRlc3Qub25jYW5wbGF5dGhyb3VnaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgc2VsZi5fY2FuUGxheUV2ZW50ID0gJ2NhbnBsYXknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgc2VsZi5ub0F1ZGlvID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5ub0F1ZGlvID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUZXN0IHRvIG1ha2Ugc3VyZSBhdWRpbyBpc24ndCBkaXNhYmxlZCBpbiBJbnRlcm5ldCBFeHBsb3Jlci5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0ZXN0ID0gbmV3IEF1ZGlvKCk7XG4gICAgICAgIGlmICh0ZXN0Lm11dGVkKSB7XG4gICAgICAgICAgc2VsZi5ub0F1ZGlvID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgLy8gQ2hlY2sgZm9yIHN1cHBvcnRlZCBjb2RlY3MuXG4gICAgICBpZiAoIXNlbGYubm9BdWRpbykge1xuICAgICAgICBzZWxmLl9zZXR1cENvZGVjcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIGJyb3dzZXIgc3VwcG9ydCBmb3IgdmFyaW91cyBjb2RlY3MgYW5kIGNhY2hlIHRoZSByZXN1bHRzLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfc2V0dXBDb2RlY3M6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcbiAgICAgIHZhciBhdWRpb1Rlc3QgPSBudWxsO1xuXG4gICAgICAvLyBNdXN0IHdyYXAgaW4gYSB0cnkvY2F0Y2ggYmVjYXVzZSBJRTExIGluIHNlcnZlciBtb2RlIHRocm93cyBhbiBlcnJvci5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF1ZGlvVGVzdCA9ICh0eXBlb2YgQXVkaW8gIT09ICd1bmRlZmluZWQnKSA/IG5ldyBBdWRpbygpIDogbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdWRpb1Rlc3QgfHwgdHlwZW9mIGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1wZWdUZXN0ID0gYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tcGVnOycpLnJlcGxhY2UoL15ubyQvLCAnJyk7XG5cbiAgICAgIC8vIE9wZXJhIHZlcnNpb24gPDMzIGhhcyBtaXhlZCBNUDMgc3VwcG9ydCwgc28gd2UgbmVlZCB0byBjaGVjayBmb3IgYW5kIGJsb2NrIGl0LlxuICAgICAgdmFyIGNoZWNrT3BlcmEgPSBzZWxmLl9uYXZpZ2F0b3IgJiYgc2VsZi5fbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvT1BSXFwvKFswLTZdLikvZyk7XG4gICAgICB2YXIgaXNPbGRPcGVyYSA9IChjaGVja09wZXJhICYmIHBhcnNlSW50KGNoZWNrT3BlcmFbMF0uc3BsaXQoJy8nKVsxXSwgMTApIDwgMzMpO1xuXG4gICAgICBzZWxmLl9jb2RlY3MgPSB7XG4gICAgICAgIG1wMzogISEoIWlzT2xkT3BlcmEgJiYgKG1wZWdUZXN0IHx8IGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vbXAzOycpLnJlcGxhY2UoL15ubyQvLCAnJykpKSxcbiAgICAgICAgbXBlZzogISFtcGVnVGVzdCxcbiAgICAgICAgb3B1czogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL29nZzsgY29kZWNzPVwib3B1c1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgb2dnOiAhIWF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIG9nYTogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL29nZzsgY29kZWNzPVwidm9yYmlzXCInKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICB3YXY6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby93YXY7IGNvZGVjcz1cIjFcIicpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIGFhYzogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBjYWY6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby94LWNhZjsnKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBtNGE6ICEhKGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8veC1tNGE7JykgfHwgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tNGE7JykgfHwgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9hYWM7JykpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIG1wNDogISEoYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby94LW1wNDsnKSB8fCBhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL21wNDsnKSB8fCBhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKSkucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgd2ViYTogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL3dlYm07IGNvZGVjcz1cInZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgd2VibTogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL3dlYm07IGNvZGVjcz1cInZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgZG9sYnk6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tcDQ7IGNvZGVjcz1cImVjLTNcIicpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIGZsYWM6ICEhKGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8veC1mbGFjOycpIHx8IGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vZmxhYzsnKSkucmVwbGFjZSgvXm5vJC8sICcnKVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNvbWUgYnJvd3NlcnMvZGV2aWNlcyB3aWxsIG9ubHkgYWxsb3cgYXVkaW8gdG8gYmUgcGxheWVkIGFmdGVyIGEgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgKiBBdHRlbXB0IHRvIGF1dG9tYXRpY2FsbHkgdW5sb2NrIGF1ZGlvIG9uIHRoZSBmaXJzdCB1c2VyIGludGVyYWN0aW9uLlxuICAgICAqIENvbmNlcHQgZnJvbTogaHR0cDovL3BhdWxiYWthdXMuY29tL3R1dG9yaWFscy9odG1sNS93ZWItYXVkaW8tb24taW9zL1xuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfdW5sb2NrQXVkaW86IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgLy8gT25seSBydW4gdGhpcyBpZiBXZWIgQXVkaW8gaXMgc3VwcG9ydGVkIGFuZCBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHVubG9ja2VkLlxuICAgICAgaWYgKHNlbGYuX2F1ZGlvVW5sb2NrZWQgfHwgIXNlbGYuY3R4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fYXVkaW9VbmxvY2tlZCA9IGZhbHNlO1xuICAgICAgc2VsZi5hdXRvVW5sb2NrID0gZmFsc2U7XG5cbiAgICAgIC8vIFNvbWUgbW9iaWxlIGRldmljZXMvcGxhdGZvcm1zIGhhdmUgZGlzdG9ydGlvbiBpc3N1ZXMgd2hlbiBvcGVuaW5nL2Nsb3NpbmcgdGFicyBhbmQvb3Igd2ViIHZpZXdzLlxuICAgICAgLy8gQnVncyBpbiB0aGUgYnJvd3NlciAoZXNwZWNpYWxseSBNb2JpbGUgU2FmYXJpKSBjYW4gY2F1c2UgdGhlIHNhbXBsZVJhdGUgdG8gY2hhbmdlIGZyb20gNDQxMDAgdG8gNDgwMDAuXG4gICAgICAvLyBCeSBjYWxsaW5nIEhvd2xlci51bmxvYWQoKSwgd2UgY3JlYXRlIGEgbmV3IEF1ZGlvQ29udGV4dCB3aXRoIHRoZSBjb3JyZWN0IHNhbXBsZVJhdGUuXG4gICAgICBpZiAoIXNlbGYuX21vYmlsZVVubG9hZGVkICYmIHNlbGYuY3R4LnNhbXBsZVJhdGUgIT09IDQ0MTAwKSB7XG4gICAgICAgIHNlbGYuX21vYmlsZVVubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi51bmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2NyYXRjaCBidWZmZXIgZm9yIGVuYWJsaW5nIGlPUyB0byBkaXNwb3NlIG9mIHdlYiBhdWRpbyBidWZmZXJzIGNvcnJlY3RseSwgYXMgcGVyOlxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNDExOTY4NFxuICAgICAgc2VsZi5fc2NyYXRjaEJ1ZmZlciA9IHNlbGYuY3R4LmNyZWF0ZUJ1ZmZlcigxLCAxLCAyMjA1MCk7XG5cbiAgICAgIC8vIENhbGwgdGhpcyBtZXRob2Qgb24gdG91Y2ggc3RhcnQgdG8gY3JlYXRlIGFuZCBwbGF5IGEgYnVmZmVyLFxuICAgICAgLy8gdGhlbiBjaGVjayBpZiB0aGUgYXVkaW8gYWN0dWFsbHkgcGxheWVkIHRvIGRldGVybWluZSBpZlxuICAgICAgLy8gYXVkaW8gaGFzIG5vdyBiZWVuIHVubG9ja2VkIG9uIGlPUywgQW5kcm9pZCwgZXRjLlxuICAgICAgdmFyIHVubG9jayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgcG9vbCBvZiB1bmxvY2tlZCBIVE1MNSBBdWRpbyBvYmplY3RzIHRoYXQgY2FuXG4gICAgICAgIC8vIGJlIHVzZWQgZm9yIHBsYXlpbmcgc291bmRzIHdpdGhvdXQgdXNlciBpbnRlcmFjdGlvbi4gSFRNTDVcbiAgICAgICAgLy8gQXVkaW8gb2JqZWN0cyBtdXN0IGJlIGluZGl2aWR1YWxseSB1bmxvY2tlZCwgYXMgb3Bwb3NlZFxuICAgICAgICAvLyB0byB0aGUgV2ViQXVkaW8gQVBJIHdoaWNoIG9ubHkgbmVlZHMgYSBzaW5nbGUgYWN0aXZhdGlvbi5cbiAgICAgICAgLy8gVGhpcyBtdXN0IG9jY3VyIGJlZm9yZSBXZWJBdWRpbyBzZXR1cCBvciB0aGUgc291cmNlLm9uZW5kZWRcbiAgICAgICAgLy8gZXZlbnQgd2lsbCBub3QgZmlyZS5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuaHRtbDVQb29sU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBhdWRpb05vZGUgPSBuZXcgQXVkaW8oKTtcblxuICAgICAgICAgICAgLy8gTWFyayB0aGlzIEF1ZGlvIG9iamVjdCBhcyB1bmxvY2tlZCB0byBlbnN1cmUgaXQgY2FuIGdldCByZXR1cm5lZFxuICAgICAgICAgICAgLy8gdG8gdGhlIHVubG9ja2VkIHBvb2wgd2hlbiByZWxlYXNlZC5cbiAgICAgICAgICAgIGF1ZGlvTm9kZS5fdW5sb2NrZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGF1ZGlvIG5vZGUgdG8gdGhlIHBvb2wuXG4gICAgICAgICAgICBzZWxmLl9yZWxlYXNlSHRtbDVBdWRpbyhhdWRpb05vZGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHNlbGYubm9BdWRpbyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFueSBhc3NpZ25lZCBhdWRpbyBub2RlcyBhbmQgdW5sb2NrIHRoZW0uXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9ob3dscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghc2VsZi5faG93bHNbaV0uX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgICAvLyBHZXQgYWxsIG9mIHRoZSBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAgICAgICAgdmFyIGlkcyA9IHNlbGYuX2hvd2xzW2ldLl9nZXRTb3VuZElkcygpO1xuXG4gICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHNvdW5kcyBhbmQgdW5sb2NrIHRoZSBhdWRpbyBub2Rlcy5cbiAgICAgICAgICAgIGZvciAodmFyIGo9MDsgajxpZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5faG93bHNbaV0uX3NvdW5kQnlJZChpZHNbal0pO1xuXG4gICAgICAgICAgICAgIGlmIChzb3VuZCAmJiBzb3VuZC5fbm9kZSAmJiAhc291bmQuX25vZGUuX3VubG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgc291bmQuX25vZGUuX3VubG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5sb2FkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXggQW5kcm9pZCBjYW4gbm90IHBsYXkgaW4gc3VzcGVuZCBzdGF0ZS5cbiAgICAgICAgc2VsZi5fYXV0b1Jlc3VtZSgpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbiBlbXB0eSBidWZmZXIuXG4gICAgICAgIHZhciBzb3VyY2UgPSBzZWxmLmN0eC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgICAgc291cmNlLmJ1ZmZlciA9IHNlbGYuX3NjcmF0Y2hCdWZmZXI7XG4gICAgICAgIHNvdXJjZS5jb25uZWN0KHNlbGYuY3R4LmRlc3RpbmF0aW9uKTtcblxuICAgICAgICAvLyBQbGF5IHRoZSBlbXB0eSBidWZmZXIuXG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlLnN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHNvdXJjZS5ub3RlT24oMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc291cmNlLnN0YXJ0KDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbGluZyByZXN1bWUoKSBvbiBhIHN0YWNrIGluaXRpYXRlZCBieSB1c2VyIGdlc3R1cmUgaXMgd2hhdCBhY3R1YWxseSB1bmxvY2tzIHRoZSBhdWRpbyBvbiBBbmRyb2lkIENocm9tZSA+PSA1NS5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmLmN0eC5yZXN1bWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzZWxmLmN0eC5yZXN1bWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldHVwIGEgdGltZW91dCB0byBjaGVjayB0aGF0IHdlIGFyZSB1bmxvY2tlZCBvbiB0aGUgbmV4dCBldmVudCBsb29wLlxuICAgICAgICBzb3VyY2Uub25lbmRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNvdXJjZS5kaXNjb25uZWN0KDApO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSB1bmxvY2tlZCBzdGF0ZSBhbmQgcHJldmVudCB0aGlzIGNoZWNrIGZyb20gaGFwcGVuaW5nIGFnYWluLlxuICAgICAgICAgIHNlbGYuX2F1ZGlvVW5sb2NrZWQgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0b3VjaCBzdGFydCBsaXN0ZW5lci5cbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdW5sb2NrLCB0cnVlKTtcbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHVubG9jaywgdHJ1ZSk7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB1bmxvY2ssIHRydWUpO1xuXG4gICAgICAgICAgLy8gTGV0IGFsbCBzb3VuZHMga25vdyB0aGF0IGF1ZGlvIGhhcyBiZWVuIHVubG9ja2VkLlxuICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9ob3dscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VsZi5faG93bHNbaV0uX2VtaXQoJ3VubG9jaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFNldHVwIGEgdG91Y2ggc3RhcnQgbGlzdGVuZXIgdG8gYXR0ZW1wdCBhbiB1bmxvY2sgaW4uXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdW5sb2NrLCB0cnVlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdW5sb2NrLCB0cnVlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdW5sb2NrLCB0cnVlKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiB1bmxvY2tlZCBIVE1MNSBBdWRpbyBvYmplY3QgZnJvbSB0aGUgcG9vbC4gSWYgbm9uZSBhcmUgbGVmdCxcbiAgICAgKiByZXR1cm4gYSBuZXcgQXVkaW8gb2JqZWN0IGFuZCB0aHJvdyBhIHdhcm5pbmcuXG4gICAgICogQHJldHVybiB7QXVkaW99IEhUTUw1IEF1ZGlvIG9iamVjdC5cbiAgICAgKi9cbiAgICBfb2J0YWluSHRtbDVBdWRpbzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMgfHwgSG93bGVyO1xuXG4gICAgICAvLyBSZXR1cm4gdGhlIG5leHQgb2JqZWN0IGZyb20gdGhlIHBvb2wgaWYgb25lIGV4aXN0cy5cbiAgICAgIGlmIChzZWxmLl9odG1sNUF1ZGlvUG9vbC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX2h0bWw1QXVkaW9Qb29sLnBvcCgpO1xuICAgICAgfVxuXG4gICAgICAvLy5DaGVjayBpZiB0aGUgYXVkaW8gaXMgbG9ja2VkIGFuZCB0aHJvdyBhIHdhcm5pbmcuXG4gICAgICB2YXIgdGVzdFBsYXkgPSBuZXcgQXVkaW8oKS5wbGF5KCk7XG4gICAgICBpZiAodGVzdFBsYXkgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmICh0ZXN0UGxheSBpbnN0YW5jZW9mIFByb21pc2UgfHwgdHlwZW9mIHRlc3RQbGF5LnRoZW4gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRlc3RQbGF5LmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignSFRNTDUgQXVkaW8gcG9vbCBleGhhdXN0ZWQsIHJldHVybmluZyBwb3RlbnRpYWxseSBsb2NrZWQgYXVkaW8gb2JqZWN0LicpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBBdWRpbygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYWN0aXZhdGVkIEhUTUw1IEF1ZGlvIG9iamVjdCB0byB0aGUgcG9vbC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgX3JlbGVhc2VIdG1sNUF1ZGlvOiBmdW5jdGlvbihhdWRpbykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgLy8gRG9uJ3QgYWRkIGF1ZGlvIHRvIHRoZSBwb29sIGlmIHdlIGRvbid0IGtub3cgaWYgaXQgaGFzIGJlZW4gdW5sb2NrZWQuXG4gICAgICBpZiAoYXVkaW8uX3VubG9ja2VkKSB7XG4gICAgICAgIHNlbGYuX2h0bWw1QXVkaW9Qb29sLnB1c2goYXVkaW8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXV0b21hdGljYWxseSBzdXNwZW5kIHRoZSBXZWIgQXVkaW8gQXVkaW9Db250ZXh0IGFmdGVyIG5vIHNvdW5kIGhhcyBwbGF5ZWQgZm9yIDMwIHNlY29uZHMuXG4gICAgICogVGhpcyBzYXZlcyBwcm9jZXNzaW5nL2VuZXJneSBhbmQgZml4ZXMgdmFyaW91cyBicm93c2VyLXNwZWNpZmljIGJ1Z3Mgd2l0aCBhdWRpbyBnZXR0aW5nIHN0dWNrLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfYXV0b1N1c3BlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoIXNlbGYuYXV0b1N1c3BlbmQgfHwgIXNlbGYuY3R4IHx8IHR5cGVvZiBzZWxmLmN0eC5zdXNwZW5kID09PSAndW5kZWZpbmVkJyB8fCAhSG93bGVyLnVzaW5nV2ViQXVkaW8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBhbnkgc291bmRzIGFyZSBwbGF5aW5nLlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX2hvd2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9ob3dsc1tpXS5fd2ViQXVkaW8pIHtcbiAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8c2VsZi5faG93bHNbaV0uX3NvdW5kcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKCFzZWxmLl9ob3dsc1tpXS5fc291bmRzW2pdLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLl9zdXNwZW5kVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3N1c3BlbmRUaW1lcik7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIHNvdW5kIGhhcyBwbGF5ZWQgYWZ0ZXIgMzAgc2Vjb25kcywgc3VzcGVuZCB0aGUgY29udGV4dC5cbiAgICAgIHNlbGYuX3N1c3BlbmRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghc2VsZi5hdXRvU3VzcGVuZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuX3N1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgIHNlbGYuc3RhdGUgPSAnc3VzcGVuZGluZyc7XG4gICAgICAgIHNlbGYuY3R4LnN1c3BlbmQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuc3RhdGUgPSAnc3VzcGVuZGVkJztcblxuICAgICAgICAgIGlmIChzZWxmLl9yZXN1bWVBZnRlclN1c3BlbmQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZWxmLl9yZXN1bWVBZnRlclN1c3BlbmQ7XG4gICAgICAgICAgICBzZWxmLl9hdXRvUmVzdW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIDMwMDAwKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgcmVzdW1lIHRoZSBXZWIgQXVkaW8gQXVkaW9Db250ZXh0IHdoZW4gYSBuZXcgc291bmQgaXMgcGxheWVkLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfYXV0b1Jlc3VtZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICghc2VsZi5jdHggfHwgdHlwZW9mIHNlbGYuY3R4LnJlc3VtZSA9PT0gJ3VuZGVmaW5lZCcgfHwgIUhvd2xlci51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdydW5uaW5nJyAmJiBzZWxmLl9zdXNwZW5kVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3N1c3BlbmRUaW1lcik7XG4gICAgICAgIHNlbGYuX3N1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgIHNlbGYuY3R4LnJlc3VtZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9ICdydW5uaW5nJztcblxuICAgICAgICAgIC8vIEVtaXQgdG8gYWxsIEhvd2xzIHRoYXQgdGhlIGF1ZGlvIGhhcyByZXN1bWVkLlxuICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9ob3dscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VsZi5faG93bHNbaV0uX2VtaXQoJ3Jlc3VtZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNlbGYuX3N1c3BlbmRUaW1lcikge1xuICAgICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9zdXNwZW5kVGltZXIpO1xuICAgICAgICAgIHNlbGYuX3N1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5zdGF0ZSA9PT0gJ3N1c3BlbmRpbmcnKSB7XG4gICAgICAgIHNlbGYuX3Jlc3VtZUFmdGVyU3VzcGVuZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgfTtcblxuICAvLyBTZXR1cCB0aGUgZ2xvYmFsIGF1ZGlvIGNvbnRyb2xsZXIuXG4gIHZhciBIb3dsZXIgPSBuZXcgSG93bGVyR2xvYmFsKCk7XG5cbiAgLyoqIEdyb3VwIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhdWRpbyBncm91cCBjb250cm9sbGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbyBQYXNzZWQgaW4gcHJvcGVydGllcyBmb3IgdGhpcyBncm91cC5cbiAgICovXG4gIHZhciBIb3dsID0gZnVuY3Rpb24obykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFRocm93IGFuIGVycm9yIGlmIG5vIHNvdXJjZSBpcyBwcm92aWRlZC5cbiAgICBpZiAoIW8uc3JjIHx8IG8uc3JjLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5lcnJvcignQW4gYXJyYXkgb2Ygc291cmNlIGZpbGVzIG11c3QgYmUgcGFzc2VkIHdpdGggYW55IG5ldyBIb3dsLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuaW5pdChvKTtcbiAgfTtcbiAgSG93bC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBIb3dsIGdyb3VwIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG8gUGFzc2VkIGluIHByb3BlcnRpZXMgZm9yIHRoaXMgZ3JvdXAuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW4gQXVkaW9Db250ZXh0IGNyZWF0ZWQgeWV0LCBydW4gdGhlIHNldHVwLlxuICAgICAgaWYgKCFIb3dsZXIuY3R4KSB7XG4gICAgICAgIHNldHVwQXVkaW9Db250ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldHVwIHVzZXItZGVmaW5lZCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9hdXRvcGxheSA9IG8uYXV0b3BsYXkgfHwgZmFsc2U7XG4gICAgICBzZWxmLl9mb3JtYXQgPSAodHlwZW9mIG8uZm9ybWF0ICE9PSAnc3RyaW5nJykgPyBvLmZvcm1hdCA6IFtvLmZvcm1hdF07XG4gICAgICBzZWxmLl9odG1sNSA9IG8uaHRtbDUgfHwgZmFsc2U7XG4gICAgICBzZWxmLl9tdXRlZCA9IG8ubXV0ZSB8fCBmYWxzZTtcbiAgICAgIHNlbGYuX2xvb3AgPSBvLmxvb3AgfHwgZmFsc2U7XG4gICAgICBzZWxmLl9wb29sID0gby5wb29sIHx8IDU7XG4gICAgICBzZWxmLl9wcmVsb2FkID0gKHR5cGVvZiBvLnByZWxvYWQgPT09ICdib29sZWFuJykgPyBvLnByZWxvYWQgOiB0cnVlO1xuICAgICAgc2VsZi5fcmF0ZSA9IG8ucmF0ZSB8fCAxO1xuICAgICAgc2VsZi5fc3ByaXRlID0gby5zcHJpdGUgfHwge307XG4gICAgICBzZWxmLl9zcmMgPSAodHlwZW9mIG8uc3JjICE9PSAnc3RyaW5nJykgPyBvLnNyYyA6IFtvLnNyY107XG4gICAgICBzZWxmLl92b2x1bWUgPSBvLnZvbHVtZSAhPT0gdW5kZWZpbmVkID8gby52b2x1bWUgOiAxO1xuICAgICAgc2VsZi5feGhyV2l0aENyZWRlbnRpYWxzID0gby54aHJXaXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG5cbiAgICAgIC8vIFNldHVwIGFsbCBvdGhlciBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9kdXJhdGlvbiA9IDA7XG4gICAgICBzZWxmLl9zdGF0ZSA9ICd1bmxvYWRlZCc7XG4gICAgICBzZWxmLl9zb3VuZHMgPSBbXTtcbiAgICAgIHNlbGYuX2VuZFRpbWVycyA9IHt9O1xuICAgICAgc2VsZi5fcXVldWUgPSBbXTtcbiAgICAgIHNlbGYuX3BsYXlMb2NrID0gZmFsc2U7XG5cbiAgICAgIC8vIFNldHVwIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgIHNlbGYuX29uZW5kID0gby5vbmVuZCA/IFt7Zm46IG8ub25lbmR9XSA6IFtdO1xuICAgICAgc2VsZi5fb25mYWRlID0gby5vbmZhZGUgPyBbe2ZuOiBvLm9uZmFkZX1dIDogW107XG4gICAgICBzZWxmLl9vbmxvYWQgPSBvLm9ubG9hZCA/IFt7Zm46IG8ub25sb2FkfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ubG9hZGVycm9yID0gby5vbmxvYWRlcnJvciA/IFt7Zm46IG8ub25sb2FkZXJyb3J9XSA6IFtdO1xuICAgICAgc2VsZi5fb25wbGF5ZXJyb3IgPSBvLm9ucGxheWVycm9yID8gW3tmbjogby5vbnBsYXllcnJvcn1dIDogW107XG4gICAgICBzZWxmLl9vbnBhdXNlID0gby5vbnBhdXNlID8gW3tmbjogby5vbnBhdXNlfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ucGxheSA9IG8ub25wbGF5ID8gW3tmbjogby5vbnBsYXl9XSA6IFtdO1xuICAgICAgc2VsZi5fb25zdG9wID0gby5vbnN0b3AgPyBbe2ZuOiBvLm9uc3RvcH1dIDogW107XG4gICAgICBzZWxmLl9vbm11dGUgPSBvLm9ubXV0ZSA/IFt7Zm46IG8ub25tdXRlfV0gOiBbXTtcbiAgICAgIHNlbGYuX29udm9sdW1lID0gby5vbnZvbHVtZSA/IFt7Zm46IG8ub252b2x1bWV9XSA6IFtdO1xuICAgICAgc2VsZi5fb25yYXRlID0gby5vbnJhdGUgPyBbe2ZuOiBvLm9ucmF0ZX1dIDogW107XG4gICAgICBzZWxmLl9vbnNlZWsgPSBvLm9uc2VlayA/IFt7Zm46IG8ub25zZWVrfV0gOiBbXTtcbiAgICAgIHNlbGYuX29udW5sb2NrID0gby5vbnVubG9jayA/IFt7Zm46IG8ub251bmxvY2t9XSA6IFtdO1xuICAgICAgc2VsZi5fb25yZXN1bWUgPSBbXTtcblxuICAgICAgLy8gV2ViIEF1ZGlvIG9yIEhUTUw1IEF1ZGlvP1xuICAgICAgc2VsZi5fd2ViQXVkaW8gPSBIb3dsZXIudXNpbmdXZWJBdWRpbyAmJiAhc2VsZi5faHRtbDU7XG5cbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgdHJ5IHRvIGVuYWJsZSBhdWRpby5cbiAgICAgIGlmICh0eXBlb2YgSG93bGVyLmN0eCAhPT0gJ3VuZGVmaW5lZCcgJiYgSG93bGVyLmN0eCAmJiBIb3dsZXIuYXV0b1VubG9jaykge1xuICAgICAgICBIb3dsZXIuX3VubG9ja0F1ZGlvKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhpcyBIb3dsIGdyb3VwIGluIHRoZSBnbG9iYWwgY29udHJvbGxlci5cbiAgICAgIEhvd2xlci5faG93bHMucHVzaChzZWxmKTtcblxuICAgICAgLy8gSWYgdGhleSBzZWxlY3RlZCBhdXRvcGxheSwgYWRkIGEgcGxheSBldmVudCB0byB0aGUgbG9hZCBxdWV1ZS5cbiAgICAgIGlmIChzZWxmLl9hdXRvcGxheSkge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ3BsYXknLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnBsYXkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIHRoZSBzb3VyY2UgZmlsZSB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAgICAgIGlmIChzZWxmLl9wcmVsb2FkKSB7XG4gICAgICAgIHNlbGYubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgYXVkaW8gZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdXJsID0gbnVsbDtcblxuICAgICAgLy8gSWYgbm8gYXVkaW8gaXMgYXZhaWxhYmxlLCBxdWl0IGltbWVkaWF0ZWx5LlxuICAgICAgaWYgKEhvd2xlci5ub0F1ZGlvKSB7XG4gICAgICAgIHNlbGYuX2VtaXQoJ2xvYWRlcnJvcicsIG51bGwsICdObyBhdWRpbyBzdXBwb3J0LicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSBvdXIgc291cmNlIGlzIGluIGFuIGFycmF5LlxuICAgICAgaWYgKHR5cGVvZiBzZWxmLl9zcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNlbGYuX3NyYyA9IFtzZWxmLl9zcmNdO1xuICAgICAgfVxuXG4gICAgICAvLyBMb29wIHRocm91Z2ggdGhlIHNvdXJjZXMgYW5kIHBpY2sgdGhlIGZpcnN0IG9uZSB0aGF0IGlzIGNvbXBhdGlibGUuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5fc3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBleHQsIHN0cjtcblxuICAgICAgICBpZiAoc2VsZi5fZm9ybWF0ICYmIHNlbGYuX2Zvcm1hdFtpXSkge1xuICAgICAgICAgIC8vIElmIGFuIGV4dGVuc2lvbiB3YXMgc3BlY2lmaWVkLCB1c2UgdGhhdCBpbnN0ZWFkLlxuICAgICAgICAgIGV4dCA9IHNlbGYuX2Zvcm1hdFtpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHNvdXJjZSBpcyBhIHN0cmluZy5cbiAgICAgICAgICBzdHIgPSBzZWxmLl9zcmNbaV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnTm9uLXN0cmluZyBmb3VuZCBpbiBzZWxlY3RlZCBhdWRpbyBzb3VyY2VzIC0gaWdub3JpbmcuJyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBmaWxlIGV4dGVuc2lvbiBmcm9tIHRoZSBVUkwgb3IgYmFzZTY0IGRhdGEgVVJJLlxuICAgICAgICAgIGV4dCA9IC9eZGF0YTphdWRpb1xcLyhbXjssXSspOy9pLmV4ZWMoc3RyKTtcbiAgICAgICAgICBpZiAoIWV4dCkge1xuICAgICAgICAgICAgZXh0ID0gL1xcLihbXi5dKykkLy5leGVjKHN0ci5zcGxpdCgnPycsIDEpWzBdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXh0KSB7XG4gICAgICAgICAgICBleHQgPSBleHRbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb2cgYSB3YXJuaW5nIGlmIG5vIGV4dGVuc2lvbiB3YXMgZm91bmQuXG4gICAgICAgIGlmICghZXh0KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdObyBmaWxlIGV4dGVuc2lvbiB3YXMgZm91bmQuIENvbnNpZGVyIHVzaW5nIHRoZSBcImZvcm1hdFwiIHByb3BlcnR5IG9yIHNwZWNpZnkgYW4gZXh0ZW5zaW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBleHRlbnNpb24gaXMgYXZhaWxhYmxlLlxuICAgICAgICBpZiAoZXh0ICYmIEhvd2xlci5jb2RlY3MoZXh0KSkge1xuICAgICAgICAgIHVybCA9IHNlbGYuX3NyY1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnTm8gY29kZWMgc3VwcG9ydCBmb3Igc2VsZWN0ZWQgYXVkaW8gc291cmNlcy4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9zcmMgPSB1cmw7XG4gICAgICBzZWxmLl9zdGF0ZSA9ICdsb2FkaW5nJztcblxuICAgICAgLy8gSWYgdGhlIGhvc3RpbmcgcGFnZSBpcyBIVFRQUyBhbmQgdGhlIHNvdXJjZSBpc24ndCxcbiAgICAgIC8vIGRyb3AgZG93biB0byBIVE1MNSBBdWRpbyB0byBhdm9pZCBNaXhlZCBDb250ZW50IGVycm9ycy5cbiAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonICYmIHVybC5zbGljZSgwLCA1KSA9PT0gJ2h0dHA6Jykge1xuICAgICAgICBzZWxmLl9odG1sNSA9IHRydWU7XG4gICAgICAgIHNlbGYuX3dlYkF1ZGlvID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBzb3VuZCBvYmplY3QgYW5kIGFkZCBpdCB0byB0aGUgcG9vbC5cbiAgICAgIG5ldyBTb3VuZChzZWxmKTtcblxuICAgICAgLy8gTG9hZCBhbmQgZGVjb2RlIHRoZSBhdWRpbyBkYXRhIGZvciBwbGF5YmFjay5cbiAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICBsb2FkQnVmZmVyKHNlbGYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGxheSBhIHNvdW5kIG9yIHJlc3VtZSBwcmV2aW91cyBwbGF5YmFjay5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmcvTnVtYmVyfSBzcHJpdGUgICBTcHJpdGUgbmFtZSBmb3Igc3ByaXRlIHBsYXliYWNrIG9yIHNvdW5kIGlkIHRvIGNvbnRpbnVlIHByZXZpb3VzLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGludGVybmFsIEludGVybmFsIFVzZTogdHJ1ZSBwcmV2ZW50cyBldmVudCBmaXJpbmcuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICBTb3VuZCBJRC5cbiAgICAgKi9cbiAgICBwbGF5OiBmdW5jdGlvbihzcHJpdGUsIGludGVybmFsKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgaWQgPSBudWxsO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgaWYgYSBzcHJpdGUsIHNvdW5kIGlkIG9yIG5vdGhpbmcgd2FzIHBhc3NlZFxuICAgICAgaWYgKHR5cGVvZiBzcHJpdGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlkID0gc3ByaXRlO1xuICAgICAgICBzcHJpdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3ByaXRlID09PSAnc3RyaW5nJyAmJiBzZWxmLl9zdGF0ZSA9PT0gJ2xvYWRlZCcgJiYgIXNlbGYuX3Nwcml0ZVtzcHJpdGVdKSB7XG4gICAgICAgIC8vIElmIHRoZSBwYXNzZWQgc3ByaXRlIGRvZXNuJ3QgZXhpc3QsIGRvIG5vdGhpbmcuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3ByaXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBVc2UgdGhlIGRlZmF1bHQgc291bmQgc3ByaXRlIChwbGF5cyB0aGUgZnVsbCBhdWRpbyBsZW5ndGgpLlxuICAgICAgICBzcHJpdGUgPSAnX19kZWZhdWx0JztcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhIHNpbmdsZSBwYXVzZWQgc291bmQgdGhhdCBpc24ndCBlbmRlZC4gXG4gICAgICAgIC8vIElmIHRoZXJlIGlzLCBwbGF5IHRoYXQgc291bmQuIElmIG5vdCwgY29udGludWUgYXMgdXN1YWwuICBcbiAgICAgICAgaWYgKCFzZWxmLl9wbGF5TG9jaykge1xuICAgICAgICAgIHZhciBudW0gPSAwO1xuICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9zb3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9zb3VuZHNbaV0uX3BhdXNlZCAmJiAhc2VsZi5fc291bmRzW2ldLl9lbmRlZCkge1xuICAgICAgICAgICAgICBudW0rKztcbiAgICAgICAgICAgICAgaWQgPSBzZWxmLl9zb3VuZHNbaV0uX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgICAgIHNwcml0ZSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBzZWxlY3RlZCBub2RlLCBvciBnZXQgb25lIGZyb20gdGhlIHBvb2wuXG4gICAgICB2YXIgc291bmQgPSBpZCA/IHNlbGYuX3NvdW5kQnlJZChpZCkgOiBzZWxmLl9pbmFjdGl2ZVNvdW5kKCk7XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBkb2Vzbid0IGV4aXN0LCBkbyBub3RoaW5nLlxuICAgICAgaWYgKCFzb3VuZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gU2VsZWN0IHRoZSBzcHJpdGUgZGVmaW5pdGlvbi5cbiAgICAgIGlmIChpZCAmJiAhc3ByaXRlKSB7XG4gICAgICAgIHNwcml0ZSA9IHNvdW5kLl9zcHJpdGUgfHwgJ19fZGVmYXVsdCc7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCB3ZSBtdXN0IHdhaXQgdG8gZ2V0IHRoZSBhdWRpbydzIGR1cmF0aW9uLlxuICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHdhaXQgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHJ1biBpbnRvIHJhY2UgY29uZGl0aW9ucyB3aXRoXG4gICAgICAvLyB0aGUgb3JkZXIgb2YgZnVuY3Rpb24gY2FsbHMuXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgIC8vIFNldCB0aGUgc3ByaXRlIHZhbHVlIG9uIHRoaXMgc291bmQuXG4gICAgICAgIHNvdW5kLl9zcHJpdGUgPSBzcHJpdGU7XG5cbiAgICAgICAgLy8gTWFyayB0aGlzIHNvdW5kIGFzIG5vdCBlbmRlZCBpbiBjYXNlIGFub3RoZXIgc291bmQgaXMgcGxheWVkIGJlZm9yZSB0aGlzIG9uZSBsb2Fkcy5cbiAgICAgICAgc291bmQuX2VuZGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBzb3VuZCB0byB0aGUgcXVldWUgdG8gYmUgcGxheWVkIG9uIGxvYWQuXG4gICAgICAgIHZhciBzb3VuZElkID0gc291bmQuX2lkO1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ3BsYXknLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnBsYXkoc291bmRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc291bmRJZDtcbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgcGxheSB0aGUgc291bmQgaWYgYW4gaWQgd2FzIHBhc3NlZCBhbmQgaXQgaXMgYWxyZWFkeSBwbGF5aW5nLlxuICAgICAgaWYgKGlkICYmICFzb3VuZC5fcGF1c2VkKSB7XG4gICAgICAgIC8vIFRyaWdnZXIgdGhlIHBsYXkgZXZlbnQsIGluIG9yZGVyIHRvIGtlZXAgaXRlcmF0aW5nIHRocm91Z2ggcXVldWUuXG4gICAgICAgIGlmICghaW50ZXJuYWwpIHtcbiAgICAgICAgICBzZWxmLl9sb2FkUXVldWUoJ3BsYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VuZC5faWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgQXVkaW9Db250ZXh0IGlzbid0IHN1c3BlbmRlZCwgYW5kIHJlc3VtZSBpdCBpZiBpdCBpcy5cbiAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICBIb3dsZXIuX2F1dG9SZXN1bWUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBsb25nIHRvIHBsYXkgZm9yIGFuZCB3aGVyZSB0byBzdGFydCBwbGF5aW5nLlxuICAgICAgdmFyIHNlZWsgPSBNYXRoLm1heCgwLCBzb3VuZC5fc2VlayA+IDAgPyBzb3VuZC5fc2VlayA6IHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzBdIC8gMTAwMCk7XG4gICAgICB2YXIgZHVyYXRpb24gPSBNYXRoLm1heCgwLCAoKHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzBdICsgc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMV0pIC8gMTAwMCkgLSBzZWVrKTtcbiAgICAgIHZhciB0aW1lb3V0ID0gKGR1cmF0aW9uICogMTAwMCkgLyBNYXRoLmFicyhzb3VuZC5fcmF0ZSk7XG4gICAgICB2YXIgc3RhcnQgPSBzZWxmLl9zcHJpdGVbc3ByaXRlXVswXSAvIDEwMDA7XG4gICAgICB2YXIgc3RvcCA9IChzZWxmLl9zcHJpdGVbc3ByaXRlXVswXSArIHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzFdKSAvIDEwMDA7XG4gICAgICBzb3VuZC5fc3ByaXRlID0gc3ByaXRlO1xuXG4gICAgICAvLyBNYXJrIHRoZSBzb3VuZCBhcyBlbmRlZCBpbnN0YW50bHkgc28gdGhhdCB0aGlzIGFzeW5jIHBsYXliYWNrXG4gICAgICAvLyBkb2Vzbid0IGdldCBncmFiYmVkIGJ5IGFub3RoZXIgY2FsbCB0byBwbGF5IHdoaWxlIHRoaXMgb25lIHdhaXRzIHRvIHN0YXJ0LlxuICAgICAgc291bmQuX2VuZGVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcGFyYW1ldGVycyBvZiB0aGUgc291bmQuXG4gICAgICB2YXIgc2V0UGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNvdW5kLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgc291bmQuX3NlZWsgPSBzZWVrO1xuICAgICAgICBzb3VuZC5fc3RhcnQgPSBzdGFydDtcbiAgICAgICAgc291bmQuX3N0b3AgPSBzdG9wO1xuICAgICAgICBzb3VuZC5fbG9vcCA9ICEhKHNvdW5kLl9sb29wIHx8IHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzJdKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEVuZCB0aGUgc291bmQgaW5zdGFudGx5IGlmIHNlZWsgaXMgYXQgdGhlIGVuZC5cbiAgICAgIGlmIChzZWVrID49IHN0b3ApIHtcbiAgICAgICAgc2VsZi5fZW5kZWQoc291bmQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEJlZ2luIHRoZSBhY3R1YWwgcGxheWJhY2suXG4gICAgICB2YXIgbm9kZSA9IHNvdW5kLl9ub2RlO1xuICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgIC8vIEZpcmUgdGhpcyB3aGVuIHRoZSBzb3VuZCBpcyByZWFkeSB0byBwbGF5IHRvIGJlZ2luIFdlYiBBdWRpbyBwbGF5YmFjay5cbiAgICAgICAgdmFyIHBsYXlXZWJBdWRpbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuX3BsYXlMb2NrID0gZmFsc2U7XG4gICAgICAgICAgc2V0UGFyYW1zKCk7XG4gICAgICAgICAgc2VsZi5fcmVmcmVzaEJ1ZmZlcihzb3VuZCk7XG5cbiAgICAgICAgICAvLyBTZXR1cCB0aGUgcGxheWJhY2sgcGFyYW1zLlxuICAgICAgICAgIHZhciB2b2wgPSAoc291bmQuX211dGVkIHx8IHNlbGYuX211dGVkKSA/IDAgOiBzb3VuZC5fdm9sdW1lO1xuICAgICAgICAgIG5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2b2wsIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgIHNvdW5kLl9wbGF5U3RhcnQgPSBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lO1xuXG4gICAgICAgICAgLy8gUGxheSB0aGUgc291bmQgdXNpbmcgdGhlIHN1cHBvcnRlZCBtZXRob2QuXG4gICAgICAgICAgaWYgKHR5cGVvZiBub2RlLmJ1ZmZlclNvdXJjZS5zdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNvdW5kLl9sb29wID8gbm9kZS5idWZmZXJTb3VyY2Uubm90ZUdyYWluT24oMCwgc2VlaywgODY0MDApIDogbm9kZS5idWZmZXJTb3VyY2Uubm90ZUdyYWluT24oMCwgc2VlaywgZHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VuZC5fbG9vcCA/IG5vZGUuYnVmZmVyU291cmNlLnN0YXJ0KDAsIHNlZWssIDg2NDAwKSA6IG5vZGUuYnVmZmVyU291cmNlLnN0YXJ0KDAsIHNlZWssIGR1cmF0aW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdGFydCBhIG5ldyB0aW1lciBpZiBub25lIGlzIHByZXNlbnQuXG4gICAgICAgICAgaWYgKHRpbWVvdXQgIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBzZWxmLl9lbmRUaW1lcnNbc291bmQuX2lkXSA9IHNldFRpbWVvdXQoc2VsZi5fZW5kZWQuYmluZChzZWxmLCBzb3VuZCksIHRpbWVvdXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3BsYXknLCBzb3VuZC5faWQpO1xuICAgICAgICAgICAgICBzZWxmLl9sb2FkUXVldWUoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoSG93bGVyLnN0YXRlID09PSAncnVubmluZycpIHtcbiAgICAgICAgICBwbGF5V2ViQXVkaW8oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLl9wbGF5TG9jayA9IHRydWU7XG5cbiAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgYXVkaW8gY29udGV4dCB0byByZXN1bWUgYmVmb3JlIHBsYXlpbmcuXG4gICAgICAgICAgc2VsZi5vbmNlKCdyZXN1bWUnLCBwbGF5V2ViQXVkaW8pO1xuXG4gICAgICAgICAgLy8gQ2FuY2VsIHRoZSBlbmQgdGltZXIuXG4gICAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihzb3VuZC5faWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaXJlIHRoaXMgd2hlbiB0aGUgc291bmQgaXMgcmVhZHkgdG8gcGxheSB0byBiZWdpbiBIVE1MNSBBdWRpbyBwbGF5YmFjay5cbiAgICAgICAgdmFyIHBsYXlIdG1sNSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG5vZGUuY3VycmVudFRpbWUgPSBzZWVrO1xuICAgICAgICAgIG5vZGUubXV0ZWQgPSBzb3VuZC5fbXV0ZWQgfHwgc2VsZi5fbXV0ZWQgfHwgSG93bGVyLl9tdXRlZCB8fCBub2RlLm11dGVkO1xuICAgICAgICAgIG5vZGUudm9sdW1lID0gc291bmQuX3ZvbHVtZSAqIEhvd2xlci52b2x1bWUoKTtcbiAgICAgICAgICBub2RlLnBsYXliYWNrUmF0ZSA9IHNvdW5kLl9yYXRlO1xuXG4gICAgICAgICAgLy8gU29tZSBicm93c2VycyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoaXMgaXMgY2FsbGVkIHdpdGhvdXQgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHBsYXkgPSBub2RlLnBsYXkoKTtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydCBvbGRlciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgcHJvbWlzZXMsIGFuZCB0aHVzIGRvbid0IGhhdmUgdGhpcyBpc3N1ZS5cbiAgICAgICAgICAgIGlmIChwbGF5ICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiAocGxheSBpbnN0YW5jZW9mIFByb21pc2UgfHwgdHlwZW9mIHBsYXkudGhlbiA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgLy8gSW1wbGVtZW50cyBhIGxvY2sgdG8gcHJldmVudCBET01FeGNlcHRpb246IFRoZSBwbGF5KCkgcmVxdWVzdCB3YXMgaW50ZXJydXB0ZWQgYnkgYSBjYWxsIHRvIHBhdXNlKCkuXG4gICAgICAgICAgICAgIHNlbGYuX3BsYXlMb2NrID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAvLyBTZXQgcGFyYW0gdmFsdWVzIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICBzZXRQYXJhbXMoKTtcblxuICAgICAgICAgICAgICAvLyBSZWxlYXNlcyB0aGUgbG9jayBhbmQgZXhlY3V0ZXMgcXVldWVkIGFjdGlvbnMuXG4gICAgICAgICAgICAgIHBsYXlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX3BsYXlMb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBub2RlLl91bmxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBpZiAoIWludGVybmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3BsYXknLCBzb3VuZC5faWQpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9sb2FkUXVldWUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX3BsYXlMb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBzZWxmLl9lbWl0KCdwbGF5ZXJyb3InLCBzb3VuZC5faWQsICdQbGF5YmFjayB3YXMgdW5hYmxlIHRvIHN0YXJ0LiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgYW4gaXNzdWUgJyArXG4gICAgICAgICAgICAgICAgICAgICdvbiBtb2JpbGUgZGV2aWNlcyBhbmQgQ2hyb21lIHdoZXJlIHBsYXliYWNrIHdhcyBub3Qgd2l0aGluIGEgdXNlciBpbnRlcmFjdGlvbi4nKTtcblxuICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGVuZGVkIGFuZCBwYXVzZWQgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgc291bmQuX2VuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHNvdW5kLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaW50ZXJuYWwpIHtcbiAgICAgICAgICAgICAgc2VsZi5fcGxheUxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2V0UGFyYW1zKCk7XG4gICAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3BsYXknLCBzb3VuZC5faWQpO1xuICAgICAgICAgICAgICBzZWxmLl9sb2FkUXVldWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dGluZyByYXRlIGJlZm9yZSBwbGF5aW5nIHdvbid0IHdvcmsgaW4gSUUsIHNvIHdlIHNldCBpdCBhZ2FpbiBoZXJlLlxuICAgICAgICAgICAgbm9kZS5wbGF5YmFja1JhdGUgPSBzb3VuZC5fcmF0ZTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgc3RpbGwgcGF1c2VkLCB0aGVuIHdlIGNhbiBhc3N1bWUgdGhlcmUgd2FzIGEgcGxheWJhY2sgaXNzdWUuXG4gICAgICAgICAgICBpZiAobm9kZS5wYXVzZWQpIHtcbiAgICAgICAgICAgICAgc2VsZi5fZW1pdCgncGxheWVycm9yJywgc291bmQuX2lkLCAnUGxheWJhY2sgd2FzIHVuYWJsZSB0byBzdGFydC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGFuIGlzc3VlICcgK1xuICAgICAgICAgICAgICAgICdvbiBtb2JpbGUgZGV2aWNlcyBhbmQgQ2hyb21lIHdoZXJlIHBsYXliYWNrIHdhcyBub3Qgd2l0aGluIGEgdXNlciBpbnRlcmFjdGlvbi4nKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCB0aGUgZW5kIHRpbWVyIG9uIHNwcml0ZXMgb3IgbGlzdGVuIGZvciB0aGUgZW5kZWQgZXZlbnQuXG4gICAgICAgICAgICBpZiAoc3ByaXRlICE9PSAnX19kZWZhdWx0JyB8fCBzb3VuZC5fbG9vcCkge1xuICAgICAgICAgICAgICBzZWxmLl9lbmRUaW1lcnNbc291bmQuX2lkXSA9IHNldFRpbWVvdXQoc2VsZi5fZW5kZWQuYmluZChzZWxmLCBzb3VuZCksIHRpbWVvdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5fZW5kVGltZXJzW3NvdW5kLl9pZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJlIGVuZGVkIG9uIHRoaXMgYXVkaW8gbm9kZS5cbiAgICAgICAgICAgICAgICBzZWxmLl9lbmRlZChzb3VuZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGlzIGxpc3RlbmVyLlxuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBzZWxmLl9lbmRUaW1lcnNbc291bmQuX2lkXSwgZmFsc2UpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgc2VsZi5fZW5kVGltZXJzW3NvdW5kLl9pZF0sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3BsYXllcnJvcicsIHNvdW5kLl9pZCwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBzdHJlYW1pbmcgYXVkaW8sIG1ha2Ugc3VyZSB0aGUgc3JjIGlzIHNldCBhbmQgbG9hZCBhZ2Fpbi5cbiAgICAgICAgaWYgKG5vZGUuc3JjID09PSAnZGF0YTphdWRpby93YXY7YmFzZTY0LFVrbEdSaWdBQUFCWFFWWkZabTEwSUJJQUFBQUJBQUVBUkt3QUFJaFlBUUFDQUJBQUFBQmtZWFJoQWdBQUFBRUEnKSB7XG4gICAgICAgICAgbm9kZS5zcmMgPSBzZWxmLl9zcmM7XG4gICAgICAgICAgbm9kZS5sb2FkKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQbGF5IGltbWVkaWF0ZWx5IGlmIHJlYWR5LCBvciB3YWl0IGZvciB0aGUgJ2NhbnBsYXl0aHJvdWdoJ2UgdmVudC5cbiAgICAgICAgdmFyIGxvYWRlZE5vUmVhZHlTdGF0ZSA9ICh3aW5kb3cgJiYgd2luZG93LmVqZWN0YSkgfHwgKCFub2RlLnJlYWR5U3RhdGUgJiYgSG93bGVyLl9uYXZpZ2F0b3IuaXNDb2Nvb25KUyk7XG4gICAgICAgIGlmIChub2RlLnJlYWR5U3RhdGUgPj0gMyB8fCBsb2FkZWROb1JlYWR5U3RhdGUpIHtcbiAgICAgICAgICBwbGF5SHRtbDUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLl9wbGF5TG9jayA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEJlZ2luIHBsYXliYWNrLlxuICAgICAgICAgICAgcGxheUh0bWw1KCk7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIHRoaXMgbGlzdGVuZXIuXG4gICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoSG93bGVyLl9jYW5QbGF5RXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoSG93bGVyLl9jYW5QbGF5RXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG5cbiAgICAgICAgICAvLyBDYW5jZWwgdGhlIGVuZCB0aW1lci5cbiAgICAgICAgICBzZWxmLl9jbGVhclRpbWVyKHNvdW5kLl9pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNvdW5kLl9pZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGF1c2UgcGxheWJhY2sgYW5kIHNhdmUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFRoZSBzb3VuZCBJRCAoZW1wdHkgdG8gcGF1c2UgYWxsIGluIGdyb3VwKS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIHBhdXNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCBvciBhIHBsYXkoKSBwcm9taXNlIGlzIHBlbmRpbmcsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBwYXVzZSB3aGVuIGNhcGFibGUuXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnIHx8IHNlbGYuX3BsYXlMb2NrKSB7XG4gICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiAncGF1c2UnLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnBhdXNlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBpZCBpcyBwYXNzZWQsIGdldCBhbGwgSUQncyB0byBiZSBwYXVzZWQuXG4gICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSBlbmQgdGltZXIuXG4gICAgICAgIHNlbGYuX2NsZWFyVGltZXIoaWRzW2ldKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgICBpZiAoc291bmQgJiYgIXNvdW5kLl9wYXVzZWQpIHtcbiAgICAgICAgICAvLyBSZXNldCB0aGUgc2VlayBwb3NpdGlvbi5cbiAgICAgICAgICBzb3VuZC5fc2VlayA9IHNlbGYuc2VlayhpZHNbaV0pO1xuICAgICAgICAgIHNvdW5kLl9yYXRlU2VlayA9IDA7XG4gICAgICAgICAgc291bmQuX3BhdXNlZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBTdG9wIGN1cnJlbnRseSBydW5uaW5nIGZhZGVzLlxuICAgICAgICAgIHNlbGYuX3N0b3BGYWRlKGlkc1tpXSk7XG5cbiAgICAgICAgICBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHNvdW5kIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgICAgICAgIGlmICghc291bmQuX25vZGUuYnVmZmVyU291cmNlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5zdG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5ub3RlT2ZmKDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5zdG9wKDApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICAgICAgICAgIHNlbGYuX2NsZWFuQnVmZmVyKHNvdW5kLl9ub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHNvdW5kLl9ub2RlLmR1cmF0aW9uKSB8fCBzb3VuZC5fbm9kZS5kdXJhdGlvbiA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJlIHRoZSBwYXVzZSBldmVudCwgdW5sZXNzIGB0cnVlYCBpcyBwYXNzZWQgYXMgdGhlIDJuZCBhcmd1bWVudC5cbiAgICAgICAgaWYgKCFhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgICBzZWxmLl9lbWl0KCdwYXVzZScsIHNvdW5kID8gc291bmQuX2lkIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgcGxheWJhY2sgYW5kIHJlc2V0IHRvIHN0YXJ0LlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgVGhlIHNvdW5kIElEIChlbXB0eSB0byBzdG9wIGFsbCBpbiBncm91cCkuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaW50ZXJuYWwgSW50ZXJuYWwgVXNlOiB0cnVlIHByZXZlbnRzIGV2ZW50IGZpcmluZy5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKGlkLCBpbnRlcm5hbCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIHN0b3Agd2hlbiBjYXBhYmxlLlxuICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJyB8fCBzZWxmLl9wbGF5TG9jaykge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ3N0b3AnLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnN0b3AoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGlkIGlzIHBhc3NlZCwgZ2V0IGFsbCBJRCdzIHRvIGJlIHN0b3BwZWQuXG4gICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSBlbmQgdGltZXIuXG4gICAgICAgIHNlbGYuX2NsZWFyVGltZXIoaWRzW2ldKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgICAvLyBSZXNldCB0aGUgc2VlayBwb3NpdGlvbi5cbiAgICAgICAgICBzb3VuZC5fc2VlayA9IHNvdW5kLl9zdGFydCB8fCAwO1xuICAgICAgICAgIHNvdW5kLl9yYXRlU2VlayA9IDA7XG4gICAgICAgICAgc291bmQuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgICAgc291bmQuX2VuZGVkID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIFN0b3AgY3VycmVudGx5IHJ1bm5pbmcgZmFkZXMuXG4gICAgICAgICAgc2VsZi5fc3RvcEZhZGUoaWRzW2ldKTtcblxuICAgICAgICAgIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgc291bmQncyBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgICAgICAgaWYgKHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc291bmQuX25vZGUuYnVmZmVyU291cmNlLnN0b3AgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2Uubm90ZU9mZigwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLnN0b3AoMCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICAgICAgICAgICAgc2VsZi5fY2xlYW5CdWZmZXIoc291bmQuX25vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihzb3VuZC5fbm9kZS5kdXJhdGlvbikgfHwgc291bmQuX25vZGUuZHVyYXRpb24gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmN1cnJlbnRUaW1lID0gc291bmQuX3N0YXJ0IHx8IDA7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLnBhdXNlKCk7XG5cbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGxpdmUgc3RyZWFtLCBzdG9wIGRvd25sb2FkIG9uY2UgdGhlIGF1ZGlvIGlzIHN0b3BwZWQuXG4gICAgICAgICAgICAgIGlmIChzb3VuZC5fbm9kZS5kdXJhdGlvbiA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9jbGVhclNvdW5kKHNvdW5kLl9ub2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3N0b3AnLCBzb3VuZC5faWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXV0ZS91bm11dGUgYSBzaW5nbGUgc291bmQgb3IgYWxsIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gbXV0ZWQgU2V0IHRvIHRydWUgdG8gbXV0ZSBhbmQgZmFsc2UgdG8gdW5tdXRlLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgICAgVGhlIHNvdW5kIElEIHRvIHVwZGF0ZSAob21pdCB0byBtdXRlL3VubXV0ZSBhbGwpLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgbXV0ZTogZnVuY3Rpb24obXV0ZWQsIGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gbXV0ZSB3aGVuIGNhcGFibGUuXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnfHwgc2VsZi5fcGxheUxvY2spIHtcbiAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6ICdtdXRlJyxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5tdXRlKG11dGVkLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYXBwbHlpbmcgbXV0ZS91bm11dGUgdG8gYWxsIHNvdW5kcywgdXBkYXRlIHRoZSBncm91cCdzIHZhbHVlLlxuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtdXRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgc2VsZi5fbXV0ZWQgPSBtdXRlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fbXV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gaWQgaXMgcGFzc2VkLCBnZXQgYWxsIElEJ3MgdG8gYmUgbXV0ZWQuXG4gICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAgIHNvdW5kLl9tdXRlZCA9IG11dGVkO1xuXG4gICAgICAgICAgLy8gQ2FuY2VsIGFjdGl2ZSBmYWRlIGFuZCBzZXQgdGhlIHZvbHVtZSB0byB0aGUgZW5kIHZhbHVlLlxuICAgICAgICAgIGlmIChzb3VuZC5faW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHNlbGYuX3N0b3BGYWRlKHNvdW5kLl9pZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmIHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKG11dGVkID8gMCA6IHNvdW5kLl92b2x1bWUsIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIHNvdW5kLl9ub2RlLm11dGVkID0gSG93bGVyLl9tdXRlZCA/IHRydWUgOiBtdXRlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLl9lbWl0KCdtdXRlJywgc291bmQuX2lkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0L3NldCB0aGUgdm9sdW1lIG9mIHRoaXMgc291bmQgb3Igb2YgdGhlIEhvd2wgZ3JvdXAuIFRoaXMgbWV0aG9kIGNhbiBvcHRpb25hbGx5IHRha2UgMCwgMSBvciAyIGFyZ3VtZW50cy5cbiAgICAgKiAgIHZvbHVtZSgpIC0+IFJldHVybnMgdGhlIGdyb3VwJ3Mgdm9sdW1lIHZhbHVlLlxuICAgICAqICAgdm9sdW1lKGlkKSAtPiBSZXR1cm5zIHRoZSBzb3VuZCBpZCdzIGN1cnJlbnQgdm9sdW1lLlxuICAgICAqICAgdm9sdW1lKHZvbCkgLT4gU2V0cyB0aGUgdm9sdW1lIG9mIGFsbCBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAqICAgdm9sdW1lKHZvbCwgaWQpIC0+IFNldHMgdGhlIHZvbHVtZSBvZiBwYXNzZWQgc291bmQgaWQuXG4gICAgICogQHJldHVybiB7SG93bC9OdW1iZXJ9IFJldHVybnMgc2VsZiBvciBjdXJyZW50IHZvbHVtZS5cbiAgICAgKi9cbiAgICB2b2x1bWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgdm9sLCBpZDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB2YWx1ZXMgYmFzZWQgb24gYXJndW1lbnRzLlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGdyb3Vwcycgdm9sdW1lLlxuICAgICAgICByZXR1cm4gc2VsZi5fdm9sdW1lO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSB8fCBhcmdzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJnc1sxXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhpcyBpcyBhbiBJRCwgYW5kIGlmIG5vdCwgYXNzdW1lIGl0IGlzIGEgbmV3IHZvbHVtZS5cbiAgICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKCk7XG4gICAgICAgIHZhciBpbmRleCA9IGlkcy5pbmRleE9mKGFyZ3NbMF0pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1swXSwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZvbCA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPj0gMikge1xuICAgICAgICB2b2wgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRoZSB2b2x1bWUgb3IgcmV0dXJuIHRoZSBjdXJyZW50IHZvbHVtZS5cbiAgICAgIHZhciBzb3VuZDtcbiAgICAgIGlmICh0eXBlb2Ygdm9sICE9PSAndW5kZWZpbmVkJyAmJiB2b2wgPj0gMCAmJiB2b2wgPD0gMSkge1xuICAgICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGNoYW5nZSB2b2x1bWUgd2hlbiBjYXBhYmxlLlxuICAgICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnfHwgc2VsZi5fcGxheUxvY2spIHtcbiAgICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiAndm9sdW1lJyxcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNlbGYudm9sdW1lLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGdyb3VwIHZvbHVtZS5cbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzZWxmLl92b2x1bWUgPSB2b2w7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgb25lIG9yIGFsbCB2b2x1bWVzLlxuICAgICAgICBpZCA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGlkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgICAgICBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZFtpXSk7XG5cbiAgICAgICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgICAgIHNvdW5kLl92b2x1bWUgPSB2b2w7XG5cbiAgICAgICAgICAgIC8vIFN0b3AgY3VycmVudGx5IHJ1bm5pbmcgZmFkZXMuXG4gICAgICAgICAgICBpZiAoIWFyZ3NbMl0pIHtcbiAgICAgICAgICAgICAgc2VsZi5fc3RvcEZhZGUoaWRbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgc291bmQuX25vZGUgJiYgIXNvdW5kLl9tdXRlZCkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKHZvbCwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdW5kLl9ub2RlICYmICFzb3VuZC5fbXV0ZWQpIHtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUudm9sdW1lID0gdm9sICogSG93bGVyLnZvbHVtZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLl9lbWl0KCd2b2x1bWUnLCBzb3VuZC5faWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291bmQgPSBpZCA/IHNlbGYuX3NvdW5kQnlJZChpZCkgOiBzZWxmLl9zb3VuZHNbMF07XG4gICAgICAgIHJldHVybiBzb3VuZCA/IHNvdW5kLl92b2x1bWUgOiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmFkZSBhIGN1cnJlbnRseSBwbGF5aW5nIHNvdW5kIGJldHdlZW4gdHdvIHZvbHVtZXMgKGlmIG5vIGlkIGlzIHBhc3NlZCwgYWxsIHNvdW5kcyB3aWxsIGZhZGUpLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZnJvbSBUaGUgdmFsdWUgdG8gZmFkZSBmcm9tICgwLjAgdG8gMS4wKS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRvICAgVGhlIHZvbHVtZSB0byBmYWRlIHRvICgwLjAgdG8gMS4wKS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxlbiAgVGltZSBpbiBtaWxsaXNlY29uZHMgdG8gZmFkZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkICAgVGhlIHNvdW5kIGlkIChvbWl0IHRvIGZhZGUgYWxsIHNvdW5kcykuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBmYWRlOiBmdW5jdGlvbihmcm9tLCB0bywgbGVuLCBpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGZhZGUgd2hlbiBjYXBhYmxlLlxuICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJyB8fCBzZWxmLl9wbGF5TG9jaykge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ2ZhZGUnLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmZhZGUoZnJvbSwgdG8sIGxlbiwgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdG8vZnJvbS9sZW4gdmFsdWVzIGFyZSBudW1iZXJzLlxuICAgICAgZnJvbSA9IHBhcnNlRmxvYXQoZnJvbSk7XG4gICAgICB0byA9IHBhcnNlRmxvYXQodG8pO1xuICAgICAgbGVuID0gcGFyc2VGbG9hdChsZW4pO1xuXG4gICAgICAvLyBTZXQgdGhlIHZvbHVtZSB0byB0aGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICBzZWxmLnZvbHVtZShmcm9tLCBpZCk7XG5cbiAgICAgIC8vIEZhZGUgdGhlIHZvbHVtZSBvZiBvbmUgb3IgYWxsIHNvdW5kcy5cbiAgICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIGxpbmVhciBmYWRlIG9yIGZhbGwgYmFjayB0byB0aW1lb3V0cyB3aXRoIEhUTUw1IEF1ZGlvLlxuICAgICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgICAvLyBTdG9wIHRoZSBwcmV2aW91cyBmYWRlIGlmIG5vIHNwcml0ZSBpcyBiZWluZyB1c2VkIChvdGhlcndpc2UsIHZvbHVtZSBoYW5kbGVzIHRoaXMpLlxuICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHNlbGYuX3N0b3BGYWRlKGlkc1tpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UgYXJlIHVzaW5nIFdlYiBBdWRpbywgbGV0IHRoZSBuYXRpdmUgbWV0aG9kcyBkbyB0aGUgYWN0dWFsIGZhZGUuXG4gICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmICFzb3VuZC5fbXV0ZWQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IEhvd2xlci5jdHguY3VycmVudFRpbWU7XG4gICAgICAgICAgICB2YXIgZW5kID0gY3VycmVudFRpbWUgKyAobGVuIC8gMTAwMCk7XG4gICAgICAgICAgICBzb3VuZC5fdm9sdW1lID0gZnJvbTtcbiAgICAgICAgICAgIHNvdW5kLl9ub2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoZnJvbSwgY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgc291bmQuX25vZGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0bywgZW5kKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLl9zdGFydEZhZGVJbnRlcnZhbChzb3VuZCwgZnJvbSwgdG8sIGxlbiwgaWRzW2ldLCB0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBpbnRlcm5hbCBpbnRlcnZhbCB0byBmYWRlIGEgc291bmQuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzb3VuZCBSZWZlcmVuY2UgdG8gc291bmQgdG8gZmFkZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZyb20gVGhlIHZhbHVlIHRvIGZhZGUgZnJvbSAoMC4wIHRvIDEuMCkuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB0byAgIFRoZSB2b2x1bWUgdG8gZmFkZSB0byAoMC4wIHRvIDEuMCkuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBsZW4gIFRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIGZhZGUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAgIFRoZSBzb3VuZCBpZCB0byBmYWRlLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzR3JvdXAgICBJZiB0cnVlLCBzZXQgdGhlIHZvbHVtZSBvbiB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgX3N0YXJ0RmFkZUludGVydmFsOiBmdW5jdGlvbihzb3VuZCwgZnJvbSwgdG8sIGxlbiwgaWQsIGlzR3JvdXApIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciB2b2wgPSBmcm9tO1xuICAgICAgdmFyIGRpZmYgPSB0byAtIGZyb207XG4gICAgICB2YXIgc3RlcHMgPSBNYXRoLmFicyhkaWZmIC8gMC4wMSk7XG4gICAgICB2YXIgc3RlcExlbiA9IE1hdGgubWF4KDQsIChzdGVwcyA+IDApID8gbGVuIC8gc3RlcHMgOiBsZW4pO1xuICAgICAgdmFyIGxhc3RUaWNrID0gRGF0ZS5ub3coKTtcblxuICAgICAgLy8gU3RvcmUgdGhlIHZhbHVlIGJlaW5nIGZhZGVkIHRvLlxuICAgICAgc291bmQuX2ZhZGVUbyA9IHRvO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIHZvbHVtZSB2YWx1ZSBvbiBlYWNoIGludGVydmFsIHRpY2suXG4gICAgICBzb3VuZC5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2b2x1bWUgYmFzZWQgb24gdGhlIHRpbWUgc2luY2UgdGhlIGxhc3QgdGljay5cbiAgICAgICAgdmFyIHRpY2sgPSAoRGF0ZS5ub3coKSAtIGxhc3RUaWNrKSAvIGxlbjtcbiAgICAgICAgbGFzdFRpY2sgPSBEYXRlLm5vdygpO1xuICAgICAgICB2b2wgKz0gZGlmZiAqIHRpY2s7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2b2x1bWUgaXMgaW4gdGhlIHJpZ2h0IGJvdW5kcy5cbiAgICAgICAgdm9sID0gTWF0aC5tYXgoMCwgdm9sKTtcbiAgICAgICAgdm9sID0gTWF0aC5taW4oMSwgdm9sKTtcblxuICAgICAgICAvLyBSb3VuZCB0byB3aXRoaW4gMiBkZWNpbWFsIHBvaW50cy5cbiAgICAgICAgdm9sID0gTWF0aC5yb3VuZCh2b2wgKiAxMDApIC8gMTAwO1xuXG4gICAgICAgIC8vIENoYW5nZSB0aGUgdm9sdW1lLlxuICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICBzb3VuZC5fdm9sdW1lID0gdm9sO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYudm9sdW1lKHZvbCwgc291bmQuX2lkLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgZ3JvdXAncyB2b2x1bWUuXG4gICAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgICAgc2VsZi5fdm9sdW1lID0gdm9sO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2hlbiB0aGUgZmFkZSBpcyBjb21wbGV0ZSwgc3RvcCBpdCBhbmQgZmlyZSBldmVudC5cbiAgICAgICAgaWYgKCh0byA8IGZyb20gJiYgdm9sIDw9IHRvKSB8fCAodG8gPiBmcm9tICYmIHZvbCA+PSB0bykpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHNvdW5kLl9pbnRlcnZhbCk7XG4gICAgICAgICAgc291bmQuX2ludGVydmFsID0gbnVsbDtcbiAgICAgICAgICBzb3VuZC5fZmFkZVRvID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnZvbHVtZSh0bywgc291bmQuX2lkKTtcbiAgICAgICAgICBzZWxmLl9lbWl0KCdmYWRlJywgc291bmQuX2lkKTtcbiAgICAgICAgfVxuICAgICAgfSwgc3RlcExlbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0aGF0IHN0b3BzIHRoZSBjdXJyZW50bHkgcGxheWluZyBmYWRlIHdoZW5cbiAgICAgKiBhIG5ldyBmYWRlIHN0YXJ0cywgdm9sdW1lIGlzIGNoYW5nZWQgb3IgdGhlIHNvdW5kIGlzIHN0b3BwZWQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCBUaGUgc291bmQgaWQuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBfc3RvcEZhZGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWQpO1xuXG4gICAgICBpZiAoc291bmQgJiYgc291bmQuX2ludGVydmFsKSB7XG4gICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgIHNvdW5kLl9ub2RlLmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJJbnRlcnZhbChzb3VuZC5faW50ZXJ2YWwpO1xuICAgICAgICBzb3VuZC5faW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICBzZWxmLnZvbHVtZShzb3VuZC5fZmFkZVRvLCBpZCk7XG4gICAgICAgIHNvdW5kLl9mYWRlVG8gPSBudWxsO1xuICAgICAgICBzZWxmLl9lbWl0KCdmYWRlJywgaWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0L3NldCB0aGUgbG9vcCBwYXJhbWV0ZXIgb24gYSBzb3VuZC4gVGhpcyBtZXRob2QgY2FuIG9wdGlvbmFsbHkgdGFrZSAwLCAxIG9yIDIgYXJndW1lbnRzLlxuICAgICAqICAgbG9vcCgpIC0+IFJldHVybnMgdGhlIGdyb3VwJ3MgbG9vcCB2YWx1ZS5cbiAgICAgKiAgIGxvb3AoaWQpIC0+IFJldHVybnMgdGhlIHNvdW5kIGlkJ3MgbG9vcCB2YWx1ZS5cbiAgICAgKiAgIGxvb3AobG9vcCkgLT4gU2V0cyB0aGUgbG9vcCB2YWx1ZSBmb3IgYWxsIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICogICBsb29wKGxvb3AsIGlkKSAtPiBTZXRzIHRoZSBsb29wIHZhbHVlIG9mIHBhc3NlZCBzb3VuZCBpZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsL0Jvb2xlYW59IFJldHVybnMgc2VsZiBvciBjdXJyZW50IGxvb3AgdmFsdWUuXG4gICAgICovXG4gICAgbG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBsb29wLCBpZCwgc291bmQ7XG5cbiAgICAgIC8vIERldGVybWluZSB0aGUgdmFsdWVzIGZvciBsb29wIGFuZCBpZC5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGdyb3UncyBsb29wIHZhbHVlLlxuICAgICAgICByZXR1cm4gc2VsZi5fbG9vcDtcbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBsb29wID0gYXJnc1swXTtcbiAgICAgICAgICBzZWxmLl9sb29wID0gbG9vcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZXR1cm4gdGhpcyBzb3VuZCdzIGxvb3AgdmFsdWUuXG4gICAgICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQocGFyc2VJbnQoYXJnc1swXSwgMTApKTtcbiAgICAgICAgICByZXR1cm4gc291bmQgPyBzb3VuZC5fbG9vcCA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGxvb3AgPSBhcmdzWzBdO1xuICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gaWQgaXMgcGFzc2VkLCBnZXQgYWxsIElEJ3MgdG8gYmUgbG9vcGVkLlxuICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgICBzb3VuZC5fbG9vcCA9IGxvb3A7XG4gICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmIHNvdW5kLl9ub2RlICYmIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSkge1xuICAgICAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmxvb3AgPSBsb29wO1xuICAgICAgICAgICAgaWYgKGxvb3ApIHtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmxvb3BTdGFydCA9IHNvdW5kLl9zdGFydCB8fCAwO1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UubG9vcEVuZCA9IHNvdW5kLl9zdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0L3NldCB0aGUgcGxheWJhY2sgcmF0ZSBvZiBhIHNvdW5kLiBUaGlzIG1ldGhvZCBjYW4gb3B0aW9uYWxseSB0YWtlIDAsIDEgb3IgMiBhcmd1bWVudHMuXG4gICAgICogICByYXRlKCkgLT4gUmV0dXJucyB0aGUgZmlyc3Qgc291bmQgbm9kZSdzIGN1cnJlbnQgcGxheWJhY2sgcmF0ZS5cbiAgICAgKiAgIHJhdGUoaWQpIC0+IFJldHVybnMgdGhlIHNvdW5kIGlkJ3MgY3VycmVudCBwbGF5YmFjayByYXRlLlxuICAgICAqICAgcmF0ZShyYXRlKSAtPiBTZXRzIHRoZSBwbGF5YmFjayByYXRlIG9mIGFsbCBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAqICAgcmF0ZShyYXRlLCBpZCkgLT4gU2V0cyB0aGUgcGxheWJhY2sgcmF0ZSBvZiBwYXNzZWQgc291bmQgaWQuXG4gICAgICogQHJldHVybiB7SG93bC9OdW1iZXJ9IFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCBwbGF5YmFjayByYXRlLlxuICAgICAqL1xuICAgIHJhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgcmF0ZSwgaWQ7XG5cbiAgICAgIC8vIERldGVybWluZSB0aGUgdmFsdWVzIGJhc2VkIG9uIGFyZ3VtZW50cy5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBXZSB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgcmF0ZSBvZiB0aGUgZmlyc3Qgbm9kZS5cbiAgICAgICAgaWQgPSBzZWxmLl9zb3VuZHNbMF0uX2lkO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGlzIGlzIGFuIElELCBhbmQgaWYgbm90LCBhc3N1bWUgaXQgaXMgYSBuZXcgcmF0ZSB2YWx1ZS5cbiAgICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKCk7XG4gICAgICAgIHZhciBpbmRleCA9IGlkcy5pbmRleE9mKGFyZ3NbMF0pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1swXSwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhdGUgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJhdGUgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRoZSBwbGF5YmFjayByYXRlIG9yIHJldHVybiB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgIHZhciBzb3VuZDtcbiAgICAgIGlmICh0eXBlb2YgcmF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBjaGFuZ2UgcGxheWJhY2sgcmF0ZSB3aGVuIGNhcGFibGUuXG4gICAgICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcgfHwgc2VsZi5fcGxheUxvY2spIHtcbiAgICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiAncmF0ZScsXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzZWxmLnJhdGUuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgZ3JvdXAgcmF0ZS5cbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzZWxmLl9yYXRlID0gcmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBvbmUgb3IgYWxsIHZvbHVtZXMuXG4gICAgICAgIGlkID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8aWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkW2ldKTtcblxuICAgICAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBvdXIgcG9zaXRpb24gd2hlbiB0aGUgcmF0ZSBjaGFuZ2VkIGFuZCB1cGRhdGUgdGhlIHBsYXliYWNrXG4gICAgICAgICAgICAvLyBzdGFydCBwb3NpdGlvbiBzbyB3ZSBjYW4gcHJvcGVybHkgYWRqdXN0IHRoZSBzZWVrIHBvc2l0aW9uIGZvciB0aW1lIGVsYXBzZWQuXG4gICAgICAgICAgICBpZiAoc2VsZi5wbGF5aW5nKGlkW2ldKSkge1xuICAgICAgICAgICAgICBzb3VuZC5fcmF0ZVNlZWsgPSBzZWxmLnNlZWsoaWRbaV0pO1xuICAgICAgICAgICAgICBzb3VuZC5fcGxheVN0YXJ0ID0gc2VsZi5fd2ViQXVkaW8gPyBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lIDogc291bmQuX3BsYXlTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdW5kLl9yYXRlID0gcmF0ZTtcblxuICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBwbGF5YmFjayByYXRlLlxuICAgICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmIHNvdW5kLl9ub2RlICYmIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnNldFZhbHVlQXRUaW1lKHJhdGUsIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5wbGF5YmFja1JhdGUgPSByYXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgdGltZXJzLlxuICAgICAgICAgICAgdmFyIHNlZWsgPSBzZWxmLnNlZWsoaWRbaV0pO1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gKChzZWxmLl9zcHJpdGVbc291bmQuX3Nwcml0ZV1bMF0gKyBzZWxmLl9zcHJpdGVbc291bmQuX3Nwcml0ZV1bMV0pIC8gMTAwMCkgLSBzZWVrO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSAoZHVyYXRpb24gKiAxMDAwKSAvIE1hdGguYWJzKHNvdW5kLl9yYXRlKTtcblxuICAgICAgICAgICAgLy8gU3RhcnQgYSBuZXcgZW5kIHRpbWVyIGlmIHNvdW5kIGlzIGFscmVhZHkgcGxheWluZy5cbiAgICAgICAgICAgIGlmIChzZWxmLl9lbmRUaW1lcnNbaWRbaV1dIHx8ICFzb3VuZC5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgIHNlbGYuX2NsZWFyVGltZXIoaWRbaV0pO1xuICAgICAgICAgICAgICBzZWxmLl9lbmRUaW1lcnNbaWRbaV1dID0gc2V0VGltZW91dChzZWxmLl9lbmRlZC5iaW5kKHNlbGYsIHNvdW5kKSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3JhdGUnLCBzb3VuZC5faWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWQpO1xuICAgICAgICByZXR1cm4gc291bmQgPyBzb3VuZC5fcmF0ZSA6IHNlbGYuX3JhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQvc2V0IHRoZSBzZWVrIHBvc2l0aW9uIG9mIGEgc291bmQuIFRoaXMgbWV0aG9kIGNhbiBvcHRpb25hbGx5IHRha2UgMCwgMSBvciAyIGFyZ3VtZW50cy5cbiAgICAgKiAgIHNlZWsoKSAtPiBSZXR1cm5zIHRoZSBmaXJzdCBzb3VuZCBub2RlJ3MgY3VycmVudCBzZWVrIHBvc2l0aW9uLlxuICAgICAqICAgc2VlayhpZCkgLT4gUmV0dXJucyB0aGUgc291bmQgaWQncyBjdXJyZW50IHNlZWsgcG9zaXRpb24uXG4gICAgICogICBzZWVrKHNlZWspIC0+IFNldHMgdGhlIHNlZWsgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHNvdW5kIG5vZGUuXG4gICAgICogICBzZWVrKHNlZWssIGlkKSAtPiBTZXRzIHRoZSBzZWVrIHBvc2l0aW9uIG9mIHBhc3NlZCBzb3VuZCBpZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsL051bWJlcn0gUmV0dXJucyBzZWxmIG9yIHRoZSBjdXJyZW50IHNlZWsgcG9zaXRpb24uXG4gICAgICovXG4gICAgc2VlazogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBzZWVrLCBpZDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB2YWx1ZXMgYmFzZWQgb24gYXJndW1lbnRzLlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFdlIHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgbm9kZS5cbiAgICAgICAgaWQgPSBzZWxmLl9zb3VuZHNbMF0uX2lkO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGlzIGlzIGFuIElELCBhbmQgaWYgbm90LCBhc3N1bWUgaXQgaXMgYSBuZXcgc2VlayBwb3NpdGlvbi5cbiAgICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKCk7XG4gICAgICAgIHZhciBpbmRleCA9IGlkcy5pbmRleE9mKGFyZ3NbMF0pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1swXSwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuX3NvdW5kcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZCA9IHNlbGYuX3NvdW5kc1swXS5faWQ7XG4gICAgICAgICAgc2VlayA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgc2VlayA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1sxXSwgMTApO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBJRCwgYmFpbCBvdXQuXG4gICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBzZWVrIHdoZW4gY2FwYWJsZS5cbiAgICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcgfHwgc2VsZi5fcGxheUxvY2spIHtcbiAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6ICdzZWVrJyxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5zZWVrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWQpO1xuXG4gICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWVrID09PSAnbnVtYmVyJyAmJiBzZWVrID49IDApIHtcbiAgICAgICAgICAvLyBQYXVzZSB0aGUgc291bmQgYW5kIHVwZGF0ZSBwb3NpdGlvbiBmb3IgcmVzdGFydGluZyBwbGF5YmFjay5cbiAgICAgICAgICB2YXIgcGxheWluZyA9IHNlbGYucGxheWluZyhpZCk7XG4gICAgICAgICAgaWYgKHBsYXlpbmcpIHtcbiAgICAgICAgICAgIHNlbGYucGF1c2UoaWQsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1vdmUgdGhlIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBhbmQgY2FuY2VsIHRpbWVyLlxuICAgICAgICAgIHNvdW5kLl9zZWVrID0gc2VlaztcbiAgICAgICAgICBzb3VuZC5fZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLl9jbGVhclRpbWVyKGlkKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2VlayBwb3NpdGlvbiBmb3IgSFRNTDUgQXVkaW8uXG4gICAgICAgICAgaWYgKCFzZWxmLl93ZWJBdWRpbyAmJiBzb3VuZC5fbm9kZSAmJiAhaXNOYU4oc291bmQuX25vZGUuZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5jdXJyZW50VGltZSA9IHNlZWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2VlayBhbmQgZW1pdCB3aGVuIHJlYWR5LlxuICAgICAgICAgIHZhciBzZWVrQW5kRW1pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5fZW1pdCgnc2VlaycsIGlkKTtcblxuICAgICAgICAgICAgLy8gUmVzdGFydCB0aGUgcGxheWJhY2sgaWYgdGhlIHNvdW5kIHdhcyBwbGF5aW5nLlxuICAgICAgICAgICAgaWYgKHBsYXlpbmcpIHtcbiAgICAgICAgICAgICAgc2VsZi5wbGF5KGlkLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHBsYXkgbG9jayB0byBiZSB1bnNldCBiZWZvcmUgZW1pdHRpbmcgKEhUTUw1IEF1ZGlvKS5cbiAgICAgICAgICBpZiAocGxheWluZyAmJiAhc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAgIHZhciBlbWl0U2VlayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoIXNlbGYuX3BsYXlMb2NrKSB7XG4gICAgICAgICAgICAgICAgc2Vla0FuZEVtaXQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGVtaXRTZWVrLCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZW1pdFNlZWssIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWVrQW5kRW1pdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAgIHZhciByZWFsVGltZSA9IHNlbGYucGxheWluZyhpZCkgPyBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lIC0gc291bmQuX3BsYXlTdGFydCA6IDA7XG4gICAgICAgICAgICB2YXIgcmF0ZVNlZWsgPSBzb3VuZC5fcmF0ZVNlZWsgPyBzb3VuZC5fcmF0ZVNlZWsgLSBzb3VuZC5fc2VlayA6IDA7XG4gICAgICAgICAgICByZXR1cm4gc291bmQuX3NlZWsgKyAocmF0ZVNlZWsgKyByZWFsVGltZSAqIE1hdGguYWJzKHNvdW5kLl9yYXRlKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VuZC5fbm9kZS5jdXJyZW50VGltZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgc3BlY2lmaWMgc291bmQgaXMgY3VycmVudGx5IHBsYXlpbmcgb3Igbm90IChpZiBpZCBpcyBwcm92aWRlZCksIG9yIGNoZWNrIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgc291bmRzIGluIHRoZSBncm91cCBpcyBwbGF5aW5nIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBpZCBUaGUgc291bmQgaWQgdG8gY2hlY2suIElmIG5vbmUgaXMgcGFzc2VkLCB0aGUgd2hvbGUgc291bmQgZ3JvdXAgaXMgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHBsYXlpbmcgYW5kIGZhbHNlIGlmIG5vdC5cbiAgICAgKi9cbiAgICBwbGF5aW5nOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBDaGVjayB0aGUgcGFzc2VkIHNvdW5kIElEIChpZiBhbnkpLlxuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkKTtcbiAgICAgICAgcmV0dXJuIHNvdW5kID8gIXNvdW5kLl9wYXVzZWQgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBsb29wIHRocm91Z2ggYWxsIHNvdW5kcyBhbmQgY2hlY2sgaWYgYW55IGFyZSBwbGF5aW5nLlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXNlbGYuX3NvdW5kc1tpXS5fcGF1c2VkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGR1cmF0aW9uIG9mIHRoaXMgc291bmQuIFBhc3NpbmcgYSBzb3VuZCBpZCB3aWxsIHJldHVybiB0aGUgc3ByaXRlIGR1cmF0aW9uLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgVGhlIHNvdW5kIGlkIHRvIGNoZWNrLiBJZiBub25lIGlzIHBhc3NlZCwgcmV0dXJuIGZ1bGwgc291cmNlIGR1cmF0aW9uLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gQXVkaW8gZHVyYXRpb24gaW4gc2Vjb25kcy5cbiAgICAgKi9cbiAgICBkdXJhdGlvbjogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBkdXJhdGlvbiA9IHNlbGYuX2R1cmF0aW9uO1xuXG4gICAgICAvLyBJZiB3ZSBwYXNzIGFuIElELCBnZXQgdGhlIHNvdW5kIGFuZCByZXR1cm4gdGhlIHNwcml0ZSBsZW5ndGguXG4gICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWQpO1xuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIGR1cmF0aW9uID0gc2VsZi5fc3ByaXRlW3NvdW5kLl9zcHJpdGVdWzFdIC8gMTAwMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxvYWRlZCBzdGF0ZSBvZiB0aGlzIEhvd2wuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAndW5sb2FkZWQnLCAnbG9hZGluZycsICdsb2FkZWQnXG4gICAgICovXG4gICAgc3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmxvYWQgYW5kIGRlc3Ryb3kgdGhlIGN1cnJlbnQgSG93bCBvYmplY3QuXG4gICAgICogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IHN0b3AgYWxsIHNvdW5kIGluc3RhbmNlcyBhdHRhY2hlZCB0byB0aGlzIGdyb3VwLlxuICAgICAqL1xuICAgIHVubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIFN0b3AgcGxheWluZyBhbnkgYWN0aXZlIHNvdW5kcy5cbiAgICAgIHZhciBzb3VuZHMgPSBzZWxmLl9zb3VuZHM7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8c291bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFN0b3AgdGhlIHNvdW5kIGlmIGl0IGlzIGN1cnJlbnRseSBwbGF5aW5nLlxuICAgICAgICBpZiAoIXNvdW5kc1tpXS5fcGF1c2VkKSB7XG4gICAgICAgICAgc2VsZi5zdG9wKHNvdW5kc1tpXS5faWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2Ugb3IgZGlzY29ubmVjdC5cbiAgICAgICAgaWYgKCFzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgIC8vIFNldCB0aGUgc291cmNlIHRvIDAtc2Vjb25kIHNpbGVuY2UgdG8gc3RvcCBhbnkgZG93bmxvYWRpbmcgKGV4Y2VwdCBpbiBJRSkuXG4gICAgICAgICAgc2VsZi5fY2xlYXJTb3VuZChzb3VuZHNbaV0uX25vZGUpO1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIGFueSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgc291bmRzW2ldLl9ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgc291bmRzW2ldLl9lcnJvckZuLCBmYWxzZSk7XG4gICAgICAgICAgc291bmRzW2ldLl9ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoSG93bGVyLl9jYW5QbGF5RXZlbnQsIHNvdW5kc1tpXS5fbG9hZEZuLCBmYWxzZSk7XG5cbiAgICAgICAgICAvLyBSZWxlYXNlIHRoZSBBdWRpbyBvYmplY3QgYmFjayB0byB0aGUgcG9vbC5cbiAgICAgICAgICBIb3dsZXIuX3JlbGVhc2VIdG1sNUF1ZGlvKHNvdW5kc1tpXS5fbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbXB0eSBvdXQgYWxsIG9mIHRoZSBub2Rlcy5cbiAgICAgICAgZGVsZXRlIHNvdW5kc1tpXS5fbm9kZTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIHRpbWVycyBhcmUgY2xlYXJlZCBvdXQuXG4gICAgICAgIHNlbGYuX2NsZWFyVGltZXIoc291bmRzW2ldLl9pZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgcmVmZXJlbmNlcyBpbiB0aGUgZ2xvYmFsIEhvd2xlciBvYmplY3QuXG4gICAgICB2YXIgaW5kZXggPSBIb3dsZXIuX2hvd2xzLmluZGV4T2Yoc2VsZik7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBIb3dsZXIuX2hvd2xzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlbGV0ZSB0aGlzIHNvdW5kIGZyb20gdGhlIGNhY2hlIChpZiBubyBvdGhlciBIb3dsIGlzIHVzaW5nIGl0KS5cbiAgICAgIHZhciByZW1DYWNoZSA9IHRydWU7XG4gICAgICBmb3IgKGk9MDsgaTxIb3dsZXIuX2hvd2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChIb3dsZXIuX2hvd2xzW2ldLl9zcmMgPT09IHNlbGYuX3NyYyB8fCBzZWxmLl9zcmMuaW5kZXhPZihIb3dsZXIuX2hvd2xzW2ldLl9zcmMpID49IDApIHtcbiAgICAgICAgICByZW1DYWNoZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWNoZSAmJiByZW1DYWNoZSkge1xuICAgICAgICBkZWxldGUgY2FjaGVbc2VsZi5fc3JjXTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgZ2xvYmFsIGVycm9ycy5cbiAgICAgIEhvd2xlci5ub0F1ZGlvID0gZmFsc2U7XG5cbiAgICAgIC8vIENsZWFyIG91dCBgc2VsZmAuXG4gICAgICBzZWxmLl9zdGF0ZSA9ICd1bmxvYWRlZCc7XG4gICAgICBzZWxmLl9zb3VuZHMgPSBbXTtcbiAgICAgIHNlbGYgPSBudWxsO1xuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuIHRvIGEgY3VzdG9tIGV2ZW50LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gICBldmVudCBFdmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICBMaXN0ZW5lciB0byBjYWxsLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICBpZCAgICAob3B0aW9uYWwpIE9ubHkgbGlzdGVuIHRvIGV2ZW50cyBmb3IgdGhpcyBzb3VuZC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgb25jZSAgKElOVEVSTkFMKSBNYXJrcyBldmVudCB0byBmaXJlIG9ubHkgb25jZS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihldmVudCwgZm4sIGlkLCBvbmNlKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gc2VsZlsnX29uJyArIGV2ZW50XTtcblxuICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudHMucHVzaChvbmNlID8ge2lkOiBpZCwgZm46IGZuLCBvbmNlOiBvbmNlfSA6IHtpZDogaWQsIGZuOiBmbn0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY3VzdG9tIGV2ZW50LiBDYWxsIHdpdGhvdXQgcGFyYW1ldGVycyB0byByZW1vdmUgYWxsIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgZXZlbnQgRXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgTGlzdGVuZXIgdG8gcmVtb3ZlLiBMZWF2ZSBlbXB0eSB0byByZW1vdmUgYWxsLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICBpZCAgICAob3B0aW9uYWwpIE9ubHkgcmVtb3ZlIGV2ZW50cyBmb3IgdGhpcyBzb3VuZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24oZXZlbnQsIGZuLCBpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGV2ZW50cyA9IHNlbGZbJ19vbicgKyBldmVudF07XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIC8vIEFsbG93IHBhc3NpbmcganVzdCBhbiBldmVudCBhbmQgSUQuXG4gICAgICBpZiAodHlwZW9mIGZuID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZCA9IGZuO1xuICAgICAgICBmbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChmbiB8fCBpZCkge1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggZXZlbnQgc3RvcmUgYW5kIHJlbW92ZSB0aGUgcGFzc2VkIGZ1bmN0aW9uLlxuICAgICAgICBmb3IgKGk9MDsgaTxldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXNJZCA9IChpZCA9PT0gZXZlbnRzW2ldLmlkKTtcbiAgICAgICAgICBpZiAoZm4gPT09IGV2ZW50c1tpXS5mbiAmJiBpc0lkIHx8ICFmbiAmJiBpc0lkKSB7XG4gICAgICAgICAgICBldmVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50KSB7XG4gICAgICAgIC8vIENsZWFyIG91dCBhbGwgZXZlbnRzIG9mIHRoaXMgdHlwZS5cbiAgICAgICAgc2VsZlsnX29uJyArIGV2ZW50XSA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IGFsbCBldmVudHMgb2YgZXZlcnkgdHlwZS5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzZWxmKTtcbiAgICAgICAgZm9yIChpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgoa2V5c1tpXS5pbmRleE9mKCdfb24nKSA9PT0gMCkgJiYgQXJyYXkuaXNBcnJheShzZWxmW2tleXNbaV1dKSkge1xuICAgICAgICAgICAgc2VsZltrZXlzW2ldXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuIHRvIGEgY3VzdG9tIGV2ZW50IGFuZCByZW1vdmUgaXQgb25jZSBmaXJlZC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgZXZlbnQgRXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgTGlzdGVuZXIgdG8gY2FsbC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgaWQgICAgKG9wdGlvbmFsKSBPbmx5IGxpc3RlbiB0byBldmVudHMgZm9yIHRoaXMgc291bmQuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBvbmNlOiBmdW5jdGlvbihldmVudCwgZm4sIGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIFNldHVwIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgIHNlbGYub24oZXZlbnQsIGZuLCBpZCwgMSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbWl0IGFsbCBldmVudHMgb2YgYSBzcGVjaWZpYyB0eXBlIGFuZCBwYXNzIHRoZSBzb3VuZCBpZC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50IEV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAgICBTb3VuZCBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG1zZyAgIE1lc3NhZ2UgdG8gZ28gd2l0aCBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9lbWl0OiBmdW5jdGlvbihldmVudCwgaWQsIG1zZykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGV2ZW50cyA9IHNlbGZbJ19vbicgKyBldmVudF07XG5cbiAgICAgIC8vIExvb3AgdGhyb3VnaCBldmVudCBzdG9yZSBhbmQgZmlyZSBhbGwgZnVuY3Rpb25zLlxuICAgICAgZm9yICh2YXIgaT1ldmVudHMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICAvLyBPbmx5IGZpcmUgdGhlIGxpc3RlbmVyIGlmIHRoZSBjb3JyZWN0IElEIGlzIHVzZWQuXG4gICAgICAgIGlmICghZXZlbnRzW2ldLmlkIHx8IGV2ZW50c1tpXS5pZCA9PT0gaWQgfHwgZXZlbnQgPT09ICdsb2FkJykge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgaWQsIG1zZyk7XG4gICAgICAgICAgfS5iaW5kKHNlbGYsIGV2ZW50c1tpXS5mbiksIDApO1xuXG4gICAgICAgICAgLy8gSWYgdGhpcyBldmVudCB3YXMgc2V0dXAgd2l0aCBgb25jZWAsIHJlbW92ZSBpdC5cbiAgICAgICAgICBpZiAoZXZlbnRzW2ldLm9uY2UpIHtcbiAgICAgICAgICAgIHNlbGYub2ZmKGV2ZW50LCBldmVudHNbaV0uZm4sIGV2ZW50c1tpXS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFBhc3MgdGhlIGV2ZW50IHR5cGUgaW50byBsb2FkIHF1ZXVlIHNvIHRoYXQgaXQgY2FuIGNvbnRpbnVlIHN0ZXBwaW5nLlxuICAgICAgc2VsZi5fbG9hZFF1ZXVlKGV2ZW50KTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1ZXVlIG9mIGFjdGlvbnMgaW5pdGlhdGVkIGJlZm9yZSB0aGUgc291bmQgaGFzIGxvYWRlZC5cbiAgICAgKiBUaGVzZSB3aWxsIGJlIGNhbGxlZCBpbiBzZXF1ZW5jZSwgd2l0aCB0aGUgbmV4dCBvbmx5IGZpcmluZ1xuICAgICAqIGFmdGVyIHRoZSBwcmV2aW91cyBoYXMgZmluaXNoZWQgZXhlY3V0aW5nIChldmVuIGlmIGFzeW5jIGxpa2UgcGxheSkuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBfbG9hZFF1ZXVlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoc2VsZi5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdGFzayA9IHNlbGYuX3F1ZXVlWzBdO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIHRhc2sgaWYgYSBtYXRjaGluZyBldmVudCB3YXMgcGFzc2VkLlxuICAgICAgICBpZiAodGFzay5ldmVudCA9PT0gZXZlbnQpIHtcbiAgICAgICAgICBzZWxmLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIHNlbGYuX2xvYWRRdWV1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVuIHRoZSB0YXNrIGlmIG5vIGV2ZW50IHR5cGUgaXMgcGFzc2VkLlxuICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgdGFzay5hY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBwbGF5YmFjayBlbmRzIGF0IHRoZSBlbmQgb2YgdGhlIGR1cmF0aW9uLlxuICAgICAqIEBwYXJhbSAge1NvdW5kfSBzb3VuZCBUaGUgc291bmQgb2JqZWN0IHRvIHdvcmsgd2l0aC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9lbmRlZDogZnVuY3Rpb24oc291bmQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzcHJpdGUgPSBzb3VuZC5fc3ByaXRlO1xuXG4gICAgICAvLyBJZiB3ZSBhcmUgdXNpbmcgSUUgYW5kIHRoZXJlIHdhcyBuZXR3b3JrIGxhdGVuY3kgd2UgbWF5IGJlIGNsaXBwaW5nXG4gICAgICAvLyBhdWRpbyBiZWZvcmUgaXQgY29tcGxldGVzIHBsYXlpbmcuIExldHMgY2hlY2sgdGhlIG5vZGUgdG8gbWFrZSBzdXJlIGl0XG4gICAgICAvLyBiZWxpZXZlcyBpdCBoYXMgY29tcGxldGVkLCBiZWZvcmUgZW5kaW5nIHRoZSBwbGF5YmFjay5cbiAgICAgIGlmICghc2VsZi5fd2ViQXVkaW8gJiYgc291bmQuX25vZGUgJiYgIXNvdW5kLl9ub2RlLnBhdXNlZCAmJiAhc291bmQuX25vZGUuZW5kZWQgJiYgc291bmQuX25vZGUuY3VycmVudFRpbWUgPCBzb3VuZC5fc3RvcCkge1xuICAgICAgICBzZXRUaW1lb3V0KHNlbGYuX2VuZGVkLmJpbmQoc2VsZiwgc291bmQpLCAxMDApO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgLy8gU2hvdWxkIHRoaXMgc291bmQgbG9vcD9cbiAgICAgIHZhciBsb29wID0gISEoc291bmQuX2xvb3AgfHwgc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMl0pO1xuXG4gICAgICAvLyBGaXJlIHRoZSBlbmRlZCBldmVudC5cbiAgICAgIHNlbGYuX2VtaXQoJ2VuZCcsIHNvdW5kLl9pZCk7XG5cbiAgICAgIC8vIFJlc3RhcnQgdGhlIHBsYXliYWNrIGZvciBIVE1MNSBBdWRpbyBsb29wLlxuICAgICAgaWYgKCFzZWxmLl93ZWJBdWRpbyAmJiBsb29wKSB7XG4gICAgICAgIHNlbGYuc3RvcChzb3VuZC5faWQsIHRydWUpLnBsYXkoc291bmQuX2lkKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzdGFydCB0aGlzIHRpbWVyIGlmIG9uIGEgV2ViIEF1ZGlvIGxvb3AuXG4gICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgbG9vcCkge1xuICAgICAgICBzZWxmLl9lbWl0KCdwbGF5Jywgc291bmQuX2lkKTtcbiAgICAgICAgc291bmQuX3NlZWsgPSBzb3VuZC5fc3RhcnQgfHwgMDtcbiAgICAgICAgc291bmQuX3JhdGVTZWVrID0gMDtcbiAgICAgICAgc291bmQuX3BsYXlTdGFydCA9IEhvd2xlci5jdHguY3VycmVudFRpbWU7XG5cbiAgICAgICAgdmFyIHRpbWVvdXQgPSAoKHNvdW5kLl9zdG9wIC0gc291bmQuX3N0YXJ0KSAqIDEwMDApIC8gTWF0aC5hYnMoc291bmQuX3JhdGUpO1xuICAgICAgICBzZWxmLl9lbmRUaW1lcnNbc291bmQuX2lkXSA9IHNldFRpbWVvdXQoc2VsZi5fZW5kZWQuYmluZChzZWxmLCBzb3VuZCksIHRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXJrIHRoZSBub2RlIGFzIHBhdXNlZC5cbiAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiAhbG9vcCkge1xuICAgICAgICBzb3VuZC5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgc291bmQuX2VuZGVkID0gdHJ1ZTtcbiAgICAgICAgc291bmQuX3NlZWsgPSBzb3VuZC5fc3RhcnQgfHwgMDtcbiAgICAgICAgc291bmQuX3JhdGVTZWVrID0gMDtcbiAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihzb3VuZC5faWQpO1xuXG4gICAgICAgIC8vIENsZWFuIHVwIHRoZSBidWZmZXIgc291cmNlLlxuICAgICAgICBzZWxmLl9jbGVhbkJ1ZmZlcihzb3VuZC5fbm9kZSk7XG5cbiAgICAgICAgLy8gQXR0ZW1wdCB0byBhdXRvLXN1c3BlbmQgQXVkaW9Db250ZXh0IGlmIG5vIHNvdW5kcyBhcmUgc3RpbGwgcGxheWluZy5cbiAgICAgICAgSG93bGVyLl9hdXRvU3VzcGVuZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGVuIHVzaW5nIGEgc3ByaXRlLCBlbmQgdGhlIHRyYWNrLlxuICAgICAgaWYgKCFzZWxmLl93ZWJBdWRpbyAmJiAhbG9vcCkge1xuICAgICAgICBzZWxmLnN0b3Aoc291bmQuX2lkLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBlbmQgdGltZXIgZm9yIGEgc291bmQgcGxheWJhY2suXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCBUaGUgc291bmQgSUQuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBfY2xlYXJUaW1lcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKHNlbGYuX2VuZFRpbWVyc1tpZF0pIHtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVvdXQgb3IgcmVtb3ZlIHRoZSBlbmRlZCBsaXN0ZW5lci5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmLl9lbmRUaW1lcnNbaWRdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX2VuZFRpbWVyc1tpZF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZCk7XG4gICAgICAgICAgaWYgKHNvdW5kICYmIHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHNlbGYuX2VuZFRpbWVyc1tpZF0sIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgc2VsZi5fZW5kVGltZXJzW2lkXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc291bmQgaWRlbnRpZmllZCBieSB0aGlzIElELCBvciByZXR1cm4gbnVsbC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFNvdW5kIElEXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICBTb3VuZCBvYmplY3Qgb3IgbnVsbC5cbiAgICAgKi9cbiAgICBfc291bmRCeUlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHNvdW5kcyBhbmQgZmluZCB0aGUgb25lIHdpdGggdGhpcyBJRC5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9zb3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlkID09PSBzZWxmLl9zb3VuZHNbaV0uX2lkKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3NvdW5kc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGluYWN0aXZlIHNvdW5kIGZyb20gdGhlIHBvb2wgb3IgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgKiBAcmV0dXJuIHtTb3VuZH0gU291bmQgcGxheWJhY2sgb2JqZWN0LlxuICAgICAqL1xuICAgIF9pbmFjdGl2ZVNvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgc2VsZi5fZHJhaW4oKTtcblxuICAgICAgLy8gRmluZCB0aGUgZmlyc3QgaW5hY3RpdmUgbm9kZSB0byByZWN5Y2xlLlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fc291bmRzW2ldLl9lbmRlZCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLl9zb3VuZHNbaV0ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBpbmFjdGl2ZSBub2RlIHdhcyBmb3VuZCwgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgIHJldHVybiBuZXcgU291bmQoc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYWluIGV4Y2VzcyBpbmFjdGl2ZSBzb3VuZHMgZnJvbSB0aGUgcG9vbC5cbiAgICAgKi9cbiAgICBfZHJhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGxpbWl0ID0gc2VsZi5fcG9vbDtcbiAgICAgIHZhciBjbnQgPSAwO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbGVzcyBzb3VuZHMgdGhhbiB0aGUgbWF4IHBvb2wgc2l6ZSwgd2UgYXJlIGRvbmUuXG4gICAgICBpZiAoc2VsZi5fc291bmRzLmxlbmd0aCA8IGxpbWl0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ291bnQgdGhlIG51bWJlciBvZiBpbmFjdGl2ZSBzb3VuZHMuXG4gICAgICBmb3IgKGk9MDsgaTxzZWxmLl9zb3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX3NvdW5kc1tpXS5fZW5kZWQpIHtcbiAgICAgICAgICBjbnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgZXhjZXNzIGluYWN0aXZlIHNvdW5kcywgZ29pbmcgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgIGZvciAoaT1zZWxmLl9zb3VuZHMubGVuZ3RoIC0gMTsgaT49MDsgaS0tKSB7XG4gICAgICAgIGlmIChjbnQgPD0gbGltaXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5fc291bmRzW2ldLl9lbmRlZCkge1xuICAgICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIGF1ZGlvIHNvdXJjZSB3aGVuIHVzaW5nIFdlYiBBdWRpby5cbiAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgc2VsZi5fc291bmRzW2ldLl9ub2RlKSB7XG4gICAgICAgICAgICBzZWxmLl9zb3VuZHNbaV0uX25vZGUuZGlzY29ubmVjdCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZW1vdmUgc291bmRzIHVudGlsIHdlIGhhdmUgdGhlIHBvb2wgc2l6ZS5cbiAgICAgICAgICBzZWxmLl9zb3VuZHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGNudC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgSUQncyBmcm9tIHRoZSBzb3VuZHMgcG9vbC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIE9ubHkgcmV0dXJuIG9uZSBJRCBpZiBvbmUgaXMgcGFzc2VkLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICBBcnJheSBvZiBJRHMuXG4gICAgICovXG4gICAgX2dldFNvdW5kSWRzOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgaWRzID0gW107XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9zb3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZHMucHVzaChzZWxmLl9zb3VuZHNbaV0uX2lkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2lkXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgc291bmQgYmFjayBpbnRvIHRoZSBidWZmZXIgc291cmNlLlxuICAgICAqIEBwYXJhbSAge1NvdW5kfSBzb3VuZCBUaGUgc291bmQgb2JqZWN0IHRvIHdvcmsgd2l0aC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9yZWZyZXNoQnVmZmVyOiBmdW5jdGlvbihzb3VuZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBTZXR1cCB0aGUgYnVmZmVyIHNvdXJjZSBmb3IgcGxheWJhY2suXG4gICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UgPSBIb3dsZXIuY3R4LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmJ1ZmZlciA9IGNhY2hlW3NlbGYuX3NyY107XG5cbiAgICAgIC8vIENvbm5lY3QgdG8gdGhlIGNvcnJlY3Qgbm9kZS5cbiAgICAgIGlmIChzb3VuZC5fcGFubmVyKSB7XG4gICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5jb25uZWN0KHNvdW5kLl9wYW5uZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmNvbm5lY3Qoc291bmQuX25vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXR1cCBsb29waW5nIGFuZCBwbGF5YmFjayByYXRlLlxuICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmxvb3AgPSBzb3VuZC5fbG9vcDtcbiAgICAgIGlmIChzb3VuZC5fbG9vcCkge1xuICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UubG9vcFN0YXJ0ID0gc291bmQuX3N0YXJ0IHx8IDA7XG4gICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5sb29wRW5kID0gc291bmQuX3N0b3AgfHwgMDtcbiAgICAgIH1cbiAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUoc291bmQuX3JhdGUsIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJldmVudCBtZW1vcnkgbGVha3MgYnkgY2xlYW5pbmcgdXAgdGhlIGJ1ZmZlciBzb3VyY2UgYWZ0ZXIgcGxheWJhY2suXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlIFNvdW5kJ3MgYXVkaW8gbm9kZSBjb250YWluaW5nIHRoZSBidWZmZXIgc291cmNlLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX2NsZWFuQnVmZmVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgaXNJT1MgPSBIb3dsZXIuX25hdmlnYXRvciAmJiBIb3dsZXIuX25hdmlnYXRvci52ZW5kb3IuaW5kZXhPZignQXBwbGUnKSA+PSAwO1xuXG4gICAgICBpZiAoSG93bGVyLl9zY3JhdGNoQnVmZmVyICYmIG5vZGUuYnVmZmVyU291cmNlKSB7XG4gICAgICAgIG5vZGUuYnVmZmVyU291cmNlLm9uZW5kZWQgPSBudWxsO1xuICAgICAgICBub2RlLmJ1ZmZlclNvdXJjZS5kaXNjb25uZWN0KDApO1xuICAgICAgICBpZiAoaXNJT1MpIHtcbiAgICAgICAgICB0cnkgeyBub2RlLmJ1ZmZlclNvdXJjZS5idWZmZXIgPSBIb3dsZXIuX3NjcmF0Y2hCdWZmZXI7IH0gY2F0Y2goZSkge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZS5idWZmZXJTb3VyY2UgPSBudWxsO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzb3VyY2UgdG8gYSAwLXNlY29uZCBzaWxlbmNlIHRvIHN0b3AgYW55IGRvd25sb2FkaW5nIChleGNlcHQgaW4gSUUpLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSBBdWRpbyBub2RlIHRvIGNsZWFyLlxuICAgICAqL1xuICAgIF9jbGVhclNvdW5kOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgY2hlY2tJRSA9IC9NU0lFIHxUcmlkZW50XFwvLy50ZXN0KEhvd2xlci5fbmF2aWdhdG9yICYmIEhvd2xlci5fbmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICBpZiAoIWNoZWNrSUUpIHtcbiAgICAgICAgbm9kZS5zcmMgPSAnZGF0YTphdWRpby93YXY7YmFzZTY0LFVrbEdSaWdBQUFCWFFWWkZabTEwSUJJQUFBQUJBQUVBUkt3QUFJaFlBUUFDQUJBQUFBQmtZWFJoQWdBQUFBRUEnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKiogU2luZ2xlIFNvdW5kIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIFNldHVwIHRoZSBzb3VuZCBvYmplY3QsIHdoaWNoIGVhY2ggbm9kZSBhdHRhY2hlZCB0byBhIEhvd2wgZ3JvdXAgaXMgY29udGFpbmVkIGluLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaG93bCBUaGUgSG93bCBwYXJlbnQgZ3JvdXAuXG4gICAqL1xuICB2YXIgU291bmQgPSBmdW5jdGlvbihob3dsKSB7XG4gICAgdGhpcy5fcGFyZW50ID0gaG93bDtcbiAgICB0aGlzLmluaXQoKTtcbiAgfTtcbiAgU291bmQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSBuZXcgU291bmQgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge1NvdW5kfVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGYuX3BhcmVudDtcblxuICAgICAgLy8gU2V0dXAgdGhlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgICAgIHNlbGYuX211dGVkID0gcGFyZW50Ll9tdXRlZDtcbiAgICAgIHNlbGYuX2xvb3AgPSBwYXJlbnQuX2xvb3A7XG4gICAgICBzZWxmLl92b2x1bWUgPSBwYXJlbnQuX3ZvbHVtZTtcbiAgICAgIHNlbGYuX3JhdGUgPSBwYXJlbnQuX3JhdGU7XG4gICAgICBzZWxmLl9zZWVrID0gMDtcbiAgICAgIHNlbGYuX3BhdXNlZCA9IHRydWU7XG4gICAgICBzZWxmLl9lbmRlZCA9IHRydWU7XG4gICAgICBzZWxmLl9zcHJpdGUgPSAnX19kZWZhdWx0JztcblxuICAgICAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgSUQgZm9yIHRoaXMgc291bmQuXG4gICAgICBzZWxmLl9pZCA9ICsrSG93bGVyLl9jb3VudGVyO1xuXG4gICAgICAvLyBBZGQgaXRzZWxmIHRvIHRoZSBwYXJlbnQncyBwb29sLlxuICAgICAgcGFyZW50Ll9zb3VuZHMucHVzaChzZWxmKTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgbm9kZS5cbiAgICAgIHNlbGYuY3JlYXRlKCk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHNldHVwIGEgbmV3IHNvdW5kIG9iamVjdCwgd2hldGhlciBIVE1MNSBBdWRpbyBvciBXZWIgQXVkaW8uXG4gICAgICogQHJldHVybiB7U291bmR9XG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnQgPSBzZWxmLl9wYXJlbnQ7XG4gICAgICB2YXIgdm9sdW1lID0gKEhvd2xlci5fbXV0ZWQgfHwgc2VsZi5fbXV0ZWQgfHwgc2VsZi5fcGFyZW50Ll9tdXRlZCkgPyAwIDogc2VsZi5fdm9sdW1lO1xuXG4gICAgICBpZiAocGFyZW50Ll93ZWJBdWRpbykge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGdhaW4gbm9kZSBmb3IgY29udHJvbGxpbmcgdm9sdW1lICh0aGUgc291cmNlIHdpbGwgY29ubmVjdCB0byB0aGlzKS5cbiAgICAgICAgc2VsZi5fbm9kZSA9ICh0eXBlb2YgSG93bGVyLmN0eC5jcmVhdGVHYWluID09PSAndW5kZWZpbmVkJykgPyBIb3dsZXIuY3R4LmNyZWF0ZUdhaW5Ob2RlKCkgOiBIb3dsZXIuY3R4LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgc2VsZi5fbm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKHZvbHVtZSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgIHNlbGYuX25vZGUucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5fbm9kZS5jb25uZWN0KEhvd2xlci5tYXN0ZXJHYWluKTtcbiAgICAgIH0gZWxzZSBpZiAoIUhvd2xlci5ub0F1ZGlvKSB7XG4gICAgICAgIC8vIEdldCBhbiB1bmxvY2tlZCBBdWRpbyBvYmplY3QgZnJvbSB0aGUgcG9vbC5cbiAgICAgICAgc2VsZi5fbm9kZSA9IEhvd2xlci5fb2J0YWluSHRtbDVBdWRpbygpO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3IgZXJyb3JzIChodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjLWF1dGhvci12aWV3L3NwZWMuaHRtbCNtZWRpYWVycm9yKS5cbiAgICAgICAgc2VsZi5fZXJyb3JGbiA9IHNlbGYuX2Vycm9yTGlzdGVuZXIuYmluZChzZWxmKTtcbiAgICAgICAgc2VsZi5fbm9kZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHNlbGYuX2Vycm9yRm4sIGZhbHNlKTtcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yICdjYW5wbGF5dGhyb3VnaCcgZXZlbnQgdG8gbGV0IHVzIGtub3cgdGhlIHNvdW5kIGlzIHJlYWR5LlxuICAgICAgICBzZWxmLl9sb2FkRm4gPSBzZWxmLl9sb2FkTGlzdGVuZXIuYmluZChzZWxmKTtcbiAgICAgICAgc2VsZi5fbm9kZS5hZGRFdmVudExpc3RlbmVyKEhvd2xlci5fY2FuUGxheUV2ZW50LCBzZWxmLl9sb2FkRm4sIGZhbHNlKTtcblxuICAgICAgICAvLyBTZXR1cCB0aGUgbmV3IGF1ZGlvIG5vZGUuXG4gICAgICAgIHNlbGYuX25vZGUuc3JjID0gcGFyZW50Ll9zcmM7XG4gICAgICAgIHNlbGYuX25vZGUucHJlbG9hZCA9ICdhdXRvJztcbiAgICAgICAgc2VsZi5fbm9kZS52b2x1bWUgPSB2b2x1bWUgKiBIb3dsZXIudm9sdW1lKCk7XG5cbiAgICAgICAgLy8gQmVnaW4gbG9hZGluZyB0aGUgc291cmNlLlxuICAgICAgICBzZWxmLl9ub2RlLmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBwYXJhbWV0ZXJzIG9mIHRoaXMgc291bmQgdG8gdGhlIG9yaWdpbmFsIHN0YXRlIChmb3IgcmVjeWNsZSkuXG4gICAgICogQHJldHVybiB7U291bmR9XG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGYuX3BhcmVudDtcblxuICAgICAgLy8gUmVzZXQgYWxsIG9mIHRoZSBwYXJhbWV0ZXJzIG9mIHRoaXMgc291bmQuXG4gICAgICBzZWxmLl9tdXRlZCA9IHBhcmVudC5fbXV0ZWQ7XG4gICAgICBzZWxmLl9sb29wID0gcGFyZW50Ll9sb29wO1xuICAgICAgc2VsZi5fdm9sdW1lID0gcGFyZW50Ll92b2x1bWU7XG4gICAgICBzZWxmLl9yYXRlID0gcGFyZW50Ll9yYXRlO1xuICAgICAgc2VsZi5fc2VlayA9IDA7XG4gICAgICBzZWxmLl9yYXRlU2VlayA9IDA7XG4gICAgICBzZWxmLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgc2VsZi5fZW5kZWQgPSB0cnVlO1xuICAgICAgc2VsZi5fc3ByaXRlID0gJ19fZGVmYXVsdCc7XG5cbiAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IElEIHNvIHRoYXQgaXQgaXNuJ3QgY29uZnVzZWQgd2l0aCB0aGUgcHJldmlvdXMgc291bmQuXG4gICAgICBzZWxmLl9pZCA9ICsrSG93bGVyLl9jb3VudGVyO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSFRNTDUgQXVkaW8gZXJyb3IgbGlzdGVuZXIgY2FsbGJhY2suXG4gICAgICovXG4gICAgX2Vycm9yTGlzdGVuZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBGaXJlIGFuIGVycm9yIGV2ZW50IGFuZCBwYXNzIGJhY2sgdGhlIGNvZGUuXG4gICAgICBzZWxmLl9wYXJlbnQuX2VtaXQoJ2xvYWRlcnJvcicsIHNlbGYuX2lkLCBzZWxmLl9ub2RlLmVycm9yID8gc2VsZi5fbm9kZS5lcnJvci5jb2RlIDogMCk7XG5cbiAgICAgIC8vIENsZWFyIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgIHNlbGYuX25vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9lcnJvckZuLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhUTUw1IEF1ZGlvIGNhbnBsYXl0aHJvdWdoIGxpc3RlbmVyIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIF9sb2FkTGlzdGVuZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGYuX3BhcmVudDtcblxuICAgICAgLy8gUm91bmQgdXAgdGhlIGR1cmF0aW9uIHRvIGFjY291bnQgZm9yIHRoZSBsb3dlciBwcmVjaXNpb24gaW4gSFRNTDUgQXVkaW8uXG4gICAgICBwYXJlbnQuX2R1cmF0aW9uID0gTWF0aC5jZWlsKHNlbGYuX25vZGUuZHVyYXRpb24gKiAxMCkgLyAxMDtcblxuICAgICAgLy8gU2V0dXAgYSBzcHJpdGUgaWYgbm9uZSBpcyBkZWZpbmVkLlxuICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcmVudC5fc3ByaXRlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGFyZW50Ll9zcHJpdGUgPSB7X19kZWZhdWx0OiBbMCwgcGFyZW50Ll9kdXJhdGlvbiAqIDEwMDBdfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudC5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgIHBhcmVudC5fc3RhdGUgPSAnbG9hZGVkJztcbiAgICAgICAgcGFyZW50Ll9lbWl0KCdsb2FkJyk7XG4gICAgICAgIHBhcmVudC5fbG9hZFF1ZXVlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgIHNlbGYuX25vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihIb3dsZXIuX2NhblBsYXlFdmVudCwgc2VsZi5fbG9hZEZuLCBmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKiBIZWxwZXIgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICB2YXIgY2FjaGUgPSB7fTtcblxuICAvKipcbiAgICogQnVmZmVyIGEgc291bmQgZnJvbSBVUkwsIERhdGEgVVJJIG9yIGNhY2hlIGFuZCBkZWNvZGUgdG8gYXVkaW8gc291cmNlIChXZWIgQXVkaW8gQVBJKS5cbiAgICogQHBhcmFtICB7SG93bH0gc2VsZlxuICAgKi9cbiAgdmFyIGxvYWRCdWZmZXIgPSBmdW5jdGlvbihzZWxmKSB7XG4gICAgdmFyIHVybCA9IHNlbGYuX3NyYztcblxuICAgIC8vIENoZWNrIGlmIHRoZSBidWZmZXIgaGFzIGFscmVhZHkgYmVlbiBjYWNoZWQgYW5kIHVzZSBpdCBpbnN0ZWFkLlxuICAgIGlmIChjYWNoZVt1cmxdKSB7XG4gICAgICAvLyBTZXQgdGhlIGR1cmF0aW9uIGZyb20gdGhlIGNhY2hlLlxuICAgICAgc2VsZi5fZHVyYXRpb24gPSBjYWNoZVt1cmxdLmR1cmF0aW9uO1xuXG4gICAgICAvLyBMb2FkIHRoZSBzb3VuZCBpbnRvIHRoaXMgSG93bC5cbiAgICAgIGxvYWRTb3VuZChzZWxmKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgvXmRhdGE6W147XSs7YmFzZTY0LC8udGVzdCh1cmwpKSB7XG4gICAgICAvLyBEZWNvZGUgdGhlIGJhc2U2NCBkYXRhIFVSSSB3aXRob3V0IFhIUiwgc2luY2Ugc29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IGl0LlxuICAgICAgdmFyIGRhdGEgPSBhdG9iKHVybC5zcGxpdCgnLCcpWzFdKTtcbiAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGRhdGFWaWV3W2ldID0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuXG4gICAgICBkZWNvZGVBdWRpb0RhdGEoZGF0YVZpZXcuYnVmZmVyLCBzZWxmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTG9hZCB0aGUgYnVmZmVyIGZyb20gdGhlIFVSTC5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHNlbGYuX3hocldpdGhDcmVkZW50aWFscztcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZ2V0IGEgc3VjY2Vzc2Z1bCByZXNwb25zZSBiYWNrLlxuICAgICAgICB2YXIgY29kZSA9ICh4aHIuc3RhdHVzICsgJycpWzBdO1xuICAgICAgICBpZiAoY29kZSAhPT0gJzAnICYmIGNvZGUgIT09ICcyJyAmJiBjb2RlICE9PSAnMycpIHtcbiAgICAgICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnRmFpbGVkIGxvYWRpbmcgYXVkaW8gZmlsZSB3aXRoIHN0YXR1czogJyArIHhoci5zdGF0dXMgKyAnLicpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZUF1ZGlvRGF0YSh4aHIucmVzcG9uc2UsIHNlbGYpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGVycm9yLCBzd2l0Y2ggdG8gSFRNTDUgQXVkaW8uXG4gICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgIHNlbGYuX2h0bWw1ID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLl93ZWJBdWRpbyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuX3NvdW5kcyA9IFtdO1xuICAgICAgICAgIGRlbGV0ZSBjYWNoZVt1cmxdO1xuICAgICAgICAgIHNlbGYubG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2FmZVhoclNlbmQoeGhyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbmQgdGhlIFhIUiByZXF1ZXN0IHdyYXBwZWQgaW4gYSB0cnkvY2F0Y2guXG4gICAqIEBwYXJhbSAge09iamVjdH0geGhyIFhIUiB0byBzZW5kLlxuICAgKi9cbiAgdmFyIHNhZmVYaHJTZW5kID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHhoci5zZW5kKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgeGhyLm9uZXJyb3IoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29kZSBhdWRpbyBkYXRhIGZyb20gYW4gYXJyYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gIHtBcnJheUJ1ZmZlcn0gYXJyYXlidWZmZXIgVGhlIGF1ZGlvIGRhdGEuXG4gICAqIEBwYXJhbSAge0hvd2x9ICAgICAgICBzZWxmXG4gICAqL1xuICB2YXIgZGVjb2RlQXVkaW9EYXRhID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHNlbGYpIHtcbiAgICAvLyBGaXJlIGEgbG9hZCBlcnJvciBpZiBzb21ldGhpbmcgYnJva2UuXG4gICAgdmFyIGVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnRGVjb2RpbmcgYXVkaW8gZGF0YSBmYWlsZWQuJyk7XG4gICAgfTtcblxuICAgIC8vIExvYWQgdGhlIHNvdW5kIG9uIHN1Y2Nlc3MuXG4gICAgdmFyIHN1Y2Nlc3MgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIGlmIChidWZmZXIgJiYgc2VsZi5fc291bmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2FjaGVbc2VsZi5fc3JjXSA9IGJ1ZmZlcjtcbiAgICAgICAgbG9hZFNvdW5kKHNlbGYsIGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcigpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBEZWNvZGUgdGhlIGJ1ZmZlciBpbnRvIGFuIGF1ZGlvIHNvdXJjZS5cbiAgICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIEhvd2xlci5jdHguZGVjb2RlQXVkaW9EYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgSG93bGVyLmN0eC5kZWNvZGVBdWRpb0RhdGEoYXJyYXlidWZmZXIpLnRoZW4oc3VjY2VzcykuY2F0Y2goZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBIb3dsZXIuY3R4LmRlY29kZUF1ZGlvRGF0YShhcnJheWJ1ZmZlciwgc3VjY2VzcywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTb3VuZCBpcyBub3cgbG9hZGVkLCBzbyBmaW5pc2ggc2V0dGluZyBldmVyeXRoaW5nIHVwIGFuZCBmaXJlIHRoZSBsb2FkZWQgZXZlbnQuXG4gICAqIEBwYXJhbSAge0hvd2x9IHNlbGZcbiAgICogQHBhcmFtICB7T2JqZWN0fSBidWZmZXIgVGhlIGRlY29kZWQgYnVmZmVyIHNvdW5kIHNvdXJjZS5cbiAgICovXG4gIHZhciBsb2FkU291bmQgPSBmdW5jdGlvbihzZWxmLCBidWZmZXIpIHtcbiAgICAvLyBTZXQgdGhlIGR1cmF0aW9uLlxuICAgIGlmIChidWZmZXIgJiYgIXNlbGYuX2R1cmF0aW9uKSB7XG4gICAgICBzZWxmLl9kdXJhdGlvbiA9IGJ1ZmZlci5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCBhIHNwcml0ZSBpZiBub25lIGlzIGRlZmluZWQuXG4gICAgaWYgKE9iamVjdC5rZXlzKHNlbGYuX3Nwcml0ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZWxmLl9zcHJpdGUgPSB7X19kZWZhdWx0OiBbMCwgc2VsZi5fZHVyYXRpb24gKiAxMDAwXX07XG4gICAgfVxuXG4gICAgLy8gRmlyZSB0aGUgbG9hZGVkIGV2ZW50LlxuICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgIHNlbGYuX3N0YXRlID0gJ2xvYWRlZCc7XG4gICAgICBzZWxmLl9lbWl0KCdsb2FkJyk7XG4gICAgICBzZWxmLl9sb2FkUXVldWUoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHVwIHRoZSBhdWRpbyBjb250ZXh0IHdoZW4gYXZhaWxhYmxlLCBvciBzd2l0Y2ggdG8gSFRNTDUgQXVkaW8gbW9kZS5cbiAgICovXG4gIHZhciBzZXR1cEF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIElmIHdlIGhhdmUgYWxyZWFkeSBkZXRlY3RlZCB0aGF0IFdlYiBBdWRpbyBpc24ndCBzdXBwb3J0ZWQsIGRvbid0IHJ1biB0aGlzIHN0ZXAgYWdhaW4uXG4gICAgaWYgKCFIb3dsZXIudXNpbmdXZWJBdWRpbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHdlIGFyZSB1c2luZyBXZWIgQXVkaW8gYW5kIHNldHVwIHRoZSBBdWRpb0NvbnRleHQgaWYgd2UgYXJlLlxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIEF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgSG93bGVyLmN0eCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdlYmtpdEF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgSG93bGVyLmN0eCA9IG5ldyB3ZWJraXRBdWRpb0NvbnRleHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEhvd2xlci51c2luZ1dlYkF1ZGlvID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBIb3dsZXIudXNpbmdXZWJBdWRpbyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBhdWRpbyBjb250ZXh0IGNyZWF0aW9uIHN0aWxsIGZhaWxlZCwgc2V0IHVzaW5nIHdlYiBhdWRpbyB0byBmYWxzZS5cbiAgICBpZiAoIUhvd2xlci5jdHgpIHtcbiAgICAgIEhvd2xlci51c2luZ1dlYkF1ZGlvID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYSB3ZWJ2aWV3IGlzIGJlaW5nIHVzZWQgb24gaU9TOCBvciBlYXJsaWVyIChyYXRoZXIgdGhhbiB0aGUgYnJvd3NlcikuXG4gICAgLy8gSWYgaXQgaXMsIGRpc2FibGUgV2ViIEF1ZGlvIGFzIGl0IGNhdXNlcyBjcmFzaGluZy5cbiAgICB2YXIgaU9TID0gKC9pUChob25lfG9kfGFkKS8udGVzdChIb3dsZXIuX25hdmlnYXRvciAmJiBIb3dsZXIuX25hdmlnYXRvci5wbGF0Zm9ybSkpO1xuICAgIHZhciBhcHBWZXJzaW9uID0gSG93bGVyLl9uYXZpZ2F0b3IgJiYgSG93bGVyLl9uYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvT1MgKFxcZCspXyhcXGQrKV8/KFxcZCspPy8pO1xuICAgIHZhciB2ZXJzaW9uID0gYXBwVmVyc2lvbiA/IHBhcnNlSW50KGFwcFZlcnNpb25bMV0sIDEwKSA6IG51bGw7XG4gICAgaWYgKGlPUyAmJiB2ZXJzaW9uICYmIHZlcnNpb24gPCA5KSB7XG4gICAgICB2YXIgc2FmYXJpID0gL3NhZmFyaS8udGVzdChIb3dsZXIuX25hdmlnYXRvciAmJiBIb3dsZXIuX25hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAoSG93bGVyLl9uYXZpZ2F0b3IgJiYgSG93bGVyLl9uYXZpZ2F0b3Iuc3RhbmRhbG9uZSAmJiAhc2FmYXJpIHx8IEhvd2xlci5fbmF2aWdhdG9yICYmICFIb3dsZXIuX25hdmlnYXRvci5zdGFuZGFsb25lICYmICFzYWZhcmkpIHtcbiAgICAgICAgSG93bGVyLnVzaW5nV2ViQXVkaW8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW5kIGV4cG9zZSB0aGUgbWFzdGVyIEdhaW5Ob2RlIHdoZW4gdXNpbmcgV2ViIEF1ZGlvICh1c2VmdWwgZm9yIHBsdWdpbnMgb3IgYWR2YW5jZWQgdXNhZ2UpLlxuICAgIGlmIChIb3dsZXIudXNpbmdXZWJBdWRpbykge1xuICAgICAgSG93bGVyLm1hc3RlckdhaW4gPSAodHlwZW9mIEhvd2xlci5jdHguY3JlYXRlR2FpbiA9PT0gJ3VuZGVmaW5lZCcpID8gSG93bGVyLmN0eC5jcmVhdGVHYWluTm9kZSgpIDogSG93bGVyLmN0eC5jcmVhdGVHYWluKCk7XG4gICAgICBIb3dsZXIubWFzdGVyR2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKEhvd2xlci5fbXV0ZWQgPyAwIDogSG93bGVyLl92b2x1bWUsIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgSG93bGVyLm1hc3RlckdhaW4uY29ubmVjdChIb3dsZXIuY3R4LmRlc3RpbmF0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBSZS1ydW4gdGhlIHNldHVwIG9uIEhvd2xlci5cbiAgICBIb3dsZXIuX3NldHVwKCk7XG4gIH07XG5cbiAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoQXN5bmNocm9ub3VzIE1vZHVsZSBEZWZpbml0aW9uKSBsaWJyYXJpZXMgc3VjaCBhcyByZXF1aXJlLmpzLlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIEhvd2xlcjogSG93bGVyLFxuICAgICAgICBIb3dsOiBIb3dsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTIGxpYnJhcmllcyBzdWNoIGFzIGJyb3dzZXJpZnkuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLkhvd2xlciA9IEhvd2xlcjtcbiAgICBleHBvcnRzLkhvd2wgPSBIb3dsO1xuICB9XG5cbiAgLy8gRGVmaW5lIGdsb2JhbGx5IGluIGNhc2UgQU1EIGlzIG5vdCBhdmFpbGFibGUgb3IgdW51c2VkLlxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuSG93bGVyR2xvYmFsID0gSG93bGVyR2xvYmFsO1xuICAgIHdpbmRvdy5Ib3dsZXIgPSBIb3dsZXI7XG4gICAgd2luZG93Lkhvd2wgPSBIb3dsO1xuICAgIHdpbmRvdy5Tb3VuZCA9IFNvdW5kO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IC8vIEFkZCB0byBnbG9iYWwgaW4gTm9kZS5qcyAoZm9yIHRlc3RpbmcsIGV0YykuXG4gICAgZ2xvYmFsLkhvd2xlckdsb2JhbCA9IEhvd2xlckdsb2JhbDtcbiAgICBnbG9iYWwuSG93bGVyID0gSG93bGVyO1xuICAgIGdsb2JhbC5Ib3dsID0gSG93bDtcbiAgICBnbG9iYWwuU291bmQgPSBTb3VuZDtcbiAgfVxufSkoKTtcblxuXG4vKiFcbiAqICBTcGF0aWFsIFBsdWdpbiAtIEFkZHMgc3VwcG9ydCBmb3Igc3RlcmVvIGFuZCAzRCBhdWRpbyB3aGVyZSBXZWIgQXVkaW8gaXMgc3VwcG9ydGVkLlxuICogIFxuICogIGhvd2xlci5qcyB2Mi4xLjNcbiAqICBob3dsZXJqcy5jb21cbiAqXG4gKiAgKGMpIDIwMTMtMjAxOSwgSmFtZXMgU2ltcHNvbiBvZiBHb2xkRmlyZSBTdHVkaW9zXG4gKiAgZ29sZGZpcmVzdHVkaW9zLmNvbVxuICpcbiAqICBNSVQgTGljZW5zZVxuICovXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gU2V0dXAgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBIb3dsZXJHbG9iYWwucHJvdG90eXBlLl9wb3MgPSBbMCwgMCwgMF07XG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUuX29yaWVudGF0aW9uID0gWzAsIDAsIC0xLCAwLCAxLCAwXTtcblxuICAvKiogR2xvYmFsIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gdXBkYXRlIHRoZSBzdGVyZW8gcGFubmluZyBwb3NpdGlvbiBvZiBhbGwgY3VycmVudCBIb3dscy5cbiAgICogRnV0dXJlIEhvd2xzIHdpbGwgbm90IHVzZSB0aGlzIHZhbHVlIHVubGVzcyBleHBsaWNpdGx5IHNldC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBwYW4gQSB2YWx1ZSBvZiAtMS4wIGlzIGFsbCB0aGUgd2F5IGxlZnQgYW5kIDEuMCBpcyBhbGwgdGhlIHdheSByaWdodC5cbiAgICogQHJldHVybiB7SG93bGVyL051bWJlcn0gICAgIFNlbGYgb3IgY3VycmVudCBzdGVyZW8gcGFubmluZyB2YWx1ZS5cbiAgICovXG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUuc3RlcmVvID0gZnVuY3Rpb24ocGFuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLmN0eCB8fCAhc2VsZi5jdHgubGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgSG93bHMgYW5kIHVwZGF0ZSB0aGVpciBzdGVyZW8gcGFubmluZy5cbiAgICBmb3IgKHZhciBpPXNlbGYuX2hvd2xzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgIHNlbGYuX2hvd2xzW2ldLnN0ZXJlbyhwYW4pO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgbGlzdGVuZXIgaW4gM0QgY2FydGVzaWFuIHNwYWNlLiBTb3VuZHMgdXNpbmdcbiAgICogM0QgcG9zaXRpb24gd2lsbCBiZSByZWxhdGl2ZSB0byB0aGUgbGlzdGVuZXIncyBwb3NpdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB4IFRoZSB4LXBvc2l0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB5IFRoZSB5LXBvc2l0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB6IFRoZSB6LXBvc2l0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7SG93bGVyL0FycmF5fSAgIFNlbGYgb3IgY3VycmVudCBsaXN0ZW5lciBwb3NpdGlvbi5cbiAgICovXG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUucG9zID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFN0b3AgcmlnaHQgaGVyZSBpZiBub3QgdXNpbmcgV2ViIEF1ZGlvLlxuICAgIGlmICghc2VsZi5jdHggfHwgIXNlbGYuY3R4Lmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHRzIGZvciBvcHRpb25hbCAneScgJiAneicuXG4gICAgeSA9ICh0eXBlb2YgeSAhPT0gJ251bWJlcicpID8gc2VsZi5fcG9zWzFdIDogeTtcbiAgICB6ID0gKHR5cGVvZiB6ICE9PSAnbnVtYmVyJykgPyBzZWxmLl9wb3NbMl0gOiB6O1xuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgc2VsZi5fcG9zID0gW3gsIHksIHpdO1xuXG4gICAgICBpZiAodHlwZW9mIHNlbGYuY3R4Lmxpc3RlbmVyLnBvc2l0aW9uWCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5jdHgubGlzdGVuZXIucG9zaXRpb25YLnNldFRhcmdldEF0VGltZShzZWxmLl9wb3NbMF0sIEhvd2xlci5jdHguY3VycmVudFRpbWUsIDAuMSk7XG4gICAgICAgIHNlbGYuY3R4Lmxpc3RlbmVyLnBvc2l0aW9uWS5zZXRUYXJnZXRBdFRpbWUoc2VsZi5fcG9zWzFdLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lLCAwLjEpO1xuICAgICAgICBzZWxmLmN0eC5saXN0ZW5lci5wb3NpdGlvblouc2V0VGFyZ2V0QXRUaW1lKHNlbGYuX3Bvc1syXSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSwgMC4xKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuY3R4Lmxpc3RlbmVyLnNldFBvc2l0aW9uKHNlbGYuX3Bvc1swXSwgc2VsZi5fcG9zWzFdLCBzZWxmLl9wb3NbMl0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2VsZi5fcG9zO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSBkaXJlY3Rpb24gdGhlIGxpc3RlbmVyIGlzIHBvaW50aW5nIGluIHRoZSAzRCBjYXJ0ZXNpYW4gc3BhY2UuXG4gICAqIEEgZnJvbnQgYW5kIHVwIHZlY3RvciBtdXN0IGJlIHByb3ZpZGVkLiBUaGUgZnJvbnQgaXMgdGhlIGRpcmVjdGlvbiB0aGVcbiAgICogZmFjZSBvZiB0aGUgbGlzdGVuZXIgaXMgcG9pbnRpbmcsIGFuZCB1cCBpcyB0aGUgZGlyZWN0aW9uIHRoZSB0b3Agb2YgdGhlXG4gICAqIGxpc3RlbmVyIGlzIHBvaW50aW5nLiBUaHVzLCB0aGVzZSB2YWx1ZXMgYXJlIGV4cGVjdGVkIHRvIGJlIGF0IHJpZ2h0IGFuZ2xlc1xuICAgKiBmcm9tIGVhY2ggb3RoZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0geCAgIFRoZSB4LW9yaWVudGF0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB5ICAgVGhlIHktb3JpZW50YXRpb24gb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHogICBUaGUgei1vcmllbnRhdGlvbiBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0geFVwIFRoZSB4LW9yaWVudGF0aW9uIG9mIHRoZSB0b3Agb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHlVcCBUaGUgeS1vcmllbnRhdGlvbiBvZiB0aGUgdG9wIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB6VXAgVGhlIHotb3JpZW50YXRpb24gb2YgdGhlIHRvcCBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEByZXR1cm4ge0hvd2xlci9BcnJheX0gICAgIFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCBvcmllbnRhdGlvbiB2ZWN0b3JzLlxuICAgKi9cbiAgSG93bGVyR2xvYmFsLnByb3RvdHlwZS5vcmllbnRhdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHosIHhVcCwgeVVwLCB6VXApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuY3R4IHx8ICFzZWxmLmN0eC5saXN0ZW5lcikge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0cyBmb3Igb3B0aW9uYWwgJ3knICYgJ3onLlxuICAgIHZhciBvciA9IHNlbGYuX29yaWVudGF0aW9uO1xuICAgIHkgPSAodHlwZW9mIHkgIT09ICdudW1iZXInKSA/IG9yWzFdIDogeTtcbiAgICB6ID0gKHR5cGVvZiB6ICE9PSAnbnVtYmVyJykgPyBvclsyXSA6IHo7XG4gICAgeFVwID0gKHR5cGVvZiB4VXAgIT09ICdudW1iZXInKSA/IG9yWzNdIDogeFVwO1xuICAgIHlVcCA9ICh0eXBlb2YgeVVwICE9PSAnbnVtYmVyJykgPyBvcls0XSA6IHlVcDtcbiAgICB6VXAgPSAodHlwZW9mIHpVcCAhPT0gJ251bWJlcicpID8gb3JbNV0gOiB6VXA7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICBzZWxmLl9vcmllbnRhdGlvbiA9IFt4LCB5LCB6LCB4VXAsIHlVcCwgelVwXTtcblxuICAgICAgaWYgKHR5cGVvZiBzZWxmLmN0eC5saXN0ZW5lci5mb3J3YXJkWCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5jdHgubGlzdGVuZXIuZm9yd2FyZFguc2V0VGFyZ2V0QXRUaW1lKHgsIEhvd2xlci5jdHguY3VycmVudFRpbWUsIDAuMSk7XG4gICAgICAgIHNlbGYuY3R4Lmxpc3RlbmVyLmZvcndhcmRZLnNldFRhcmdldEF0VGltZSh5LCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lLCAwLjEpO1xuICAgICAgICBzZWxmLmN0eC5saXN0ZW5lci5mb3J3YXJkWi5zZXRUYXJnZXRBdFRpbWUoeiwgSG93bGVyLmN0eC5jdXJyZW50VGltZSwgMC4xKTtcbiAgICAgICAgc2VsZi5jdHgubGlzdGVuZXIudXBYLnNldFRhcmdldEF0VGltZSh4VXAsIEhvd2xlci5jdHguY3VycmVudFRpbWUsIDAuMSk7XG4gICAgICAgIHNlbGYuY3R4Lmxpc3RlbmVyLnVwWS5zZXRUYXJnZXRBdFRpbWUoeVVwLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lLCAwLjEpO1xuICAgICAgICBzZWxmLmN0eC5saXN0ZW5lci51cFouc2V0VGFyZ2V0QXRUaW1lKHpVcCwgSG93bGVyLmN0eC5jdXJyZW50VGltZSwgMC4xKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuY3R4Lmxpc3RlbmVyLnNldE9yaWVudGF0aW9uKHgsIHksIHosIHhVcCwgeVVwLCB6VXApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLyoqIEdyb3VwIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIEFkZCBuZXcgcHJvcGVydGllcyB0byB0aGUgY29yZSBpbml0LlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gX3N1cGVyIENvcmUgaW5pdCBtZXRob2QuXG4gICAqIEByZXR1cm4ge0hvd2x9XG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5pbml0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIFNldHVwIHVzZXItZGVmaW5lZCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9vcmllbnRhdGlvbiA9IG8ub3JpZW50YXRpb24gfHwgWzEsIDAsIDBdO1xuICAgICAgc2VsZi5fc3RlcmVvID0gby5zdGVyZW8gfHwgbnVsbDtcbiAgICAgIHNlbGYuX3BvcyA9IG8ucG9zIHx8IG51bGw7XG4gICAgICBzZWxmLl9wYW5uZXJBdHRyID0ge1xuICAgICAgICBjb25lSW5uZXJBbmdsZTogdHlwZW9mIG8uY29uZUlubmVyQW5nbGUgIT09ICd1bmRlZmluZWQnID8gby5jb25lSW5uZXJBbmdsZSA6IDM2MCxcbiAgICAgICAgY29uZU91dGVyQW5nbGU6IHR5cGVvZiBvLmNvbmVPdXRlckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZU91dGVyQW5nbGUgOiAzNjAsXG4gICAgICAgIGNvbmVPdXRlckdhaW46IHR5cGVvZiBvLmNvbmVPdXRlckdhaW4gIT09ICd1bmRlZmluZWQnID8gby5jb25lT3V0ZXJHYWluIDogMCxcbiAgICAgICAgZGlzdGFuY2VNb2RlbDogdHlwZW9mIG8uZGlzdGFuY2VNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLmRpc3RhbmNlTW9kZWwgOiAnaW52ZXJzZScsXG4gICAgICAgIG1heERpc3RhbmNlOiB0eXBlb2Ygby5tYXhEaXN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLm1heERpc3RhbmNlIDogMTAwMDAsXG4gICAgICAgIHBhbm5pbmdNb2RlbDogdHlwZW9mIG8ucGFubmluZ01vZGVsICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmluZ01vZGVsIDogJ0hSVEYnLFxuICAgICAgICByZWZEaXN0YW5jZTogdHlwZW9mIG8ucmVmRGlzdGFuY2UgIT09ICd1bmRlZmluZWQnID8gby5yZWZEaXN0YW5jZSA6IDEsXG4gICAgICAgIHJvbGxvZmZGYWN0b3I6IHR5cGVvZiBvLnJvbGxvZmZGYWN0b3IgIT09ICd1bmRlZmluZWQnID8gby5yb2xsb2ZmRmFjdG9yIDogMVxuICAgICAgfTtcblxuICAgICAgLy8gU2V0dXAgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgc2VsZi5fb25zdGVyZW8gPSBvLm9uc3RlcmVvID8gW3tmbjogby5vbnN0ZXJlb31dIDogW107XG4gICAgICBzZWxmLl9vbnBvcyA9IG8ub25wb3MgPyBbe2ZuOiBvLm9ucG9zfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ub3JpZW50YXRpb24gPSBvLm9ub3JpZW50YXRpb24gPyBbe2ZuOiBvLm9ub3JpZW50YXRpb259XSA6IFtdO1xuXG4gICAgICAvLyBDb21wbGV0ZSBpbml0aWxpemF0aW9uIHdpdGggaG93bGVyLmpzIGNvcmUncyBpbml0IGZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG8pO1xuICAgIH07XG4gIH0pKEhvd2wucHJvdG90eXBlLmluaXQpO1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSBzdGVyZW8gcGFubmluZyBvZiB0aGUgYXVkaW8gc291cmNlIGZvciB0aGlzIHNvdW5kIG9yIGFsbCBpbiB0aGUgZ3JvdXAuXG4gICAqIEBwYXJhbSAge051bWJlcn0gcGFuICBBIHZhbHVlIG9mIC0xLjAgaXMgYWxsIHRoZSB3YXkgbGVmdCBhbmQgMS4wIGlzIGFsbCB0aGUgd2F5IHJpZ2h0LlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIChvcHRpb25hbCkgVGhlIHNvdW5kIElELiBJZiBub25lIGlzIHBhc3NlZCwgYWxsIGluIGdyb3VwIHdpbGwgYmUgdXBkYXRlZC5cbiAgICogQHJldHVybiB7SG93bC9OdW1iZXJ9ICAgIFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCBzdGVyZW8gcGFubmluZyB2YWx1ZS5cbiAgICovXG4gIEhvd2wucHJvdG90eXBlLnN0ZXJlbyA9IGZ1bmN0aW9uKHBhbiwgaWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGNoYW5nZSBzdGVyZW8gcGFuIHdoZW4gY2FwYWJsZS5cbiAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgZXZlbnQ6ICdzdGVyZW8nLFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuc3RlcmVvKHBhbiwgaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIFBhbm5lclN0ZXJlb05vZGUgc3VwcG9ydCBhbmQgZmFsbGJhY2sgdG8gUGFubmVyTm9kZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgIHZhciBwYW5uZXJUeXBlID0gKHR5cGVvZiBIb3dsZXIuY3R4LmNyZWF0ZVN0ZXJlb1Bhbm5lciA9PT0gJ3VuZGVmaW5lZCcpID8gJ3NwYXRpYWwnIDogJ3N0ZXJlbyc7XG5cbiAgICAvLyBTZXR1cCB0aGUgZ3JvdXAncyBzdGVyZW8gcGFubmluZyBpZiBubyBJRCBpcyBwYXNzZWQuXG4gICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgZ3JvdXAncyBzdGVyZW8gcGFubmluZyBpZiBubyBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQuXG4gICAgICBpZiAodHlwZW9mIHBhbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2VsZi5fc3RlcmVvID0gcGFuO1xuICAgICAgICBzZWxmLl9wb3MgPSBbcGFuLCAwLCAwXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9zdGVyZW87XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBzdHJlbyBwYW5uaW5nIG9mIG9uZSBvciBhbGwgc291bmRzIGluIGdyb3VwLlxuICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc291bmQuX3N0ZXJlbyA9IHBhbjtcbiAgICAgICAgICBzb3VuZC5fcG9zID0gW3BhbiwgMCwgMF07XG5cbiAgICAgICAgICBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBmYWxsaW5nIGJhY2ssIG1ha2Ugc3VyZSB0aGUgcGFubmluZ01vZGVsIGlzIGVxdWFscG93ZXIuXG4gICAgICAgICAgICBzb3VuZC5fcGFubmVyQXR0ci5wYW5uaW5nTW9kZWwgPSAnZXF1YWxwb3dlcic7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgcGFubmVyIHNldHVwIGFuZCBjcmVhdGUgYSBuZXcgb25lIGlmIG5vdC5cbiAgICAgICAgICAgIGlmICghc291bmQuX3Bhbm5lciB8fCAhc291bmQuX3Bhbm5lci5wYW4pIHtcbiAgICAgICAgICAgICAgc2V0dXBQYW5uZXIoc291bmQsIHBhbm5lclR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFubmVyVHlwZSA9PT0gJ3NwYXRpYWwnKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygc291bmQuX3Bhbm5lci5wb3NpdGlvblggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc291bmQuX3Bhbm5lci5wb3NpdGlvblguc2V0VmFsdWVBdFRpbWUocGFuLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLnBvc2l0aW9uWS5zZXRWYWx1ZUF0VGltZSgwLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLnBvc2l0aW9uWi5zZXRWYWx1ZUF0VGltZSgwLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLnNldFBvc2l0aW9uKHBhbiwgMCwgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIucGFuLnNldFZhbHVlQXRUaW1lKHBhbiwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgnc3RlcmVvJywgc291bmQuX2lkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc291bmQuX3N0ZXJlbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSAzRCBzcGF0aWFsIHBvc2l0aW9uIG9mIHRoZSBhdWRpbyBzb3VyY2UgZm9yIHRoaXMgc291bmQgb3IgZ3JvdXAgcmVsYXRpdmUgdG8gdGhlIGdsb2JhbCBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB4ICBUaGUgeC1wb3NpdGlvbiBvZiB0aGUgYXVkaW8gc291cmNlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgIFRoZSB5LXBvc2l0aW9uIG9mIHRoZSBhdWRpbyBzb3VyY2UuXG4gICAqIEBwYXJhbSAge051bWJlcn0geiAgVGhlIHotcG9zaXRpb24gb2YgdGhlIGF1ZGlvIHNvdXJjZS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAob3B0aW9uYWwpIFRoZSBzb3VuZCBJRC4gSWYgbm9uZSBpcyBwYXNzZWQsIGFsbCBpbiBncm91cCB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEByZXR1cm4ge0hvd2wvQXJyYXl9ICAgIFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCAzRCBzcGF0aWFsIHBvc2l0aW9uOiBbeCwgeSwgel0uXG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5wb3MgPSBmdW5jdGlvbih4LCB5LCB6LCBpZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFN0b3AgcmlnaHQgaGVyZSBpZiBub3QgdXNpbmcgV2ViIEF1ZGlvLlxuICAgIGlmICghc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gY2hhbmdlIHBvc2l0aW9uIHdoZW4gY2FwYWJsZS5cbiAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgZXZlbnQ6ICdwb3MnLFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYucG9zKHgsIHksIHosIGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMgZm9yIG9wdGlvbmFsICd5JyAmICd6Jy5cbiAgICB5ID0gKHR5cGVvZiB5ICE9PSAnbnVtYmVyJykgPyAwIDogeTtcbiAgICB6ID0gKHR5cGVvZiB6ICE9PSAnbnVtYmVyJykgPyAtMC41IDogejtcblxuICAgIC8vIFNldHVwIHRoZSBncm91cCdzIHNwYXRpYWwgcG9zaXRpb24gaWYgbm8gSUQgaXMgcGFzc2VkLlxuICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGdyb3VwJ3Mgc3BhdGlhbCBwb3NpdGlvbiBpZiBubyBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNlbGYuX3BvcyA9IFt4LCB5LCB6XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9wb3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBzcGF0aWFsIHBvc2l0aW9uIG9mIG9uZSBvciBhbGwgc291bmRzIGluIGdyb3VwLlxuICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHNvdW5kLl9wb3MgPSBbeCwgeSwgel07XG5cbiAgICAgICAgICBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgcGFubmVyIHNldHVwIGFuZCBjcmVhdGUgYSBuZXcgb25lIGlmIG5vdC5cbiAgICAgICAgICAgIGlmICghc291bmQuX3Bhbm5lciB8fCBzb3VuZC5fcGFubmVyLnBhbikge1xuICAgICAgICAgICAgICBzZXR1cFBhbm5lcihzb3VuZCwgJ3NwYXRpYWwnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VuZC5fcGFubmVyLnBvc2l0aW9uWCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgc291bmQuX3Bhbm5lci5wb3NpdGlvblguc2V0VmFsdWVBdFRpbWUoeCwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIucG9zaXRpb25ZLnNldFZhbHVlQXRUaW1lKHksIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLnBvc2l0aW9uWi5zZXRWYWx1ZUF0VGltZSh6LCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIuc2V0UG9zaXRpb24oeCwgeSwgeik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgncG9zJywgc291bmQuX2lkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc291bmQuX3BvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSBkaXJlY3Rpb24gdGhlIGF1ZGlvIHNvdXJjZSBpcyBwb2ludGluZyBpbiB0aGUgM0QgY2FydGVzaWFuIGNvb3JkaW5hdGVcbiAgICogc3BhY2UuIERlcGVuZGluZyBvbiBob3cgZGlyZWN0aW9uIHRoZSBzb3VuZCBpcywgYmFzZWQgb24gdGhlIGBjb25lYCBhdHRyaWJ1dGVzLFxuICAgKiBhIHNvdW5kIHBvaW50aW5nIGF3YXkgZnJvbSB0aGUgbGlzdGVuZXIgY2FuIGJlIHF1aWV0IG9yIHNpbGVudC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB4ICBUaGUgeC1vcmllbnRhdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgIFRoZSB5LW9yaWVudGF0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSAge051bWJlcn0geiAgVGhlIHotb3JpZW50YXRpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAob3B0aW9uYWwpIFRoZSBzb3VuZCBJRC4gSWYgbm9uZSBpcyBwYXNzZWQsIGFsbCBpbiBncm91cCB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEByZXR1cm4ge0hvd2wvQXJyYXl9ICAgIFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCAzRCBzcGF0aWFsIG9yaWVudGF0aW9uOiBbeCwgeSwgel0uXG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5vcmllbnRhdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHosIGlkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLl93ZWJBdWRpbykge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBjaGFuZ2Ugb3JpZW50YXRpb24gd2hlbiBjYXBhYmxlLlxuICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICBldmVudDogJ29yaWVudGF0aW9uJyxcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLm9yaWVudGF0aW9uKHgsIHksIHosIGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMgZm9yIG9wdGlvbmFsICd5JyAmICd6Jy5cbiAgICB5ID0gKHR5cGVvZiB5ICE9PSAnbnVtYmVyJykgPyBzZWxmLl9vcmllbnRhdGlvblsxXSA6IHk7XG4gICAgeiA9ICh0eXBlb2YgeiAhPT0gJ251bWJlcicpID8gc2VsZi5fb3JpZW50YXRpb25bMl0gOiB6O1xuXG4gICAgLy8gU2V0dXAgdGhlIGdyb3VwJ3Mgc3BhdGlhbCBvcmllbnRhdGlvbiBpZiBubyBJRCBpcyBwYXNzZWQuXG4gICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgZ3JvdXAncyBzcGF0aWFsIG9yaWVudGF0aW9uIGlmIG5vIHBhcmFtZXRlcnMgYXJlIHBhc3NlZC5cbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2VsZi5fb3JpZW50YXRpb24gPSBbeCwgeSwgel07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5fb3JpZW50YXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBzcGF0aWFsIG9yaWVudGF0aW9uIG9mIG9uZSBvciBhbGwgc291bmRzIGluIGdyb3VwLlxuICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHNvdW5kLl9vcmllbnRhdGlvbiA9IFt4LCB5LCB6XTtcblxuICAgICAgICAgIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSBwYW5uZXIgc2V0dXAgYW5kIGNyZWF0ZSBhIG5ldyBvbmUgaWYgbm90LlxuICAgICAgICAgICAgaWYgKCFzb3VuZC5fcGFubmVyKSB7XG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgcG9zaXRpb24gdG8gc2V0dXAgdGhlIG5vZGUgd2l0aC5cbiAgICAgICAgICAgICAgaWYgKCFzb3VuZC5fcG9zKSB7XG4gICAgICAgICAgICAgICAgc291bmQuX3BvcyA9IHNlbGYuX3BvcyB8fCBbMCwgMCwgLTAuNV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZXR1cFBhbm5lcihzb3VuZCwgJ3NwYXRpYWwnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VuZC5fcGFubmVyLm9yaWVudGF0aW9uWCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgc291bmQuX3Bhbm5lci5vcmllbnRhdGlvblguc2V0VmFsdWVBdFRpbWUoeCwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIub3JpZW50YXRpb25ZLnNldFZhbHVlQXRUaW1lKHksIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLm9yaWVudGF0aW9uWi5zZXRWYWx1ZUF0VGltZSh6LCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIuc2V0T3JpZW50YXRpb24oeCwgeSwgeik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgnb3JpZW50YXRpb24nLCBzb3VuZC5faWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzb3VuZC5fb3JpZW50YXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCB0aGUgcGFubmVyIG5vZGUncyBhdHRyaWJ1dGVzIGZvciBhIHNvdW5kIG9yIGdyb3VwIG9mIHNvdW5kcy5cbiAgICogVGhpcyBtZXRob2QgY2FuIG9wdGlvbmFsbCB0YWtlIDAsIDEgb3IgMiBhcmd1bWVudHMuXG4gICAqICAgcGFubmVyQXR0cigpIC0+IFJldHVybnMgdGhlIGdyb3VwJ3MgdmFsdWVzLlxuICAgKiAgIHBhbm5lckF0dHIoaWQpIC0+IFJldHVybnMgdGhlIHNvdW5kIGlkJ3MgdmFsdWVzLlxuICAgKiAgIHBhbm5lckF0dHIobykgLT4gU2V0J3MgdGhlIHZhbHVlcyBvZiBhbGwgc291bmRzIGluIHRoaXMgSG93bCBncm91cC5cbiAgICogICBwYW5uZXJBdHRyKG8sIGlkKSAtPiBTZXQncyB0aGUgdmFsdWVzIG9mIHBhc3NlZCBzb3VuZCBpZC5cbiAgICpcbiAgICogICBBdHRyaWJ1dGVzOlxuICAgKiAgICAgY29uZUlubmVyQW5nbGUgLSAoMzYwIGJ5IGRlZmF1bHQpIEEgcGFyYW1ldGVyIGZvciBkaXJlY3Rpb25hbCBhdWRpbyBzb3VyY2VzLCB0aGlzIGlzIGFuIGFuZ2xlLCBpbiBkZWdyZWVzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBpbnNpZGUgb2Ygd2hpY2ggdGhlcmUgd2lsbCBiZSBubyB2b2x1bWUgcmVkdWN0aW9uLlxuICAgKiAgICAgY29uZU91dGVyQW5nbGUgLSAoMzYwIGJ5IGRlZmF1bHQpIEEgcGFyYW1ldGVyIGZvciBkaXJlY3Rpb25hbCBhdWRpbyBzb3VyY2VzLCB0aGlzIGlzIGFuIGFuZ2xlLCBpbiBkZWdyZWVzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBvdXRzaWRlIG9mIHdoaWNoIHRoZSB2b2x1bWUgd2lsbCBiZSByZWR1Y2VkIHRvIGEgY29uc3RhbnQgdmFsdWUgb2YgYGNvbmVPdXRlckdhaW5gLlxuICAgKiAgICAgY29uZU91dGVyR2FpbiAtICgwIGJ5IGRlZmF1bHQpIEEgcGFyYW1ldGVyIGZvciBkaXJlY3Rpb25hbCBhdWRpbyBzb3VyY2VzLCB0aGlzIGlzIHRoZSBnYWluIG91dHNpZGUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgYGNvbmVPdXRlckFuZ2xlYC4gSXQgaXMgYSBsaW5lYXIgdmFsdWUgaW4gdGhlIHJhbmdlIGBbMCwgMV1gLlxuICAgKiAgICAgZGlzdGFuY2VNb2RlbCAtICgnaW52ZXJzZScgYnkgZGVmYXVsdCkgRGV0ZXJtaW5lcyBhbGdvcml0aG0gdXNlZCB0byByZWR1Y2Ugdm9sdW1lIGFzIGF1ZGlvIG1vdmVzIGF3YXkgZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLiBDYW4gYmUgYGxpbmVhcmAsIGBpbnZlcnNlYCBvciBgZXhwb25lbnRpYWwuXG4gICAqICAgICBtYXhEaXN0YW5jZSAtICgxMDAwMCBieSBkZWZhdWx0KSBUaGUgbWF4aW11bSBkaXN0YW5jZSBiZXR3ZWVuIHNvdXJjZSBhbmQgbGlzdGVuZXIsIGFmdGVyIHdoaWNoIHRoZSB2b2x1bWVcbiAgICogICAgICAgICAgICAgICAgICAgd2lsbCBub3QgYmUgcmVkdWNlZCBhbnkgZnVydGhlci5cbiAgICogICAgIHJlZkRpc3RhbmNlIC0gKDEgYnkgZGVmYXVsdCkgQSByZWZlcmVuY2UgZGlzdGFuY2UgZm9yIHJlZHVjaW5nIHZvbHVtZSBhcyBzb3VyY2UgbW92ZXMgZnVydGhlciBmcm9tIHRoZSBsaXN0ZW5lci5cbiAgICogICAgICAgICAgICAgICAgICAgVGhpcyBpcyBzaW1wbHkgYSB2YXJpYWJsZSBvZiB0aGUgZGlzdGFuY2UgbW9kZWwgYW5kIGhhcyBhIGRpZmZlcmVudCBlZmZlY3QgZGVwZW5kaW5nIG9uIHdoaWNoIG1vZGVsXG4gICAqICAgICAgICAgICAgICAgICAgIGlzIHVzZWQgYW5kIHRoZSBzY2FsZSBvZiB5b3VyIGNvb3JkaW5hdGVzLiBHZW5lcmFsbHksIHZvbHVtZSB3aWxsIGJlIGVxdWFsIHRvIDEgYXQgdGhpcyBkaXN0YW5jZS5cbiAgICogICAgIHJvbGxvZmZGYWN0b3IgLSAoMSBieSBkZWZhdWx0KSBIb3cgcXVpY2tseSB0aGUgdm9sdW1lIHJlZHVjZXMgYXMgc291cmNlIG1vdmVzIGZyb20gbGlzdGVuZXIuIFRoaXMgaXMgc2ltcGx5IGFcbiAgICogICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSBvZiB0aGUgZGlzdGFuY2UgbW9kZWwgYW5kIGNhbiBiZSBpbiB0aGUgcmFuZ2Ugb2YgYFswLCAxXWAgd2l0aCBgbGluZWFyYCBhbmQgYFswLCDiiJ5dYFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHdpdGggYGludmVyc2VgIGFuZCBgZXhwb25lbnRpYWxgLlxuICAgKiAgICAgcGFubmluZ01vZGVsIC0gKCdIUlRGJyBieSBkZWZhdWx0KSBEZXRlcm1pbmVzIHdoaWNoIHNwYXRpYWxpemF0aW9uIGFsZ29yaXRobSBpcyB1c2VkIHRvIHBvc2l0aW9uIGF1ZGlvLlxuICAgKiAgICAgICAgICAgICAgICAgICAgIENhbiBiZSBgSFJURmAgb3IgYGVxdWFscG93ZXJgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtIb3dsL09iamVjdH0gUmV0dXJucyBzZWxmIG9yIGN1cnJlbnQgcGFubmVyIGF0dHJpYnV0ZXMuXG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5wYW5uZXJBdHRyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBvLCBpZCwgc291bmQ7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHZhbHVlcyBiYXNlZCBvbiBhcmd1bWVudHMuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGdyb3VwJ3MgcGFubmVyIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gICAgICByZXR1cm4gc2VsZi5fcGFubmVyQXR0cjtcbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG8gPSBhcmdzWzBdO1xuXG4gICAgICAgIC8vIFNldCB0aGUgZ3JvdSdzIHBhbm5lciBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmICghby5wYW5uZXJBdHRyKSB7XG4gICAgICAgICAgICBvLnBhbm5lckF0dHIgPSB7XG4gICAgICAgICAgICAgIGNvbmVJbm5lckFuZ2xlOiBvLmNvbmVJbm5lckFuZ2xlLFxuICAgICAgICAgICAgICBjb25lT3V0ZXJBbmdsZTogby5jb25lT3V0ZXJBbmdsZSxcbiAgICAgICAgICAgICAgY29uZU91dGVyR2Fpbjogby5jb25lT3V0ZXJHYWluLFxuICAgICAgICAgICAgICBkaXN0YW5jZU1vZGVsOiBvLmRpc3RhbmNlTW9kZWwsXG4gICAgICAgICAgICAgIG1heERpc3RhbmNlOiBvLm1heERpc3RhbmNlLFxuICAgICAgICAgICAgICByZWZEaXN0YW5jZTogby5yZWZEaXN0YW5jZSxcbiAgICAgICAgICAgICAgcm9sbG9mZkZhY3Rvcjogby5yb2xsb2ZmRmFjdG9yLFxuICAgICAgICAgICAgICBwYW5uaW5nTW9kZWw6IG8ucGFubmluZ01vZGVsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuX3Bhbm5lckF0dHIgPSB7XG4gICAgICAgICAgICBjb25lSW5uZXJBbmdsZTogdHlwZW9mIG8ucGFubmVyQXR0ci5jb25lSW5uZXJBbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5lckF0dHIuY29uZUlubmVyQW5nbGUgOiBzZWxmLl9jb25lSW5uZXJBbmdsZSxcbiAgICAgICAgICAgIGNvbmVPdXRlckFuZ2xlOiB0eXBlb2Ygby5wYW5uZXJBdHRyLmNvbmVPdXRlckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmVyQXR0ci5jb25lT3V0ZXJBbmdsZSA6IHNlbGYuX2NvbmVPdXRlckFuZ2xlLFxuICAgICAgICAgICAgY29uZU91dGVyR2FpbjogdHlwZW9mIG8ucGFubmVyQXR0ci5jb25lT3V0ZXJHYWluICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmVyQXR0ci5jb25lT3V0ZXJHYWluIDogc2VsZi5fY29uZU91dGVyR2FpbixcbiAgICAgICAgICAgIGRpc3RhbmNlTW9kZWw6IHR5cGVvZiBvLnBhbm5lckF0dHIuZGlzdGFuY2VNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5lckF0dHIuZGlzdGFuY2VNb2RlbCA6IHNlbGYuX2Rpc3RhbmNlTW9kZWwsXG4gICAgICAgICAgICBtYXhEaXN0YW5jZTogdHlwZW9mIG8ucGFubmVyQXR0ci5tYXhEaXN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5lckF0dHIubWF4RGlzdGFuY2UgOiBzZWxmLl9tYXhEaXN0YW5jZSxcbiAgICAgICAgICAgIHJlZkRpc3RhbmNlOiB0eXBlb2Ygby5wYW5uZXJBdHRyLnJlZkRpc3RhbmNlICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmVyQXR0ci5yZWZEaXN0YW5jZSA6IHNlbGYuX3JlZkRpc3RhbmNlLFxuICAgICAgICAgICAgcm9sbG9mZkZhY3RvcjogdHlwZW9mIG8ucGFubmVyQXR0ci5yb2xsb2ZmRmFjdG9yICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmVyQXR0ci5yb2xsb2ZmRmFjdG9yIDogc2VsZi5fcm9sbG9mZkZhY3RvcixcbiAgICAgICAgICAgIHBhbm5pbmdNb2RlbDogdHlwZW9mIG8ucGFubmVyQXR0ci5wYW5uaW5nTW9kZWwgIT09ICd1bmRlZmluZWQnID8gby5wYW5uZXJBdHRyLnBhbm5pbmdNb2RlbCA6IHNlbGYuX3Bhbm5pbmdNb2RlbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldHVybiB0aGlzIHNvdW5kJ3MgcGFubmVyIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKHBhcnNlSW50KGFyZ3NbMF0sIDEwKSk7XG4gICAgICAgIHJldHVybiBzb3VuZCA/IHNvdW5kLl9wYW5uZXJBdHRyIDogc2VsZi5fcGFubmVyQXR0cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBvID0gYXJnc1swXTtcbiAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1sxXSwgMTApO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgdmFsdWVzIG9mIHRoZSBzcGVjaWZpZWQgc291bmRzLlxuICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIC8vIE1lcmdlIHRoZSBuZXcgdmFsdWVzIGludG8gdGhlIHNvdW5kLlxuICAgICAgICB2YXIgcGEgPSBzb3VuZC5fcGFubmVyQXR0cjtcbiAgICAgICAgcGEgPSB7XG4gICAgICAgICAgY29uZUlubmVyQW5nbGU6IHR5cGVvZiBvLmNvbmVJbm5lckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZUlubmVyQW5nbGUgOiBwYS5jb25lSW5uZXJBbmdsZSxcbiAgICAgICAgICBjb25lT3V0ZXJBbmdsZTogdHlwZW9mIG8uY29uZU91dGVyQW5nbGUgIT09ICd1bmRlZmluZWQnID8gby5jb25lT3V0ZXJBbmdsZSA6IHBhLmNvbmVPdXRlckFuZ2xlLFxuICAgICAgICAgIGNvbmVPdXRlckdhaW46IHR5cGVvZiBvLmNvbmVPdXRlckdhaW4gIT09ICd1bmRlZmluZWQnID8gby5jb25lT3V0ZXJHYWluIDogcGEuY29uZU91dGVyR2FpbixcbiAgICAgICAgICBkaXN0YW5jZU1vZGVsOiB0eXBlb2Ygby5kaXN0YW5jZU1vZGVsICE9PSAndW5kZWZpbmVkJyA/IG8uZGlzdGFuY2VNb2RlbCA6IHBhLmRpc3RhbmNlTW9kZWwsXG4gICAgICAgICAgbWF4RGlzdGFuY2U6IHR5cGVvZiBvLm1heERpc3RhbmNlICE9PSAndW5kZWZpbmVkJyA/IG8ubWF4RGlzdGFuY2UgOiBwYS5tYXhEaXN0YW5jZSxcbiAgICAgICAgICByZWZEaXN0YW5jZTogdHlwZW9mIG8ucmVmRGlzdGFuY2UgIT09ICd1bmRlZmluZWQnID8gby5yZWZEaXN0YW5jZSA6IHBhLnJlZkRpc3RhbmNlLFxuICAgICAgICAgIHJvbGxvZmZGYWN0b3I6IHR5cGVvZiBvLnJvbGxvZmZGYWN0b3IgIT09ICd1bmRlZmluZWQnID8gby5yb2xsb2ZmRmFjdG9yIDogcGEucm9sbG9mZkZhY3RvcixcbiAgICAgICAgICBwYW5uaW5nTW9kZWw6IHR5cGVvZiBvLnBhbm5pbmdNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5pbmdNb2RlbCA6IHBhLnBhbm5pbmdNb2RlbFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcGFubmVyIHZhbHVlcyBvciBjcmVhdGUgYSBuZXcgcGFubmVyIGlmIG5vbmUgZXhpc3RzLlxuICAgICAgICB2YXIgcGFubmVyID0gc291bmQuX3Bhbm5lcjtcbiAgICAgICAgaWYgKHBhbm5lcikge1xuICAgICAgICAgIHBhbm5lci5jb25lSW5uZXJBbmdsZSA9IHBhLmNvbmVJbm5lckFuZ2xlO1xuICAgICAgICAgIHBhbm5lci5jb25lT3V0ZXJBbmdsZSA9IHBhLmNvbmVPdXRlckFuZ2xlO1xuICAgICAgICAgIHBhbm5lci5jb25lT3V0ZXJHYWluID0gcGEuY29uZU91dGVyR2FpbjtcbiAgICAgICAgICBwYW5uZXIuZGlzdGFuY2VNb2RlbCA9IHBhLmRpc3RhbmNlTW9kZWw7XG4gICAgICAgICAgcGFubmVyLm1heERpc3RhbmNlID0gcGEubWF4RGlzdGFuY2U7XG4gICAgICAgICAgcGFubmVyLnJlZkRpc3RhbmNlID0gcGEucmVmRGlzdGFuY2U7XG4gICAgICAgICAgcGFubmVyLnJvbGxvZmZGYWN0b3IgPSBwYS5yb2xsb2ZmRmFjdG9yO1xuICAgICAgICAgIHBhbm5lci5wYW5uaW5nTW9kZWwgPSBwYS5wYW5uaW5nTW9kZWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBwb3NpdGlvbiB0byBzZXR1cCB0aGUgbm9kZSB3aXRoLlxuICAgICAgICAgIGlmICghc291bmQuX3Bvcykge1xuICAgICAgICAgICAgc291bmQuX3BvcyA9IHNlbGYuX3BvcyB8fCBbMCwgMCwgLTAuNV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBhbm5lciBub2RlLlxuICAgICAgICAgIHNldHVwUGFubmVyKHNvdW5kLCAnc3BhdGlhbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLyoqIFNpbmdsZSBTb3VuZCBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBBZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlIGNvcmUgU291bmQgaW5pdC5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IF9zdXBlciBDb3JlIFNvdW5kIGluaXQgbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtTb3VuZH1cbiAgICovXG4gIFNvdW5kLnByb3RvdHlwZS5pbml0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnQgPSBzZWxmLl9wYXJlbnQ7XG5cbiAgICAgIC8vIFNldHVwIHVzZXItZGVmaW5lZCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9vcmllbnRhdGlvbiA9IHBhcmVudC5fb3JpZW50YXRpb247XG4gICAgICBzZWxmLl9zdGVyZW8gPSBwYXJlbnQuX3N0ZXJlbztcbiAgICAgIHNlbGYuX3BvcyA9IHBhcmVudC5fcG9zO1xuICAgICAgc2VsZi5fcGFubmVyQXR0ciA9IHBhcmVudC5fcGFubmVyQXR0cjtcblxuICAgICAgLy8gQ29tcGxldGUgaW5pdGlsaXphdGlvbiB3aXRoIGhvd2xlci5qcyBjb3JlIFNvdW5kJ3MgaW5pdCBmdW5jdGlvbi5cbiAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuXG4gICAgICAvLyBJZiBhIHN0ZXJlbyBvciBwb3NpdGlvbiB3YXMgc3BlY2lmaWVkLCBzZXQgaXQgdXAuXG4gICAgICBpZiAoc2VsZi5fc3RlcmVvKSB7XG4gICAgICAgIHBhcmVudC5zdGVyZW8oc2VsZi5fc3RlcmVvKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5fcG9zKSB7XG4gICAgICAgIHBhcmVudC5wb3Moc2VsZi5fcG9zWzBdLCBzZWxmLl9wb3NbMV0sIHNlbGYuX3Bvc1syXSwgc2VsZi5faWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKFNvdW5kLnByb3RvdHlwZS5pbml0KTtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIFNvdW5kLnJlc2V0IG1ldGhvZCB0byBjbGVhbiB1cCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwYXRpYWwgcGx1Z2luLlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gX3N1cGVyIFNvdW5kIHJlc2V0IG1ldGhvZC5cbiAgICogQHJldHVybiB7U291bmR9XG4gICAqL1xuICBTb3VuZC5wcm90b3R5cGUucmVzZXQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGYuX3BhcmVudDtcblxuICAgICAgLy8gUmVzZXQgYWxsIHNwYXRpYWwgcGx1Z2luIHByb3BlcnRpZXMgb24gdGhpcyBzb3VuZC5cbiAgICAgIHNlbGYuX29yaWVudGF0aW9uID0gcGFyZW50Ll9vcmllbnRhdGlvbjtcbiAgICAgIHNlbGYuX3N0ZXJlbyA9IHBhcmVudC5fc3RlcmVvO1xuICAgICAgc2VsZi5fcG9zID0gcGFyZW50Ll9wb3M7XG4gICAgICBzZWxmLl9wYW5uZXJBdHRyID0gcGFyZW50Ll9wYW5uZXJBdHRyO1xuXG4gICAgICAvLyBJZiBhIHN0ZXJlbyBvciBwb3NpdGlvbiB3YXMgc3BlY2lmaWVkLCBzZXQgaXQgdXAuXG4gICAgICBpZiAoc2VsZi5fc3RlcmVvKSB7XG4gICAgICAgIHBhcmVudC5zdGVyZW8oc2VsZi5fc3RlcmVvKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5fcG9zKSB7XG4gICAgICAgIHBhcmVudC5wb3Moc2VsZi5fcG9zWzBdLCBzZWxmLl9wb3NbMV0sIHNlbGYuX3Bvc1syXSwgc2VsZi5faWQpO1xuICAgICAgfSBlbHNlIGlmIChzZWxmLl9wYW5uZXIpIHtcbiAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgcGFubmVyLlxuICAgICAgICBzZWxmLl9wYW5uZXIuZGlzY29ubmVjdCgwKTtcbiAgICAgICAgc2VsZi5fcGFubmVyID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJlbnQuX3JlZnJlc2hCdWZmZXIoc2VsZik7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXBsZXRlIHJlc2V0dGluZyBvZiB0aGUgc291bmQuXG4gICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfSkoU291bmQucHJvdG90eXBlLnJlc2V0KTtcblxuICAvKiogSGVscGVyIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwYW5uZXIgbm9kZSBhbmQgc2F2ZSBpdCBvbiB0aGUgc291bmQuXG4gICAqIEBwYXJhbSAge1NvdW5kfSBzb3VuZCBTcGVjaWZpYyBzb3VuZCB0byBzZXR1cCBwYW5uaW5nIG9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIHBhbm5lciB0byBjcmVhdGU6ICdzdGVyZW8nIG9yICdzcGF0aWFsJy5cbiAgICovXG4gIHZhciBzZXR1cFBhbm5lciA9IGZ1bmN0aW9uKHNvdW5kLCB0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUgfHwgJ3NwYXRpYWwnO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBuZXcgcGFubmVyIG5vZGUuXG4gICAgaWYgKHR5cGUgPT09ICdzcGF0aWFsJykge1xuICAgICAgc291bmQuX3Bhbm5lciA9IEhvd2xlci5jdHguY3JlYXRlUGFubmVyKCk7XG4gICAgICBzb3VuZC5fcGFubmVyLmNvbmVJbm5lckFuZ2xlID0gc291bmQuX3Bhbm5lckF0dHIuY29uZUlubmVyQW5nbGU7XG4gICAgICBzb3VuZC5fcGFubmVyLmNvbmVPdXRlckFuZ2xlID0gc291bmQuX3Bhbm5lckF0dHIuY29uZU91dGVyQW5nbGU7XG4gICAgICBzb3VuZC5fcGFubmVyLmNvbmVPdXRlckdhaW4gPSBzb3VuZC5fcGFubmVyQXR0ci5jb25lT3V0ZXJHYWluO1xuICAgICAgc291bmQuX3Bhbm5lci5kaXN0YW5jZU1vZGVsID0gc291bmQuX3Bhbm5lckF0dHIuZGlzdGFuY2VNb2RlbDtcbiAgICAgIHNvdW5kLl9wYW5uZXIubWF4RGlzdGFuY2UgPSBzb3VuZC5fcGFubmVyQXR0ci5tYXhEaXN0YW5jZTtcbiAgICAgIHNvdW5kLl9wYW5uZXIucmVmRGlzdGFuY2UgPSBzb3VuZC5fcGFubmVyQXR0ci5yZWZEaXN0YW5jZTtcbiAgICAgIHNvdW5kLl9wYW5uZXIucm9sbG9mZkZhY3RvciA9IHNvdW5kLl9wYW5uZXJBdHRyLnJvbGxvZmZGYWN0b3I7XG4gICAgICBzb3VuZC5fcGFubmVyLnBhbm5pbmdNb2RlbCA9IHNvdW5kLl9wYW5uZXJBdHRyLnBhbm5pbmdNb2RlbDtcblxuICAgICAgaWYgKHR5cGVvZiBzb3VuZC5fcGFubmVyLnBvc2l0aW9uWCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc291bmQuX3Bhbm5lci5wb3NpdGlvblguc2V0VmFsdWVBdFRpbWUoc291bmQuX3Bvc1swXSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgIHNvdW5kLl9wYW5uZXIucG9zaXRpb25ZLnNldFZhbHVlQXRUaW1lKHNvdW5kLl9wb3NbMV0sIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICBzb3VuZC5fcGFubmVyLnBvc2l0aW9uWi5zZXRWYWx1ZUF0VGltZShzb3VuZC5fcG9zWzJdLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdW5kLl9wYW5uZXIuc2V0UG9zaXRpb24oc291bmQuX3Bvc1swXSwgc291bmQuX3Bvc1sxXSwgc291bmQuX3Bvc1syXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc291bmQuX3Bhbm5lci5vcmllbnRhdGlvblggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNvdW5kLl9wYW5uZXIub3JpZW50YXRpb25YLnNldFZhbHVlQXRUaW1lKHNvdW5kLl9vcmllbnRhdGlvblswXSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgIHNvdW5kLl9wYW5uZXIub3JpZW50YXRpb25ZLnNldFZhbHVlQXRUaW1lKHNvdW5kLl9vcmllbnRhdGlvblsxXSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgIHNvdW5kLl9wYW5uZXIub3JpZW50YXRpb25aLnNldFZhbHVlQXRUaW1lKHNvdW5kLl9vcmllbnRhdGlvblsyXSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VuZC5fcGFubmVyLnNldE9yaWVudGF0aW9uKHNvdW5kLl9vcmllbnRhdGlvblswXSwgc291bmQuX29yaWVudGF0aW9uWzFdLCBzb3VuZC5fb3JpZW50YXRpb25bMl0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzb3VuZC5fcGFubmVyID0gSG93bGVyLmN0eC5jcmVhdGVTdGVyZW9QYW5uZXIoKTtcbiAgICAgIHNvdW5kLl9wYW5uZXIucGFuLnNldFZhbHVlQXRUaW1lKHNvdW5kLl9zdGVyZW8sIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIHNvdW5kLl9wYW5uZXIuY29ubmVjdChzb3VuZC5fbm9kZSk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIGNvbm5lY3Rpb25zLlxuICAgIGlmICghc291bmQuX3BhdXNlZCkge1xuICAgICAgc291bmQuX3BhcmVudC5wYXVzZShzb3VuZC5faWQsIHRydWUpLnBsYXkoc291bmQuX2lkLCB0cnVlKTtcbiAgICB9XG4gIH07XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/howler/dist/howler.js\n");

/***/ }),

/***/ "./node_modules/p2/package.json":
/*!**************************************!*\
  !*** ./node_modules/p2/package.json ***!
  \**************************************/
/*! exports provided: _args, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, bugs, dependencies, description, devDependencies, engines, homepage, keywords, licenses, main, name, repository, version, default */
/*! all exports used */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"_args\\\":[[\\\"p2@0.7.1\\\",\\\"D:\\\\\\\\VS_Projects\\\\\\\\SF\\\\\\\\jam_2018\\\"]],\\\"_from\\\":\\\"p2@0.7.1\\\",\\\"_id\\\":\\\"p2@0.7.1\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha1-JfJHTZvDptMUCh2iamfJ4RislUM=\\\",\\\"_location\\\":\\\"/p2\\\",\\\"_phantomChildren\\\":{},\\\"_requested\\\":{\\\"type\\\":\\\"version\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"p2@0.7.1\\\",\\\"name\\\":\\\"p2\\\",\\\"escapedName\\\":\\\"p2\\\",\\\"rawSpec\\\":\\\"0.7.1\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"0.7.1\\\"},\\\"_requiredBy\\\":[\\\"/\\\"],\\\"_resolved\\\":\\\"https://registry.npmjs.org/p2/-/p2-0.7.1.tgz\\\",\\\"_spec\\\":\\\"0.7.1\\\",\\\"_where\\\":\\\"D:\\\\\\\\VS_Projects\\\\\\\\SF\\\\\\\\jam_2018\\\",\\\"author\\\":{\\\"name\\\":\\\"Stefan Hedman\\\",\\\"email\\\":\\\"schteppe@gmail.com\\\",\\\"url\\\":\\\"http://steffe.se\\\"},\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/schteppe/p2.js/issues\\\"},\\\"dependencies\\\":{\\\"poly-decomp\\\":\\\"0.1.1\\\"},\\\"description\\\":\\\"A JavaScript 2D physics engine.\\\",\\\"devDependencies\\\":{\\\"grunt\\\":\\\"^0.4.5\\\",\\\"grunt-browserify\\\":\\\"~2.0.1\\\",\\\"grunt-contrib-concat\\\":\\\"^0.4.0\\\",\\\"grunt-contrib-jshint\\\":\\\"^0.11.2\\\",\\\"grunt-contrib-nodeunit\\\":\\\"^0.4.1\\\",\\\"grunt-contrib-uglify\\\":\\\"~0.4.0\\\",\\\"grunt-contrib-watch\\\":\\\"~0.5.0\\\"},\\\"engines\\\":{\\\"node\\\":\\\"*\\\"},\\\"homepage\\\":\\\"https://github.com/schteppe/p2.js#readme\\\",\\\"keywords\\\":[\\\"p2.js\\\",\\\"p2\\\",\\\"physics\\\",\\\"engine\\\",\\\"2d\\\"],\\\"licenses\\\":[{\\\"type\\\":\\\"MIT\\\"}],\\\"main\\\":\\\"./src/p2.js\\\",\\\"name\\\":\\\"p2\\\",\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/schteppe/p2.js.git\\\"},\\\"version\\\":\\\"0.7.1\\\"}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvcGFja2FnZS5qc29uLmpzIiwic291cmNlcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/package.json\n");

/***/ }),

/***/ "./node_modules/p2/src/collision/AABB.js":
/*!***********************************************!*\
  !*** ./node_modules/p2/src/collision/AABB.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,   Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\");\n\nmodule.exports = AABB;\n\n/**\n * Axis aligned bounding box class.\n * @class AABB\n * @constructor\n * @param {Object}  [options]\n * @param {Array}   [options.upperBound]\n * @param {Array}   [options.lowerBound]\n */\nfunction AABB(options){\n\n    /**\n     * The lower bound of the bounding box.\n     * @property lowerBound\n     * @type {Array}\n     */\n    this.lowerBound = vec2.create();\n    if(options && options.lowerBound){\n        vec2.copy(this.lowerBound, options.lowerBound);\n    }\n\n    /**\n     * The upper bound of the bounding box.\n     * @property upperBound\n     * @type {Array}\n     */\n    this.upperBound = vec2.create();\n    if(options && options.upperBound){\n        vec2.copy(this.upperBound, options.upperBound);\n    }\n}\n\nvar tmp = vec2.create();\n\n/**\n * Set the AABB bounds from a set of points, transformed by the given position and angle.\n * @method setFromPoints\n * @param {Array} points An array of vec2's.\n * @param {Array} position\n * @param {number} angle\n * @param {number} skinSize Some margin to be added to the AABB.\n */\nAABB.prototype.setFromPoints = function(points, position, angle, skinSize){\n    var l = this.lowerBound,\n        u = this.upperBound;\n\n    if(typeof(angle) !== \"number\"){\n        angle = 0;\n    }\n\n    // Set to the first point\n    if(angle !== 0){\n        vec2.rotate(l, points[0], angle);\n    } else {\n        vec2.copy(l, points[0]);\n    }\n    vec2.copy(u, l);\n\n    // Compute cosines and sines just once\n    var cosAngle = Math.cos(angle),\n        sinAngle = Math.sin(angle);\n    for(var i = 1; i<points.length; i++){\n        var p = points[i];\n\n        if(angle !== 0){\n            var x = p[0],\n                y = p[1];\n            tmp[0] = cosAngle * x -sinAngle * y;\n            tmp[1] = sinAngle * x +cosAngle * y;\n            p = tmp;\n        }\n\n        for(var j=0; j<2; j++){\n            if(p[j] > u[j]){\n                u[j] = p[j];\n            }\n            if(p[j] < l[j]){\n                l[j] = p[j];\n            }\n        }\n    }\n\n    // Add offset\n    if(position){\n        vec2.add(this.lowerBound, this.lowerBound, position);\n        vec2.add(this.upperBound, this.upperBound, position);\n    }\n\n    if(skinSize){\n        this.lowerBound[0] -= skinSize;\n        this.lowerBound[1] -= skinSize;\n        this.upperBound[0] += skinSize;\n        this.upperBound[1] += skinSize;\n    }\n};\n\n/**\n * Copy bounds from an AABB to this AABB\n * @method copy\n * @param  {AABB} aabb\n */\nAABB.prototype.copy = function(aabb){\n    vec2.copy(this.lowerBound, aabb.lowerBound);\n    vec2.copy(this.upperBound, aabb.upperBound);\n};\n\n/**\n * Extend this AABB so that it covers the given AABB too.\n * @method extend\n * @param  {AABB} aabb\n */\nAABB.prototype.extend = function(aabb){\n    // Loop over x and y\n    var i = 2;\n    while(i--){\n        // Extend lower bound\n        var l = aabb.lowerBound[i];\n        if(this.lowerBound[i] > l){\n            this.lowerBound[i] = l;\n        }\n\n        // Upper\n        var u = aabb.upperBound[i];\n        if(this.upperBound[i] < u){\n            this.upperBound[i] = u;\n        }\n    }\n};\n\n/**\n * Returns true if the given AABB overlaps this AABB.\n * @method overlaps\n * @param  {AABB} aabb\n * @return {Boolean}\n */\nAABB.prototype.overlaps = function(aabb){\n    var l1 = this.lowerBound,\n        u1 = this.upperBound,\n        l2 = aabb.lowerBound,\n        u2 = aabb.upperBound;\n\n    //      l2        u2\n    //      |---------|\n    // |--------|\n    // l1       u1\n\n    return ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&\n           ((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));\n};\n\n/**\n * @method containsPoint\n * @param  {Array} point\n * @return {boolean}\n */\nAABB.prototype.containsPoint = function(point){\n    var l = this.lowerBound,\n        u = this.upperBound;\n    return l[0] <= point[0] && point[0] <= u[0] && l[1] <= point[1] && point[1] <= u[1];\n};\n\n/**\n * Check if the AABB is hit by a ray.\n * @method overlapsRay\n * @param  {Ray} ray\n * @return {number} -1 if no hit, a number between 0 and 1 if hit.\n */\nAABB.prototype.overlapsRay = function(ray){\n    var t = 0;\n\n    // ray.direction is unit direction vector of ray\n    var dirFracX = 1 / ray.direction[0];\n    var dirFracY = 1 / ray.direction[1];\n\n    // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner\n    var t1 = (this.lowerBound[0] - ray.from[0]) * dirFracX;\n    var t2 = (this.upperBound[0] - ray.from[0]) * dirFracX;\n    var t3 = (this.lowerBound[1] - ray.from[1]) * dirFracY;\n    var t4 = (this.upperBound[1] - ray.from[1]) * dirFracY;\n\n    var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));\n    var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));\n\n    // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us\n    if (tmax < 0){\n        //t = tmax;\n        return -1;\n    }\n\n    // if tmin > tmax, ray doesn't intersect AABB\n    if (tmin > tmax){\n        //t = tmax;\n        return -1;\n    }\n\n    return tmin;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbGxpc2lvbi9BQUJCLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9jb2xsaXNpb24vQUFCQi5qcz8yMzJjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJylcbiwgICBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQUFCQjtcblxuLyoqXG4gKiBBeGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGNsYXNzLlxuICogQGNsYXNzIEFBQkJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMudXBwZXJCb3VuZF1cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG93ZXJCb3VuZF1cbiAqL1xuZnVuY3Rpb24gQUFCQihvcHRpb25zKXtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb3dlciBib3VuZCBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckJvdW5kXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJCb3VuZCA9IHZlYzIuY3JlYXRlKCk7XG4gICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmxvd2VyQm91bmQpe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5sb3dlckJvdW5kLCBvcHRpb25zLmxvd2VyQm91bmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqIEBwcm9wZXJ0eSB1cHBlckJvdW5kXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJCb3VuZCA9IHZlYzIuY3JlYXRlKCk7XG4gICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLnVwcGVyQm91bmQpe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy51cHBlckJvdW5kLCBvcHRpb25zLnVwcGVyQm91bmQpO1xuICAgIH1cbn1cblxudmFyIHRtcCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogU2V0IHRoZSBBQUJCIGJvdW5kcyBmcm9tIGEgc2V0IG9mIHBvaW50cywgdHJhbnNmb3JtZWQgYnkgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBhbmdsZS5cbiAqIEBtZXRob2Qgc2V0RnJvbVBvaW50c1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFuIGFycmF5IG9mIHZlYzIncy5cbiAqIEBwYXJhbSB7QXJyYXl9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBza2luU2l6ZSBTb21lIG1hcmdpbiB0byBiZSBhZGRlZCB0byB0aGUgQUFCQi5cbiAqL1xuQUFCQi5wcm90b3R5cGUuc2V0RnJvbVBvaW50cyA9IGZ1bmN0aW9uKHBvaW50cywgcG9zaXRpb24sIGFuZ2xlLCBza2luU2l6ZSl7XG4gICAgdmFyIGwgPSB0aGlzLmxvd2VyQm91bmQsXG4gICAgICAgIHUgPSB0aGlzLnVwcGVyQm91bmQ7XG5cbiAgICBpZih0eXBlb2YoYW5nbGUpICE9PSBcIm51bWJlclwiKXtcbiAgICAgICAgYW5nbGUgPSAwO1xuICAgIH1cblxuICAgIC8vIFNldCB0byB0aGUgZmlyc3QgcG9pbnRcbiAgICBpZihhbmdsZSAhPT0gMCl7XG4gICAgICAgIHZlYzIucm90YXRlKGwsIHBvaW50c1swXSwgYW5nbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZlYzIuY29weShsLCBwb2ludHNbMF0pO1xuICAgIH1cbiAgICB2ZWMyLmNvcHkodSwgbCk7XG5cbiAgICAvLyBDb21wdXRlIGNvc2luZXMgYW5kIHNpbmVzIGp1c3Qgb25jZVxuICAgIHZhciBjb3NBbmdsZSA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgZm9yKHZhciBpID0gMTsgaTxwb2ludHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcblxuICAgICAgICBpZihhbmdsZSAhPT0gMCl7XG4gICAgICAgICAgICB2YXIgeCA9IHBbMF0sXG4gICAgICAgICAgICAgICAgeSA9IHBbMV07XG4gICAgICAgICAgICB0bXBbMF0gPSBjb3NBbmdsZSAqIHggLXNpbkFuZ2xlICogeTtcbiAgICAgICAgICAgIHRtcFsxXSA9IHNpbkFuZ2xlICogeCArY29zQW5nbGUgKiB5O1xuICAgICAgICAgICAgcCA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqPDI7IGorKyl7XG4gICAgICAgICAgICBpZihwW2pdID4gdVtqXSl7XG4gICAgICAgICAgICAgICAgdVtqXSA9IHBbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihwW2pdIDwgbFtqXSl7XG4gICAgICAgICAgICAgICAgbFtqXSA9IHBbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgb2Zmc2V0XG4gICAgaWYocG9zaXRpb24pe1xuICAgICAgICB2ZWMyLmFkZCh0aGlzLmxvd2VyQm91bmQsIHRoaXMubG93ZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgICAgICB2ZWMyLmFkZCh0aGlzLnVwcGVyQm91bmQsIHRoaXMudXBwZXJCb3VuZCwgcG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmKHNraW5TaXplKXtcbiAgICAgICAgdGhpcy5sb3dlckJvdW5kWzBdIC09IHNraW5TaXplO1xuICAgICAgICB0aGlzLmxvd2VyQm91bmRbMV0gLT0gc2tpblNpemU7XG4gICAgICAgIHRoaXMudXBwZXJCb3VuZFswXSArPSBza2luU2l6ZTtcbiAgICAgICAgdGhpcy51cHBlckJvdW5kWzFdICs9IHNraW5TaXplO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29weSBib3VuZHMgZnJvbSBhbiBBQUJCIHRvIHRoaXMgQUFCQlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKi9cbkFBQkIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihhYWJiKXtcbiAgICB2ZWMyLmNvcHkodGhpcy5sb3dlckJvdW5kLCBhYWJiLmxvd2VyQm91bmQpO1xuICAgIHZlYzIuY29weSh0aGlzLnVwcGVyQm91bmQsIGFhYmIudXBwZXJCb3VuZCk7XG59O1xuXG4vKipcbiAqIEV4dGVuZCB0aGlzIEFBQkIgc28gdGhhdCBpdCBjb3ZlcnMgdGhlIGdpdmVuIEFBQkIgdG9vLlxuICogQG1ldGhvZCBleHRlbmRcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuQUFCQi5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24oYWFiYil7XG4gICAgLy8gTG9vcCBvdmVyIHggYW5kIHlcbiAgICB2YXIgaSA9IDI7XG4gICAgd2hpbGUoaS0tKXtcbiAgICAgICAgLy8gRXh0ZW5kIGxvd2VyIGJvdW5kXG4gICAgICAgIHZhciBsID0gYWFiYi5sb3dlckJvdW5kW2ldO1xuICAgICAgICBpZih0aGlzLmxvd2VyQm91bmRbaV0gPiBsKXtcbiAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZFtpXSA9IGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcHBlclxuICAgICAgICB2YXIgdSA9IGFhYmIudXBwZXJCb3VuZFtpXTtcbiAgICAgICAgaWYodGhpcy51cHBlckJvdW5kW2ldIDwgdSl7XG4gICAgICAgICAgICB0aGlzLnVwcGVyQm91bmRbaV0gPSB1O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIEFBQkIgb3ZlcmxhcHMgdGhpcyBBQUJCLlxuICogQG1ldGhvZCBvdmVybGFwc1xuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuQUFCQi5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbihhYWJiKXtcbiAgICB2YXIgbDEgPSB0aGlzLmxvd2VyQm91bmQsXG4gICAgICAgIHUxID0gdGhpcy51cHBlckJvdW5kLFxuICAgICAgICBsMiA9IGFhYmIubG93ZXJCb3VuZCxcbiAgICAgICAgdTIgPSBhYWJiLnVwcGVyQm91bmQ7XG5cbiAgICAvLyAgICAgIGwyICAgICAgICB1MlxuICAgIC8vICAgICAgfC0tLS0tLS0tLXxcbiAgICAvLyB8LS0tLS0tLS18XG4gICAgLy8gbDEgICAgICAgdTFcblxuICAgIHJldHVybiAoKGwyWzBdIDw9IHUxWzBdICYmIHUxWzBdIDw9IHUyWzBdKSB8fCAobDFbMF0gPD0gdTJbMF0gJiYgdTJbMF0gPD0gdTFbMF0pKSAmJlxuICAgICAgICAgICAoKGwyWzFdIDw9IHUxWzFdICYmIHUxWzFdIDw9IHUyWzFdKSB8fCAobDFbMV0gPD0gdTJbMV0gJiYgdTJbMV0gPD0gdTFbMV0pKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb250YWluc1BvaW50XG4gKiBAcGFyYW0gIHtBcnJheX0gcG9pbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkFBQkIucHJvdG90eXBlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbihwb2ludCl7XG4gICAgdmFyIGwgPSB0aGlzLmxvd2VyQm91bmQsXG4gICAgICAgIHUgPSB0aGlzLnVwcGVyQm91bmQ7XG4gICAgcmV0dXJuIGxbMF0gPD0gcG9pbnRbMF0gJiYgcG9pbnRbMF0gPD0gdVswXSAmJiBsWzFdIDw9IHBvaW50WzFdICYmIHBvaW50WzFdIDw9IHVbMV07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBBQUJCIGlzIGhpdCBieSBhIHJheS5cbiAqIEBtZXRob2Qgb3ZlcmxhcHNSYXlcbiAqIEBwYXJhbSAge1JheX0gcmF5XG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0xIGlmIG5vIGhpdCwgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIGlmIGhpdC5cbiAqL1xuQUFCQi5wcm90b3R5cGUub3ZlcmxhcHNSYXkgPSBmdW5jdGlvbihyYXkpe1xuICAgIHZhciB0ID0gMDtcblxuICAgIC8vIHJheS5kaXJlY3Rpb24gaXMgdW5pdCBkaXJlY3Rpb24gdmVjdG9yIG9mIHJheVxuICAgIHZhciBkaXJGcmFjWCA9IDEgLyByYXkuZGlyZWN0aW9uWzBdO1xuICAgIHZhciBkaXJGcmFjWSA9IDEgLyByYXkuZGlyZWN0aW9uWzFdO1xuXG4gICAgLy8gdGhpcy5sb3dlckJvdW5kIGlzIHRoZSBjb3JuZXIgb2YgQUFCQiB3aXRoIG1pbmltYWwgY29vcmRpbmF0ZXMgLSBsZWZ0IGJvdHRvbSwgcnQgaXMgbWF4aW1hbCBjb3JuZXJcbiAgICB2YXIgdDEgPSAodGhpcy5sb3dlckJvdW5kWzBdIC0gcmF5LmZyb21bMF0pICogZGlyRnJhY1g7XG4gICAgdmFyIHQyID0gKHRoaXMudXBwZXJCb3VuZFswXSAtIHJheS5mcm9tWzBdKSAqIGRpckZyYWNYO1xuICAgIHZhciB0MyA9ICh0aGlzLmxvd2VyQm91bmRbMV0gLSByYXkuZnJvbVsxXSkgKiBkaXJGcmFjWTtcbiAgICB2YXIgdDQgPSAodGhpcy51cHBlckJvdW5kWzFdIC0gcmF5LmZyb21bMV0pICogZGlyRnJhY1k7XG5cbiAgICB2YXIgdG1pbiA9IE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWluKHQxLCB0MiksIE1hdGgubWluKHQzLCB0NCkpKTtcbiAgICB2YXIgdG1heCA9IE1hdGgubWluKE1hdGgubWluKE1hdGgubWF4KHQxLCB0MiksIE1hdGgubWF4KHQzLCB0NCkpKTtcblxuICAgIC8vIGlmIHRtYXggPCAwLCByYXkgKGxpbmUpIGlzIGludGVyc2VjdGluZyBBQUJCLCBidXQgd2hvbGUgQUFCQiBpcyBiZWhpbmcgdXNcbiAgICBpZiAodG1heCA8IDApe1xuICAgICAgICAvL3QgPSB0bWF4O1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLy8gaWYgdG1pbiA+IHRtYXgsIHJheSBkb2Vzbid0IGludGVyc2VjdCBBQUJCXG4gICAgaWYgKHRtaW4gPiB0bWF4KXtcbiAgICAgICAgLy90ID0gdG1heDtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHJldHVybiB0bWluO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/collision/AABB.js\n");

/***/ }),

/***/ "./node_modules/p2/src/collision/Broadphase.js":
/*!*****************************************************!*\
  !*** ./node_modules/p2/src/collision/Broadphase.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\nvar Body = __webpack_require__(/*! ../objects/Body */ \"./node_modules/p2/src/objects/Body.js\");\n\nmodule.exports = Broadphase;\n\n/**\n * Base class for broadphase implementations.\n * @class Broadphase\n * @constructor\n */\nfunction Broadphase(type){\n\n    this.type = type;\n\n    /**\n     * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().\n     * @property result\n     * @type {Array}\n     */\n    this.result = [];\n\n    /**\n     * The world to search for collision pairs in. To change it, use .setWorld()\n     * @property world\n     * @type {World}\n     * @readOnly\n     */\n    this.world = null;\n\n    /**\n     * The bounding volume type to use in the broadphase algorithms. Should be set to Broadphase.AABB or Broadphase.BOUNDING_CIRCLE.\n     * @property {Number} boundingVolumeType\n     */\n    this.boundingVolumeType = Broadphase.AABB;\n}\n\n/**\n * Axis aligned bounding box type.\n * @static\n * @property {Number} AABB\n */\nBroadphase.AABB = 1;\n\n/**\n * Bounding circle type.\n * @static\n * @property {Number} BOUNDING_CIRCLE\n */\nBroadphase.BOUNDING_CIRCLE = 2;\n\n/**\n * Set the world that we are searching for collision pairs in.\n * @method setWorld\n * @param  {World} world\n */\nBroadphase.prototype.setWorld = function(world){\n    this.world = world;\n};\n\n/**\n * Get all potential intersecting body pairs.\n * @method getCollisionPairs\n * @param  {World} world The world to search in.\n * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).\n */\nBroadphase.prototype.getCollisionPairs = function(world){};\n\nvar dist = vec2.create();\n\n/**\n * Check whether the bounding radius of two bodies overlap.\n * @method  boundingRadiusCheck\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nBroadphase.boundingRadiusCheck = function(bodyA, bodyB){\n    vec2.sub(dist, bodyA.position, bodyB.position);\n    var d2 = vec2.squaredLength(dist),\n        r = bodyA.boundingRadius + bodyB.boundingRadius;\n    return d2 <= r*r;\n};\n\n/**\n * Check whether the bounding radius of two bodies overlap.\n * @method  boundingRadiusCheck\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nBroadphase.aabbCheck = function(bodyA, bodyB){\n    return bodyA.getAABB().overlaps(bodyB.getAABB());\n};\n\n/**\n * Check whether the bounding radius of two bodies overlap.\n * @method  boundingRadiusCheck\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nBroadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB){\n    var result;\n\n    switch(this.boundingVolumeType){\n    case Broadphase.BOUNDING_CIRCLE:\n        result =  Broadphase.boundingRadiusCheck(bodyA,bodyB);\n        break;\n    case Broadphase.AABB:\n        result = Broadphase.aabbCheck(bodyA,bodyB);\n        break;\n    default:\n        throw new Error('Bounding volume type not recognized: '+this.boundingVolumeType);\n    }\n    return result;\n};\n\n/**\n * Check whether two bodies are allowed to collide at all.\n * @method  canCollide\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nBroadphase.canCollide = function(bodyA, bodyB){\n    var KINEMATIC = Body.KINEMATIC;\n    var STATIC = Body.STATIC;\n\n    // Cannot collide static bodies\n    if(bodyA.type === STATIC && bodyB.type === STATIC){\n        return false;\n    }\n\n    // Cannot collide static vs kinematic bodies\n    if( (bodyA.type === KINEMATIC && bodyB.type === STATIC) ||\n        (bodyA.type === STATIC    && bodyB.type === KINEMATIC)){\n        return false;\n    }\n\n    // Cannot collide kinematic vs kinematic\n    if(bodyA.type === KINEMATIC && bodyB.type === KINEMATIC){\n        return false;\n    }\n\n    // Cannot collide both sleeping bodies\n    if(bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING){\n        return false;\n    }\n\n    // Cannot collide if one is static and the other is sleeping\n    if( (bodyA.sleepState === Body.SLEEPING && bodyB.type === STATIC) ||\n        (bodyB.sleepState === Body.SLEEPING && bodyA.type === STATIC)){\n        return false;\n    }\n\n    return true;\n};\n\nBroadphase.NAIVE = 1;\nBroadphase.SAP = 2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbGxpc2lvbi9Ccm9hZHBoYXNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9jb2xsaXNpb24vQnJvYWRwaGFzZS5qcz84MTdkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJyk7XG52YXIgQm9keSA9IHJlcXVpcmUoJy4uL29iamVjdHMvQm9keScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJyb2FkcGhhc2U7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbnMuXG4gKiBAY2xhc3MgQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJyb2FkcGhhc2UodHlwZSl7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJlc3VsdGluZyBvdmVybGFwcGluZyBwYWlycy4gV2lsbCBiZSBmaWxsZWQgd2l0aCByZXN1bHRzIGR1cmluZyAuZ2V0Q29sbGlzaW9uUGFpcnMoKS5cbiAgICAgKiBAcHJvcGVydHkgcmVzdWx0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMucmVzdWx0ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd29ybGQgdG8gc2VhcmNoIGZvciBjb2xsaXNpb24gcGFpcnMgaW4uIFRvIGNoYW5nZSBpdCwgdXNlIC5zZXRXb3JsZCgpXG4gICAgICogQHByb3BlcnR5IHdvcmxkXG4gICAgICogQHR5cGUge1dvcmxkfVxuICAgICAqIEByZWFkT25seVxuICAgICAqL1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvdW5kaW5nIHZvbHVtZSB0eXBlIHRvIHVzZSBpbiB0aGUgYnJvYWRwaGFzZSBhbGdvcml0aG1zLiBTaG91bGQgYmUgc2V0IHRvIEJyb2FkcGhhc2UuQUFCQiBvciBCcm9hZHBoYXNlLkJPVU5ESU5HX0NJUkNMRS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYm91bmRpbmdWb2x1bWVUeXBlXG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1ZvbHVtZVR5cGUgPSBCcm9hZHBoYXNlLkFBQkI7XG59XG5cbi8qKlxuICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCB0eXBlLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEFBQkJcbiAqL1xuQnJvYWRwaGFzZS5BQUJCID0gMTtcblxuLyoqXG4gKiBCb3VuZGluZyBjaXJjbGUgdHlwZS5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBCT1VORElOR19DSVJDTEVcbiAqL1xuQnJvYWRwaGFzZS5CT1VORElOR19DSVJDTEUgPSAyO1xuXG4vKipcbiAqIFNldCB0aGUgd29ybGQgdGhhdCB3ZSBhcmUgc2VhcmNoaW5nIGZvciBjb2xsaXNpb24gcGFpcnMgaW4uXG4gKiBAbWV0aG9kIHNldFdvcmxkXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuc2V0V29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xufTtcblxuLyoqXG4gKiBHZXQgYWxsIHBvdGVudGlhbCBpbnRlcnNlY3RpbmcgYm9keSBwYWlycy5cbiAqIEBtZXRob2QgZ2V0Q29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZCBUaGUgd29ybGQgdG8gc2VhcmNoIGluLlxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSBib2RpZXMsIG9yZGVyZWQgaW4gcGFpcnMuIEV4YW1wbGU6IEEgcmVzdWx0IG9mIFthLGIsYyxkXSBtZWFucyB0aGF0IHRoZSBwb3RlbnRpYWwgcGFpcnMgYXJlOiAoYSxiKSwgKGMsZCkuXG4gKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLmdldENvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQpe307XG5cbnZhciBkaXN0ID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLmJvdW5kaW5nUmFkaXVzQ2hlY2sgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZlYzIuc3ViKGRpc3QsIGJvZHlBLnBvc2l0aW9uLCBib2R5Qi5wb3NpdGlvbik7XG4gICAgdmFyIGQyID0gdmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpLFxuICAgICAgICByID0gYm9keUEuYm91bmRpbmdSYWRpdXMgKyBib2R5Qi5ib3VuZGluZ1JhZGl1cztcbiAgICByZXR1cm4gZDIgPD0gcipyO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLmFhYmJDaGVjayA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgcmV0dXJuIGJvZHlBLmdldEFBQkIoKS5vdmVybGFwcyhib2R5Qi5nZXRBQUJCKCkpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCAgYm91bmRpbmdSYWRpdXNDaGVja1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5ib3VuZGluZ1ZvbHVtZUNoZWNrID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgc3dpdGNoKHRoaXMuYm91bmRpbmdWb2x1bWVUeXBlKXtcbiAgICBjYXNlIEJyb2FkcGhhc2UuQk9VTkRJTkdfQ0lSQ0xFOlxuICAgICAgICByZXN1bHQgPSAgQnJvYWRwaGFzZS5ib3VuZGluZ1JhZGl1c0NoZWNrKGJvZHlBLGJvZHlCKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBCcm9hZHBoYXNlLkFBQkI6XG4gICAgICAgIHJlc3VsdCA9IEJyb2FkcGhhc2UuYWFiYkNoZWNrKGJvZHlBLGJvZHlCKTtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3VuZGluZyB2b2x1bWUgdHlwZSBub3QgcmVjb2duaXplZDogJyt0aGlzLmJvdW5kaW5nVm9sdW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdHdvIGJvZGllcyBhcmUgYWxsb3dlZCB0byBjb2xsaWRlIGF0IGFsbC5cbiAqIEBtZXRob2QgIGNhbkNvbGxpZGVcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuQnJvYWRwaGFzZS5jYW5Db2xsaWRlID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2YXIgS0lORU1BVElDID0gQm9keS5LSU5FTUFUSUM7XG4gICAgdmFyIFNUQVRJQyA9IEJvZHkuU1RBVElDO1xuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgc3RhdGljIGJvZGllc1xuICAgIGlmKGJvZHlBLnR5cGUgPT09IFNUQVRJQyAmJiBib2R5Qi50eXBlID09PSBTVEFUSUMpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2Fubm90IGNvbGxpZGUgc3RhdGljIHZzIGtpbmVtYXRpYyBib2RpZXNcbiAgICBpZiggKGJvZHlBLnR5cGUgPT09IEtJTkVNQVRJQyAmJiBib2R5Qi50eXBlID09PSBTVEFUSUMpIHx8XG4gICAgICAgIChib2R5QS50eXBlID09PSBTVEFUSUMgICAgJiYgYm9keUIudHlwZSA9PT0gS0lORU1BVElDKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBraW5lbWF0aWMgdnMga2luZW1hdGljXG4gICAgaWYoYm9keUEudHlwZSA9PT0gS0lORU1BVElDICYmIGJvZHlCLnR5cGUgPT09IEtJTkVNQVRJQyl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBib3RoIHNsZWVwaW5nIGJvZGllc1xuICAgIGlmKGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgJiYgYm9keUIuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDYW5ub3QgY29sbGlkZSBpZiBvbmUgaXMgc3RhdGljIGFuZCB0aGUgb3RoZXIgaXMgc2xlZXBpbmdcbiAgICBpZiggKGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgJiYgYm9keUIudHlwZSA9PT0gU1RBVElDKSB8fFxuICAgICAgICAoYm9keUIuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJiBib2R5QS50eXBlID09PSBTVEFUSUMpKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuQnJvYWRwaGFzZS5OQUlWRSA9IDE7XG5Ccm9hZHBoYXNlLlNBUCA9IDI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/collision/Broadphase.js\n");

/***/ }),

/***/ "./node_modules/p2/src/collision/NaiveBroadphase.js":
/*!**********************************************************!*\
  !*** ./node_modules/p2/src/collision/NaiveBroadphase.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Circle = __webpack_require__(/*! ../shapes/Circle */ \"./node_modules/p2/src/shapes/Circle.js\"),\n    Plane = __webpack_require__(/*! ../shapes/Plane */ \"./node_modules/p2/src/shapes/Plane.js\"),\n    Shape = __webpack_require__(/*! ../shapes/Shape */ \"./node_modules/p2/src/shapes/Shape.js\"),\n    Particle = __webpack_require__(/*! ../shapes/Particle */ \"./node_modules/p2/src/shapes/Particle.js\"),\n    Broadphase = __webpack_require__(/*! ../collision/Broadphase */ \"./node_modules/p2/src/collision/Broadphase.js\"),\n    vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\n\nmodule.exports = NaiveBroadphase;\n\n/**\n * Naive broadphase implementation. Does N^2 tests.\n *\n * @class NaiveBroadphase\n * @constructor\n * @extends Broadphase\n */\nfunction NaiveBroadphase(){\n    Broadphase.call(this, Broadphase.NAIVE);\n}\nNaiveBroadphase.prototype = new Broadphase();\nNaiveBroadphase.prototype.constructor = NaiveBroadphase;\n\n/**\n * Get the colliding pairs\n * @method getCollisionPairs\n * @param  {World} world\n * @return {Array}\n */\nNaiveBroadphase.prototype.getCollisionPairs = function(world){\n    var bodies = world.bodies,\n        result = this.result;\n\n    result.length = 0;\n\n    for(var i=0, Ncolliding=bodies.length; i!==Ncolliding; i++){\n        var bi = bodies[i];\n\n        for(var j=0; j<i; j++){\n            var bj = bodies[j];\n\n            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){\n                result.push(bi,bj);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Returns all the bodies within an AABB.\n * @method aabbQuery\n * @param  {World} world\n * @param  {AABB} aabb\n * @param {array} result An array to store resulting bodies in.\n * @return {array}\n */\nNaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){\n    result = result || [];\n\n    var bodies = world.bodies;\n    for(var i = 0; i < bodies.length; i++){\n        var b = bodies[i];\n\n        if(b.aabbNeedsUpdate){\n            b.updateAABB();\n        }\n\n        if(b.aabb.overlaps(aabb)){\n            result.push(b);\n        }\n    }\n\n    return result;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2UuanM/YmRkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ2lyY2xlID0gcmVxdWlyZSgnLi4vc2hhcGVzL0NpcmNsZScpLFxuICAgIFBsYW5lID0gcmVxdWlyZSgnLi4vc2hhcGVzL1BsYW5lJyksXG4gICAgU2hhcGUgPSByZXF1aXJlKCcuLi9zaGFwZXMvU2hhcGUnKSxcbiAgICBQYXJ0aWNsZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9QYXJ0aWNsZScpLFxuICAgIEJyb2FkcGhhc2UgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxuICAgIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYWl2ZUJyb2FkcGhhc2U7XG5cbi8qKlxuICogTmFpdmUgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbi4gRG9lcyBOXjIgdGVzdHMuXG4gKlxuICogQGNsYXNzIE5haXZlQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXG4gKi9cbmZ1bmN0aW9uIE5haXZlQnJvYWRwaGFzZSgpe1xuICAgIEJyb2FkcGhhc2UuY2FsbCh0aGlzLCBCcm9hZHBoYXNlLk5BSVZFKTtcbn1cbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5haXZlQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbGxpZGluZyBwYWlyc1xuICogQG1ldGhvZCBnZXRDb2xsaXNpb25QYWlyc1xuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5nZXRDb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdDtcblxuICAgIHJlc3VsdC5sZW5ndGggPSAwO1xuXG4gICAgZm9yKHZhciBpPTAsIE5jb2xsaWRpbmc9Ym9kaWVzLmxlbmd0aDsgaSE9PU5jb2xsaWRpbmc7IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcblxuICAgICAgICBmb3IodmFyIGo9MDsgajxpOyBqKyspe1xuICAgICAgICAgICAgdmFyIGJqID0gYm9kaWVzW2pdO1xuXG4gICAgICAgICAgICBpZihCcm9hZHBoYXNlLmNhbkNvbGxpZGUoYmksYmopICYmIHRoaXMuYm91bmRpbmdWb2x1bWVDaGVjayhiaSxiaikpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJpLGJqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXG4gKiBAbWV0aG9kIGFhYmJRdWVyeVxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGJvZGllcyBpbi5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKHdvcmxkLCBhYWJiLCByZXN1bHQpe1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICAgIHZhciBib2RpZXMgPSB3b3JsZC5ib2RpZXM7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgIGlmKGIuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGIudXBkYXRlQUFCQigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYi5hYWJiLm92ZXJsYXBzKGFhYmIpKXtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/collision/NaiveBroadphase.js\n");

/***/ }),

/***/ "./node_modules/p2/src/collision/Narrowphase.js":
/*!******************************************************!*\
  !*** ./node_modules/p2/src/collision/Narrowphase.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,   sub = vec2.sub\n,   add = vec2.add\n,   dot = vec2.dot\n,   Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\")\n,   ContactEquationPool = __webpack_require__(/*! ../utils/ContactEquationPool */ \"./node_modules/p2/src/utils/ContactEquationPool.js\")\n,   FrictionEquationPool = __webpack_require__(/*! ../utils/FrictionEquationPool */ \"./node_modules/p2/src/utils/FrictionEquationPool.js\")\n,   TupleDictionary = __webpack_require__(/*! ../utils/TupleDictionary */ \"./node_modules/p2/src/utils/TupleDictionary.js\")\n,   Equation = __webpack_require__(/*! ../equations/Equation */ \"./node_modules/p2/src/equations/Equation.js\")\n,   ContactEquation = __webpack_require__(/*! ../equations/ContactEquation */ \"./node_modules/p2/src/equations/ContactEquation.js\")\n,   FrictionEquation = __webpack_require__(/*! ../equations/FrictionEquation */ \"./node_modules/p2/src/equations/FrictionEquation.js\")\n,   Circle = __webpack_require__(/*! ../shapes/Circle */ \"./node_modules/p2/src/shapes/Circle.js\")\n,   Convex = __webpack_require__(/*! ../shapes/Convex */ \"./node_modules/p2/src/shapes/Convex.js\")\n,   Shape = __webpack_require__(/*! ../shapes/Shape */ \"./node_modules/p2/src/shapes/Shape.js\")\n,   Body = __webpack_require__(/*! ../objects/Body */ \"./node_modules/p2/src/objects/Body.js\")\n,   Box = __webpack_require__(/*! ../shapes/Box */ \"./node_modules/p2/src/shapes/Box.js\");\n\nmodule.exports = Narrowphase;\n\n// Temp things\nvar yAxis = vec2.fromValues(0,1);\n\nvar tmp1 = vec2.fromValues(0,0)\n,   tmp2 = vec2.fromValues(0,0)\n,   tmp3 = vec2.fromValues(0,0)\n,   tmp4 = vec2.fromValues(0,0)\n,   tmp5 = vec2.fromValues(0,0)\n,   tmp6 = vec2.fromValues(0,0)\n,   tmp7 = vec2.fromValues(0,0)\n,   tmp8 = vec2.fromValues(0,0)\n,   tmp9 = vec2.fromValues(0,0)\n,   tmp10 = vec2.fromValues(0,0)\n,   tmp11 = vec2.fromValues(0,0)\n,   tmp12 = vec2.fromValues(0,0)\n,   tmp13 = vec2.fromValues(0,0)\n,   tmp14 = vec2.fromValues(0,0)\n,   tmp15 = vec2.fromValues(0,0)\n,   tmp16 = vec2.fromValues(0,0)\n,   tmp17 = vec2.fromValues(0,0)\n,   tmp18 = vec2.fromValues(0,0)\n,   tmpArray = [];\n\n/**\n * Narrowphase. Creates contacts and friction given shapes and transforms.\n * @class Narrowphase\n * @constructor\n */\nfunction Narrowphase(){\n\n    /**\n     * @property contactEquations\n     * @type {Array}\n     */\n    this.contactEquations = [];\n\n    /**\n     * @property frictionEquations\n     * @type {Array}\n     */\n    this.frictionEquations = [];\n\n    /**\n     * Whether to make friction equations in the upcoming contacts.\n     * @property enableFriction\n     * @type {Boolean}\n     */\n    this.enableFriction = true;\n\n    /**\n     * Whether to make equations enabled in upcoming contacts.\n     * @property enabledEquations\n     * @type {Boolean}\n     */\n    this.enabledEquations = true;\n\n    /**\n     * The friction slip force to use when creating friction equations.\n     * @property slipForce\n     * @type {Number}\n     */\n    this.slipForce = 10.0;\n\n    /**\n     * The friction value to use in the upcoming friction equations.\n     * @property frictionCoefficient\n     * @type {Number}\n     */\n    this.frictionCoefficient = 0.3;\n\n    /**\n     * Will be the .relativeVelocity in each produced FrictionEquation.\n     * @property {Number} surfaceVelocity\n     */\n    this.surfaceVelocity = 0;\n\n    /**\n     * Keeps track of the allocated ContactEquations.\n     * @property {ContactEquationPool} contactEquationPool\n     *\n     * @example\n     *\n     *     // Allocate a few equations before starting the simulation.\n     *     // This way, no contact objects need to be created on the fly in the game loop.\n     *     world.narrowphase.contactEquationPool.resize(1024);\n     *     world.narrowphase.frictionEquationPool.resize(1024);\n     */\n    this.contactEquationPool = new ContactEquationPool({ size: 32 });\n\n    /**\n     * Keeps track of the allocated ContactEquations.\n     * @property {FrictionEquationPool} frictionEquationPool\n     */\n    this.frictionEquationPool = new FrictionEquationPool({ size: 64 });\n\n    /**\n     * The restitution value to use in the next contact equations.\n     * @property restitution\n     * @type {Number}\n     */\n    this.restitution = 0;\n\n    /**\n     * The stiffness value to use in the next contact equations.\n     * @property {Number} stiffness\n     */\n    this.stiffness = Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * The stiffness value to use in the next contact equations.\n     * @property {Number} stiffness\n     */\n    this.relaxation = Equation.DEFAULT_RELAXATION;\n\n    /**\n     * The stiffness value to use in the next friction equations.\n     * @property frictionStiffness\n     * @type {Number}\n     */\n    this.frictionStiffness = Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * The relaxation value to use in the next friction equations.\n     * @property frictionRelaxation\n     * @type {Number}\n     */\n    this.frictionRelaxation = Equation.DEFAULT_RELAXATION;\n\n    /**\n     * Enable reduction of friction equations. If disabled, a box on a plane will generate 2 contact equations and 2 friction equations. If enabled, there will be only one friction equation. Same kind of simplifications are made  for all collision types.\n     * @property enableFrictionReduction\n     * @type {Boolean}\n     * @deprecated This flag will be removed when the feature is stable enough.\n     * @default true\n     */\n    this.enableFrictionReduction = true;\n\n    /**\n     * Keeps track of the colliding bodies last step.\n     * @private\n     * @property collidingBodiesLastStep\n     * @type {TupleDictionary}\n     */\n    this.collidingBodiesLastStep = new TupleDictionary();\n\n    /**\n     * Contact skin size value to use in the next contact equations.\n     * @property {Number} contactSkinSize\n     * @default 0.01\n     */\n    this.contactSkinSize = 0.01;\n}\n\nvar bodiesOverlap_shapePositionA = vec2.create();\nvar bodiesOverlap_shapePositionB = vec2.create();\n\n/**\n * @method bodiesOverlap\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n * @todo shape world transforms are wrong\n */\nNarrowphase.prototype.bodiesOverlap = function(bodyA, bodyB){\n    var shapePositionA = bodiesOverlap_shapePositionA;\n    var shapePositionB = bodiesOverlap_shapePositionB;\n\n    // Loop over all shapes of bodyA\n    for(var k=0, Nshapesi=bodyA.shapes.length; k!==Nshapesi; k++){\n        var shapeA = bodyA.shapes[k];\n\n        bodyA.toWorldFrame(shapePositionA, shapeA.position);\n\n        // All shapes of body j\n        for(var l=0, Nshapesj=bodyB.shapes.length; l!==Nshapesj; l++){\n            var shapeB = bodyB.shapes[l];\n\n            bodyB.toWorldFrame(shapePositionB, shapeB.position);\n\n            if(this[shapeA.type | shapeB.type](\n                bodyA,\n                shapeA,\n                shapePositionA,\n                shapeA.angle + bodyA.angle,\n                bodyB,\n                shapeB,\n                shapePositionB,\n                shapeB.angle + bodyB.angle,\n                true\n            )){\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Check if the bodies were in contact since the last reset().\n * @method collidedLastStep\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nNarrowphase.prototype.collidedLastStep = function(bodyA, bodyB){\n    var id1 = bodyA.id|0,\n        id2 = bodyB.id|0;\n    return !!this.collidingBodiesLastStep.get(id1, id2);\n};\n\n/**\n * Throws away the old equations and gets ready to create new\n * @method reset\n */\nNarrowphase.prototype.reset = function(){\n    this.collidingBodiesLastStep.reset();\n\n    var eqs = this.contactEquations;\n    var l = eqs.length;\n    while(l--){\n        var eq = eqs[l],\n            id1 = eq.bodyA.id,\n            id2 = eq.bodyB.id;\n        this.collidingBodiesLastStep.set(id1, id2, true);\n    }\n\n    var ce = this.contactEquations,\n        fe = this.frictionEquations;\n    for(var i=0; i<ce.length; i++){\n        this.contactEquationPool.release(ce[i]);\n    }\n    for(var i=0; i<fe.length; i++){\n        this.frictionEquationPool.release(fe[i]);\n    }\n\n    // Reset\n    this.contactEquations.length = this.frictionEquations.length = 0;\n};\n\n/**\n * Creates a ContactEquation, either by reusing an existing object or creating a new one.\n * @method createContactEquation\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {ContactEquation}\n */\nNarrowphase.prototype.createContactEquation = function(bodyA, bodyB, shapeA, shapeB){\n    var c = this.contactEquationPool.get();\n    c.bodyA = bodyA;\n    c.bodyB = bodyB;\n    c.shapeA = shapeA;\n    c.shapeB = shapeB;\n    c.restitution = this.restitution;\n    c.firstImpact = !this.collidedLastStep(bodyA,bodyB);\n    c.stiffness = this.stiffness;\n    c.relaxation = this.relaxation;\n    c.needsUpdate = true;\n    c.enabled = this.enabledEquations;\n    c.offset = this.contactSkinSize;\n\n    return c;\n};\n\n/**\n * Creates a FrictionEquation, either by reusing an existing object or creating a new one.\n * @method createFrictionEquation\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {FrictionEquation}\n */\nNarrowphase.prototype.createFrictionEquation = function(bodyA, bodyB, shapeA, shapeB){\n    var c = this.frictionEquationPool.get();\n    c.bodyA = bodyA;\n    c.bodyB = bodyB;\n    c.shapeA = shapeA;\n    c.shapeB = shapeB;\n    c.setSlipForce(this.slipForce);\n    c.frictionCoefficient = this.frictionCoefficient;\n    c.relativeVelocity = this.surfaceVelocity;\n    c.enabled = this.enabledEquations;\n    c.needsUpdate = true;\n    c.stiffness = this.frictionStiffness;\n    c.relaxation = this.frictionRelaxation;\n    c.contactEquations.length = 0;\n    return c;\n};\n\n/**\n * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.\n * @method createFrictionFromContact\n * @param  {ContactEquation} contactEquation\n * @return {FrictionEquation}\n */\nNarrowphase.prototype.createFrictionFromContact = function(c){\n    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);\n    vec2.copy(eq.contactPointA, c.contactPointA);\n    vec2.copy(eq.contactPointB, c.contactPointB);\n    vec2.rotate90cw(eq.t, c.normalA);\n    eq.contactEquations.push(c);\n    return eq;\n};\n\n// Take the average N latest contact point on the plane.\nNarrowphase.prototype.createFrictionFromAverage = function(numContacts){\n    var c = this.contactEquations[this.contactEquations.length - 1];\n    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);\n    var bodyA = c.bodyA;\n    var bodyB = c.bodyB;\n    vec2.set(eq.contactPointA, 0, 0);\n    vec2.set(eq.contactPointB, 0, 0);\n    vec2.set(eq.t, 0, 0);\n    for(var i=0; i!==numContacts; i++){\n        c = this.contactEquations[this.contactEquations.length - 1 - i];\n        if(c.bodyA === bodyA){\n            vec2.add(eq.t, eq.t, c.normalA);\n            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);\n            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointB);\n        } else {\n            vec2.sub(eq.t, eq.t, c.normalA);\n            vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointB);\n            vec2.add(eq.contactPointB, eq.contactPointB, c.contactPointA);\n        }\n        eq.contactEquations.push(c);\n    }\n\n    var invNumContacts = 1/numContacts;\n    vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);\n    vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);\n    vec2.normalize(eq.t, eq.t);\n    vec2.rotate90cw(eq.t, eq.t);\n    return eq;\n};\n\n/**\n * Convex/line narrowphase\n * @method convexLine\n * @param  {Body}       convexBody\n * @param  {Convex}     convexShape\n * @param  {Array}      convexOffset\n * @param  {Number}     convexAngle\n * @param  {Body}       lineBody\n * @param  {Line}       lineShape\n * @param  {Array}      lineOffset\n * @param  {Number}     lineAngle\n * @param {boolean}     justTest\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.LINE | Shape.CONVEX] =\nNarrowphase.prototype.convexLine = function(\n    convexBody,\n    convexShape,\n    convexOffset,\n    convexAngle,\n    lineBody,\n    lineShape,\n    lineOffset,\n    lineAngle,\n    justTest\n){\n    // TODO\n    if(justTest){\n        return false;\n    } else {\n        return 0;\n    }\n};\n\n/**\n * Line/box narrowphase\n * @method lineBox\n * @param  {Body}       lineBody\n * @param  {Line}       lineShape\n * @param  {Array}      lineOffset\n * @param  {Number}     lineAngle\n * @param  {Body}       boxBody\n * @param  {Box}  boxShape\n * @param  {Array}      boxOffset\n * @param  {Number}     boxAngle\n * @param  {Boolean}    justTest\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.LINE | Shape.BOX] =\nNarrowphase.prototype.lineBox = function(\n    lineBody,\n    lineShape,\n    lineOffset,\n    lineAngle,\n    boxBody,\n    boxShape,\n    boxOffset,\n    boxAngle,\n    justTest\n){\n    // TODO\n    if(justTest){\n        return false;\n    } else {\n        return 0;\n    }\n};\n\nfunction setConvexToCapsuleShapeMiddle(convexShape, capsuleShape){\n    vec2.set(convexShape.vertices[0], -capsuleShape.length * 0.5, -capsuleShape.radius);\n    vec2.set(convexShape.vertices[1],  capsuleShape.length * 0.5, -capsuleShape.radius);\n    vec2.set(convexShape.vertices[2],  capsuleShape.length * 0.5,  capsuleShape.radius);\n    vec2.set(convexShape.vertices[3], -capsuleShape.length * 0.5,  capsuleShape.radius);\n}\n\nvar convexCapsule_tempRect = new Box({ width: 1, height: 1 }),\n    convexCapsule_tempVec = vec2.create();\n\n/**\n * Convex/capsule narrowphase\n * @method convexCapsule\n * @param  {Body}       convexBody\n * @param  {Convex}     convexShape\n * @param  {Array}      convexPosition\n * @param  {Number}     convexAngle\n * @param  {Body}       capsuleBody\n * @param  {Capsule}    capsuleShape\n * @param  {Array}      capsulePosition\n * @param  {Number}     capsuleAngle\n */\nNarrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] =\nNarrowphase.prototype[Shape.CAPSULE | Shape.BOX] =\nNarrowphase.prototype.convexCapsule = function(\n    convexBody,\n    convexShape,\n    convexPosition,\n    convexAngle,\n    capsuleBody,\n    capsuleShape,\n    capsulePosition,\n    capsuleAngle,\n    justTest\n){\n\n    // Check the circles\n    // Add offsets!\n    var circlePos = convexCapsule_tempVec;\n    vec2.set(circlePos, capsuleShape.length/2,0);\n    vec2.rotate(circlePos,circlePos,capsuleAngle);\n    vec2.add(circlePos,circlePos,capsulePosition);\n    var result1 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);\n\n    vec2.set(circlePos,-capsuleShape.length/2, 0);\n    vec2.rotate(circlePos,circlePos,capsuleAngle);\n    vec2.add(circlePos,circlePos,capsulePosition);\n    var result2 = this.circleConvex(capsuleBody,capsuleShape,circlePos,capsuleAngle, convexBody,convexShape,convexPosition,convexAngle, justTest, capsuleShape.radius);\n\n    if(justTest && (result1 || result2)){\n        return true;\n    }\n\n    // Check center rect\n    var r = convexCapsule_tempRect;\n    setConvexToCapsuleShapeMiddle(r,capsuleShape);\n    var result = this.convexConvex(convexBody,convexShape,convexPosition,convexAngle, capsuleBody,r,capsulePosition,capsuleAngle, justTest);\n\n    return result + result1 + result2;\n};\n\n/**\n * Capsule/line narrowphase\n * @method lineCapsule\n * @param  {Body}       lineBody\n * @param  {Line}       lineShape\n * @param  {Array}      linePosition\n * @param  {Number}     lineAngle\n * @param  {Body}       capsuleBody\n * @param  {Capsule}    capsuleShape\n * @param  {Array}      capsulePosition\n * @param  {Number}     capsuleAngle\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.CAPSULE | Shape.LINE] =\nNarrowphase.prototype.lineCapsule = function(\n    lineBody,\n    lineShape,\n    linePosition,\n    lineAngle,\n    capsuleBody,\n    capsuleShape,\n    capsulePosition,\n    capsuleAngle,\n    justTest\n){\n    // TODO\n    if(justTest){\n        return false;\n    } else {\n        return 0;\n    }\n};\n\nvar capsuleCapsule_tempVec1 = vec2.create();\nvar capsuleCapsule_tempVec2 = vec2.create();\nvar capsuleCapsule_tempRect1 = new Box({ width: 1, height: 1 });\n\n/**\n * Capsule/capsule narrowphase\n * @method capsuleCapsule\n * @param  {Body}       bi\n * @param  {Capsule}    si\n * @param  {Array}      xi\n * @param  {Number}     ai\n * @param  {Body}       bj\n * @param  {Capsule}    sj\n * @param  {Array}      xj\n * @param  {Number}     aj\n */\nNarrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] =\nNarrowphase.prototype.capsuleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){\n\n    var enableFrictionBefore;\n\n    // Check the circles\n    // Add offsets!\n    var circlePosi = capsuleCapsule_tempVec1,\n        circlePosj = capsuleCapsule_tempVec2;\n\n    var numContacts = 0;\n\n\n    // Need 4 circle checks, between all\n    for(var i=0; i<2; i++){\n\n        vec2.set(circlePosi,(i===0?-1:1)*si.length/2,0);\n        vec2.rotate(circlePosi,circlePosi,ai);\n        vec2.add(circlePosi,circlePosi,xi);\n\n        for(var j=0; j<2; j++){\n\n            vec2.set(circlePosj,(j===0?-1:1)*sj.length/2, 0);\n            vec2.rotate(circlePosj,circlePosj,aj);\n            vec2.add(circlePosj,circlePosj,xj);\n\n            // Temporarily turn off friction\n            if(this.enableFrictionReduction){\n                enableFrictionBefore = this.enableFriction;\n                this.enableFriction = false;\n            }\n\n            var result = this.circleCircle(bi,si,circlePosi,ai, bj,sj,circlePosj,aj, justTest, si.radius, sj.radius);\n\n            if(this.enableFrictionReduction){\n                this.enableFriction = enableFrictionBefore;\n            }\n\n            if(justTest && result){\n                return true;\n            }\n\n            numContacts += result;\n        }\n    }\n\n    if(this.enableFrictionReduction){\n        // Temporarily turn off friction\n        enableFrictionBefore = this.enableFriction;\n        this.enableFriction = false;\n    }\n\n    // Check circles against the center boxs\n    var rect = capsuleCapsule_tempRect1;\n    setConvexToCapsuleShapeMiddle(rect,si);\n    var result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);\n\n    if(this.enableFrictionReduction){\n        this.enableFriction = enableFrictionBefore;\n    }\n\n    if(justTest && result1){\n        return true;\n    }\n    numContacts += result1;\n\n    if(this.enableFrictionReduction){\n        // Temporarily turn off friction\n        var enableFrictionBefore = this.enableFriction;\n        this.enableFriction = false;\n    }\n\n    setConvexToCapsuleShapeMiddle(rect,sj);\n    var result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);\n\n    if(this.enableFrictionReduction){\n        this.enableFriction = enableFrictionBefore;\n    }\n\n    if(justTest && result2){\n        return true;\n    }\n    numContacts += result2;\n\n    if(this.enableFrictionReduction){\n        if(numContacts && this.enableFriction){\n            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));\n        }\n    }\n\n    return numContacts;\n};\n\n/**\n * Line/line narrowphase\n * @method lineLine\n * @param  {Body}       bodyA\n * @param  {Line}       shapeA\n * @param  {Array}      positionA\n * @param  {Number}     angleA\n * @param  {Body}       bodyB\n * @param  {Line}       shapeB\n * @param  {Array}      positionB\n * @param  {Number}     angleB\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.LINE | Shape.LINE] =\nNarrowphase.prototype.lineLine = function(\n    bodyA,\n    shapeA,\n    positionA,\n    angleA,\n    bodyB,\n    shapeB,\n    positionB,\n    angleB,\n    justTest\n){\n    // TODO\n    if(justTest){\n        return false;\n    } else {\n        return 0;\n    }\n};\n\n/**\n * Plane/line Narrowphase\n * @method planeLine\n * @param  {Body}   planeBody\n * @param  {Plane}  planeShape\n * @param  {Array}  planeOffset\n * @param  {Number} planeAngle\n * @param  {Body}   lineBody\n * @param  {Line}   lineShape\n * @param  {Array}  lineOffset\n * @param  {Number} lineAngle\n */\nNarrowphase.prototype[Shape.PLANE | Shape.LINE] =\nNarrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle,\n                                           lineBody,  lineShape,  lineOffset,  lineAngle, justTest){\n    var worldVertex0 = tmp1,\n        worldVertex1 = tmp2,\n        worldVertex01 = tmp3,\n        worldVertex11 = tmp4,\n        worldEdge = tmp5,\n        worldEdgeUnit = tmp6,\n        dist = tmp7,\n        worldNormal = tmp8,\n        worldTangent = tmp9,\n        verts = tmpArray,\n        numContacts = 0;\n\n    // Get start and end points\n    vec2.set(worldVertex0, -lineShape.length/2, 0);\n    vec2.set(worldVertex1,  lineShape.length/2, 0);\n\n    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.\n    vec2.rotate(worldVertex01, worldVertex0, lineAngle);\n    vec2.rotate(worldVertex11, worldVertex1, lineAngle);\n\n    add(worldVertex01, worldVertex01, lineOffset);\n    add(worldVertex11, worldVertex11, lineOffset);\n\n    vec2.copy(worldVertex0,worldVertex01);\n    vec2.copy(worldVertex1,worldVertex11);\n\n    // Get vector along the line\n    sub(worldEdge, worldVertex1, worldVertex0);\n    vec2.normalize(worldEdgeUnit, worldEdge);\n\n    // Get tangent to the edge.\n    vec2.rotate90cw(worldTangent, worldEdgeUnit);\n\n    vec2.rotate(worldNormal, yAxis, planeAngle);\n\n    // Check line ends\n    verts[0] = worldVertex0;\n    verts[1] = worldVertex1;\n    for(var i=0; i<verts.length; i++){\n        var v = verts[i];\n\n        sub(dist, v, planeOffset);\n\n        var d = dot(dist,worldNormal);\n\n        if(d < 0){\n\n            if(justTest){\n                return true;\n            }\n\n            var c = this.createContactEquation(planeBody,lineBody,planeShape,lineShape);\n            numContacts++;\n\n            vec2.copy(c.normalA, worldNormal);\n            vec2.normalize(c.normalA,c.normalA);\n\n            // distance vector along plane normal\n            vec2.scale(dist, worldNormal, d);\n\n            // Vector from plane center to contact\n            sub(c.contactPointA, v, dist);\n            sub(c.contactPointA, c.contactPointA, planeBody.position);\n\n            // From line center to contact\n            sub(c.contactPointB, v,    lineOffset);\n            add(c.contactPointB, c.contactPointB, lineOffset);\n            sub(c.contactPointB, c.contactPointB, lineBody.position);\n\n            this.contactEquations.push(c);\n\n            if(!this.enableFrictionReduction){\n                if(this.enableFriction){\n                    this.frictionEquations.push(this.createFrictionFromContact(c));\n                }\n            }\n        }\n    }\n\n    if(justTest){\n        return false;\n    }\n\n    if(!this.enableFrictionReduction){\n        if(numContacts && this.enableFriction){\n            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));\n        }\n    }\n\n    return numContacts;\n};\n\nNarrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =\nNarrowphase.prototype.particleCapsule = function(\n    particleBody,\n    particleShape,\n    particlePosition,\n    particleAngle,\n    capsuleBody,\n    capsuleShape,\n    capsulePosition,\n    capsuleAngle,\n    justTest\n){\n    return this.circleLine(particleBody,particleShape,particlePosition,particleAngle, capsuleBody,capsuleShape,capsulePosition,capsuleAngle, justTest, capsuleShape.radius, 0);\n};\n\n/**\n * Circle/line Narrowphase\n * @method circleLine\n * @param  {Body} circleBody\n * @param  {Circle} circleShape\n * @param  {Array} circleOffset\n * @param  {Number} circleAngle\n * @param  {Body} lineBody\n * @param  {Line} lineShape\n * @param  {Array} lineOffset\n * @param  {Number} lineAngle\n * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.\n * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.\n * @param {Number} circleRadius If set, this value overrides the circle shape radius.\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.LINE] =\nNarrowphase.prototype.circleLine = function(\n    circleBody,\n    circleShape,\n    circleOffset,\n    circleAngle,\n    lineBody,\n    lineShape,\n    lineOffset,\n    lineAngle,\n    justTest,\n    lineRadius,\n    circleRadius\n){\n    var lineRadius = lineRadius || 0,\n        circleRadius = typeof(circleRadius)!==\"undefined\" ? circleRadius : circleShape.radius,\n\n        orthoDist = tmp1,\n        lineToCircleOrthoUnit = tmp2,\n        projectedPoint = tmp3,\n        centerDist = tmp4,\n        worldTangent = tmp5,\n        worldEdge = tmp6,\n        worldEdgeUnit = tmp7,\n        worldVertex0 = tmp8,\n        worldVertex1 = tmp9,\n        worldVertex01 = tmp10,\n        worldVertex11 = tmp11,\n        dist = tmp12,\n        lineToCircle = tmp13,\n        lineEndToLineRadius = tmp14,\n\n        verts = tmpArray;\n\n    // Get start and end points\n    vec2.set(worldVertex0, -lineShape.length/2, 0);\n    vec2.set(worldVertex1,  lineShape.length/2, 0);\n\n    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.\n    vec2.rotate(worldVertex01, worldVertex0, lineAngle);\n    vec2.rotate(worldVertex11, worldVertex1, lineAngle);\n\n    add(worldVertex01, worldVertex01, lineOffset);\n    add(worldVertex11, worldVertex11, lineOffset);\n\n    vec2.copy(worldVertex0,worldVertex01);\n    vec2.copy(worldVertex1,worldVertex11);\n\n    // Get vector along the line\n    sub(worldEdge, worldVertex1, worldVertex0);\n    vec2.normalize(worldEdgeUnit, worldEdge);\n\n    // Get tangent to the edge.\n    vec2.rotate90cw(worldTangent, worldEdgeUnit);\n\n    // Check distance from the plane spanned by the edge vs the circle\n    sub(dist, circleOffset, worldVertex0);\n    var d = dot(dist, worldTangent); // Distance from center of line to circle center\n    sub(centerDist, worldVertex0, lineOffset);\n\n    sub(lineToCircle, circleOffset, lineOffset);\n\n    var radiusSum = circleRadius + lineRadius;\n\n    if(Math.abs(d) < radiusSum){\n\n        // Now project the circle onto the edge\n        vec2.scale(orthoDist, worldTangent, d);\n        sub(projectedPoint, circleOffset, orthoDist);\n\n        // Add the missing line radius\n        vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));\n        vec2.normalize(lineToCircleOrthoUnit,lineToCircleOrthoUnit);\n        vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);\n        add(projectedPoint,projectedPoint,lineToCircleOrthoUnit);\n\n        // Check if the point is within the edge span\n        var pos =  dot(worldEdgeUnit, projectedPoint);\n        var pos0 = dot(worldEdgeUnit, worldVertex0);\n        var pos1 = dot(worldEdgeUnit, worldVertex1);\n\n        if(pos > pos0 && pos < pos1){\n            // We got contact!\n\n            if(justTest){\n                return true;\n            }\n\n            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);\n\n            vec2.scale(c.normalA, orthoDist, -1);\n            vec2.normalize(c.normalA, c.normalA);\n\n            vec2.scale( c.contactPointA, c.normalA,  circleRadius);\n            add(c.contactPointA, c.contactPointA, circleOffset);\n            sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n            sub(c.contactPointB, projectedPoint, lineOffset);\n            add(c.contactPointB, c.contactPointB, lineOffset);\n            sub(c.contactPointB, c.contactPointB, lineBody.position);\n\n            this.contactEquations.push(c);\n\n            if(this.enableFriction){\n                this.frictionEquations.push(this.createFrictionFromContact(c));\n            }\n\n            return 1;\n        }\n    }\n\n    // Add corner\n    verts[0] = worldVertex0;\n    verts[1] = worldVertex1;\n\n    for(var i=0; i<verts.length; i++){\n        var v = verts[i];\n\n        sub(dist, v, circleOffset);\n\n        if(vec2.squaredLength(dist) < Math.pow(radiusSum, 2)){\n\n            if(justTest){\n                return true;\n            }\n\n            var c = this.createContactEquation(circleBody,lineBody,circleShape,lineShape);\n\n            vec2.copy(c.normalA, dist);\n            vec2.normalize(c.normalA,c.normalA);\n\n            // Vector from circle to contact point is the normal times the circle radius\n            vec2.scale(c.contactPointA, c.normalA, circleRadius);\n            add(c.contactPointA, c.contactPointA, circleOffset);\n            sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n            sub(c.contactPointB, v, lineOffset);\n            vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);\n            add(c.contactPointB, c.contactPointB, lineEndToLineRadius);\n            add(c.contactPointB, c.contactPointB, lineOffset);\n            sub(c.contactPointB, c.contactPointB, lineBody.position);\n\n            this.contactEquations.push(c);\n\n            if(this.enableFriction){\n                this.frictionEquations.push(this.createFrictionFromContact(c));\n            }\n\n            return 1;\n        }\n    }\n\n    return 0;\n};\n\n/**\n * Circle/capsule Narrowphase\n * @method circleCapsule\n * @param  {Body}   bi\n * @param  {Circle} si\n * @param  {Array}  xi\n * @param  {Number} ai\n * @param  {Body}   bj\n * @param  {Line}   sj\n * @param  {Array}  xj\n * @param  {Number} aj\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =\nNarrowphase.prototype.circleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){\n    return this.circleLine(bi,si,xi,ai, bj,sj,xj,aj, justTest, sj.radius);\n};\n\n/**\n * Circle/convex Narrowphase.\n * @method circleConvex\n * @param  {Body} circleBody\n * @param  {Circle} circleShape\n * @param  {Array} circleOffset\n * @param  {Number} circleAngle\n * @param  {Body} convexBody\n * @param  {Convex} convexShape\n * @param  {Array} convexOffset\n * @param  {Number} convexAngle\n * @param  {Boolean} justTest\n * @param  {Number} circleRadius\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =\nNarrowphase.prototype[Shape.CIRCLE | Shape.BOX] =\nNarrowphase.prototype.circleConvex = function(\n    circleBody,\n    circleShape,\n    circleOffset,\n    circleAngle,\n    convexBody,\n    convexShape,\n    convexOffset,\n    convexAngle,\n    justTest,\n    circleRadius\n){\n    var circleRadius = typeof(circleRadius)===\"number\" ? circleRadius : circleShape.radius;\n\n    var worldVertex0 = tmp1,\n        worldVertex1 = tmp2,\n        worldEdge = tmp3,\n        worldEdgeUnit = tmp4,\n        worldNormal = tmp5,\n        centerDist = tmp6,\n        convexToCircle = tmp7,\n        orthoDist = tmp8,\n        projectedPoint = tmp9,\n        dist = tmp10,\n        worldVertex = tmp11,\n\n        closestEdge = -1,\n        closestEdgeDistance = null,\n        closestEdgeOrthoDist = tmp12,\n        closestEdgeProjectedPoint = tmp13,\n        candidate = tmp14,\n        candidateDist = tmp15,\n        minCandidate = tmp16,\n\n        found = false,\n        minCandidateDistance = Number.MAX_VALUE;\n\n    var numReported = 0;\n\n    // New algorithm:\n    // 1. Check so center of circle is not inside the polygon. If it is, this wont work...\n    // 2. For each edge\n    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)\n    // 2. 2. Check if point is inside.\n\n    var verts = convexShape.vertices;\n\n    // Check all edges first\n    for(var i=0; i!==verts.length+1; i++){\n        var v0 = verts[i%verts.length],\n            v1 = verts[(i+1)%verts.length];\n\n        vec2.rotate(worldVertex0, v0, convexAngle);\n        vec2.rotate(worldVertex1, v1, convexAngle);\n        add(worldVertex0, worldVertex0, convexOffset);\n        add(worldVertex1, worldVertex1, convexOffset);\n        sub(worldEdge, worldVertex1, worldVertex0);\n\n        vec2.normalize(worldEdgeUnit, worldEdge);\n\n        // Get tangent to the edge. Points out of the Convex\n        vec2.rotate90cw(worldNormal, worldEdgeUnit);\n\n        // Get point on circle, closest to the polygon\n        vec2.scale(candidate,worldNormal,-circleShape.radius);\n        add(candidate,candidate,circleOffset);\n\n        if(pointInConvex(candidate,convexShape,convexOffset,convexAngle)){\n\n            vec2.sub(candidateDist,worldVertex0,candidate);\n            var candidateDistance = Math.abs(vec2.dot(candidateDist,worldNormal));\n\n            if(candidateDistance < minCandidateDistance){\n                vec2.copy(minCandidate,candidate);\n                minCandidateDistance = candidateDistance;\n                vec2.scale(closestEdgeProjectedPoint,worldNormal,candidateDistance);\n                vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,candidate);\n                found = true;\n            }\n        }\n    }\n\n    if(found){\n\n        if(justTest){\n            return true;\n        }\n\n        var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);\n        vec2.sub(c.normalA, minCandidate, circleOffset);\n        vec2.normalize(c.normalA, c.normalA);\n\n        vec2.scale(c.contactPointA,  c.normalA, circleRadius);\n        add(c.contactPointA, c.contactPointA, circleOffset);\n        sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);\n        add(c.contactPointB, c.contactPointB, convexOffset);\n        sub(c.contactPointB, c.contactPointB, convexBody.position);\n\n        this.contactEquations.push(c);\n\n        if(this.enableFriction){\n            this.frictionEquations.push( this.createFrictionFromContact(c) );\n        }\n\n        return 1;\n    }\n\n    // Check all vertices\n    if(circleRadius > 0){\n        for(var i=0; i<verts.length; i++){\n            var localVertex = verts[i];\n            vec2.rotate(worldVertex, localVertex, convexAngle);\n            add(worldVertex, worldVertex, convexOffset);\n\n            sub(dist, worldVertex, circleOffset);\n            if(vec2.squaredLength(dist) < Math.pow(circleRadius, 2)){\n\n                if(justTest){\n                    return true;\n                }\n\n                var c = this.createContactEquation(circleBody,convexBody,circleShape,convexShape);\n\n                vec2.copy(c.normalA, dist);\n                vec2.normalize(c.normalA,c.normalA);\n\n                // Vector from circle to contact point is the normal times the circle radius\n                vec2.scale(c.contactPointA, c.normalA, circleRadius);\n                add(c.contactPointA, c.contactPointA, circleOffset);\n                sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n                sub(c.contactPointB, worldVertex, convexOffset);\n                add(c.contactPointB, c.contactPointB, convexOffset);\n                sub(c.contactPointB, c.contactPointB, convexBody.position);\n\n                this.contactEquations.push(c);\n\n                if(this.enableFriction){\n                    this.frictionEquations.push(this.createFrictionFromContact(c));\n                }\n\n                return 1;\n            }\n        }\n    }\n\n    return 0;\n};\n\nvar pic_worldVertex0 = vec2.create(),\n    pic_worldVertex1 = vec2.create(),\n    pic_r0 = vec2.create(),\n    pic_r1 = vec2.create();\n\n/*\n * Check if a point is in a polygon\n */\nfunction pointInConvex(worldPoint,convexShape,convexOffset,convexAngle){\n    var worldVertex0 = pic_worldVertex0,\n        worldVertex1 = pic_worldVertex1,\n        r0 = pic_r0,\n        r1 = pic_r1,\n        point = worldPoint,\n        verts = convexShape.vertices,\n        lastCross = null;\n    for(var i=0; i!==verts.length+1; i++){\n        var v0 = verts[i%verts.length],\n            v1 = verts[(i+1)%verts.length];\n\n        // Transform vertices to world\n        // @todo The point should be transformed to local coordinates in the convex, no need to transform each vertex\n        vec2.rotate(worldVertex0, v0, convexAngle);\n        vec2.rotate(worldVertex1, v1, convexAngle);\n        add(worldVertex0, worldVertex0, convexOffset);\n        add(worldVertex1, worldVertex1, convexOffset);\n\n        sub(r0, worldVertex0, point);\n        sub(r1, worldVertex1, point);\n        var cross = vec2.crossLength(r0,r1);\n\n        if(lastCross===null){\n            lastCross = cross;\n        }\n\n        // If we got a different sign of the distance vector, the point is out of the polygon\n        if(cross*lastCross <= 0){\n            return false;\n        }\n        lastCross = cross;\n    }\n    return true;\n}\n\n/**\n * Particle/convex Narrowphase\n * @method particleConvex\n * @param  {Body} particleBody\n * @param  {Particle} particleShape\n * @param  {Array} particleOffset\n * @param  {Number} particleAngle\n * @param  {Body} convexBody\n * @param  {Convex} convexShape\n * @param  {Array} convexOffset\n * @param  {Number} convexAngle\n * @param {Boolean} justTest\n * @todo use pointInConvex and code more similar to circleConvex\n * @todo don't transform each vertex, but transform the particle position to convex-local instead\n */\nNarrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =\nNarrowphase.prototype[Shape.PARTICLE | Shape.BOX] =\nNarrowphase.prototype.particleConvex = function(\n    particleBody,\n    particleShape,\n    particleOffset,\n    particleAngle,\n    convexBody,\n    convexShape,\n    convexOffset,\n    convexAngle,\n    justTest\n){\n    var worldVertex0 = tmp1,\n        worldVertex1 = tmp2,\n        worldEdge = tmp3,\n        worldEdgeUnit = tmp4,\n        worldTangent = tmp5,\n        centerDist = tmp6,\n        convexToparticle = tmp7,\n        orthoDist = tmp8,\n        projectedPoint = tmp9,\n        dist = tmp10,\n        worldVertex = tmp11,\n        closestEdge = -1,\n        closestEdgeDistance = null,\n        closestEdgeOrthoDist = tmp12,\n        closestEdgeProjectedPoint = tmp13,\n        r0 = tmp14, // vector from particle to vertex0\n        r1 = tmp15,\n        localPoint = tmp16,\n        candidateDist = tmp17,\n        minEdgeNormal = tmp18,\n        minCandidateDistance = Number.MAX_VALUE;\n\n    var numReported = 0,\n        found = false,\n        verts = convexShape.vertices;\n\n    // Check if the particle is in the polygon at all\n    if(!pointInConvex(particleOffset,convexShape,convexOffset,convexAngle)){\n        return 0;\n    }\n\n    if(justTest){\n        return true;\n    }\n\n    // Check edges first\n    var lastCross = null;\n    for(var i=0; i!==verts.length+1; i++){\n        var v0 = verts[i%verts.length],\n            v1 = verts[(i+1)%verts.length];\n\n        // Transform vertices to world\n        vec2.rotate(worldVertex0, v0, convexAngle);\n        vec2.rotate(worldVertex1, v1, convexAngle);\n        add(worldVertex0, worldVertex0, convexOffset);\n        add(worldVertex1, worldVertex1, convexOffset);\n\n        // Get world edge\n        sub(worldEdge, worldVertex1, worldVertex0);\n        vec2.normalize(worldEdgeUnit, worldEdge);\n\n        // Get tangent to the edge. Points out of the Convex\n        vec2.rotate90cw(worldTangent, worldEdgeUnit);\n\n        // Check distance from the infinite line (spanned by the edge) to the particle\n        sub(dist, particleOffset, worldVertex0);\n        var d = dot(dist, worldTangent);\n        sub(centerDist, worldVertex0, convexOffset);\n\n        sub(convexToparticle, particleOffset, convexOffset);\n\n        vec2.sub(candidateDist,worldVertex0,particleOffset);\n        var candidateDistance = Math.abs(vec2.dot(candidateDist,worldTangent));\n\n        if(candidateDistance < minCandidateDistance){\n            minCandidateDistance = candidateDistance;\n            vec2.scale(closestEdgeProjectedPoint,worldTangent,candidateDistance);\n            vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,particleOffset);\n            vec2.copy(minEdgeNormal,worldTangent);\n            found = true;\n        }\n    }\n\n    if(found){\n        var c = this.createContactEquation(particleBody,convexBody,particleShape,convexShape);\n\n        vec2.scale(c.normalA, minEdgeNormal, -1);\n        vec2.normalize(c.normalA, c.normalA);\n\n        // Particle has no extent to the contact point\n        vec2.set(c.contactPointA,  0, 0);\n        add(c.contactPointA, c.contactPointA, particleOffset);\n        sub(c.contactPointA, c.contactPointA, particleBody.position);\n\n        // From convex center to point\n        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);\n        add(c.contactPointB, c.contactPointB, convexOffset);\n        sub(c.contactPointB, c.contactPointB, convexBody.position);\n\n        this.contactEquations.push(c);\n\n        if(this.enableFriction){\n            this.frictionEquations.push( this.createFrictionFromContact(c) );\n        }\n\n        return 1;\n    }\n\n\n    return 0;\n};\n\n/**\n * Circle/circle Narrowphase\n * @method circleCircle\n * @param  {Body} bodyA\n * @param  {Circle} shapeA\n * @param  {Array} offsetA\n * @param  {Number} angleA\n * @param  {Body} bodyB\n * @param  {Circle} shapeB\n * @param  {Array} offsetB\n * @param  {Number} angleB\n * @param {Boolean} justTest\n * @param {Number} [radiusA] Optional radius to use for shapeA\n * @param {Number} [radiusB] Optional radius to use for shapeB\n */\nNarrowphase.prototype[Shape.CIRCLE] =\nNarrowphase.prototype.circleCircle = function(\n    bodyA,\n    shapeA,\n    offsetA,\n    angleA,\n    bodyB,\n    shapeB,\n    offsetB,\n    angleB,\n    justTest,\n    radiusA,\n    radiusB\n){\n\n    var dist = tmp1,\n        radiusA = radiusA || shapeA.radius,\n        radiusB = radiusB || shapeB.radius;\n\n    sub(dist,offsetA,offsetB);\n    var r = radiusA + radiusB;\n    if(vec2.squaredLength(dist) > Math.pow(r,2)){\n        return 0;\n    }\n\n    if(justTest){\n        return true;\n    }\n\n    var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);\n    sub(c.normalA, offsetB, offsetA);\n    vec2.normalize(c.normalA,c.normalA);\n\n    vec2.scale( c.contactPointA, c.normalA,  radiusA);\n    vec2.scale( c.contactPointB, c.normalA, -radiusB);\n\n    add(c.contactPointA, c.contactPointA, offsetA);\n    sub(c.contactPointA, c.contactPointA, bodyA.position);\n\n    add(c.contactPointB, c.contactPointB, offsetB);\n    sub(c.contactPointB, c.contactPointB, bodyB.position);\n\n    this.contactEquations.push(c);\n\n    if(this.enableFriction){\n        this.frictionEquations.push(this.createFrictionFromContact(c));\n    }\n    return 1;\n};\n\n/**\n * Plane/Convex Narrowphase\n * @method planeConvex\n * @param  {Body} planeBody\n * @param  {Plane} planeShape\n * @param  {Array} planeOffset\n * @param  {Number} planeAngle\n * @param  {Body} convexBody\n * @param  {Convex} convexShape\n * @param  {Array} convexOffset\n * @param  {Number} convexAngle\n * @param {Boolean} justTest\n */\nNarrowphase.prototype[Shape.PLANE | Shape.CONVEX] =\nNarrowphase.prototype[Shape.PLANE | Shape.BOX] =\nNarrowphase.prototype.planeConvex = function(\n    planeBody,\n    planeShape,\n    planeOffset,\n    planeAngle,\n    convexBody,\n    convexShape,\n    convexOffset,\n    convexAngle,\n    justTest\n){\n    var worldVertex = tmp1,\n        worldNormal = tmp2,\n        dist = tmp3;\n\n    var numReported = 0;\n    vec2.rotate(worldNormal, yAxis, planeAngle);\n\n    for(var i=0; i!==convexShape.vertices.length; i++){\n        var v = convexShape.vertices[i];\n        vec2.rotate(worldVertex, v, convexAngle);\n        add(worldVertex, worldVertex, convexOffset);\n\n        sub(dist, worldVertex, planeOffset);\n\n        if(dot(dist,worldNormal) <= 0){\n\n            if(justTest){\n                return true;\n            }\n\n            // Found vertex\n            numReported++;\n\n            var c = this.createContactEquation(planeBody,convexBody,planeShape,convexShape);\n\n            sub(dist, worldVertex, planeOffset);\n\n            vec2.copy(c.normalA, worldNormal);\n\n            var d = dot(dist, c.normalA);\n            vec2.scale(dist, c.normalA, d);\n\n            // rj is from convex center to contact\n            sub(c.contactPointB, worldVertex, convexBody.position);\n\n\n            // ri is from plane center to contact\n            sub( c.contactPointA, worldVertex, dist);\n            sub( c.contactPointA, c.contactPointA, planeBody.position);\n\n            this.contactEquations.push(c);\n\n            if(!this.enableFrictionReduction){\n                if(this.enableFriction){\n                    this.frictionEquations.push(this.createFrictionFromContact(c));\n                }\n            }\n        }\n    }\n\n    if(this.enableFrictionReduction){\n        if(this.enableFriction && numReported){\n            this.frictionEquations.push(this.createFrictionFromAverage(numReported));\n        }\n    }\n\n    return numReported;\n};\n\n/**\n * Narrowphase for particle vs plane\n * @method particlePlane\n * @param  {Body}       particleBody\n * @param  {Particle}   particleShape\n * @param  {Array}      particleOffset\n * @param  {Number}     particleAngle\n * @param  {Body}       planeBody\n * @param  {Plane}      planeShape\n * @param  {Array}      planeOffset\n * @param  {Number}     planeAngle\n * @param {Boolean}     justTest\n */\nNarrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =\nNarrowphase.prototype.particlePlane = function(\n    particleBody,\n    particleShape,\n    particleOffset,\n    particleAngle,\n    planeBody,\n    planeShape,\n    planeOffset,\n    planeAngle,\n    justTest\n){\n    var dist = tmp1,\n        worldNormal = tmp2;\n\n    planeAngle = planeAngle || 0;\n\n    sub(dist, particleOffset, planeOffset);\n    vec2.rotate(worldNormal, yAxis, planeAngle);\n\n    var d = dot(dist, worldNormal);\n\n    if(d > 0){\n        return 0;\n    }\n    if(justTest){\n        return true;\n    }\n\n    var c = this.createContactEquation(planeBody,particleBody,planeShape,particleShape);\n\n    vec2.copy(c.normalA, worldNormal);\n    vec2.scale( dist, c.normalA, d );\n    // dist is now the distance vector in the normal direction\n\n    // ri is the particle position projected down onto the plane, from the plane center\n    sub( c.contactPointA, particleOffset, dist);\n    sub( c.contactPointA, c.contactPointA, planeBody.position);\n\n    // rj is from the body center to the particle center\n    sub( c.contactPointB, particleOffset, particleBody.position );\n\n    this.contactEquations.push(c);\n\n    if(this.enableFriction){\n        this.frictionEquations.push(this.createFrictionFromContact(c));\n    }\n    return 1;\n};\n\n/**\n * Circle/Particle Narrowphase\n * @method circleParticle\n * @param  {Body} circleBody\n * @param  {Circle} circleShape\n * @param  {Array} circleOffset\n * @param  {Number} circleAngle\n * @param  {Body} particleBody\n * @param  {Particle} particleShape\n * @param  {Array} particleOffset\n * @param  {Number} particleAngle\n * @param  {Boolean} justTest\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =\nNarrowphase.prototype.circleParticle = function(\n    circleBody,\n    circleShape,\n    circleOffset,\n    circleAngle,\n    particleBody,\n    particleShape,\n    particleOffset,\n    particleAngle,\n    justTest\n){\n    var dist = tmp1;\n\n    sub(dist, particleOffset, circleOffset);\n    if(vec2.squaredLength(dist) > Math.pow(circleShape.radius, 2)){\n        return 0;\n    }\n    if(justTest){\n        return true;\n    }\n\n    var c = this.createContactEquation(circleBody,particleBody,circleShape,particleShape);\n    vec2.copy(c.normalA, dist);\n    vec2.normalize(c.normalA,c.normalA);\n\n    // Vector from circle to contact point is the normal times the circle radius\n    vec2.scale(c.contactPointA, c.normalA, circleShape.radius);\n    add(c.contactPointA, c.contactPointA, circleOffset);\n    sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n    // Vector from particle center to contact point is zero\n    sub(c.contactPointB, particleOffset, particleBody.position);\n\n    this.contactEquations.push(c);\n\n    if(this.enableFriction){\n        this.frictionEquations.push(this.createFrictionFromContact(c));\n    }\n\n    return 1;\n};\n\nvar planeCapsule_tmpCircle = new Circle({ radius: 1 }),\n    planeCapsule_tmp1 = vec2.create(),\n    planeCapsule_tmp2 = vec2.create(),\n    planeCapsule_tmp3 = vec2.create();\n\n/**\n * @method planeCapsule\n * @param  {Body} planeBody\n * @param  {Circle} planeShape\n * @param  {Array} planeOffset\n * @param  {Number} planeAngle\n * @param  {Body} capsuleBody\n * @param  {Particle} capsuleShape\n * @param  {Array} capsuleOffset\n * @param  {Number} capsuleAngle\n * @param {Boolean} justTest\n */\nNarrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =\nNarrowphase.prototype.planeCapsule = function(\n    planeBody,\n    planeShape,\n    planeOffset,\n    planeAngle,\n    capsuleBody,\n    capsuleShape,\n    capsuleOffset,\n    capsuleAngle,\n    justTest\n){\n    var end1 = planeCapsule_tmp1,\n        end2 = planeCapsule_tmp2,\n        circle = planeCapsule_tmpCircle,\n        dst = planeCapsule_tmp3;\n\n    // Compute world end positions\n    vec2.set(end1, -capsuleShape.length/2, 0);\n    vec2.rotate(end1,end1,capsuleAngle);\n    add(end1,end1,capsuleOffset);\n\n    vec2.set(end2,  capsuleShape.length/2, 0);\n    vec2.rotate(end2,end2,capsuleAngle);\n    add(end2,end2,capsuleOffset);\n\n    circle.radius = capsuleShape.radius;\n\n    var enableFrictionBefore;\n\n    // Temporarily turn off friction\n    if(this.enableFrictionReduction){\n        enableFrictionBefore = this.enableFriction;\n        this.enableFriction = false;\n    }\n\n    // Do Narrowphase as two circles\n    var numContacts1 = this.circlePlane(capsuleBody,circle,end1,0, planeBody,planeShape,planeOffset,planeAngle, justTest),\n        numContacts2 = this.circlePlane(capsuleBody,circle,end2,0, planeBody,planeShape,planeOffset,planeAngle, justTest);\n\n    // Restore friction\n    if(this.enableFrictionReduction){\n        this.enableFriction = enableFrictionBefore;\n    }\n\n    if(justTest){\n        return numContacts1 || numContacts2;\n    } else {\n        var numTotal = numContacts1 + numContacts2;\n        if(this.enableFrictionReduction){\n            if(numTotal){\n                this.frictionEquations.push(this.createFrictionFromAverage(numTotal));\n            }\n        }\n        return numTotal;\n    }\n};\n\n/**\n * Creates ContactEquations and FrictionEquations for a collision.\n * @method circlePlane\n * @param  {Body}    bi     The first body that should be connected to the equations.\n * @param  {Circle}  si     The circle shape participating in the collision.\n * @param  {Array}   xi     Extra offset to take into account for the Shape, in addition to the one in circleBody.position. Will *not* be rotated by circleBody.angle (maybe it should, for sake of homogenity?). Set to null if none.\n * @param  {Body}    bj     The second body that should be connected to the equations.\n * @param  {Plane}   sj     The Plane shape that is participating\n * @param  {Array}   xj     Extra offset for the plane shape.\n * @param  {Number}  aj     Extra angle to apply to the plane\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =\nNarrowphase.prototype.circlePlane = function(   bi,si,xi,ai, bj,sj,xj,aj, justTest ){\n    var circleBody = bi,\n        circleShape = si,\n        circleOffset = xi, // Offset from body center, rotated!\n        planeBody = bj,\n        shapeB = sj,\n        planeOffset = xj,\n        planeAngle = aj;\n\n    planeAngle = planeAngle || 0;\n\n    // Vector from plane to circle\n    var planeToCircle = tmp1,\n        worldNormal = tmp2,\n        temp = tmp3;\n\n    sub(planeToCircle, circleOffset, planeOffset);\n\n    // World plane normal\n    vec2.rotate(worldNormal, yAxis, planeAngle);\n\n    // Normal direction distance\n    var d = dot(worldNormal, planeToCircle);\n\n    if(d > circleShape.radius){\n        return 0; // No overlap. Abort.\n    }\n\n    if(justTest){\n        return true;\n    }\n\n    // Create contact\n    var contact = this.createContactEquation(planeBody,circleBody,sj,si);\n\n    // ni is the plane world normal\n    vec2.copy(contact.normalA, worldNormal);\n\n    // rj is the vector from circle center to the contact point\n    vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);\n    add(contact.contactPointB, contact.contactPointB, circleOffset);\n    sub(contact.contactPointB, contact.contactPointB, circleBody.position);\n\n    // ri is the distance from plane center to contact.\n    vec2.scale(temp, contact.normalA, d);\n    sub(contact.contactPointA, planeToCircle, temp ); // Subtract normal distance vector from the distance vector\n    add(contact.contactPointA, contact.contactPointA, planeOffset);\n    sub(contact.contactPointA, contact.contactPointA, planeBody.position);\n\n    this.contactEquations.push(contact);\n\n    if(this.enableFriction){\n        this.frictionEquations.push( this.createFrictionFromContact(contact) );\n    }\n\n    return 1;\n};\n\n/**\n * Convex/convex Narrowphase.See <a href=\"http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/\">this article</a> for more info.\n * @method convexConvex\n * @param  {Body} bi\n * @param  {Convex} si\n * @param  {Array} xi\n * @param  {Number} ai\n * @param  {Body} bj\n * @param  {Convex} sj\n * @param  {Array} xj\n * @param  {Number} aj\n */\nNarrowphase.prototype[Shape.CONVEX] =\nNarrowphase.prototype[Shape.CONVEX | Shape.BOX] =\nNarrowphase.prototype[Shape.BOX] =\nNarrowphase.prototype.convexConvex = function(  bi,si,xi,ai, bj,sj,xj,aj, justTest, precision ){\n    var sepAxis = tmp1,\n        worldPoint = tmp2,\n        worldPoint0 = tmp3,\n        worldPoint1 = tmp4,\n        worldEdge = tmp5,\n        projected = tmp6,\n        penetrationVec = tmp7,\n        dist = tmp8,\n        worldNormal = tmp9,\n        numContacts = 0,\n        precision = typeof(precision) === 'number' ? precision : 0;\n\n    var found = Narrowphase.findSeparatingAxis(si,xi,ai,sj,xj,aj,sepAxis);\n    if(!found){\n        return 0;\n    }\n\n    // Make sure the separating axis is directed from shape i to shape j\n    sub(dist,xj,xi);\n    if(dot(sepAxis,dist) > 0){\n        vec2.scale(sepAxis,sepAxis,-1);\n    }\n\n    // Find edges with normals closest to the separating axis\n    var closestEdge1 = Narrowphase.getClosestEdge(si,ai,sepAxis,true), // Flipped axis\n        closestEdge2 = Narrowphase.getClosestEdge(sj,aj,sepAxis);\n\n    if(closestEdge1 === -1 || closestEdge2 === -1){\n        return 0;\n    }\n\n    // Loop over the shapes\n    for(var k=0; k<2; k++){\n\n        var closestEdgeA = closestEdge1,\n            closestEdgeB = closestEdge2,\n            shapeA =  si, shapeB =  sj,\n            offsetA = xi, offsetB = xj,\n            angleA = ai, angleB = aj,\n            bodyA = bi, bodyB = bj;\n\n        if(k === 0){\n            // Swap!\n            var tmp;\n            tmp = closestEdgeA;\n            closestEdgeA = closestEdgeB;\n            closestEdgeB = tmp;\n\n            tmp = shapeA;\n            shapeA = shapeB;\n            shapeB = tmp;\n\n            tmp = offsetA;\n            offsetA = offsetB;\n            offsetB = tmp;\n\n            tmp = angleA;\n            angleA = angleB;\n            angleB = tmp;\n\n            tmp = bodyA;\n            bodyA = bodyB;\n            bodyB = tmp;\n        }\n\n        // Loop over 2 points in convex B\n        for(var j=closestEdgeB; j<closestEdgeB+2; j++){\n\n            // Get world point\n            var v = shapeB.vertices[(j+shapeB.vertices.length)%shapeB.vertices.length];\n            vec2.rotate(worldPoint, v, angleB);\n            add(worldPoint, worldPoint, offsetB);\n\n            var insideNumEdges = 0;\n\n            // Loop over the 3 closest edges in convex A\n            for(var i=closestEdgeA-1; i<closestEdgeA+2; i++){\n\n                var v0 = shapeA.vertices[(i  +shapeA.vertices.length)%shapeA.vertices.length],\n                    v1 = shapeA.vertices[(i+1+shapeA.vertices.length)%shapeA.vertices.length];\n\n                // Construct the edge\n                vec2.rotate(worldPoint0, v0, angleA);\n                vec2.rotate(worldPoint1, v1, angleA);\n                add(worldPoint0, worldPoint0, offsetA);\n                add(worldPoint1, worldPoint1, offsetA);\n\n                sub(worldEdge, worldPoint1, worldPoint0);\n\n                vec2.rotate90cw(worldNormal, worldEdge); // Normal points out of convex 1\n                vec2.normalize(worldNormal,worldNormal);\n\n                sub(dist, worldPoint, worldPoint0);\n\n                var d = dot(worldNormal,dist);\n\n                if((i === closestEdgeA && d <= precision) || (i !== closestEdgeA && d <= 0)){\n                    insideNumEdges++;\n                }\n            }\n\n            if(insideNumEdges >= 3){\n\n                if(justTest){\n                    return true;\n                }\n\n                // worldPoint was on the \"inside\" side of each of the 3 checked edges.\n                // Project it to the center edge and use the projection direction as normal\n\n                // Create contact\n                var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);\n                numContacts++;\n\n                // Get center edge from body A\n                var v0 = shapeA.vertices[(closestEdgeA)   % shapeA.vertices.length],\n                    v1 = shapeA.vertices[(closestEdgeA+1) % shapeA.vertices.length];\n\n                // Construct the edge\n                vec2.rotate(worldPoint0, v0, angleA);\n                vec2.rotate(worldPoint1, v1, angleA);\n                add(worldPoint0, worldPoint0, offsetA);\n                add(worldPoint1, worldPoint1, offsetA);\n\n                sub(worldEdge, worldPoint1, worldPoint0);\n\n                vec2.rotate90cw(c.normalA, worldEdge); // Normal points out of convex A\n                vec2.normalize(c.normalA,c.normalA);\n\n                sub(dist, worldPoint, worldPoint0); // From edge point to the penetrating point\n                var d = dot(c.normalA,dist);             // Penetration\n                vec2.scale(penetrationVec, c.normalA, d);     // Vector penetration\n\n                sub(c.contactPointA, worldPoint, offsetA);\n                sub(c.contactPointA, c.contactPointA, penetrationVec);\n                add(c.contactPointA, c.contactPointA, offsetA);\n                sub(c.contactPointA, c.contactPointA, bodyA.position);\n\n                sub(c.contactPointB, worldPoint, offsetB);\n                add(c.contactPointB, c.contactPointB, offsetB);\n                sub(c.contactPointB, c.contactPointB, bodyB.position);\n\n                this.contactEquations.push(c);\n\n                // Todo reduce to 1 friction equation if we have 2 contact points\n                if(!this.enableFrictionReduction){\n                    if(this.enableFriction){\n                        this.frictionEquations.push(this.createFrictionFromContact(c));\n                    }\n                }\n            }\n        }\n    }\n\n    if(this.enableFrictionReduction){\n        if(this.enableFriction && numContacts){\n            this.frictionEquations.push(this.createFrictionFromAverage(numContacts));\n        }\n    }\n\n    return numContacts;\n};\n\n// .projectConvex is called by other functions, need local tmp vectors\nvar pcoa_tmp1 = vec2.fromValues(0,0);\n\n/**\n * Project a Convex onto a world-oriented axis\n * @method projectConvexOntoAxis\n * @static\n * @param  {Convex} convexShape\n * @param  {Array} convexOffset\n * @param  {Number} convexAngle\n * @param  {Array} worldAxis\n * @param  {Array} result\n */\nNarrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result){\n    var max=null,\n        min=null,\n        v,\n        value,\n        localAxis = pcoa_tmp1;\n\n    // Convert the axis to local coords of the body\n    vec2.rotate(localAxis, worldAxis, -convexAngle);\n\n    // Get projected position of all vertices\n    for(var i=0; i<convexShape.vertices.length; i++){\n        v = convexShape.vertices[i];\n        value = dot(v,localAxis);\n        if(max === null || value > max){\n            max = value;\n        }\n        if(min === null || value < min){\n            min = value;\n        }\n    }\n\n    if(min > max){\n        var t = min;\n        min = max;\n        max = t;\n    }\n\n    // Project the position of the body onto the axis - need to add this to the result\n    var offset = dot(convexOffset, worldAxis);\n\n    vec2.set( result, min + offset, max + offset);\n};\n\n// .findSeparatingAxis is called by other functions, need local tmp vectors\nvar fsa_tmp1 = vec2.fromValues(0,0)\n,   fsa_tmp2 = vec2.fromValues(0,0)\n,   fsa_tmp3 = vec2.fromValues(0,0)\n,   fsa_tmp4 = vec2.fromValues(0,0)\n,   fsa_tmp5 = vec2.fromValues(0,0)\n,   fsa_tmp6 = vec2.fromValues(0,0);\n\n/**\n * Find a separating axis between the shapes, that maximizes the separating distance between them.\n * @method findSeparatingAxis\n * @static\n * @param  {Convex}     c1\n * @param  {Array}      offset1\n * @param  {Number}     angle1\n * @param  {Convex}     c2\n * @param  {Array}      offset2\n * @param  {Number}     angle2\n * @param  {Array}      sepAxis     The resulting axis\n * @return {Boolean}                Whether the axis could be found.\n */\nNarrowphase.findSeparatingAxis = function(c1,offset1,angle1,c2,offset2,angle2,sepAxis){\n    var maxDist = null,\n        overlap = false,\n        found = false,\n        edge = fsa_tmp1,\n        worldPoint0 = fsa_tmp2,\n        worldPoint1 = fsa_tmp3,\n        normal = fsa_tmp4,\n        span1 = fsa_tmp5,\n        span2 = fsa_tmp6;\n\n    if(c1 instanceof Box && c2 instanceof Box){\n\n        for(var j=0; j!==2; j++){\n            var c = c1,\n                angle = angle1;\n            if(j===1){\n                c = c2;\n                angle = angle2;\n            }\n\n            for(var i=0; i!==2; i++){\n\n                // Get the world edge\n                if(i === 0){\n                    vec2.set(normal, 0, 1);\n                } else if(i === 1) {\n                    vec2.set(normal, 1, 0);\n                }\n                if(angle !== 0){\n                    vec2.rotate(normal, normal, angle);\n                }\n\n                // Project hulls onto that normal\n                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);\n                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);\n\n                // Order by span position\n                var a=span1,\n                    b=span2,\n                    swapped = false;\n                if(span1[0] > span2[0]){\n                    b=span1;\n                    a=span2;\n                    swapped = true;\n                }\n\n                // Get separating distance\n                var dist = b[0] - a[1];\n                overlap = (dist <= 0);\n\n                if(maxDist===null || dist > maxDist){\n                    vec2.copy(sepAxis, normal);\n                    maxDist = dist;\n                    found = overlap;\n                }\n            }\n        }\n\n    } else {\n\n        for(var j=0; j!==2; j++){\n            var c = c1,\n                angle = angle1;\n            if(j===1){\n                c = c2;\n                angle = angle2;\n            }\n\n            for(var i=0; i!==c.vertices.length; i++){\n                // Get the world edge\n                vec2.rotate(worldPoint0, c.vertices[i], angle);\n                vec2.rotate(worldPoint1, c.vertices[(i+1)%c.vertices.length], angle);\n\n                sub(edge, worldPoint1, worldPoint0);\n\n                // Get normal - just rotate 90 degrees since vertices are given in CCW\n                vec2.rotate90cw(normal, edge);\n                vec2.normalize(normal,normal);\n\n                // Project hulls onto that normal\n                Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);\n                Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);\n\n                // Order by span position\n                var a=span1,\n                    b=span2,\n                    swapped = false;\n                if(span1[0] > span2[0]){\n                    b=span1;\n                    a=span2;\n                    swapped = true;\n                }\n\n                // Get separating distance\n                var dist = b[0] - a[1];\n                overlap = (dist <= 0);\n\n                if(maxDist===null || dist > maxDist){\n                    vec2.copy(sepAxis, normal);\n                    maxDist = dist;\n                    found = overlap;\n                }\n            }\n        }\n    }\n\n\n    /*\n    // Needs to be tested some more\n    for(var j=0; j!==2; j++){\n        var c = c1,\n            angle = angle1;\n        if(j===1){\n            c = c2;\n            angle = angle2;\n        }\n\n        for(var i=0; i!==c.axes.length; i++){\n\n            var normal = c.axes[i];\n\n            // Project hulls onto that normal\n            Narrowphase.projectConvexOntoAxis(c1, offset1, angle1, normal, span1);\n            Narrowphase.projectConvexOntoAxis(c2, offset2, angle2, normal, span2);\n\n            // Order by span position\n            var a=span1,\n                b=span2,\n                swapped = false;\n            if(span1[0] > span2[0]){\n                b=span1;\n                a=span2;\n                swapped = true;\n            }\n\n            // Get separating distance\n            var dist = b[0] - a[1];\n            overlap = (dist <= Narrowphase.convexPrecision);\n\n            if(maxDist===null || dist > maxDist){\n                vec2.copy(sepAxis, normal);\n                maxDist = dist;\n                found = overlap;\n            }\n        }\n    }\n    */\n\n    return found;\n};\n\n// .getClosestEdge is called by other functions, need local tmp vectors\nvar gce_tmp1 = vec2.fromValues(0,0)\n,   gce_tmp2 = vec2.fromValues(0,0)\n,   gce_tmp3 = vec2.fromValues(0,0);\n\n/**\n * Get the edge that has a normal closest to an axis.\n * @method getClosestEdge\n * @static\n * @param  {Convex}     c\n * @param  {Number}     angle\n * @param  {Array}      axis\n * @param  {Boolean}    flip\n * @return {Number}             Index of the edge that is closest. This index and the next spans the resulting edge. Returns -1 if failed.\n */\nNarrowphase.getClosestEdge = function(c,angle,axis,flip){\n    var localAxis = gce_tmp1,\n        edge = gce_tmp2,\n        normal = gce_tmp3;\n\n    // Convert the axis to local coords of the body\n    vec2.rotate(localAxis, axis, -angle);\n    if(flip){\n        vec2.scale(localAxis,localAxis,-1);\n    }\n\n    var closestEdge = -1,\n        N = c.vertices.length,\n        maxDot = -1;\n    for(var i=0; i!==N; i++){\n        // Get the edge\n        sub(edge, c.vertices[(i+1)%N], c.vertices[i%N]);\n\n        // Get normal - just rotate 90 degrees since vertices are given in CCW\n        vec2.rotate90cw(normal, edge);\n        vec2.normalize(normal,normal);\n\n        var d = dot(normal,localAxis);\n        if(closestEdge === -1 || d > maxDot){\n            closestEdge = i % N;\n            maxDot = d;\n        }\n    }\n\n    return closestEdge;\n};\n\nvar circleHeightfield_candidate = vec2.create(),\n    circleHeightfield_dist = vec2.create(),\n    circleHeightfield_v0 = vec2.create(),\n    circleHeightfield_v1 = vec2.create(),\n    circleHeightfield_minCandidate = vec2.create(),\n    circleHeightfield_worldNormal = vec2.create(),\n    circleHeightfield_minCandidateNormal = vec2.create();\n\n/**\n * @method circleHeightfield\n * @param  {Body}           bi\n * @param  {Circle}         si\n * @param  {Array}          xi\n * @param  {Body}           bj\n * @param  {Heightfield}    sj\n * @param  {Array}          xj\n * @param  {Number}         aj\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =\nNarrowphase.prototype.circleHeightfield = function( circleBody,circleShape,circlePos,circleAngle,\n                                                    hfBody,hfShape,hfPos,hfAngle, justTest, radius ){\n    var data = hfShape.heights,\n        radius = radius || circleShape.radius,\n        w = hfShape.elementWidth,\n        dist = circleHeightfield_dist,\n        candidate = circleHeightfield_candidate,\n        minCandidate = circleHeightfield_minCandidate,\n        minCandidateNormal = circleHeightfield_minCandidateNormal,\n        worldNormal = circleHeightfield_worldNormal,\n        v0 = circleHeightfield_v0,\n        v1 = circleHeightfield_v1;\n\n    // Get the index of the points to test against\n    var idxA = Math.floor( (circlePos[0] - radius - hfPos[0]) / w ),\n        idxB = Math.ceil(  (circlePos[0] + radius - hfPos[0]) / w );\n\n    /*if(idxB < 0 || idxA >= data.length)\n        return justTest ? false : 0;*/\n\n    if(idxA < 0){\n        idxA = 0;\n    }\n    if(idxB >= data.length){\n        idxB = data.length-1;\n    }\n\n    // Get max and min\n    var max = data[idxA],\n        min = data[idxB];\n    for(var i=idxA; i<idxB; i++){\n        if(data[i] < min){\n            min = data[i];\n        }\n        if(data[i] > max){\n            max = data[i];\n        }\n    }\n\n    if(circlePos[1]-radius > max){\n        return justTest ? false : 0;\n    }\n\n    /*\n    if(circlePos[1]+radius < min){\n        // Below the minimum point... We can just guess.\n        // TODO\n    }\n    */\n\n    // 1. Check so center of circle is not inside the field. If it is, this wont work...\n    // 2. For each edge\n    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)\n    // 2. 2. Check if point is inside.\n\n    var found = false;\n\n    // Check all edges first\n    for(var i=idxA; i<idxB; i++){\n\n        // Get points\n        vec2.set(v0,     i*w, data[i]  );\n        vec2.set(v1, (i+1)*w, data[i+1]);\n        vec2.add(v0,v0,hfPos);\n        vec2.add(v1,v1,hfPos);\n\n        // Get normal\n        vec2.sub(worldNormal, v1, v0);\n        vec2.rotate(worldNormal, worldNormal, Math.PI/2);\n        vec2.normalize(worldNormal,worldNormal);\n\n        // Get point on circle, closest to the edge\n        vec2.scale(candidate,worldNormal,-radius);\n        vec2.add(candidate,candidate,circlePos);\n\n        // Distance from v0 to the candidate point\n        vec2.sub(dist,candidate,v0);\n\n        // Check if it is in the element \"stick\"\n        var d = vec2.dot(dist,worldNormal);\n        if(candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0){\n\n            if(justTest){\n                return true;\n            }\n\n            found = true;\n\n            // Store the candidate point, projected to the edge\n            vec2.scale(dist,worldNormal,-d);\n            vec2.add(minCandidate,candidate,dist);\n            vec2.copy(minCandidateNormal,worldNormal);\n\n            var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);\n\n            // Normal is out of the heightfield\n            vec2.copy(c.normalA, minCandidateNormal);\n\n            // Vector from circle to heightfield\n            vec2.scale(c.contactPointB,  c.normalA, -radius);\n            add(c.contactPointB, c.contactPointB, circlePos);\n            sub(c.contactPointB, c.contactPointB, circleBody.position);\n\n            vec2.copy(c.contactPointA, minCandidate);\n            vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);\n\n            this.contactEquations.push(c);\n\n            if(this.enableFriction){\n                this.frictionEquations.push( this.createFrictionFromContact(c) );\n            }\n        }\n    }\n\n    // Check all vertices\n    found = false;\n    if(radius > 0){\n        for(var i=idxA; i<=idxB; i++){\n\n            // Get point\n            vec2.set(v0, i*w, data[i]);\n            vec2.add(v0,v0,hfPos);\n\n            vec2.sub(dist, circlePos, v0);\n\n            if(vec2.squaredLength(dist) < Math.pow(radius, 2)){\n\n                if(justTest){\n                    return true;\n                }\n\n                found = true;\n\n                var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);\n\n                // Construct normal - out of heightfield\n                vec2.copy(c.normalA, dist);\n                vec2.normalize(c.normalA,c.normalA);\n\n                vec2.scale(c.contactPointB, c.normalA, -radius);\n                add(c.contactPointB, c.contactPointB, circlePos);\n                sub(c.contactPointB, c.contactPointB, circleBody.position);\n\n                sub(c.contactPointA, v0, hfPos);\n                add(c.contactPointA, c.contactPointA, hfPos);\n                sub(c.contactPointA, c.contactPointA, hfBody.position);\n\n                this.contactEquations.push(c);\n\n                if(this.enableFriction){\n                    this.frictionEquations.push(this.createFrictionFromContact(c));\n                }\n            }\n        }\n    }\n\n    if(found){\n        return 1;\n    }\n\n    return 0;\n\n};\n\nvar convexHeightfield_v0 = vec2.create(),\n    convexHeightfield_v1 = vec2.create(),\n    convexHeightfield_tilePos = vec2.create(),\n    convexHeightfield_tempConvexShape = new Convex({ vertices: [vec2.create(),vec2.create(),vec2.create(),vec2.create()] });\n/**\n * @method circleHeightfield\n * @param  {Body}           bi\n * @param  {Circle}         si\n * @param  {Array}          xi\n * @param  {Body}           bj\n * @param  {Heightfield}    sj\n * @param  {Array}          xj\n * @param  {Number}         aj\n */\nNarrowphase.prototype[Shape.BOX | Shape.HEIGHTFIELD] =\nNarrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =\nNarrowphase.prototype.convexHeightfield = function( convexBody,convexShape,convexPos,convexAngle,\n                                                    hfBody,hfShape,hfPos,hfAngle, justTest ){\n    var data = hfShape.heights,\n        w = hfShape.elementWidth,\n        v0 = convexHeightfield_v0,\n        v1 = convexHeightfield_v1,\n        tilePos = convexHeightfield_tilePos,\n        tileConvex = convexHeightfield_tempConvexShape;\n\n    // Get the index of the points to test against\n    var idxA = Math.floor( (convexBody.aabb.lowerBound[0] - hfPos[0]) / w ),\n        idxB = Math.ceil(  (convexBody.aabb.upperBound[0] - hfPos[0]) / w );\n\n    if(idxA < 0){\n        idxA = 0;\n    }\n    if(idxB >= data.length){\n        idxB = data.length-1;\n    }\n\n    // Get max and min\n    var max = data[idxA],\n        min = data[idxB];\n    for(var i=idxA; i<idxB; i++){\n        if(data[i] < min){\n            min = data[i];\n        }\n        if(data[i] > max){\n            max = data[i];\n        }\n    }\n\n    if(convexBody.aabb.lowerBound[1] > max){\n        return justTest ? false : 0;\n    }\n\n    var found = false;\n    var numContacts = 0;\n\n    // Loop over all edges\n    // TODO: If possible, construct a convex from several data points (need o check if the points make a convex shape)\n    for(var i=idxA; i<idxB; i++){\n\n        // Get points\n        vec2.set(v0,     i*w, data[i]  );\n        vec2.set(v1, (i+1)*w, data[i+1]);\n        vec2.add(v0,v0,hfPos);\n        vec2.add(v1,v1,hfPos);\n\n        // Construct a convex\n        var tileHeight = 100; // todo\n        vec2.set(tilePos, (v1[0] + v0[0])*0.5, (v1[1] + v0[1] - tileHeight)*0.5);\n\n        vec2.sub(tileConvex.vertices[0], v1, tilePos);\n        vec2.sub(tileConvex.vertices[1], v0, tilePos);\n        vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);\n        vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);\n        tileConvex.vertices[2][1] -= tileHeight;\n        tileConvex.vertices[3][1] -= tileHeight;\n\n        // Do convex collision\n        numContacts += this.convexConvex(   convexBody, convexShape, convexPos, convexAngle,\n                                            hfBody, tileConvex, tilePos, 0, justTest);\n    }\n\n    return numContacts;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbGxpc2lvbi9OYXJyb3dwaGFzZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvY29sbGlzaW9uL05hcnJvd3BoYXNlLmpzP2I4MjQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKVxuLCAgIHN1YiA9IHZlYzIuc3ViXG4sICAgYWRkID0gdmVjMi5hZGRcbiwgICBkb3QgPSB2ZWMyLmRvdFxuLCAgIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKVxuLCAgIENvbnRhY3RFcXVhdGlvblBvb2wgPSByZXF1aXJlKCcuLi91dGlscy9Db250YWN0RXF1YXRpb25Qb29sJylcbiwgICBGcmljdGlvbkVxdWF0aW9uUG9vbCA9IHJlcXVpcmUoJy4uL3V0aWxzL0ZyaWN0aW9uRXF1YXRpb25Qb29sJylcbiwgICBUdXBsZURpY3Rpb25hcnkgPSByZXF1aXJlKCcuLi91dGlscy9UdXBsZURpY3Rpb25hcnknKVxuLCAgIEVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0VxdWF0aW9uJylcbiwgICBDb250YWN0RXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJylcbiwgICBGcmljdGlvbkVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKVxuLCAgIENpcmNsZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9DaXJjbGUnKVxuLCAgIENvbnZleCA9IHJlcXVpcmUoJy4uL3NoYXBlcy9Db252ZXgnKVxuLCAgIFNoYXBlID0gcmVxdWlyZSgnLi4vc2hhcGVzL1NoYXBlJylcbiwgICBCb2R5ID0gcmVxdWlyZSgnLi4vb2JqZWN0cy9Cb2R5JylcbiwgICBCb3ggPSByZXF1aXJlKCcuLi9zaGFwZXMvQm94Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmFycm93cGhhc2U7XG5cbi8vIFRlbXAgdGhpbmdzXG52YXIgeUF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwxKTtcblxudmFyIHRtcDEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDQgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDUgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDYgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDcgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDggPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDkgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDEwID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxMSA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDEzID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxNCA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTUgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcDE2ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICB0bXAxNyA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgdG1wMTggPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIHRtcEFycmF5ID0gW107XG5cbi8qKlxuICogTmFycm93cGhhc2UuIENyZWF0ZXMgY29udGFjdHMgYW5kIGZyaWN0aW9uIGdpdmVuIHNoYXBlcyBhbmQgdHJhbnNmb3Jtcy5cbiAqIEBjbGFzcyBOYXJyb3dwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE5hcnJvd3BoYXNlKCl7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgY29udGFjdEVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIG1ha2UgZnJpY3Rpb24gZXF1YXRpb25zIGluIHRoZSB1cGNvbWluZyBjb250YWN0cy5cbiAgICAgKiBAcHJvcGVydHkgZW5hYmxlRnJpY3Rpb25cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZUZyaWN0aW9uID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gbWFrZSBlcXVhdGlvbnMgZW5hYmxlZCBpbiB1cGNvbWluZyBjb250YWN0cy5cbiAgICAgKiBAcHJvcGVydHkgZW5hYmxlZEVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlZEVxdWF0aW9ucyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJpY3Rpb24gc2xpcCBmb3JjZSB0byB1c2Ugd2hlbiBjcmVhdGluZyBmcmljdGlvbiBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHNsaXBGb3JjZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zbGlwRm9yY2UgPSAxMC4wO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyaWN0aW9uIHZhbHVlIHRvIHVzZSBpbiB0aGUgdXBjb21pbmcgZnJpY3Rpb24gZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkNvZWZmaWNpZW50XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uQ29lZmZpY2llbnQgPSAwLjM7XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIHRoZSAucmVsYXRpdmVWZWxvY2l0eSBpbiBlYWNoIHByb2R1Y2VkIEZyaWN0aW9uRXF1YXRpb24uXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHN1cmZhY2VWZWxvY2l0eVxuICAgICAqL1xuICAgIHRoaXMuc3VyZmFjZVZlbG9jaXR5ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBhbGxvY2F0ZWQgQ29udGFjdEVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge0NvbnRhY3RFcXVhdGlvblBvb2x9IGNvbnRhY3RFcXVhdGlvblBvb2xcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgLy8gQWxsb2NhdGUgYSBmZXcgZXF1YXRpb25zIGJlZm9yZSBzdGFydGluZyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKiAgICAgLy8gVGhpcyB3YXksIG5vIGNvbnRhY3Qgb2JqZWN0cyBuZWVkIHRvIGJlIGNyZWF0ZWQgb24gdGhlIGZseSBpbiB0aGUgZ2FtZSBsb29wLlxuICAgICAqICAgICB3b3JsZC5uYXJyb3dwaGFzZS5jb250YWN0RXF1YXRpb25Qb29sLnJlc2l6ZSgxMDI0KTtcbiAgICAgKiAgICAgd29ybGQubmFycm93cGhhc2UuZnJpY3Rpb25FcXVhdGlvblBvb2wucmVzaXplKDEwMjQpO1xuICAgICAqL1xuICAgIHRoaXMuY29udGFjdEVxdWF0aW9uUG9vbCA9IG5ldyBDb250YWN0RXF1YXRpb25Qb29sKHsgc2l6ZTogMzIgfSk7XG5cbiAgICAvKipcbiAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgYWxsb2NhdGVkIENvbnRhY3RFcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IHtGcmljdGlvbkVxdWF0aW9uUG9vbH0gZnJpY3Rpb25FcXVhdGlvblBvb2xcbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sID0gbmV3IEZyaWN0aW9uRXF1YXRpb25Qb29sKHsgc2l6ZTogNjQgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdGl0dXRpb24gdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGNvbnRhY3QgZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0aXR1dGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3RpZmZuZXNzXG4gICAgICovXG4gICAgdGhpcy5zdGlmZm5lc3MgPSBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGlmZm5lc3MgdmFsdWUgdG8gdXNlIGluIHRoZSBuZXh0IGNvbnRhY3QgZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzdGlmZm5lc3NcbiAgICAgKi9cbiAgICB0aGlzLnJlbGF4YXRpb24gPSBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RpZmZuZXNzIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBmcmljdGlvbiBlcXVhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uU3RpZmZuZXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uU3RpZmZuZXNzID0gRXF1YXRpb24uREVGQVVMVF9TVElGRk5FU1M7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVsYXhhdGlvbiB2YWx1ZSB0byB1c2UgaW4gdGhlIG5leHQgZnJpY3Rpb24gZXF1YXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblJlbGF4YXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25SZWxheGF0aW9uID0gRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHJlZHVjdGlvbiBvZiBmcmljdGlvbiBlcXVhdGlvbnMuIElmIGRpc2FibGVkLCBhIGJveCBvbiBhIHBsYW5lIHdpbGwgZ2VuZXJhdGUgMiBjb250YWN0IGVxdWF0aW9ucyBhbmQgMiBmcmljdGlvbiBlcXVhdGlvbnMuIElmIGVuYWJsZWQsIHRoZXJlIHdpbGwgYmUgb25seSBvbmUgZnJpY3Rpb24gZXF1YXRpb24uIFNhbWUga2luZCBvZiBzaW1wbGlmaWNhdGlvbnMgYXJlIG1hZGUgIGZvciBhbGwgY29sbGlzaW9uIHR5cGVzLlxuICAgICAqIEBwcm9wZXJ0eSBlbmFibGVGcmljdGlvblJlZHVjdGlvblxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgZmxhZyB3aWxsIGJlIHJlbW92ZWQgd2hlbiB0aGUgZmVhdHVyZSBpcyBzdGFibGUgZW5vdWdoLlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjb2xsaWRpbmcgYm9kaWVzIGxhc3Qgc3RlcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaWRpbmdCb2RpZXNMYXN0U3RlcFxuICAgICAqIEB0eXBlIHtUdXBsZURpY3Rpb25hcnl9XG4gICAgICovXG4gICAgdGhpcy5jb2xsaWRpbmdCb2RpZXNMYXN0U3RlcCA9IG5ldyBUdXBsZURpY3Rpb25hcnkoKTtcblxuICAgIC8qKlxuICAgICAqIENvbnRhY3Qgc2tpbiBzaXplIHZhbHVlIHRvIHVzZSBpbiB0aGUgbmV4dCBjb250YWN0IGVxdWF0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29udGFjdFNraW5TaXplXG4gICAgICogQGRlZmF1bHQgMC4wMVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFNraW5TaXplID0gMC4wMTtcbn1cblxudmFyIGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkEgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgYm9kaWVzT3ZlcmxhcFxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHRvZG8gc2hhcGUgd29ybGQgdHJhbnNmb3JtcyBhcmUgd3JvbmdcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmJvZGllc092ZXJsYXAgPSBmdW5jdGlvbihib2R5QSwgYm9keUIpe1xuICAgIHZhciBzaGFwZVBvc2l0aW9uQSA9IGJvZGllc092ZXJsYXBfc2hhcGVQb3NpdGlvbkE7XG4gICAgdmFyIHNoYXBlUG9zaXRpb25CID0gYm9kaWVzT3ZlcmxhcF9zaGFwZVBvc2l0aW9uQjtcblxuICAgIC8vIExvb3Agb3ZlciBhbGwgc2hhcGVzIG9mIGJvZHlBXG4gICAgZm9yKHZhciBrPTAsIE5zaGFwZXNpPWJvZHlBLnNoYXBlcy5sZW5ndGg7IGshPT1Oc2hhcGVzaTsgaysrKXtcbiAgICAgICAgdmFyIHNoYXBlQSA9IGJvZHlBLnNoYXBlc1trXTtcblxuICAgICAgICBib2R5QS50b1dvcmxkRnJhbWUoc2hhcGVQb3NpdGlvbkEsIHNoYXBlQS5wb3NpdGlvbik7XG5cbiAgICAgICAgLy8gQWxsIHNoYXBlcyBvZiBib2R5IGpcbiAgICAgICAgZm9yKHZhciBsPTAsIE5zaGFwZXNqPWJvZHlCLnNoYXBlcy5sZW5ndGg7IGwhPT1Oc2hhcGVzajsgbCsrKXtcbiAgICAgICAgICAgIHZhciBzaGFwZUIgPSBib2R5Qi5zaGFwZXNbbF07XG5cbiAgICAgICAgICAgIGJvZHlCLnRvV29ybGRGcmFtZShzaGFwZVBvc2l0aW9uQiwgc2hhcGVCLnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgaWYodGhpc1tzaGFwZUEudHlwZSB8IHNoYXBlQi50eXBlXShcbiAgICAgICAgICAgICAgICBib2R5QSxcbiAgICAgICAgICAgICAgICBzaGFwZUEsXG4gICAgICAgICAgICAgICAgc2hhcGVQb3NpdGlvbkEsXG4gICAgICAgICAgICAgICAgc2hhcGVBLmFuZ2xlICsgYm9keUEuYW5nbGUsXG4gICAgICAgICAgICAgICAgYm9keUIsXG4gICAgICAgICAgICAgICAgc2hhcGVCLFxuICAgICAgICAgICAgICAgIHNoYXBlUG9zaXRpb25CLFxuICAgICAgICAgICAgICAgIHNoYXBlQi5hbmdsZSArIGJvZHlCLmFuZ2xlLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICkpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm9kaWVzIHdlcmUgaW4gY29udGFjdCBzaW5jZSB0aGUgbGFzdCByZXNldCgpLlxuICogQG1ldGhvZCBjb2xsaWRlZExhc3RTdGVwXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb2xsaWRlZExhc3RTdGVwID0gZnVuY3Rpb24oYm9keUEsIGJvZHlCKXtcbiAgICB2YXIgaWQxID0gYm9keUEuaWR8MCxcbiAgICAgICAgaWQyID0gYm9keUIuaWR8MDtcbiAgICByZXR1cm4gISF0aGlzLmNvbGxpZGluZ0JvZGllc0xhc3RTdGVwLmdldChpZDEsIGlkMik7XG59O1xuXG4vKipcbiAqIFRocm93cyBhd2F5IHRoZSBvbGQgZXF1YXRpb25zIGFuZCBnZXRzIHJlYWR5IHRvIGNyZWF0ZSBuZXdcbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmNvbGxpZGluZ0JvZGllc0xhc3RTdGVwLnJlc2V0KCk7XG5cbiAgICB2YXIgZXFzID0gdGhpcy5jb250YWN0RXF1YXRpb25zO1xuICAgIHZhciBsID0gZXFzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIgZXEgPSBlcXNbbF0sXG4gICAgICAgICAgICBpZDEgPSBlcS5ib2R5QS5pZCxcbiAgICAgICAgICAgIGlkMiA9IGVxLmJvZHlCLmlkO1xuICAgICAgICB0aGlzLmNvbGxpZGluZ0JvZGllc0xhc3RTdGVwLnNldChpZDEsIGlkMiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGNlID0gdGhpcy5jb250YWN0RXF1YXRpb25zLFxuICAgICAgICBmZSA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnM7XG4gICAgZm9yKHZhciBpPTA7IGk8Y2UubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblBvb2wucmVsZWFzZShjZVtpXSk7XG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpPGZlLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbC5yZWxlYXNlKGZlW2ldKTtcbiAgICB9XG5cbiAgICAvLyBSZXNldFxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggPSB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDb250YWN0RXF1YXRpb24sIGVpdGhlciBieSByZXVzaW5nIGFuIGV4aXN0aW5nIG9iamVjdCBvciBjcmVhdGluZyBhIG5ldyBvbmUuXG4gKiBAbWV0aG9kIGNyZWF0ZUNvbnRhY3RFcXVhdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtDb250YWN0RXF1YXRpb259XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVDb250YWN0RXF1YXRpb24gPSBmdW5jdGlvbihib2R5QSwgYm9keUIsIHNoYXBlQSwgc2hhcGVCKXtcbiAgICB2YXIgYyA9IHRoaXMuY29udGFjdEVxdWF0aW9uUG9vbC5nZXQoKTtcbiAgICBjLmJvZHlBID0gYm9keUE7XG4gICAgYy5ib2R5QiA9IGJvZHlCO1xuICAgIGMuc2hhcGVBID0gc2hhcGVBO1xuICAgIGMuc2hhcGVCID0gc2hhcGVCO1xuICAgIGMucmVzdGl0dXRpb24gPSB0aGlzLnJlc3RpdHV0aW9uO1xuICAgIGMuZmlyc3RJbXBhY3QgPSAhdGhpcy5jb2xsaWRlZExhc3RTdGVwKGJvZHlBLGJvZHlCKTtcbiAgICBjLnN0aWZmbmVzcyA9IHRoaXMuc3RpZmZuZXNzO1xuICAgIGMucmVsYXhhdGlvbiA9IHRoaXMucmVsYXhhdGlvbjtcbiAgICBjLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBjLmVuYWJsZWQgPSB0aGlzLmVuYWJsZWRFcXVhdGlvbnM7XG4gICAgYy5vZmZzZXQgPSB0aGlzLmNvbnRhY3RTa2luU2l6ZTtcblxuICAgIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgRnJpY3Rpb25FcXVhdGlvbiwgZWl0aGVyIGJ5IHJldXNpbmcgYW4gZXhpc3Rpbmcgb2JqZWN0IG9yIGNyZWF0aW5nIGEgbmV3IG9uZS5cbiAqIEBtZXRob2QgY3JlYXRlRnJpY3Rpb25FcXVhdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtGcmljdGlvbkVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbiA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qiwgc2hhcGVBLCBzaGFwZUIpe1xuICAgIHZhciBjID0gdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbC5nZXQoKTtcbiAgICBjLmJvZHlBID0gYm9keUE7XG4gICAgYy5ib2R5QiA9IGJvZHlCO1xuICAgIGMuc2hhcGVBID0gc2hhcGVBO1xuICAgIGMuc2hhcGVCID0gc2hhcGVCO1xuICAgIGMuc2V0U2xpcEZvcmNlKHRoaXMuc2xpcEZvcmNlKTtcbiAgICBjLmZyaWN0aW9uQ29lZmZpY2llbnQgPSB0aGlzLmZyaWN0aW9uQ29lZmZpY2llbnQ7XG4gICAgYy5yZWxhdGl2ZVZlbG9jaXR5ID0gdGhpcy5zdXJmYWNlVmVsb2NpdHk7XG4gICAgYy5lbmFibGVkID0gdGhpcy5lbmFibGVkRXF1YXRpb25zO1xuICAgIGMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIGMuc3RpZmZuZXNzID0gdGhpcy5mcmljdGlvblN0aWZmbmVzcztcbiAgICBjLnJlbGF4YXRpb24gPSB0aGlzLmZyaWN0aW9uUmVsYXhhdGlvbjtcbiAgICBjLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIEZyaWN0aW9uRXF1YXRpb24gZ2l2ZW4gdGhlIGRhdGEgaW4gdGhlIENvbnRhY3RFcXVhdGlvbi4gVXNlcyBzYW1lIG9mZnNldCB2ZWN0b3JzIHJpIGFuZCByaiwgYnV0IHRoZSB0YW5nZW50IHZlY3RvciB3aWxsIGJlIGNvbnN0cnVjdGVkIGZyb20gdGhlIGNvbGxpc2lvbiBub3JtYWwuXG4gKiBAbWV0aG9kIGNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3RcbiAqIEBwYXJhbSAge0NvbnRhY3RFcXVhdGlvbn0gY29udGFjdEVxdWF0aW9uXG4gKiBAcmV0dXJuIHtGcmljdGlvbkVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdCA9IGZ1bmN0aW9uKGMpe1xuICAgIHZhciBlcSA9IHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbihjLmJvZHlBLCBjLmJvZHlCLCBjLnNoYXBlQSwgYy5zaGFwZUIpO1xuICAgIHZlYzIuY29weShlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEpO1xuICAgIHZlYzIuY29weShlcS5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIpO1xuICAgIHZlYzIucm90YXRlOTBjdyhlcS50LCBjLm5vcm1hbEEpO1xuICAgIGVxLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcbiAgICByZXR1cm4gZXE7XG59O1xuXG4vLyBUYWtlIHRoZSBhdmVyYWdlIE4gbGF0ZXN0IGNvbnRhY3QgcG9pbnQgb24gdGhlIHBsYW5lLlxuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UgPSBmdW5jdGlvbihudW1Db250YWN0cyl7XG4gICAgdmFyIGMgPSB0aGlzLmNvbnRhY3RFcXVhdGlvbnNbdGhpcy5jb250YWN0RXF1YXRpb25zLmxlbmd0aCAtIDFdO1xuICAgIHZhciBlcSA9IHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbihjLmJvZHlBLCBjLmJvZHlCLCBjLnNoYXBlQSwgYy5zaGFwZUIpO1xuICAgIHZhciBib2R5QSA9IGMuYm9keUE7XG4gICAgdmFyIGJvZHlCID0gYy5ib2R5QjtcbiAgICB2ZWMyLnNldChlcS5jb250YWN0UG9pbnRBLCAwLCAwKTtcbiAgICB2ZWMyLnNldChlcS5jb250YWN0UG9pbnRCLCAwLCAwKTtcbiAgICB2ZWMyLnNldChlcS50LCAwLCAwKTtcbiAgICBmb3IodmFyIGk9MDsgaSE9PW51bUNvbnRhY3RzOyBpKyspe1xuICAgICAgICBjID0gdGhpcy5jb250YWN0RXF1YXRpb25zW3RoaXMuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgIGlmKGMuYm9keUEgPT09IGJvZHlBKXtcbiAgICAgICAgICAgIHZlYzIuYWRkKGVxLnQsIGVxLnQsIGMubm9ybWFsQSk7XG4gICAgICAgICAgICB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QiwgZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlYzIuc3ViKGVxLnQsIGVxLnQsIGMubm9ybWFsQSk7XG4gICAgICAgICAgICB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEIpO1xuICAgICAgICAgICAgdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QiwgZXEuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRBKTtcbiAgICAgICAgfVxuICAgICAgICBlcS5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG4gICAgfVxuXG4gICAgdmFyIGludk51bUNvbnRhY3RzID0gMS9udW1Db250YWN0cztcbiAgICB2ZWMyLnNjYWxlKGVxLmNvbnRhY3RQb2ludEEsIGVxLmNvbnRhY3RQb2ludEEsIGludk51bUNvbnRhY3RzKTtcbiAgICB2ZWMyLnNjYWxlKGVxLmNvbnRhY3RQb2ludEIsIGVxLmNvbnRhY3RQb2ludEIsIGludk51bUNvbnRhY3RzKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZShlcS50LCBlcS50KTtcbiAgICB2ZWMyLnJvdGF0ZTkwY3coZXEudCwgZXEudCk7XG4gICAgcmV0dXJuIGVxO1xufTtcblxuLyoqXG4gKiBDb252ZXgvbGluZSBuYXJyb3dwaGFzZVxuICogQG1ldGhvZCBjb252ZXhMaW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9ICAgICBjb252ZXhTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBjb252ZXhBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBqdXN0VGVzdFxuICogQHRvZG8gSW1wbGVtZW50IG1lIVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuTElORSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleExpbmUgPSBmdW5jdGlvbihcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleE9mZnNldCxcbiAgICBjb252ZXhBbmdsZSxcbiAgICBsaW5lQm9keSxcbiAgICBsaW5lU2hhcGUsXG4gICAgbGluZU9mZnNldCxcbiAgICBsaW5lQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgLy8gVE9ET1xuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGluZS9ib3ggbmFycm93cGhhc2VcbiAqIEBtZXRob2QgbGluZUJveFxuICogQHBhcmFtICB7Qm9keX0gICAgICAgbGluZUJvZHlcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGluZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBib3hCb2R5XG4gKiBAcGFyYW0gIHtCb3h9ICBib3hTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgYm94T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBib3hBbmdsZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gICAganVzdFRlc3RcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkxJTkUgfCBTaGFwZS5CT1hdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5saW5lQm94ID0gZnVuY3Rpb24oXG4gICAgbGluZUJvZHksXG4gICAgbGluZVNoYXBlLFxuICAgIGxpbmVPZmZzZXQsXG4gICAgbGluZUFuZ2xlLFxuICAgIGJveEJvZHksXG4gICAgYm94U2hhcGUsXG4gICAgYm94T2Zmc2V0LFxuICAgIGJveEFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIC8vIFRPRE9cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShjb252ZXhTaGFwZSwgY2Fwc3VsZVNoYXBlKXtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1swXSwgLWNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsIC1jYXBzdWxlU2hhcGUucmFkaXVzKTtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1sxXSwgIGNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsIC1jYXBzdWxlU2hhcGUucmFkaXVzKTtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1syXSwgIGNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsICBjYXBzdWxlU2hhcGUucmFkaXVzKTtcbiAgICB2ZWMyLnNldChjb252ZXhTaGFwZS52ZXJ0aWNlc1szXSwgLWNhcHN1bGVTaGFwZS5sZW5ndGggKiAwLjUsICBjYXBzdWxlU2hhcGUucmFkaXVzKTtcbn1cblxudmFyIGNvbnZleENhcHN1bGVfdGVtcFJlY3QgPSBuZXcgQm94KHsgd2lkdGg6IDEsIGhlaWdodDogMSB9KSxcbiAgICBjb252ZXhDYXBzdWxlX3RlbXBWZWMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIENvbnZleC9jYXBzdWxlIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNvbnZleENhcHN1bGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGNvbnZleEJvZHlcbiAqIEBwYXJhbSAge0NvbnZleH0gICAgIGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBjb252ZXhQb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgY29udmV4QW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGNhcHN1bGVCb2R5XG4gKiBAcGFyYW0gIHtDYXBzdWxlfSAgICBjYXBzdWxlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGNhcHN1bGVQb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgY2Fwc3VsZUFuZ2xlXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DQVBTVUxFIHwgU2hhcGUuQ09OVkVYXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0FQU1VMRSB8IFNoYXBlLkJPWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleENhcHN1bGUgPSBmdW5jdGlvbihcbiAgICBjb252ZXhCb2R5LFxuICAgIGNvbnZleFNoYXBlLFxuICAgIGNvbnZleFBvc2l0aW9uLFxuICAgIGNvbnZleEFuZ2xlLFxuICAgIGNhcHN1bGVCb2R5LFxuICAgIGNhcHN1bGVTaGFwZSxcbiAgICBjYXBzdWxlUG9zaXRpb24sXG4gICAgY2Fwc3VsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuXG4gICAgLy8gQ2hlY2sgdGhlIGNpcmNsZXNcbiAgICAvLyBBZGQgb2Zmc2V0cyFcbiAgICB2YXIgY2lyY2xlUG9zID0gY29udmV4Q2Fwc3VsZV90ZW1wVmVjO1xuICAgIHZlYzIuc2V0KGNpcmNsZVBvcywgY2Fwc3VsZVNoYXBlLmxlbmd0aC8yLDApO1xuICAgIHZlYzIucm90YXRlKGNpcmNsZVBvcyxjaXJjbGVQb3MsY2Fwc3VsZUFuZ2xlKTtcbiAgICB2ZWMyLmFkZChjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVQb3NpdGlvbik7XG4gICAgdmFyIHJlc3VsdDEgPSB0aGlzLmNpcmNsZUNvbnZleChjYXBzdWxlQm9keSxjYXBzdWxlU2hhcGUsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSwgY29udmV4Qm9keSxjb252ZXhTaGFwZSxjb252ZXhQb3NpdGlvbixjb252ZXhBbmdsZSwganVzdFRlc3QsIGNhcHN1bGVTaGFwZS5yYWRpdXMpO1xuXG4gICAgdmVjMi5zZXQoY2lyY2xlUG9zLC1jYXBzdWxlU2hhcGUubGVuZ3RoLzIsIDApO1xuICAgIHZlYzIucm90YXRlKGNpcmNsZVBvcyxjaXJjbGVQb3MsY2Fwc3VsZUFuZ2xlKTtcbiAgICB2ZWMyLmFkZChjaXJjbGVQb3MsY2lyY2xlUG9zLGNhcHN1bGVQb3NpdGlvbik7XG4gICAgdmFyIHJlc3VsdDIgPSB0aGlzLmNpcmNsZUNvbnZleChjYXBzdWxlQm9keSxjYXBzdWxlU2hhcGUsY2lyY2xlUG9zLGNhcHN1bGVBbmdsZSwgY29udmV4Qm9keSxjb252ZXhTaGFwZSxjb252ZXhQb3NpdGlvbixjb252ZXhBbmdsZSwganVzdFRlc3QsIGNhcHN1bGVTaGFwZS5yYWRpdXMpO1xuXG4gICAgaWYoanVzdFRlc3QgJiYgKHJlc3VsdDEgfHwgcmVzdWx0Mikpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjZW50ZXIgcmVjdFxuICAgIHZhciByID0gY29udmV4Q2Fwc3VsZV90ZW1wUmVjdDtcbiAgICBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShyLGNhcHN1bGVTaGFwZSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuY29udmV4Q29udmV4KGNvbnZleEJvZHksY29udmV4U2hhcGUsY29udmV4UG9zaXRpb24sY29udmV4QW5nbGUsIGNhcHN1bGVCb2R5LHIsY2Fwc3VsZVBvc2l0aW9uLGNhcHN1bGVBbmdsZSwganVzdFRlc3QpO1xuXG4gICAgcmV0dXJuIHJlc3VsdCArIHJlc3VsdDEgKyByZXN1bHQyO1xufTtcblxuLyoqXG4gKiBDYXBzdWxlL2xpbmUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgbGluZUNhcHN1bGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGxpbmVCb2R5XG4gKiBAcGFyYW0gIHtMaW5lfSAgICAgICBsaW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGxpbmVQb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgbGluZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBjYXBzdWxlQm9keVxuICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgY2Fwc3VsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBjYXBzdWxlUG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGNhcHN1bGVBbmdsZVxuICogQHRvZG8gSW1wbGVtZW50IG1lIVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0FQU1VMRSB8IFNoYXBlLkxJTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5saW5lQ2Fwc3VsZSA9IGZ1bmN0aW9uKFxuICAgIGxpbmVCb2R5LFxuICAgIGxpbmVTaGFwZSxcbiAgICBsaW5lUG9zaXRpb24sXG4gICAgbGluZUFuZ2xlLFxuICAgIGNhcHN1bGVCb2R5LFxuICAgIGNhcHN1bGVTaGFwZSxcbiAgICBjYXBzdWxlUG9zaXRpb24sXG4gICAgY2Fwc3VsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIC8vIFRPRE9cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG52YXIgY2Fwc3VsZUNhcHN1bGVfdGVtcFZlYzEgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMyID0gdmVjMi5jcmVhdGUoKTtcbnZhciBjYXBzdWxlQ2Fwc3VsZV90ZW1wUmVjdDEgPSBuZXcgQm94KHsgd2lkdGg6IDEsIGhlaWdodDogMSB9KTtcblxuLyoqXG4gKiBDYXBzdWxlL2NhcHN1bGUgbmFycm93cGhhc2VcbiAqIEBtZXRob2QgY2Fwc3VsZUNhcHN1bGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtDYXBzdWxlfSAgICBzaVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgeGlcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICogQHBhcmFtICB7Q2Fwc3VsZX0gICAgc2pcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHhqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhalxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0FQU1VMRSB8IFNoYXBlLkNBUFNVTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jYXBzdWxlQ2Fwc3VsZSA9IGZ1bmN0aW9uKGJpLHNpLHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3Qpe1xuXG4gICAgdmFyIGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGNpcmNsZXNcbiAgICAvLyBBZGQgb2Zmc2V0cyFcbiAgICB2YXIgY2lyY2xlUG9zaSA9IGNhcHN1bGVDYXBzdWxlX3RlbXBWZWMxLFxuICAgICAgICBjaXJjbGVQb3NqID0gY2Fwc3VsZUNhcHN1bGVfdGVtcFZlYzI7XG5cbiAgICB2YXIgbnVtQ29udGFjdHMgPSAwO1xuXG5cbiAgICAvLyBOZWVkIDQgY2lyY2xlIGNoZWNrcywgYmV0d2VlbiBhbGxcbiAgICBmb3IodmFyIGk9MDsgaTwyOyBpKyspe1xuXG4gICAgICAgIHZlYzIuc2V0KGNpcmNsZVBvc2ksKGk9PT0wPy0xOjEpKnNpLmxlbmd0aC8yLDApO1xuICAgICAgICB2ZWMyLnJvdGF0ZShjaXJjbGVQb3NpLGNpcmNsZVBvc2ksYWkpO1xuICAgICAgICB2ZWMyLmFkZChjaXJjbGVQb3NpLGNpcmNsZVBvc2kseGkpO1xuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqPDI7IGorKyl7XG5cbiAgICAgICAgICAgIHZlYzIuc2V0KGNpcmNsZVBvc2osKGo9PT0wPy0xOjEpKnNqLmxlbmd0aC8yLCAwKTtcbiAgICAgICAgICAgIHZlYzIucm90YXRlKGNpcmNsZVBvc2osY2lyY2xlUG9zaixhaik7XG4gICAgICAgICAgICB2ZWMyLmFkZChjaXJjbGVQb3NqLGNpcmNsZVBvc2oseGopO1xuXG4gICAgICAgICAgICAvLyBUZW1wb3JhcmlseSB0dXJuIG9mZiBmcmljdGlvblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgZW5hYmxlRnJpY3Rpb25CZWZvcmUgPSB0aGlzLmVuYWJsZUZyaWN0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2lyY2xlQ2lyY2xlKGJpLHNpLGNpcmNsZVBvc2ksYWksIGJqLHNqLGNpcmNsZVBvc2osYWosIGp1c3RUZXN0LCBzaS5yYWRpdXMsIHNqLnJhZGl1cyk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBlbmFibGVGcmljdGlvbkJlZm9yZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoanVzdFRlc3QgJiYgcmVzdWx0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbnVtQ29udGFjdHMgKz0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IHR1cm4gb2ZmIGZyaWN0aW9uXG4gICAgICAgIGVuYWJsZUZyaWN0aW9uQmVmb3JlID0gdGhpcy5lbmFibGVGcmljdGlvbjtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGNpcmNsZXMgYWdhaW5zdCB0aGUgY2VudGVyIGJveHNcbiAgICB2YXIgcmVjdCA9IGNhcHN1bGVDYXBzdWxlX3RlbXBSZWN0MTtcbiAgICBzZXRDb252ZXhUb0NhcHN1bGVTaGFwZU1pZGRsZShyZWN0LHNpKTtcbiAgICB2YXIgcmVzdWx0MSA9IHRoaXMuY29udmV4Q2Fwc3VsZShiaSxyZWN0LHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3QpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBlbmFibGVGcmljdGlvbkJlZm9yZTtcbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCAmJiByZXN1bHQxKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG51bUNvbnRhY3RzICs9IHJlc3VsdDE7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgdHVybiBvZmYgZnJpY3Rpb25cbiAgICAgICAgdmFyIGVuYWJsZUZyaWN0aW9uQmVmb3JlID0gdGhpcy5lbmFibGVGcmljdGlvbjtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHNldENvbnZleFRvQ2Fwc3VsZVNoYXBlTWlkZGxlKHJlY3Qsc2opO1xuICAgIHZhciByZXN1bHQyID0gdGhpcy5jb252ZXhDYXBzdWxlKGJqLHJlY3QseGosYWosIGJpLHNpLHhpLGFpLCBqdXN0VGVzdCk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgdGhpcy5lbmFibGVGcmljdGlvbiA9IGVuYWJsZUZyaWN0aW9uQmVmb3JlO1xuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0ICYmIHJlc3VsdDIpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbnVtQ29udGFjdHMgKz0gcmVzdWx0MjtcblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICBpZihudW1Db250YWN0cyAmJiB0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1Db250YWN0cztcbn07XG5cbi8qKlxuICogTGluZS9saW5lIG5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGxpbmVMaW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBib2R5QVxuICogQHBhcmFtICB7TGluZX0gICAgICAgc2hhcGVBXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICBwb3NpdGlvbkFcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlQVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYm9keUJcbiAqIEBwYXJhbSAge0xpbmV9ICAgICAgIHNoYXBlQlxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcG9zaXRpb25CXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBhbmdsZUJcbiAqIEB0b2RvIEltcGxlbWVudCBtZSFcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkxJTkUgfCBTaGFwZS5MSU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUubGluZUxpbmUgPSBmdW5jdGlvbihcbiAgICBib2R5QSxcbiAgICBzaGFwZUEsXG4gICAgcG9zaXRpb25BLFxuICAgIGFuZ2xlQSxcbiAgICBib2R5QixcbiAgICBzaGFwZUIsXG4gICAgcG9zaXRpb25CLFxuICAgIGFuZ2xlQixcbiAgICBqdXN0VGVzdFxuKXtcbiAgICAvLyBUT0RPXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQbGFuZS9saW5lIE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIHBsYW5lTGluZVxuICogQHBhcmFtICB7Qm9keX0gICBwbGFuZUJvZHlcbiAqIEBwYXJhbSAge1BsYW5lfSAgcGxhbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICBwbGFuZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBwbGFuZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgIGxpbmVCb2R5XG4gKiBAcGFyYW0gIHtMaW5lfSAgIGxpbmVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9ICBsaW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGxpbmVBbmdsZVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5MSU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVMaW5lID0gZnVuY3Rpb24ocGxhbmVCb2R5LCBwbGFuZVNoYXBlLCBwbGFuZU9mZnNldCwgcGxhbmVBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lQm9keSwgIGxpbmVTaGFwZSwgIGxpbmVPZmZzZXQsICBsaW5lQW5nbGUsIGp1c3RUZXN0KXtcbiAgICB2YXIgd29ybGRWZXJ0ZXgwID0gdG1wMSxcbiAgICAgICAgd29ybGRWZXJ0ZXgxID0gdG1wMixcbiAgICAgICAgd29ybGRWZXJ0ZXgwMSA9IHRtcDMsXG4gICAgICAgIHdvcmxkVmVydGV4MTEgPSB0bXA0LFxuICAgICAgICB3b3JsZEVkZ2UgPSB0bXA1LFxuICAgICAgICB3b3JsZEVkZ2VVbml0ID0gdG1wNixcbiAgICAgICAgZGlzdCA9IHRtcDcsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wOCxcbiAgICAgICAgd29ybGRUYW5nZW50ID0gdG1wOSxcbiAgICAgICAgdmVydHMgPSB0bXBBcnJheSxcbiAgICAgICAgbnVtQ29udGFjdHMgPSAwO1xuXG4gICAgLy8gR2V0IHN0YXJ0IGFuZCBlbmQgcG9pbnRzXG4gICAgdmVjMi5zZXQod29ybGRWZXJ0ZXgwLCAtbGluZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnNldCh3b3JsZFZlcnRleDEsICBsaW5lU2hhcGUubGVuZ3RoLzIsIDApO1xuXG4gICAgLy8gTm90IHN1cmUgd2h5IHdlIGhhdmUgdG8gdXNlIHdvcmxkVmVydGV4KjEgaGVyZSwgYnV0IGl0IHdvbid0IHdvcmsgb3RoZXJ3aXNlLiBUaXJlZC5cbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDAxLCB3b3JsZFZlcnRleDAsIGxpbmVBbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgxMSwgd29ybGRWZXJ0ZXgxLCBsaW5lQW5nbGUpO1xuXG4gICAgYWRkKHdvcmxkVmVydGV4MDEsIHdvcmxkVmVydGV4MDEsIGxpbmVPZmZzZXQpO1xuICAgIGFkZCh3b3JsZFZlcnRleDExLCB3b3JsZFZlcnRleDExLCBsaW5lT2Zmc2V0KTtcblxuICAgIHZlYzIuY29weSh3b3JsZFZlcnRleDAsd29ybGRWZXJ0ZXgwMSk7XG4gICAgdmVjMi5jb3B5KHdvcmxkVmVydGV4MSx3b3JsZFZlcnRleDExKTtcblxuICAgIC8vIEdldCB2ZWN0b3IgYWxvbmcgdGhlIGxpbmVcbiAgICBzdWIod29ybGRFZGdlLCB3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MCk7XG4gICAgdmVjMi5ub3JtYWxpemUod29ybGRFZGdlVW5pdCwgd29ybGRFZGdlKTtcblxuICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLlxuICAgIHZlYzIucm90YXRlOTBjdyh3b3JsZFRhbmdlbnQsIHdvcmxkRWRnZVVuaXQpO1xuXG4gICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcblxuICAgIC8vIENoZWNrIGxpbmUgZW5kc1xuICAgIHZlcnRzWzBdID0gd29ybGRWZXJ0ZXgwO1xuICAgIHZlcnRzWzFdID0gd29ybGRWZXJ0ZXgxO1xuICAgIGZvcih2YXIgaT0wOyBpPHZlcnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcblxuICAgICAgICBzdWIoZGlzdCwgdiwgcGxhbmVPZmZzZXQpO1xuXG4gICAgICAgIHZhciBkID0gZG90KGRpc3Qsd29ybGROb3JtYWwpO1xuXG4gICAgICAgIGlmKGQgPCAwKXtcblxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSxsaW5lQm9keSxwbGFuZVNoYXBlLGxpbmVTaGFwZSk7XG4gICAgICAgICAgICBudW1Db250YWN0cysrO1xuXG4gICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XG4gICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgLy8gZGlzdGFuY2UgdmVjdG9yIGFsb25nIHBsYW5lIG5vcm1hbFxuICAgICAgICAgICAgdmVjMi5zY2FsZShkaXN0LCB3b3JsZE5vcm1hbCwgZCk7XG5cbiAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIHBsYW5lIGNlbnRlciB0byBjb250YWN0XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCB2LCBkaXN0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGxhbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgLy8gRnJvbSBsaW5lIGNlbnRlciB0byBjb250YWN0XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB2LCAgICBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZU9mZnNldCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICBpZihudW1Db250YWN0cyAmJiB0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1Db250YWN0cztcbn07XG5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QQVJUSUNMRSB8IFNoYXBlLkNBUFNVTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wYXJ0aWNsZUNhcHN1bGUgPSBmdW5jdGlvbihcbiAgICBwYXJ0aWNsZUJvZHksXG4gICAgcGFydGljbGVTaGFwZSxcbiAgICBwYXJ0aWNsZVBvc2l0aW9uLFxuICAgIHBhcnRpY2xlQW5nbGUsXG4gICAgY2Fwc3VsZUJvZHksXG4gICAgY2Fwc3VsZVNoYXBlLFxuICAgIGNhcHN1bGVQb3NpdGlvbixcbiAgICBjYXBzdWxlQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgcmV0dXJuIHRoaXMuY2lyY2xlTGluZShwYXJ0aWNsZUJvZHkscGFydGljbGVTaGFwZSxwYXJ0aWNsZVBvc2l0aW9uLHBhcnRpY2xlQW5nbGUsIGNhcHN1bGVCb2R5LGNhcHN1bGVTaGFwZSxjYXBzdWxlUG9zaXRpb24sY2Fwc3VsZUFuZ2xlLCBqdXN0VGVzdCwgY2Fwc3VsZVNoYXBlLnJhZGl1cywgMCk7XG59O1xuXG4vKipcbiAqIENpcmNsZS9saW5lIE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNpcmNsZUxpbmVcbiAqIEBwYXJhbSAge0JvZHl9IGNpcmNsZUJvZHlcbiAqIEBwYXJhbSAge0NpcmNsZX0gY2lyY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjaXJjbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY2lyY2xlQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IGxpbmVCb2R5XG4gKiBAcGFyYW0gIHtMaW5lfSBsaW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBsaW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGxpbmVBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdCBJZiBzZXQgdG8gdHJ1ZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IChpbnRlcnNlY3Rpb24gb3Igbm90KSB3aXRob3V0IGFkZGluZyBlcXVhdGlvbnMuXG4gKiBAcGFyYW0ge051bWJlcn0gbGluZVJhZGl1cyBSYWRpdXMgdG8gYWRkIHRvIHRoZSBsaW5lLiBDYW4gYmUgdXNlZCB0byB0ZXN0IENhcHN1bGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNpcmNsZVJhZGl1cyBJZiBzZXQsIHRoaXMgdmFsdWUgb3ZlcnJpZGVzIHRoZSBjaXJjbGUgc2hhcGUgcmFkaXVzLlxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuTElORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUxpbmUgPSBmdW5jdGlvbihcbiAgICBjaXJjbGVCb2R5LFxuICAgIGNpcmNsZVNoYXBlLFxuICAgIGNpcmNsZU9mZnNldCxcbiAgICBjaXJjbGVBbmdsZSxcbiAgICBsaW5lQm9keSxcbiAgICBsaW5lU2hhcGUsXG4gICAgbGluZU9mZnNldCxcbiAgICBsaW5lQW5nbGUsXG4gICAganVzdFRlc3QsXG4gICAgbGluZVJhZGl1cyxcbiAgICBjaXJjbGVSYWRpdXNcbil7XG4gICAgdmFyIGxpbmVSYWRpdXMgPSBsaW5lUmFkaXVzIHx8IDAsXG4gICAgICAgIGNpcmNsZVJhZGl1cyA9IHR5cGVvZihjaXJjbGVSYWRpdXMpIT09XCJ1bmRlZmluZWRcIiA/IGNpcmNsZVJhZGl1cyA6IGNpcmNsZVNoYXBlLnJhZGl1cyxcblxuICAgICAgICBvcnRob0Rpc3QgPSB0bXAxLFxuICAgICAgICBsaW5lVG9DaXJjbGVPcnRob1VuaXQgPSB0bXAyLFxuICAgICAgICBwcm9qZWN0ZWRQb2ludCA9IHRtcDMsXG4gICAgICAgIGNlbnRlckRpc3QgPSB0bXA0LFxuICAgICAgICB3b3JsZFRhbmdlbnQgPSB0bXA1LFxuICAgICAgICB3b3JsZEVkZ2UgPSB0bXA2LFxuICAgICAgICB3b3JsZEVkZ2VVbml0ID0gdG1wNyxcbiAgICAgICAgd29ybGRWZXJ0ZXgwID0gdG1wOCxcbiAgICAgICAgd29ybGRWZXJ0ZXgxID0gdG1wOSxcbiAgICAgICAgd29ybGRWZXJ0ZXgwMSA9IHRtcDEwLFxuICAgICAgICB3b3JsZFZlcnRleDExID0gdG1wMTEsXG4gICAgICAgIGRpc3QgPSB0bXAxMixcbiAgICAgICAgbGluZVRvQ2lyY2xlID0gdG1wMTMsXG4gICAgICAgIGxpbmVFbmRUb0xpbmVSYWRpdXMgPSB0bXAxNCxcblxuICAgICAgICB2ZXJ0cyA9IHRtcEFycmF5O1xuXG4gICAgLy8gR2V0IHN0YXJ0IGFuZCBlbmQgcG9pbnRzXG4gICAgdmVjMi5zZXQod29ybGRWZXJ0ZXgwLCAtbGluZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnNldCh3b3JsZFZlcnRleDEsICBsaW5lU2hhcGUubGVuZ3RoLzIsIDApO1xuXG4gICAgLy8gTm90IHN1cmUgd2h5IHdlIGhhdmUgdG8gdXNlIHdvcmxkVmVydGV4KjEgaGVyZSwgYnV0IGl0IHdvbid0IHdvcmsgb3RoZXJ3aXNlLiBUaXJlZC5cbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDAxLCB3b3JsZFZlcnRleDAsIGxpbmVBbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgxMSwgd29ybGRWZXJ0ZXgxLCBsaW5lQW5nbGUpO1xuXG4gICAgYWRkKHdvcmxkVmVydGV4MDEsIHdvcmxkVmVydGV4MDEsIGxpbmVPZmZzZXQpO1xuICAgIGFkZCh3b3JsZFZlcnRleDExLCB3b3JsZFZlcnRleDExLCBsaW5lT2Zmc2V0KTtcblxuICAgIHZlYzIuY29weSh3b3JsZFZlcnRleDAsd29ybGRWZXJ0ZXgwMSk7XG4gICAgdmVjMi5jb3B5KHdvcmxkVmVydGV4MSx3b3JsZFZlcnRleDExKTtcblxuICAgIC8vIEdldCB2ZWN0b3IgYWxvbmcgdGhlIGxpbmVcbiAgICBzdWIod29ybGRFZGdlLCB3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MCk7XG4gICAgdmVjMi5ub3JtYWxpemUod29ybGRFZGdlVW5pdCwgd29ybGRFZGdlKTtcblxuICAgIC8vIEdldCB0YW5nZW50IHRvIHRoZSBlZGdlLlxuICAgIHZlYzIucm90YXRlOTBjdyh3b3JsZFRhbmdlbnQsIHdvcmxkRWRnZVVuaXQpO1xuXG4gICAgLy8gQ2hlY2sgZGlzdGFuY2UgZnJvbSB0aGUgcGxhbmUgc3Bhbm5lZCBieSB0aGUgZWRnZSB2cyB0aGUgY2lyY2xlXG4gICAgc3ViKGRpc3QsIGNpcmNsZU9mZnNldCwgd29ybGRWZXJ0ZXgwKTtcbiAgICB2YXIgZCA9IGRvdChkaXN0LCB3b3JsZFRhbmdlbnQpOyAvLyBEaXN0YW5jZSBmcm9tIGNlbnRlciBvZiBsaW5lIHRvIGNpcmNsZSBjZW50ZXJcbiAgICBzdWIoY2VudGVyRGlzdCwgd29ybGRWZXJ0ZXgwLCBsaW5lT2Zmc2V0KTtcblxuICAgIHN1YihsaW5lVG9DaXJjbGUsIGNpcmNsZU9mZnNldCwgbGluZU9mZnNldCk7XG5cbiAgICB2YXIgcmFkaXVzU3VtID0gY2lyY2xlUmFkaXVzICsgbGluZVJhZGl1cztcblxuICAgIGlmKE1hdGguYWJzKGQpIDwgcmFkaXVzU3VtKXtcblxuICAgICAgICAvLyBOb3cgcHJvamVjdCB0aGUgY2lyY2xlIG9udG8gdGhlIGVkZ2VcbiAgICAgICAgdmVjMi5zY2FsZShvcnRob0Rpc3QsIHdvcmxkVGFuZ2VudCwgZCk7XG4gICAgICAgIHN1Yihwcm9qZWN0ZWRQb2ludCwgY2lyY2xlT2Zmc2V0LCBvcnRob0Rpc3QpO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgbWlzc2luZyBsaW5lIHJhZGl1c1xuICAgICAgICB2ZWMyLnNjYWxlKGxpbmVUb0NpcmNsZU9ydGhvVW5pdCwgd29ybGRUYW5nZW50LCBkb3Qod29ybGRUYW5nZW50LCBsaW5lVG9DaXJjbGUpKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUobGluZVRvQ2lyY2xlT3J0aG9Vbml0LGxpbmVUb0NpcmNsZU9ydGhvVW5pdCk7XG4gICAgICAgIHZlYzIuc2NhbGUobGluZVRvQ2lyY2xlT3J0aG9Vbml0LCBsaW5lVG9DaXJjbGVPcnRob1VuaXQsIGxpbmVSYWRpdXMpO1xuICAgICAgICBhZGQocHJvamVjdGVkUG9pbnQscHJvamVjdGVkUG9pbnQsbGluZVRvQ2lyY2xlT3J0aG9Vbml0KTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBlZGdlIHNwYW5cbiAgICAgICAgdmFyIHBvcyA9ICBkb3Qod29ybGRFZGdlVW5pdCwgcHJvamVjdGVkUG9pbnQpO1xuICAgICAgICB2YXIgcG9zMCA9IGRvdCh3b3JsZEVkZ2VVbml0LCB3b3JsZFZlcnRleDApO1xuICAgICAgICB2YXIgcG9zMSA9IGRvdCh3b3JsZEVkZ2VVbml0LCB3b3JsZFZlcnRleDEpO1xuXG4gICAgICAgIGlmKHBvcyA+IHBvczAgJiYgcG9zIDwgcG9zMSl7XG4gICAgICAgICAgICAvLyBXZSBnb3QgY29udGFjdCFcblxuICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksbGluZUJvZHksY2lyY2xlU2hhcGUsbGluZVNoYXBlKTtcblxuICAgICAgICAgICAgdmVjMi5zY2FsZShjLm5vcm1hbEEsIG9ydGhvRGlzdCwgLTEpO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLCBjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKCBjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgIGNpcmNsZVJhZGl1cyk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBwcm9qZWN0ZWRQb2ludCwgbGluZU9mZnNldCk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVPZmZzZXQpO1xuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgY29ybmVyXG4gICAgdmVydHNbMF0gPSB3b3JsZFZlcnRleDA7XG4gICAgdmVydHNbMV0gPSB3b3JsZFZlcnRleDE7XG5cbiAgICBmb3IodmFyIGk9MDsgaTx2ZXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdmVydHNbaV07XG5cbiAgICAgICAgc3ViKGRpc3QsIHYsIGNpcmNsZU9mZnNldCk7XG5cbiAgICAgICAgaWYodmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpIDwgTWF0aC5wb3cocmFkaXVzU3VtLCAyKSl7XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LGxpbmVCb2R5LGNpcmNsZVNoYXBlLGxpbmVTaGFwZSk7XG5cbiAgICAgICAgICAgIHZlYzIuY29weShjLm5vcm1hbEEsIGRpc3QpO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBjb250YWN0IHBvaW50IGlzIHRoZSBub3JtYWwgdGltZXMgdGhlIGNpcmNsZSByYWRpdXNcbiAgICAgICAgICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRBLCBjLm5vcm1hbEEsIGNpcmNsZVJhZGl1cyk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCB2LCBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIHZlYzIuc2NhbGUobGluZUVuZFRvTGluZVJhZGl1cywgYy5ub3JtYWxBLCAtbGluZVJhZGl1cyk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGxpbmVFbmRUb0xpbmVSYWRpdXMpO1xuICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBsaW5lT2Zmc2V0KTtcbiAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgbGluZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIENpcmNsZS9jYXBzdWxlIE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNpcmNsZUNhcHN1bGVcbiAqIEBwYXJhbSAge0JvZHl9ICAgYmlcbiAqIEBwYXJhbSAge0NpcmNsZX0gc2lcbiAqIEBwYXJhbSAge0FycmF5fSAgeGlcbiAqIEBwYXJhbSAge051bWJlcn0gYWlcbiAqIEBwYXJhbSAge0JvZHl9ICAgYmpcbiAqIEBwYXJhbSAge0xpbmV9ICAgc2pcbiAqIEBwYXJhbSAge0FycmF5fSAgeGpcbiAqIEBwYXJhbSAge051bWJlcn0gYWpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLkNBUFNVTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVDYXBzdWxlID0gZnVuY3Rpb24oYmksc2kseGksYWksIGJqLHNqLHhqLGFqLCBqdXN0VGVzdCl7XG4gICAgcmV0dXJuIHRoaXMuY2lyY2xlTGluZShiaSxzaSx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0LCBzai5yYWRpdXMpO1xufTtcblxuLyoqXG4gKiBDaXJjbGUvY29udmV4IE5hcnJvd3BoYXNlLlxuICogQG1ldGhvZCBjaXJjbGVDb252ZXhcbiAqIEBwYXJhbSAge0JvZHl9IGNpcmNsZUJvZHlcbiAqIEBwYXJhbSAge0NpcmNsZX0gY2lyY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjaXJjbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY2lyY2xlQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IGNvbnZleEJvZHlcbiAqIEBwYXJhbSAge0NvbnZleH0gY29udmV4U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjb252ZXhPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY29udmV4QW5nbGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGp1c3RUZXN0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNpcmNsZVJhZGl1c1xuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuQ09OVkVYXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuQk9YXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlQ29udmV4ID0gZnVuY3Rpb24oXG4gICAgY2lyY2xlQm9keSxcbiAgICBjaXJjbGVTaGFwZSxcbiAgICBjaXJjbGVPZmZzZXQsXG4gICAgY2lyY2xlQW5nbGUsXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhPZmZzZXQsXG4gICAgY29udmV4QW5nbGUsXG4gICAganVzdFRlc3QsXG4gICAgY2lyY2xlUmFkaXVzXG4pe1xuICAgIHZhciBjaXJjbGVSYWRpdXMgPSB0eXBlb2YoY2lyY2xlUmFkaXVzKT09PVwibnVtYmVyXCIgPyBjaXJjbGVSYWRpdXMgOiBjaXJjbGVTaGFwZS5yYWRpdXM7XG5cbiAgICB2YXIgd29ybGRWZXJ0ZXgwID0gdG1wMSxcbiAgICAgICAgd29ybGRWZXJ0ZXgxID0gdG1wMixcbiAgICAgICAgd29ybGRFZGdlID0gdG1wMyxcbiAgICAgICAgd29ybGRFZGdlVW5pdCA9IHRtcDQsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wNSxcbiAgICAgICAgY2VudGVyRGlzdCA9IHRtcDYsXG4gICAgICAgIGNvbnZleFRvQ2lyY2xlID0gdG1wNyxcbiAgICAgICAgb3J0aG9EaXN0ID0gdG1wOCxcbiAgICAgICAgcHJvamVjdGVkUG9pbnQgPSB0bXA5LFxuICAgICAgICBkaXN0ID0gdG1wMTAsXG4gICAgICAgIHdvcmxkVmVydGV4ID0gdG1wMTEsXG5cbiAgICAgICAgY2xvc2VzdEVkZ2UgPSAtMSxcbiAgICAgICAgY2xvc2VzdEVkZ2VEaXN0YW5jZSA9IG51bGwsXG4gICAgICAgIGNsb3Nlc3RFZGdlT3J0aG9EaXN0ID0gdG1wMTIsXG4gICAgICAgIGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQgPSB0bXAxMyxcbiAgICAgICAgY2FuZGlkYXRlID0gdG1wMTQsXG4gICAgICAgIGNhbmRpZGF0ZURpc3QgPSB0bXAxNSxcbiAgICAgICAgbWluQ2FuZGlkYXRlID0gdG1wMTYsXG5cbiAgICAgICAgZm91bmQgPSBmYWxzZSxcbiAgICAgICAgbWluQ2FuZGlkYXRlRGlzdGFuY2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgdmFyIG51bVJlcG9ydGVkID0gMDtcblxuICAgIC8vIE5ldyBhbGdvcml0aG06XG4gICAgLy8gMS4gQ2hlY2sgc28gY2VudGVyIG9mIGNpcmNsZSBpcyBub3QgaW5zaWRlIHRoZSBwb2x5Z29uLiBJZiBpdCBpcywgdGhpcyB3b250IHdvcmsuLi5cbiAgICAvLyAyLiBGb3IgZWFjaCBlZGdlXG4gICAgLy8gMi4gMS4gR2V0IHBvaW50IG9uIGNpcmNsZSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIGVkZ2UgKHNjYWxlIG5vcm1hbCB3aXRoIC1yYWRpdXMpXG4gICAgLy8gMi4gMi4gQ2hlY2sgaWYgcG9pbnQgaXMgaW5zaWRlLlxuXG4gICAgdmFyIHZlcnRzID0gY29udmV4U2hhcGUudmVydGljZXM7XG5cbiAgICAvLyBDaGVjayBhbGwgZWRnZXMgZmlyc3RcbiAgICBmb3IodmFyIGk9MDsgaSE9PXZlcnRzLmxlbmd0aCsxOyBpKyspe1xuICAgICAgICB2YXIgdjAgPSB2ZXJ0c1tpJXZlcnRzLmxlbmd0aF0sXG4gICAgICAgICAgICB2MSA9IHZlcnRzWyhpKzEpJXZlcnRzLmxlbmd0aF07XG5cbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgwLCB2MCwgY29udmV4QW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlcnRleDEsIHYxLCBjb252ZXhBbmdsZSk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDAsIHdvcmxkVmVydGV4MCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4MSwgd29ybGRWZXJ0ZXgxLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBzdWIod29ybGRFZGdlLCB3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MCk7XG5cbiAgICAgICAgdmVjMi5ub3JtYWxpemUod29ybGRFZGdlVW5pdCwgd29ybGRFZGdlKTtcblxuICAgICAgICAvLyBHZXQgdGFuZ2VudCB0byB0aGUgZWRnZS4gUG9pbnRzIG91dCBvZiB0aGUgQ29udmV4XG4gICAgICAgIHZlYzIucm90YXRlOTBjdyh3b3JsZE5vcm1hbCwgd29ybGRFZGdlVW5pdCk7XG5cbiAgICAgICAgLy8gR2V0IHBvaW50IG9uIGNpcmNsZSwgY2xvc2VzdCB0byB0aGUgcG9seWdvblxuICAgICAgICB2ZWMyLnNjYWxlKGNhbmRpZGF0ZSx3b3JsZE5vcm1hbCwtY2lyY2xlU2hhcGUucmFkaXVzKTtcbiAgICAgICAgYWRkKGNhbmRpZGF0ZSxjYW5kaWRhdGUsY2lyY2xlT2Zmc2V0KTtcblxuICAgICAgICBpZihwb2ludEluQ29udmV4KGNhbmRpZGF0ZSxjb252ZXhTaGFwZSxjb252ZXhPZmZzZXQsY29udmV4QW5nbGUpKXtcblxuICAgICAgICAgICAgdmVjMi5zdWIoY2FuZGlkYXRlRGlzdCx3b3JsZFZlcnRleDAsY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGVEaXN0YW5jZSA9IE1hdGguYWJzKHZlYzIuZG90KGNhbmRpZGF0ZURpc3Qsd29ybGROb3JtYWwpKTtcblxuICAgICAgICAgICAgaWYoY2FuZGlkYXRlRGlzdGFuY2UgPCBtaW5DYW5kaWRhdGVEaXN0YW5jZSl7XG4gICAgICAgICAgICAgICAgdmVjMi5jb3B5KG1pbkNhbmRpZGF0ZSxjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gY2FuZGlkYXRlRGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdmVjMi5zY2FsZShjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LHdvcmxkTm9ybWFsLGNhbmRpZGF0ZURpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB2ZWMyLmFkZChjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQsY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihmb3VuZCl7XG5cbiAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGNpcmNsZUJvZHksY29udmV4Qm9keSxjaXJjbGVTaGFwZSxjb252ZXhTaGFwZSk7XG4gICAgICAgIHZlYzIuc3ViKGMubm9ybWFsQSwgbWluQ2FuZGlkYXRlLCBjaXJjbGVPZmZzZXQpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsIGMubm9ybWFsQSk7XG5cbiAgICAgICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEEsICBjLm5vcm1hbEEsIGNpcmNsZVJhZGl1cyk7XG4gICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4Qm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgYWxsIHZlcnRpY2VzXG4gICAgaWYoY2lyY2xlUmFkaXVzID4gMCl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHZlcnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBsb2NhbFZlcnRleCA9IHZlcnRzW2ldO1xuICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgsIGxvY2FsVmVydGV4LCBjb252ZXhBbmdsZSk7XG4gICAgICAgICAgICBhZGQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4LCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRWZXJ0ZXgsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgICAgICBpZih2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCkgPCBNYXRoLnBvdyhjaXJjbGVSYWRpdXMsIDIpKXtcblxuICAgICAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LGNvbnZleEJvZHksY2lyY2xlU2hhcGUsY29udmV4U2hhcGUpO1xuXG4gICAgICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgZGlzdCk7XG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUoYy5ub3JtYWxBLGMubm9ybWFsQSk7XG5cbiAgICAgICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBjaXJjbGUgdG8gY29udGFjdCBwb2ludCBpcyB0aGUgbm9ybWFsIHRpbWVzIHRoZSBjaXJjbGUgcmFkaXVzXG4gICAgICAgICAgICAgICAgdmVjMi5zY2FsZShjLmNvbnRhY3RQb2ludEEsIGMubm9ybWFsQSwgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHdvcmxkVmVydGV4LCBjb252ZXhPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleEJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn07XG5cbnZhciBwaWNfd29ybGRWZXJ0ZXgwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBwaWNfd29ybGRWZXJ0ZXgxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBwaWNfcjAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHBpY19yMSA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qXG4gKiBDaGVjayBpZiBhIHBvaW50IGlzIGluIGEgcG9seWdvblxuICovXG5mdW5jdGlvbiBwb2ludEluQ29udmV4KHdvcmxkUG9pbnQsY29udmV4U2hhcGUsY29udmV4T2Zmc2V0LGNvbnZleEFuZ2xlKXtcbiAgICB2YXIgd29ybGRWZXJ0ZXgwID0gcGljX3dvcmxkVmVydGV4MCxcbiAgICAgICAgd29ybGRWZXJ0ZXgxID0gcGljX3dvcmxkVmVydGV4MSxcbiAgICAgICAgcjAgPSBwaWNfcjAsXG4gICAgICAgIHIxID0gcGljX3IxLFxuICAgICAgICBwb2ludCA9IHdvcmxkUG9pbnQsXG4gICAgICAgIHZlcnRzID0gY29udmV4U2hhcGUudmVydGljZXMsXG4gICAgICAgIGxhc3RDcm9zcyA9IG51bGw7XG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGgrMTsgaSsrKXtcbiAgICAgICAgdmFyIHYwID0gdmVydHNbaSV2ZXJ0cy5sZW5ndGhdLFxuICAgICAgICAgICAgdjEgPSB2ZXJ0c1soaSsxKSV2ZXJ0cy5sZW5ndGhdO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybSB2ZXJ0aWNlcyB0byB3b3JsZFxuICAgICAgICAvLyBAdG9kbyBUaGUgcG9pbnQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkIHRvIGxvY2FsIGNvb3JkaW5hdGVzIGluIHRoZSBjb252ZXgsIG5vIG5lZWQgdG8gdHJhbnNmb3JtIGVhY2ggdmVydGV4XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MCwgdjAsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgxLCB2MSwgY29udmV4QW5nbGUpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgwLCB3b3JsZFZlcnRleDAsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MSwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICBzdWIocjAsIHdvcmxkVmVydGV4MCwgcG9pbnQpO1xuICAgICAgICBzdWIocjEsIHdvcmxkVmVydGV4MSwgcG9pbnQpO1xuICAgICAgICB2YXIgY3Jvc3MgPSB2ZWMyLmNyb3NzTGVuZ3RoKHIwLHIxKTtcblxuICAgICAgICBpZihsYXN0Q3Jvc3M9PT1udWxsKXtcbiAgICAgICAgICAgIGxhc3RDcm9zcyA9IGNyb3NzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgZ290IGEgZGlmZmVyZW50IHNpZ24gb2YgdGhlIGRpc3RhbmNlIHZlY3RvciwgdGhlIHBvaW50IGlzIG91dCBvZiB0aGUgcG9seWdvblxuICAgICAgICBpZihjcm9zcypsYXN0Q3Jvc3MgPD0gMCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENyb3NzID0gY3Jvc3M7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFBhcnRpY2xlL2NvbnZleCBOYXJyb3dwaGFzZVxuICogQG1ldGhvZCBwYXJ0aWNsZUNvbnZleFxuICogQHBhcmFtICB7Qm9keX0gcGFydGljbGVCb2R5XG4gKiBAcGFyYW0gIHtQYXJ0aWNsZX0gcGFydGljbGVTaGFwZVxuICogQHBhcmFtICB7QXJyYXl9IHBhcnRpY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHBhcnRpY2xlQW5nbGVcbiAqIEBwYXJhbSAge0JvZHl9IGNvbnZleEJvZHlcbiAqIEBwYXJhbSAge0NvbnZleH0gY29udmV4U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjb252ZXhPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY29udmV4QW5nbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqIEB0b2RvIHVzZSBwb2ludEluQ29udmV4IGFuZCBjb2RlIG1vcmUgc2ltaWxhciB0byBjaXJjbGVDb252ZXhcbiAqIEB0b2RvIGRvbid0IHRyYW5zZm9ybSBlYWNoIHZlcnRleCwgYnV0IHRyYW5zZm9ybSB0aGUgcGFydGljbGUgcG9zaXRpb24gdG8gY29udmV4LWxvY2FsIGluc3RlYWRcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBBUlRJQ0xFIHwgU2hhcGUuQ09OVkVYXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUEFSVElDTEUgfCBTaGFwZS5CT1hdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wYXJ0aWNsZUNvbnZleCA9IGZ1bmN0aW9uKFxuICAgIHBhcnRpY2xlQm9keSxcbiAgICBwYXJ0aWNsZVNoYXBlLFxuICAgIHBhcnRpY2xlT2Zmc2V0LFxuICAgIHBhcnRpY2xlQW5nbGUsXG4gICAgY29udmV4Qm9keSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBjb252ZXhPZmZzZXQsXG4gICAgY29udmV4QW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgdmFyIHdvcmxkVmVydGV4MCA9IHRtcDEsXG4gICAgICAgIHdvcmxkVmVydGV4MSA9IHRtcDIsXG4gICAgICAgIHdvcmxkRWRnZSA9IHRtcDMsXG4gICAgICAgIHdvcmxkRWRnZVVuaXQgPSB0bXA0LFxuICAgICAgICB3b3JsZFRhbmdlbnQgPSB0bXA1LFxuICAgICAgICBjZW50ZXJEaXN0ID0gdG1wNixcbiAgICAgICAgY29udmV4VG9wYXJ0aWNsZSA9IHRtcDcsXG4gICAgICAgIG9ydGhvRGlzdCA9IHRtcDgsXG4gICAgICAgIHByb2plY3RlZFBvaW50ID0gdG1wOSxcbiAgICAgICAgZGlzdCA9IHRtcDEwLFxuICAgICAgICB3b3JsZFZlcnRleCA9IHRtcDExLFxuICAgICAgICBjbG9zZXN0RWRnZSA9IC0xLFxuICAgICAgICBjbG9zZXN0RWRnZURpc3RhbmNlID0gbnVsbCxcbiAgICAgICAgY2xvc2VzdEVkZ2VPcnRob0Rpc3QgPSB0bXAxMixcbiAgICAgICAgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCA9IHRtcDEzLFxuICAgICAgICByMCA9IHRtcDE0LCAvLyB2ZWN0b3IgZnJvbSBwYXJ0aWNsZSB0byB2ZXJ0ZXgwXG4gICAgICAgIHIxID0gdG1wMTUsXG4gICAgICAgIGxvY2FsUG9pbnQgPSB0bXAxNixcbiAgICAgICAgY2FuZGlkYXRlRGlzdCA9IHRtcDE3LFxuICAgICAgICBtaW5FZGdlTm9ybWFsID0gdG1wMTgsXG4gICAgICAgIG1pbkNhbmRpZGF0ZURpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgIHZhciBudW1SZXBvcnRlZCA9IDAsXG4gICAgICAgIGZvdW5kID0gZmFsc2UsXG4gICAgICAgIHZlcnRzID0gY29udmV4U2hhcGUudmVydGljZXM7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgcGFydGljbGUgaXMgaW4gdGhlIHBvbHlnb24gYXQgYWxsXG4gICAgaWYoIXBvaW50SW5Db252ZXgocGFydGljbGVPZmZzZXQsY29udmV4U2hhcGUsY29udmV4T2Zmc2V0LGNvbnZleEFuZ2xlKSl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZWRnZXMgZmlyc3RcbiAgICB2YXIgbGFzdENyb3NzID0gbnVsbDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PXZlcnRzLmxlbmd0aCsxOyBpKyspe1xuICAgICAgICB2YXIgdjAgPSB2ZXJ0c1tpJXZlcnRzLmxlbmd0aF0sXG4gICAgICAgICAgICB2MSA9IHZlcnRzWyhpKzEpJXZlcnRzLmxlbmd0aF07XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIHZlcnRpY2VzIHRvIHdvcmxkXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkVmVydGV4MCwgdjAsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgxLCB2MSwgY29udmV4QW5nbGUpO1xuICAgICAgICBhZGQod29ybGRWZXJ0ZXgwLCB3b3JsZFZlcnRleDAsIGNvbnZleE9mZnNldCk7XG4gICAgICAgIGFkZCh3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MSwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICAvLyBHZXQgd29ybGQgZWRnZVxuICAgICAgICBzdWIod29ybGRFZGdlLCB3b3JsZFZlcnRleDEsIHdvcmxkVmVydGV4MCk7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKHdvcmxkRWRnZVVuaXQsIHdvcmxkRWRnZSk7XG5cbiAgICAgICAgLy8gR2V0IHRhbmdlbnQgdG8gdGhlIGVkZ2UuIFBvaW50cyBvdXQgb2YgdGhlIENvbnZleFxuICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cod29ybGRUYW5nZW50LCB3b3JsZEVkZ2VVbml0KTtcblxuICAgICAgICAvLyBDaGVjayBkaXN0YW5jZSBmcm9tIHRoZSBpbmZpbml0ZSBsaW5lIChzcGFubmVkIGJ5IHRoZSBlZGdlKSB0byB0aGUgcGFydGljbGVcbiAgICAgICAgc3ViKGRpc3QsIHBhcnRpY2xlT2Zmc2V0LCB3b3JsZFZlcnRleDApO1xuICAgICAgICB2YXIgZCA9IGRvdChkaXN0LCB3b3JsZFRhbmdlbnQpO1xuICAgICAgICBzdWIoY2VudGVyRGlzdCwgd29ybGRWZXJ0ZXgwLCBjb252ZXhPZmZzZXQpO1xuXG4gICAgICAgIHN1Yihjb252ZXhUb3BhcnRpY2xlLCBwYXJ0aWNsZU9mZnNldCwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICB2ZWMyLnN1YihjYW5kaWRhdGVEaXN0LHdvcmxkVmVydGV4MCxwYXJ0aWNsZU9mZnNldCk7XG4gICAgICAgIHZhciBjYW5kaWRhdGVEaXN0YW5jZSA9IE1hdGguYWJzKHZlYzIuZG90KGNhbmRpZGF0ZURpc3Qsd29ybGRUYW5nZW50KSk7XG5cbiAgICAgICAgaWYoY2FuZGlkYXRlRGlzdGFuY2UgPCBtaW5DYW5kaWRhdGVEaXN0YW5jZSl7XG4gICAgICAgICAgICBtaW5DYW5kaWRhdGVEaXN0YW5jZSA9IGNhbmRpZGF0ZURpc3RhbmNlO1xuICAgICAgICAgICAgdmVjMi5zY2FsZShjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LHdvcmxkVGFuZ2VudCxjYW5kaWRhdGVEaXN0YW5jZSk7XG4gICAgICAgICAgICB2ZWMyLmFkZChjbG9zZXN0RWRnZVByb2plY3RlZFBvaW50LGNsb3Nlc3RFZGdlUHJvamVjdGVkUG9pbnQscGFydGljbGVPZmZzZXQpO1xuICAgICAgICAgICAgdmVjMi5jb3B5KG1pbkVkZ2VOb3JtYWwsd29ybGRUYW5nZW50KTtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGZvdW5kKXtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwYXJ0aWNsZUJvZHksY29udmV4Qm9keSxwYXJ0aWNsZVNoYXBlLGNvbnZleFNoYXBlKTtcblxuICAgICAgICB2ZWMyLnNjYWxlKGMubm9ybWFsQSwgbWluRWRnZU5vcm1hbCwgLTEpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsIGMubm9ybWFsQSk7XG5cbiAgICAgICAgLy8gUGFydGljbGUgaGFzIG5vIGV4dGVudCB0byB0aGUgY29udGFjdCBwb2ludFxuICAgICAgICB2ZWMyLnNldChjLmNvbnRhY3RQb2ludEEsICAwLCAwKTtcbiAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwYXJ0aWNsZU9mZnNldCk7XG4gICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgcGFydGljbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgICAgICAvLyBGcm9tIGNvbnZleCBjZW50ZXIgdG8gcG9pbnRcbiAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QiwgY2xvc2VzdEVkZ2VQcm9qZWN0ZWRQb2ludCwgY29udmV4T2Zmc2V0KTtcbiAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBjb252ZXhPZmZzZXQpO1xuICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNvbnZleEJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKCB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIENpcmNsZS9jaXJjbGUgTmFycm93cGhhc2VcbiAqIEBtZXRob2QgY2lyY2xlQ2lyY2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5QVxuICogQHBhcmFtICB7Q2lyY2xlfSBzaGFwZUFcbiAqIEBwYXJhbSAge0FycmF5fSBvZmZzZXRBXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlQVxuICogQHBhcmFtICB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSAge0NpcmNsZX0gc2hhcGVCXG4gKiBAcGFyYW0gIHtBcnJheX0gb2Zmc2V0QlxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZUJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzQV0gT3B0aW9uYWwgcmFkaXVzIHRvIHVzZSBmb3Igc2hhcGVBXG4gKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1c0JdIE9wdGlvbmFsIHJhZGl1cyB0byB1c2UgZm9yIHNoYXBlQlxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlQ2lyY2xlID0gZnVuY3Rpb24oXG4gICAgYm9keUEsXG4gICAgc2hhcGVBLFxuICAgIG9mZnNldEEsXG4gICAgYW5nbGVBLFxuICAgIGJvZHlCLFxuICAgIHNoYXBlQixcbiAgICBvZmZzZXRCLFxuICAgIGFuZ2xlQixcbiAgICBqdXN0VGVzdCxcbiAgICByYWRpdXNBLFxuICAgIHJhZGl1c0Jcbil7XG5cbiAgICB2YXIgZGlzdCA9IHRtcDEsXG4gICAgICAgIHJhZGl1c0EgPSByYWRpdXNBIHx8IHNoYXBlQS5yYWRpdXMsXG4gICAgICAgIHJhZGl1c0IgPSByYWRpdXNCIHx8IHNoYXBlQi5yYWRpdXM7XG5cbiAgICBzdWIoZGlzdCxvZmZzZXRBLG9mZnNldEIpO1xuICAgIHZhciByID0gcmFkaXVzQSArIHJhZGl1c0I7XG4gICAgaWYodmVjMi5zcXVhcmVkTGVuZ3RoKGRpc3QpID4gTWF0aC5wb3cociwyKSl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5QixzaGFwZUEsc2hhcGVCKTtcbiAgICBzdWIoYy5ub3JtYWxBLCBvZmZzZXRCLCBvZmZzZXRBKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgIHZlYzIuc2NhbGUoIGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCAgcmFkaXVzQSk7XG4gICAgdmVjMi5zY2FsZSggYy5jb250YWN0UG9pbnRCLCBjLm5vcm1hbEEsIC1yYWRpdXNCKTtcblxuICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgb2Zmc2V0QSk7XG4gICAgc3ViKGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBib2R5QS5wb3NpdGlvbik7XG5cbiAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIG9mZnNldEIpO1xuICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgYm9keUIucG9zaXRpb24pO1xuXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBQbGFuZS9Db252ZXggTmFycm93cGhhc2VcbiAqIEBtZXRob2QgcGxhbmVDb252ZXhcbiAqIEBwYXJhbSAge0JvZHl9IHBsYW5lQm9keVxuICogQHBhcmFtICB7UGxhbmV9IHBsYW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBwbGFuZU9mZnNldFxuICogQHBhcmFtICB7TnVtYmVyfSBwbGFuZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBjb252ZXhCb2R5XG4gKiBAcGFyYW0gIHtDb252ZXh9IGNvbnZleFNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY29udmV4T2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNvbnZleEFuZ2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGp1c3RUZXN0XG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5QTEFORSB8IFNoYXBlLkNPTlZFWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLlBMQU5FIHwgU2hhcGUuQk9YXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVDb252ZXggPSBmdW5jdGlvbihcbiAgICBwbGFuZUJvZHksXG4gICAgcGxhbmVTaGFwZSxcbiAgICBwbGFuZU9mZnNldCxcbiAgICBwbGFuZUFuZ2xlLFxuICAgIGNvbnZleEJvZHksXG4gICAgY29udmV4U2hhcGUsXG4gICAgY29udmV4T2Zmc2V0LFxuICAgIGNvbnZleEFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciB3b3JsZFZlcnRleCA9IHRtcDEsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gdG1wMixcbiAgICAgICAgZGlzdCA9IHRtcDM7XG5cbiAgICB2YXIgbnVtUmVwb3J0ZWQgPSAwO1xuICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB5QXhpcywgcGxhbmVBbmdsZSk7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PWNvbnZleFNoYXBlLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSBjb252ZXhTaGFwZS52ZXJ0aWNlc1tpXTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRWZXJ0ZXgsIHYsIGNvbnZleEFuZ2xlKTtcbiAgICAgICAgYWRkKHdvcmxkVmVydGV4LCB3b3JsZFZlcnRleCwgY29udmV4T2Zmc2V0KTtcblxuICAgICAgICBzdWIoZGlzdCwgd29ybGRWZXJ0ZXgsIHBsYW5lT2Zmc2V0KTtcblxuICAgICAgICBpZihkb3QoZGlzdCx3b3JsZE5vcm1hbCkgPD0gMCl7XG5cbiAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm91bmQgdmVydGV4XG4gICAgICAgICAgICBudW1SZXBvcnRlZCsrO1xuXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSxjb252ZXhCb2R5LHBsYW5lU2hhcGUsY29udmV4U2hhcGUpO1xuXG4gICAgICAgICAgICBzdWIoZGlzdCwgd29ybGRWZXJ0ZXgsIHBsYW5lT2Zmc2V0KTtcblxuICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgd29ybGROb3JtYWwpO1xuXG4gICAgICAgICAgICB2YXIgZCA9IGRvdChkaXN0LCBjLm5vcm1hbEEpO1xuICAgICAgICAgICAgdmVjMi5zY2FsZShkaXN0LCBjLm5vcm1hbEEsIGQpO1xuXG4gICAgICAgICAgICAvLyByaiBpcyBmcm9tIGNvbnZleCBjZW50ZXIgdG8gY29udGFjdFxuICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50Qiwgd29ybGRWZXJ0ZXgsIGNvbnZleEJvZHkucG9zaXRpb24pO1xuXG5cbiAgICAgICAgICAgIC8vIHJpIGlzIGZyb20gcGxhbmUgY2VudGVyIHRvIGNvbnRhY3RcbiAgICAgICAgICAgIHN1YiggYy5jb250YWN0UG9pbnRBLCB3b3JsZFZlcnRleCwgZGlzdCk7XG4gICAgICAgICAgICBzdWIoIGMuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbiAmJiBudW1SZXBvcnRlZCl7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bVJlcG9ydGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtUmVwb3J0ZWQ7XG59O1xuXG4vKipcbiAqIE5hcnJvd3BoYXNlIGZvciBwYXJ0aWNsZSB2cyBwbGFuZVxuICogQG1ldGhvZCBwYXJ0aWNsZVBsYW5lXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBwYXJ0aWNsZUJvZHlcbiAqIEBwYXJhbSAge1BhcnRpY2xlfSAgIHBhcnRpY2xlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBhcnRpY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBwYXJ0aWNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBwbGFuZUJvZHlcbiAqIEBwYXJhbSAge1BsYW5lfSAgICAgIHBsYW5lU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHBsYW5lT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICBwbGFuZUFuZ2xlXG4gKiBAcGFyYW0ge0Jvb2xlYW59ICAgICBqdXN0VGVzdFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUEFSVElDTEUgfCBTaGFwZS5QTEFORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBhcnRpY2xlUGxhbmUgPSBmdW5jdGlvbihcbiAgICBwYXJ0aWNsZUJvZHksXG4gICAgcGFydGljbGVTaGFwZSxcbiAgICBwYXJ0aWNsZU9mZnNldCxcbiAgICBwYXJ0aWNsZUFuZ2xlLFxuICAgIHBsYW5lQm9keSxcbiAgICBwbGFuZVNoYXBlLFxuICAgIHBsYW5lT2Zmc2V0LFxuICAgIHBsYW5lQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgdmFyIGRpc3QgPSB0bXAxLFxuICAgICAgICB3b3JsZE5vcm1hbCA9IHRtcDI7XG5cbiAgICBwbGFuZUFuZ2xlID0gcGxhbmVBbmdsZSB8fCAwO1xuXG4gICAgc3ViKGRpc3QsIHBhcnRpY2xlT2Zmc2V0LCBwbGFuZU9mZnNldCk7XG4gICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHlBeGlzLCBwbGFuZUFuZ2xlKTtcblxuICAgIHZhciBkID0gZG90KGRpc3QsIHdvcmxkTm9ybWFsKTtcblxuICAgIGlmKGQgPiAwKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHkscGFydGljbGVCb2R5LHBsYW5lU2hhcGUscGFydGljbGVTaGFwZSk7XG5cbiAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCB3b3JsZE5vcm1hbCk7XG4gICAgdmVjMi5zY2FsZSggZGlzdCwgYy5ub3JtYWxBLCBkICk7XG4gICAgLy8gZGlzdCBpcyBub3cgdGhlIGRpc3RhbmNlIHZlY3RvciBpbiB0aGUgbm9ybWFsIGRpcmVjdGlvblxuXG4gICAgLy8gcmkgaXMgdGhlIHBhcnRpY2xlIHBvc2l0aW9uIHByb2plY3RlZCBkb3duIG9udG8gdGhlIHBsYW5lLCBmcm9tIHRoZSBwbGFuZSBjZW50ZXJcbiAgICBzdWIoIGMuY29udGFjdFBvaW50QSwgcGFydGljbGVPZmZzZXQsIGRpc3QpO1xuICAgIHN1YiggYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBsYW5lQm9keS5wb3NpdGlvbik7XG5cbiAgICAvLyByaiBpcyBmcm9tIHRoZSBib2R5IGNlbnRlciB0byB0aGUgcGFydGljbGUgY2VudGVyXG4gICAgc3ViKCBjLmNvbnRhY3RQb2ludEIsIHBhcnRpY2xlT2Zmc2V0LCBwYXJ0aWNsZUJvZHkucG9zaXRpb24gKTtcblxuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvbil7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoYykpO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbn07XG5cbi8qKlxuICogQ2lyY2xlL1BhcnRpY2xlIE5hcnJvd3BoYXNlXG4gKiBAbWV0aG9kIGNpcmNsZVBhcnRpY2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBjaXJjbGVCb2R5XG4gKiBAcGFyYW0gIHtDaXJjbGV9IGNpcmNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gY2lyY2xlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNpcmNsZUFuZ2xlXG4gKiBAcGFyYW0gIHtCb2R5fSBwYXJ0aWNsZUJvZHlcbiAqIEBwYXJhbSAge1BhcnRpY2xlfSBwYXJ0aWNsZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGFydGljbGVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gcGFydGljbGVBbmdsZVxuICogQHBhcmFtICB7Qm9vbGVhbn0ganVzdFRlc3RcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNJUkNMRSB8IFNoYXBlLlBBUlRJQ0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY2lyY2xlUGFydGljbGUgPSBmdW5jdGlvbihcbiAgICBjaXJjbGVCb2R5LFxuICAgIGNpcmNsZVNoYXBlLFxuICAgIGNpcmNsZU9mZnNldCxcbiAgICBjaXJjbGVBbmdsZSxcbiAgICBwYXJ0aWNsZUJvZHksXG4gICAgcGFydGljbGVTaGFwZSxcbiAgICBwYXJ0aWNsZU9mZnNldCxcbiAgICBwYXJ0aWNsZUFuZ2xlLFxuICAgIGp1c3RUZXN0XG4pe1xuICAgIHZhciBkaXN0ID0gdG1wMTtcblxuICAgIHN1YihkaXN0LCBwYXJ0aWNsZU9mZnNldCwgY2lyY2xlT2Zmc2V0KTtcbiAgICBpZih2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCkgPiBNYXRoLnBvdyhjaXJjbGVTaGFwZS5yYWRpdXMsIDIpKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihjaXJjbGVCb2R5LHBhcnRpY2xlQm9keSxjaXJjbGVTaGFwZSxwYXJ0aWNsZVNoYXBlKTtcbiAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcbiAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgIC8vIFZlY3RvciBmcm9tIGNpcmNsZSB0byBjb250YWN0IHBvaW50IGlzIHRoZSBub3JtYWwgdGltZXMgdGhlIGNpcmNsZSByYWRpdXNcbiAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QSwgYy5ub3JtYWxBLCBjaXJjbGVTaGFwZS5yYWRpdXMpO1xuICAgIGFkZChjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgY2lyY2xlT2Zmc2V0KTtcbiAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgLy8gVmVjdG9yIGZyb20gcGFydGljbGUgY2VudGVyIHRvIGNvbnRhY3QgcG9pbnQgaXMgemVyb1xuICAgIHN1YihjLmNvbnRhY3RQb2ludEIsIHBhcnRpY2xlT2Zmc2V0LCBwYXJ0aWNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goYyk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG59O1xuXG52YXIgcGxhbmVDYXBzdWxlX3RtcENpcmNsZSA9IG5ldyBDaXJjbGUoeyByYWRpdXM6IDEgfSksXG4gICAgcGxhbmVDYXBzdWxlX3RtcDEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHBsYW5lQ2Fwc3VsZV90bXAyID0gdmVjMi5jcmVhdGUoKSxcbiAgICBwbGFuZUNhcHN1bGVfdG1wMyA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBwbGFuZUNhcHN1bGVcbiAqIEBwYXJhbSAge0JvZHl9IHBsYW5lQm9keVxuICogQHBhcmFtICB7Q2lyY2xlfSBwbGFuZVNoYXBlXG4gKiBAcGFyYW0gIHtBcnJheX0gcGxhbmVPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gcGxhbmVBbmdsZVxuICogQHBhcmFtICB7Qm9keX0gY2Fwc3VsZUJvZHlcbiAqIEBwYXJhbSAge1BhcnRpY2xlfSBjYXBzdWxlU2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjYXBzdWxlT2Zmc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNhcHN1bGVBbmdsZVxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0VGVzdFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuUExBTkUgfCBTaGFwZS5DQVBTVUxFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVDYXBzdWxlID0gZnVuY3Rpb24oXG4gICAgcGxhbmVCb2R5LFxuICAgIHBsYW5lU2hhcGUsXG4gICAgcGxhbmVPZmZzZXQsXG4gICAgcGxhbmVBbmdsZSxcbiAgICBjYXBzdWxlQm9keSxcbiAgICBjYXBzdWxlU2hhcGUsXG4gICAgY2Fwc3VsZU9mZnNldCxcbiAgICBjYXBzdWxlQW5nbGUsXG4gICAganVzdFRlc3Rcbil7XG4gICAgdmFyIGVuZDEgPSBwbGFuZUNhcHN1bGVfdG1wMSxcbiAgICAgICAgZW5kMiA9IHBsYW5lQ2Fwc3VsZV90bXAyLFxuICAgICAgICBjaXJjbGUgPSBwbGFuZUNhcHN1bGVfdG1wQ2lyY2xlLFxuICAgICAgICBkc3QgPSBwbGFuZUNhcHN1bGVfdG1wMztcblxuICAgIC8vIENvbXB1dGUgd29ybGQgZW5kIHBvc2l0aW9uc1xuICAgIHZlYzIuc2V0KGVuZDEsIC1jYXBzdWxlU2hhcGUubGVuZ3RoLzIsIDApO1xuICAgIHZlYzIucm90YXRlKGVuZDEsZW5kMSxjYXBzdWxlQW5nbGUpO1xuICAgIGFkZChlbmQxLGVuZDEsY2Fwc3VsZU9mZnNldCk7XG5cbiAgICB2ZWMyLnNldChlbmQyLCAgY2Fwc3VsZVNoYXBlLmxlbmd0aC8yLCAwKTtcbiAgICB2ZWMyLnJvdGF0ZShlbmQyLGVuZDIsY2Fwc3VsZUFuZ2xlKTtcbiAgICBhZGQoZW5kMixlbmQyLGNhcHN1bGVPZmZzZXQpO1xuXG4gICAgY2lyY2xlLnJhZGl1cyA9IGNhcHN1bGVTaGFwZS5yYWRpdXM7XG5cbiAgICB2YXIgZW5hYmxlRnJpY3Rpb25CZWZvcmU7XG5cbiAgICAvLyBUZW1wb3JhcmlseSB0dXJuIG9mZiBmcmljdGlvblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICBlbmFibGVGcmljdGlvbkJlZm9yZSA9IHRoaXMuZW5hYmxlRnJpY3Rpb247XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBEbyBOYXJyb3dwaGFzZSBhcyB0d28gY2lyY2xlc1xuICAgIHZhciBudW1Db250YWN0czEgPSB0aGlzLmNpcmNsZVBsYW5lKGNhcHN1bGVCb2R5LGNpcmNsZSxlbmQxLDAsIHBsYW5lQm9keSxwbGFuZVNoYXBlLHBsYW5lT2Zmc2V0LHBsYW5lQW5nbGUsIGp1c3RUZXN0KSxcbiAgICAgICAgbnVtQ29udGFjdHMyID0gdGhpcy5jaXJjbGVQbGFuZShjYXBzdWxlQm9keSxjaXJjbGUsZW5kMiwwLCBwbGFuZUJvZHkscGxhbmVTaGFwZSxwbGFuZU9mZnNldCxwbGFuZUFuZ2xlLCBqdXN0VGVzdCk7XG5cbiAgICAvLyBSZXN0b3JlIGZyaWN0aW9uXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb24gPSBlbmFibGVGcmljdGlvbkJlZm9yZTtcbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiBudW1Db250YWN0czEgfHwgbnVtQ29udGFjdHMyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBudW1Ub3RhbCA9IG51bUNvbnRhY3RzMSArIG51bUNvbnRhY3RzMjtcbiAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICBpZihudW1Ub3RhbCl7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Ub3RhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW1Ub3RhbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgQ29udGFjdEVxdWF0aW9ucyBhbmQgRnJpY3Rpb25FcXVhdGlvbnMgZm9yIGEgY29sbGlzaW9uLlxuICogQG1ldGhvZCBjaXJjbGVQbGFuZVxuICogQHBhcmFtICB7Qm9keX0gICAgYmkgICAgIFRoZSBmaXJzdCBib2R5IHRoYXQgc2hvdWxkIGJlIGNvbm5lY3RlZCB0byB0aGUgZXF1YXRpb25zLlxuICogQHBhcmFtICB7Q2lyY2xlfSAgc2kgICAgIFRoZSBjaXJjbGUgc2hhcGUgcGFydGljaXBhdGluZyBpbiB0aGUgY29sbGlzaW9uLlxuICogQHBhcmFtICB7QXJyYXl9ICAgeGkgICAgIEV4dHJhIG9mZnNldCB0byB0YWtlIGludG8gYWNjb3VudCBmb3IgdGhlIFNoYXBlLCBpbiBhZGRpdGlvbiB0byB0aGUgb25lIGluIGNpcmNsZUJvZHkucG9zaXRpb24uIFdpbGwgKm5vdCogYmUgcm90YXRlZCBieSBjaXJjbGVCb2R5LmFuZ2xlIChtYXliZSBpdCBzaG91bGQsIGZvciBzYWtlIG9mIGhvbW9nZW5pdHk/KS4gU2V0IHRvIG51bGwgaWYgbm9uZS5cbiAqIEBwYXJhbSAge0JvZHl9ICAgIGJqICAgICBUaGUgc2Vjb25kIGJvZHkgdGhhdCBzaG91bGQgYmUgY29ubmVjdGVkIHRvIHRoZSBlcXVhdGlvbnMuXG4gKiBAcGFyYW0gIHtQbGFuZX0gICBzaiAgICAgVGhlIFBsYW5lIHNoYXBlIHRoYXQgaXMgcGFydGljaXBhdGluZ1xuICogQHBhcmFtICB7QXJyYXl9ICAgeGogICAgIEV4dHJhIG9mZnNldCBmb3IgdGhlIHBsYW5lIHNoYXBlLlxuICogQHBhcmFtICB7TnVtYmVyfSAgYWogICAgIEV4dHJhIGFuZ2xlIHRvIGFwcGx5IHRvIHRoZSBwbGFuZVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ0lSQ0xFIHwgU2hhcGUuUExBTkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jaXJjbGVQbGFuZSA9IGZ1bmN0aW9uKCAgIGJpLHNpLHhpLGFpLCBiaixzaix4aixhaiwganVzdFRlc3QgKXtcbiAgICB2YXIgY2lyY2xlQm9keSA9IGJpLFxuICAgICAgICBjaXJjbGVTaGFwZSA9IHNpLFxuICAgICAgICBjaXJjbGVPZmZzZXQgPSB4aSwgLy8gT2Zmc2V0IGZyb20gYm9keSBjZW50ZXIsIHJvdGF0ZWQhXG4gICAgICAgIHBsYW5lQm9keSA9IGJqLFxuICAgICAgICBzaGFwZUIgPSBzaixcbiAgICAgICAgcGxhbmVPZmZzZXQgPSB4aixcbiAgICAgICAgcGxhbmVBbmdsZSA9IGFqO1xuXG4gICAgcGxhbmVBbmdsZSA9IHBsYW5lQW5nbGUgfHwgMDtcblxuICAgIC8vIFZlY3RvciBmcm9tIHBsYW5lIHRvIGNpcmNsZVxuICAgIHZhciBwbGFuZVRvQ2lyY2xlID0gdG1wMSxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXAyLFxuICAgICAgICB0ZW1wID0gdG1wMztcblxuICAgIHN1YihwbGFuZVRvQ2lyY2xlLCBjaXJjbGVPZmZzZXQsIHBsYW5lT2Zmc2V0KTtcblxuICAgIC8vIFdvcmxkIHBsYW5lIG5vcm1hbFxuICAgIHZlYzIucm90YXRlKHdvcmxkTm9ybWFsLCB5QXhpcywgcGxhbmVBbmdsZSk7XG5cbiAgICAvLyBOb3JtYWwgZGlyZWN0aW9uIGRpc3RhbmNlXG4gICAgdmFyIGQgPSBkb3Qod29ybGROb3JtYWwsIHBsYW5lVG9DaXJjbGUpO1xuXG4gICAgaWYoZCA+IGNpcmNsZVNoYXBlLnJhZGl1cyl7XG4gICAgICAgIHJldHVybiAwOyAvLyBObyBvdmVybGFwLiBBYm9ydC5cbiAgICB9XG5cbiAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBjb250YWN0XG4gICAgdmFyIGNvbnRhY3QgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksY2lyY2xlQm9keSxzaixzaSk7XG5cbiAgICAvLyBuaSBpcyB0aGUgcGxhbmUgd29ybGQgbm9ybWFsXG4gICAgdmVjMi5jb3B5KGNvbnRhY3Qubm9ybWFsQSwgd29ybGROb3JtYWwpO1xuXG4gICAgLy8gcmogaXMgdGhlIHZlY3RvciBmcm9tIGNpcmNsZSBjZW50ZXIgdG8gdGhlIGNvbnRhY3QgcG9pbnRcbiAgICB2ZWMyLnNjYWxlKGNvbnRhY3QuY29udGFjdFBvaW50QiwgY29udGFjdC5ub3JtYWxBLCAtY2lyY2xlU2hhcGUucmFkaXVzKTtcbiAgICBhZGQoY29udGFjdC5jb250YWN0UG9pbnRCLCBjb250YWN0LmNvbnRhY3RQb2ludEIsIGNpcmNsZU9mZnNldCk7XG4gICAgc3ViKGNvbnRhY3QuY29udGFjdFBvaW50QiwgY29udGFjdC5jb250YWN0UG9pbnRCLCBjaXJjbGVCb2R5LnBvc2l0aW9uKTtcblxuICAgIC8vIHJpIGlzIHRoZSBkaXN0YW5jZSBmcm9tIHBsYW5lIGNlbnRlciB0byBjb250YWN0LlxuICAgIHZlYzIuc2NhbGUodGVtcCwgY29udGFjdC5ub3JtYWxBLCBkKTtcbiAgICBzdWIoY29udGFjdC5jb250YWN0UG9pbnRBLCBwbGFuZVRvQ2lyY2xlLCB0ZW1wICk7IC8vIFN1YnRyYWN0IG5vcm1hbCBkaXN0YW5jZSB2ZWN0b3IgZnJvbSB0aGUgZGlzdGFuY2UgdmVjdG9yXG4gICAgYWRkKGNvbnRhY3QuY29udGFjdFBvaW50QSwgY29udGFjdC5jb250YWN0UG9pbnRBLCBwbGFuZU9mZnNldCk7XG4gICAgc3ViKGNvbnRhY3QuY29udGFjdFBvaW50QSwgY29udGFjdC5jb250YWN0UG9pbnRBLCBwbGFuZUJvZHkucG9zaXRpb24pO1xuXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25zLnB1c2goY29udGFjdCk7XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKCB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUNvbnRhY3QoY29udGFjdCkgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbn07XG5cbi8qKlxuICogQ29udmV4L2NvbnZleCBOYXJyb3dwaGFzZS5TZWUgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWx0ZGV2YmxvZ2FkYXkuY29tLzIwMTEvMDUvMTMvY29udGFjdC1nZW5lcmF0aW9uLWJldHdlZW4tM2QtY29udmV4LW1lc2hlcy9cIj50aGlzIGFydGljbGU8L2E+IGZvciBtb3JlIGluZm8uXG4gKiBAbWV0aG9kIGNvbnZleENvbnZleFxuICogQHBhcmFtICB7Qm9keX0gYmlcbiAqIEBwYXJhbSAge0NvbnZleH0gc2lcbiAqIEBwYXJhbSAge0FycmF5fSB4aVxuICogQHBhcmFtICB7TnVtYmVyfSBhaVxuICogQHBhcmFtICB7Qm9keX0gYmpcbiAqIEBwYXJhbSAge0NvbnZleH0gc2pcbiAqIEBwYXJhbSAge0FycmF5fSB4alxuICogQHBhcmFtICB7TnVtYmVyfSBhalxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ09OVkVYXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQ09OVkVYIHwgU2hhcGUuQk9YXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUuQk9YXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4Q29udmV4ID0gZnVuY3Rpb24oICBiaSxzaSx4aSxhaSwgYmosc2oseGosYWosIGp1c3RUZXN0LCBwcmVjaXNpb24gKXtcbiAgICB2YXIgc2VwQXhpcyA9IHRtcDEsXG4gICAgICAgIHdvcmxkUG9pbnQgPSB0bXAyLFxuICAgICAgICB3b3JsZFBvaW50MCA9IHRtcDMsXG4gICAgICAgIHdvcmxkUG9pbnQxID0gdG1wNCxcbiAgICAgICAgd29ybGRFZGdlID0gdG1wNSxcbiAgICAgICAgcHJvamVjdGVkID0gdG1wNixcbiAgICAgICAgcGVuZXRyYXRpb25WZWMgPSB0bXA3LFxuICAgICAgICBkaXN0ID0gdG1wOCxcbiAgICAgICAgd29ybGROb3JtYWwgPSB0bXA5LFxuICAgICAgICBudW1Db250YWN0cyA9IDAsXG4gICAgICAgIHByZWNpc2lvbiA9IHR5cGVvZihwcmVjaXNpb24pID09PSAnbnVtYmVyJyA/IHByZWNpc2lvbiA6IDA7XG5cbiAgICB2YXIgZm91bmQgPSBOYXJyb3dwaGFzZS5maW5kU2VwYXJhdGluZ0F4aXMoc2kseGksYWksc2oseGosYWosc2VwQXhpcyk7XG4gICAgaWYoIWZvdW5kKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBzZXBhcmF0aW5nIGF4aXMgaXMgZGlyZWN0ZWQgZnJvbSBzaGFwZSBpIHRvIHNoYXBlIGpcbiAgICBzdWIoZGlzdCx4aix4aSk7XG4gICAgaWYoZG90KHNlcEF4aXMsZGlzdCkgPiAwKXtcbiAgICAgICAgdmVjMi5zY2FsZShzZXBBeGlzLHNlcEF4aXMsLTEpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgZWRnZXMgd2l0aCBub3JtYWxzIGNsb3Nlc3QgdG8gdGhlIHNlcGFyYXRpbmcgYXhpc1xuICAgIHZhciBjbG9zZXN0RWRnZTEgPSBOYXJyb3dwaGFzZS5nZXRDbG9zZXN0RWRnZShzaSxhaSxzZXBBeGlzLHRydWUpLCAvLyBGbGlwcGVkIGF4aXNcbiAgICAgICAgY2xvc2VzdEVkZ2UyID0gTmFycm93cGhhc2UuZ2V0Q2xvc2VzdEVkZ2Uoc2osYWosc2VwQXhpcyk7XG5cbiAgICBpZihjbG9zZXN0RWRnZTEgPT09IC0xIHx8IGNsb3Nlc3RFZGdlMiA9PT0gLTEpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBMb29wIG92ZXIgdGhlIHNoYXBlc1xuICAgIGZvcih2YXIgaz0wOyBrPDI7IGsrKyl7XG5cbiAgICAgICAgdmFyIGNsb3Nlc3RFZGdlQSA9IGNsb3Nlc3RFZGdlMSxcbiAgICAgICAgICAgIGNsb3Nlc3RFZGdlQiA9IGNsb3Nlc3RFZGdlMixcbiAgICAgICAgICAgIHNoYXBlQSA9ICBzaSwgc2hhcGVCID0gIHNqLFxuICAgICAgICAgICAgb2Zmc2V0QSA9IHhpLCBvZmZzZXRCID0geGosXG4gICAgICAgICAgICBhbmdsZUEgPSBhaSwgYW5nbGVCID0gYWosXG4gICAgICAgICAgICBib2R5QSA9IGJpLCBib2R5QiA9IGJqO1xuXG4gICAgICAgIGlmKGsgPT09IDApe1xuICAgICAgICAgICAgLy8gU3dhcCFcbiAgICAgICAgICAgIHZhciB0bXA7XG4gICAgICAgICAgICB0bXAgPSBjbG9zZXN0RWRnZUE7XG4gICAgICAgICAgICBjbG9zZXN0RWRnZUEgPSBjbG9zZXN0RWRnZUI7XG4gICAgICAgICAgICBjbG9zZXN0RWRnZUIgPSB0bXA7XG5cbiAgICAgICAgICAgIHRtcCA9IHNoYXBlQTtcbiAgICAgICAgICAgIHNoYXBlQSA9IHNoYXBlQjtcbiAgICAgICAgICAgIHNoYXBlQiA9IHRtcDtcblxuICAgICAgICAgICAgdG1wID0gb2Zmc2V0QTtcbiAgICAgICAgICAgIG9mZnNldEEgPSBvZmZzZXRCO1xuICAgICAgICAgICAgb2Zmc2V0QiA9IHRtcDtcblxuICAgICAgICAgICAgdG1wID0gYW5nbGVBO1xuICAgICAgICAgICAgYW5nbGVBID0gYW5nbGVCO1xuICAgICAgICAgICAgYW5nbGVCID0gdG1wO1xuXG4gICAgICAgICAgICB0bXAgPSBib2R5QTtcbiAgICAgICAgICAgIGJvZHlBID0gYm9keUI7XG4gICAgICAgICAgICBib2R5QiA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvb3Agb3ZlciAyIHBvaW50cyBpbiBjb252ZXggQlxuICAgICAgICBmb3IodmFyIGo9Y2xvc2VzdEVkZ2VCOyBqPGNsb3Nlc3RFZGdlQisyOyBqKyspe1xuXG4gICAgICAgICAgICAvLyBHZXQgd29ybGQgcG9pbnRcbiAgICAgICAgICAgIHZhciB2ID0gc2hhcGVCLnZlcnRpY2VzWyhqK3NoYXBlQi52ZXJ0aWNlcy5sZW5ndGgpJXNoYXBlQi52ZXJ0aWNlcy5sZW5ndGhdO1xuICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludCwgdiwgYW5nbGVCKTtcbiAgICAgICAgICAgIGFkZCh3b3JsZFBvaW50LCB3b3JsZFBvaW50LCBvZmZzZXRCKTtcblxuICAgICAgICAgICAgdmFyIGluc2lkZU51bUVkZ2VzID0gMDtcblxuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIHRoZSAzIGNsb3Nlc3QgZWRnZXMgaW4gY29udmV4IEFcbiAgICAgICAgICAgIGZvcih2YXIgaT1jbG9zZXN0RWRnZUEtMTsgaTxjbG9zZXN0RWRnZUErMjsgaSsrKXtcblxuICAgICAgICAgICAgICAgIHZhciB2MCA9IHNoYXBlQS52ZXJ0aWNlc1soaSAgK3NoYXBlQS52ZXJ0aWNlcy5sZW5ndGgpJXNoYXBlQS52ZXJ0aWNlcy5sZW5ndGhdLFxuICAgICAgICAgICAgICAgICAgICB2MSA9IHNoYXBlQS52ZXJ0aWNlc1soaSsxK3NoYXBlQS52ZXJ0aWNlcy5sZW5ndGgpJXNoYXBlQS52ZXJ0aWNlcy5sZW5ndGhdO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBlZGdlXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDAsIHYwLCBhbmdsZUEpO1xuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQxLCB2MSwgYW5nbGVBKTtcbiAgICAgICAgICAgICAgICBhZGQod29ybGRQb2ludDAsIHdvcmxkUG9pbnQwLCBvZmZzZXRBKTtcbiAgICAgICAgICAgICAgICBhZGQod29ybGRQb2ludDEsIHdvcmxkUG9pbnQxLCBvZmZzZXRBKTtcblxuICAgICAgICAgICAgICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MCk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cod29ybGROb3JtYWwsIHdvcmxkRWRnZSk7IC8vIE5vcm1hbCBwb2ludHMgb3V0IG9mIGNvbnZleCAxXG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUod29ybGROb3JtYWwsd29ybGROb3JtYWwpO1xuXG4gICAgICAgICAgICAgICAgc3ViKGRpc3QsIHdvcmxkUG9pbnQsIHdvcmxkUG9pbnQwKTtcblxuICAgICAgICAgICAgICAgIHZhciBkID0gZG90KHdvcmxkTm9ybWFsLGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgaWYoKGkgPT09IGNsb3Nlc3RFZGdlQSAmJiBkIDw9IHByZWNpc2lvbikgfHwgKGkgIT09IGNsb3Nlc3RFZGdlQSAmJiBkIDw9IDApKXtcbiAgICAgICAgICAgICAgICAgICAgaW5zaWRlTnVtRWRnZXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGluc2lkZU51bUVkZ2VzID49IDMpe1xuXG4gICAgICAgICAgICAgICAgaWYoanVzdFRlc3Qpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB3b3JsZFBvaW50IHdhcyBvbiB0aGUgXCJpbnNpZGVcIiBzaWRlIG9mIGVhY2ggb2YgdGhlIDMgY2hlY2tlZCBlZGdlcy5cbiAgICAgICAgICAgICAgICAvLyBQcm9qZWN0IGl0IHRvIHRoZSBjZW50ZXIgZWRnZSBhbmQgdXNlIHRoZSBwcm9qZWN0aW9uIGRpcmVjdGlvbiBhcyBub3JtYWxcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBjb250YWN0XG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5QixzaGFwZUEsc2hhcGVCKTtcbiAgICAgICAgICAgICAgICBudW1Db250YWN0cysrO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGNlbnRlciBlZGdlIGZyb20gYm9keSBBXG4gICAgICAgICAgICAgICAgdmFyIHYwID0gc2hhcGVBLnZlcnRpY2VzWyhjbG9zZXN0RWRnZUEpICAgJSBzaGFwZUEudmVydGljZXMubGVuZ3RoXSxcbiAgICAgICAgICAgICAgICAgICAgdjEgPSBzaGFwZUEudmVydGljZXNbKGNsb3Nlc3RFZGdlQSsxKSAlIHNoYXBlQS52ZXJ0aWNlcy5sZW5ndGhdO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBlZGdlXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQb2ludDAsIHYwLCBhbmdsZUEpO1xuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQxLCB2MSwgYW5nbGVBKTtcbiAgICAgICAgICAgICAgICBhZGQod29ybGRQb2ludDAsIHdvcmxkUG9pbnQwLCBvZmZzZXRBKTtcbiAgICAgICAgICAgICAgICBhZGQod29ybGRQb2ludDEsIHdvcmxkUG9pbnQxLCBvZmZzZXRBKTtcblxuICAgICAgICAgICAgICAgIHN1Yih3b3JsZEVkZ2UsIHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MCk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZTkwY3coYy5ub3JtYWxBLCB3b3JsZEVkZ2UpOyAvLyBOb3JtYWwgcG9pbnRzIG91dCBvZiBjb252ZXggQVxuICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKGMubm9ybWFsQSxjLm5vcm1hbEEpO1xuXG4gICAgICAgICAgICAgICAgc3ViKGRpc3QsIHdvcmxkUG9pbnQsIHdvcmxkUG9pbnQwKTsgLy8gRnJvbSBlZGdlIHBvaW50IHRvIHRoZSBwZW5ldHJhdGluZyBwb2ludFxuICAgICAgICAgICAgICAgIHZhciBkID0gZG90KGMubm9ybWFsQSxkaXN0KTsgICAgICAgICAgICAgLy8gUGVuZXRyYXRpb25cbiAgICAgICAgICAgICAgICB2ZWMyLnNjYWxlKHBlbmV0cmF0aW9uVmVjLCBjLm5vcm1hbEEsIGQpOyAgICAgLy8gVmVjdG9yIHBlbmV0cmF0aW9uXG5cbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCB3b3JsZFBvaW50LCBvZmZzZXRBKTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIHBlbmV0cmF0aW9uVmVjKTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIG9mZnNldEEpO1xuICAgICAgICAgICAgICAgIHN1YihjLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSwgYm9keUEucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50Qiwgd29ybGRQb2ludCwgb2Zmc2V0Qik7XG4gICAgICAgICAgICAgICAgYWRkKGMuY29udGFjdFBvaW50QiwgYy5jb250YWN0UG9pbnRCLCBvZmZzZXRCKTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGJvZHlCLnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICAgICAgLy8gVG9kbyByZWR1Y2UgdG8gMSBmcmljdGlvbiBlcXVhdGlvbiBpZiB3ZSBoYXZlIDIgY29udGFjdCBwb2ludHNcbiAgICAgICAgICAgICAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKXtcbiAgICAgICAgaWYodGhpcy5lbmFibGVGcmljdGlvbiAmJiBudW1Db250YWN0cyl7XG4gICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtQ29udGFjdHM7XG59O1xuXG4vLyAucHJvamVjdENvbnZleCBpcyBjYWxsZWQgYnkgb3RoZXIgZnVuY3Rpb25zLCBuZWVkIGxvY2FsIHRtcCB2ZWN0b3JzXG52YXIgcGNvYV90bXAxID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogUHJvamVjdCBhIENvbnZleCBvbnRvIGEgd29ybGQtb3JpZW50ZWQgYXhpc1xuICogQG1ldGhvZCBwcm9qZWN0Q29udmV4T250b0F4aXNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0NvbnZleH0gY29udmV4U2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBjb252ZXhPZmZzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gY29udmV4QW5nbGVcbiAqIEBwYXJhbSAge0FycmF5fSB3b3JsZEF4aXNcbiAqIEBwYXJhbSAge0FycmF5fSByZXN1bHRcbiAqL1xuTmFycm93cGhhc2UucHJvamVjdENvbnZleE9udG9BeGlzID0gZnVuY3Rpb24oY29udmV4U2hhcGUsIGNvbnZleE9mZnNldCwgY29udmV4QW5nbGUsIHdvcmxkQXhpcywgcmVzdWx0KXtcbiAgICB2YXIgbWF4PW51bGwsXG4gICAgICAgIG1pbj1udWxsLFxuICAgICAgICB2LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbG9jYWxBeGlzID0gcGNvYV90bXAxO1xuXG4gICAgLy8gQ29udmVydCB0aGUgYXhpcyB0byBsb2NhbCBjb29yZHMgb2YgdGhlIGJvZHlcbiAgICB2ZWMyLnJvdGF0ZShsb2NhbEF4aXMsIHdvcmxkQXhpcywgLWNvbnZleEFuZ2xlKTtcblxuICAgIC8vIEdldCBwcm9qZWN0ZWQgcG9zaXRpb24gb2YgYWxsIHZlcnRpY2VzXG4gICAgZm9yKHZhciBpPTA7IGk8Y29udmV4U2hhcGUudmVydGljZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2ID0gY29udmV4U2hhcGUudmVydGljZXNbaV07XG4gICAgICAgIHZhbHVlID0gZG90KHYsbG9jYWxBeGlzKTtcbiAgICAgICAgaWYobWF4ID09PSBudWxsIHx8IHZhbHVlID4gbWF4KXtcbiAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKG1pbiA9PT0gbnVsbCB8fCB2YWx1ZSA8IG1pbil7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKG1pbiA+IG1heCl7XG4gICAgICAgIHZhciB0ID0gbWluO1xuICAgICAgICBtaW4gPSBtYXg7XG4gICAgICAgIG1heCA9IHQ7XG4gICAgfVxuXG4gICAgLy8gUHJvamVjdCB0aGUgcG9zaXRpb24gb2YgdGhlIGJvZHkgb250byB0aGUgYXhpcyAtIG5lZWQgdG8gYWRkIHRoaXMgdG8gdGhlIHJlc3VsdFxuICAgIHZhciBvZmZzZXQgPSBkb3QoY29udmV4T2Zmc2V0LCB3b3JsZEF4aXMpO1xuXG4gICAgdmVjMi5zZXQoIHJlc3VsdCwgbWluICsgb2Zmc2V0LCBtYXggKyBvZmZzZXQpO1xufTtcblxuLy8gLmZpbmRTZXBhcmF0aW5nQXhpcyBpcyBjYWxsZWQgYnkgb3RoZXIgZnVuY3Rpb25zLCBuZWVkIGxvY2FsIHRtcCB2ZWN0b3JzXG52YXIgZnNhX3RtcDEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGZzYV90bXAyID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBmc2FfdG1wMyA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZnNhX3RtcDQgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKVxuLCAgIGZzYV90bXA1ID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBmc2FfdG1wNiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4vKipcbiAqIEZpbmQgYSBzZXBhcmF0aW5nIGF4aXMgYmV0d2VlbiB0aGUgc2hhcGVzLCB0aGF0IG1heGltaXplcyB0aGUgc2VwYXJhdGluZyBkaXN0YW5jZSBiZXR3ZWVuIHRoZW0uXG4gKiBAbWV0aG9kIGZpbmRTZXBhcmF0aW5nQXhpc1xuICogQHN0YXRpY1xuICogQHBhcmFtICB7Q29udmV4fSAgICAgYzFcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIG9mZnNldDFcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlMVxuICogQHBhcmFtICB7Q29udmV4fSAgICAgYzJcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIG9mZnNldDJcbiAqIEBwYXJhbSAge051bWJlcn0gICAgIGFuZ2xlMlxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgc2VwQXhpcyAgICAgVGhlIHJlc3VsdGluZyBheGlzXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICBXaGV0aGVyIHRoZSBheGlzIGNvdWxkIGJlIGZvdW5kLlxuICovXG5OYXJyb3dwaGFzZS5maW5kU2VwYXJhdGluZ0F4aXMgPSBmdW5jdGlvbihjMSxvZmZzZXQxLGFuZ2xlMSxjMixvZmZzZXQyLGFuZ2xlMixzZXBBeGlzKXtcbiAgICB2YXIgbWF4RGlzdCA9IG51bGwsXG4gICAgICAgIG92ZXJsYXAgPSBmYWxzZSxcbiAgICAgICAgZm91bmQgPSBmYWxzZSxcbiAgICAgICAgZWRnZSA9IGZzYV90bXAxLFxuICAgICAgICB3b3JsZFBvaW50MCA9IGZzYV90bXAyLFxuICAgICAgICB3b3JsZFBvaW50MSA9IGZzYV90bXAzLFxuICAgICAgICBub3JtYWwgPSBmc2FfdG1wNCxcbiAgICAgICAgc3BhbjEgPSBmc2FfdG1wNSxcbiAgICAgICAgc3BhbjIgPSBmc2FfdG1wNjtcblxuICAgIGlmKGMxIGluc3RhbmNlb2YgQm94ICYmIGMyIGluc3RhbmNlb2YgQm94KXtcblxuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PTI7IGorKyl7XG4gICAgICAgICAgICB2YXIgYyA9IGMxLFxuICAgICAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUxO1xuICAgICAgICAgICAgaWYoaj09PTEpe1xuICAgICAgICAgICAgICAgIGMgPSBjMjtcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkhPT0yOyBpKyspe1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB3b3JsZCBlZGdlXG4gICAgICAgICAgICAgICAgaWYoaSA9PT0gMCl7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIuc2V0KG5vcm1hbCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5zZXQobm9ybWFsLCAxLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoYW5nbGUgIT09IDApe1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZShub3JtYWwsIG5vcm1hbCwgYW5nbGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFByb2plY3QgaHVsbHMgb250byB0aGF0IG5vcm1hbFxuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMSxvZmZzZXQxLGFuZ2xlMSxub3JtYWwsc3BhbjEpO1xuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb2plY3RDb252ZXhPbnRvQXhpcyhjMixvZmZzZXQyLGFuZ2xlMixub3JtYWwsc3BhbjIpO1xuXG4gICAgICAgICAgICAgICAgLy8gT3JkZXIgYnkgc3BhbiBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHZhciBhPXNwYW4xLFxuICAgICAgICAgICAgICAgICAgICBiPXNwYW4yLFxuICAgICAgICAgICAgICAgICAgICBzd2FwcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYoc3BhbjFbMF0gPiBzcGFuMlswXSl7XG4gICAgICAgICAgICAgICAgICAgIGI9c3BhbjE7XG4gICAgICAgICAgICAgICAgICAgIGE9c3BhbjI7XG4gICAgICAgICAgICAgICAgICAgIHN3YXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEdldCBzZXBhcmF0aW5nIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBiWzBdIC0gYVsxXTtcbiAgICAgICAgICAgICAgICBvdmVybGFwID0gKGRpc3QgPD0gMCk7XG5cbiAgICAgICAgICAgICAgICBpZihtYXhEaXN0PT09bnVsbCB8fCBkaXN0ID4gbWF4RGlzdCl7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIuY29weShzZXBBeGlzLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICBtYXhEaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PTI7IGorKyl7XG4gICAgICAgICAgICB2YXIgYyA9IGMxLFxuICAgICAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUxO1xuICAgICAgICAgICAgaWYoaj09PTEpe1xuICAgICAgICAgICAgICAgIGMgPSBjMjtcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1jLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHdvcmxkIGVkZ2VcbiAgICAgICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBvaW50MCwgYy52ZXJ0aWNlc1tpXSwgYW5nbGUpO1xuICAgICAgICAgICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9pbnQxLCBjLnZlcnRpY2VzWyhpKzEpJWMudmVydGljZXMubGVuZ3RoXSwgYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgc3ViKGVkZ2UsIHdvcmxkUG9pbnQxLCB3b3JsZFBvaW50MCk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgbm9ybWFsIC0ganVzdCByb3RhdGUgOTAgZGVncmVlcyBzaW5jZSB2ZXJ0aWNlcyBhcmUgZ2l2ZW4gaW4gQ0NXXG4gICAgICAgICAgICAgICAgdmVjMi5yb3RhdGU5MGN3KG5vcm1hbCwgZWRnZSk7XG4gICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9qZWN0IGh1bGxzIG9udG8gdGhhdCBub3JtYWxcbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzEsb2Zmc2V0MSxhbmdsZTEsbm9ybWFsLHNwYW4xKTtcbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzIsb2Zmc2V0MixhbmdsZTIsbm9ybWFsLHNwYW4yKTtcblxuICAgICAgICAgICAgICAgIC8vIE9yZGVyIGJ5IHNwYW4gcG9zaXRpb25cbiAgICAgICAgICAgICAgICB2YXIgYT1zcGFuMSxcbiAgICAgICAgICAgICAgICAgICAgYj1zcGFuMixcbiAgICAgICAgICAgICAgICAgICAgc3dhcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmKHNwYW4xWzBdID4gc3BhbjJbMF0pe1xuICAgICAgICAgICAgICAgICAgICBiPXNwYW4xO1xuICAgICAgICAgICAgICAgICAgICBhPXNwYW4yO1xuICAgICAgICAgICAgICAgICAgICBzd2FwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgc2VwYXJhdGluZyBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gYlswXSAtIGFbMV07XG4gICAgICAgICAgICAgICAgb3ZlcmxhcCA9IChkaXN0IDw9IDApO1xuXG4gICAgICAgICAgICAgICAgaWYobWF4RGlzdD09PW51bGwgfHwgZGlzdCA+IG1heERpc3Qpe1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoc2VwQXhpcywgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4RGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qXG4gICAgLy8gTmVlZHMgdG8gYmUgdGVzdGVkIHNvbWUgbW9yZVxuICAgIGZvcih2YXIgaj0wOyBqIT09MjsgaisrKXtcbiAgICAgICAgdmFyIGMgPSBjMSxcbiAgICAgICAgICAgIGFuZ2xlID0gYW5nbGUxO1xuICAgICAgICBpZihqPT09MSl7XG4gICAgICAgICAgICBjID0gYzI7XG4gICAgICAgICAgICBhbmdsZSA9IGFuZ2xlMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09Yy5heGVzLmxlbmd0aDsgaSsrKXtcblxuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IGMuYXhlc1tpXTtcblxuICAgICAgICAgICAgLy8gUHJvamVjdCBodWxscyBvbnRvIHRoYXQgbm9ybWFsXG4gICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzEsIG9mZnNldDEsIGFuZ2xlMSwgbm9ybWFsLCBzcGFuMSk7XG4gICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm9qZWN0Q29udmV4T250b0F4aXMoYzIsIG9mZnNldDIsIGFuZ2xlMiwgbm9ybWFsLCBzcGFuMik7XG5cbiAgICAgICAgICAgIC8vIE9yZGVyIGJ5IHNwYW4gcG9zaXRpb25cbiAgICAgICAgICAgIHZhciBhPXNwYW4xLFxuICAgICAgICAgICAgICAgIGI9c3BhbjIsXG4gICAgICAgICAgICAgICAgc3dhcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYoc3BhbjFbMF0gPiBzcGFuMlswXSl7XG4gICAgICAgICAgICAgICAgYj1zcGFuMTtcbiAgICAgICAgICAgICAgICBhPXNwYW4yO1xuICAgICAgICAgICAgICAgIHN3YXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgc2VwYXJhdGluZyBkaXN0YW5jZVxuICAgICAgICAgICAgdmFyIGRpc3QgPSBiWzBdIC0gYVsxXTtcbiAgICAgICAgICAgIG92ZXJsYXAgPSAoZGlzdCA8PSBOYXJyb3dwaGFzZS5jb252ZXhQcmVjaXNpb24pO1xuXG4gICAgICAgICAgICBpZihtYXhEaXN0PT09bnVsbCB8fCBkaXN0ID4gbWF4RGlzdCl7XG4gICAgICAgICAgICAgICAgdmVjMi5jb3B5KHNlcEF4aXMsIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgbWF4RGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBvdmVybGFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICovXG5cbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG4vLyAuZ2V0Q2xvc2VzdEVkZ2UgaXMgY2FsbGVkIGJ5IG90aGVyIGZ1bmN0aW9ucywgbmVlZCBsb2NhbCB0bXAgdmVjdG9yc1xudmFyIGdjZV90bXAxID0gdmVjMi5mcm9tVmFsdWVzKDAsMClcbiwgICBnY2VfdG1wMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApXG4sICAgZ2NlX3RtcDMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBHZXQgdGhlIGVkZ2UgdGhhdCBoYXMgYSBub3JtYWwgY2xvc2VzdCB0byBhbiBheGlzLlxuICogQG1ldGhvZCBnZXRDbG9zZXN0RWRnZVxuICogQHN0YXRpY1xuICogQHBhcmFtICB7Q29udmV4fSAgICAgY1xuICogQHBhcmFtICB7TnVtYmVyfSAgICAgYW5nbGVcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIGF4aXNcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgIGZsaXBcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgSW5kZXggb2YgdGhlIGVkZ2UgdGhhdCBpcyBjbG9zZXN0LiBUaGlzIGluZGV4IGFuZCB0aGUgbmV4dCBzcGFucyB0aGUgcmVzdWx0aW5nIGVkZ2UuIFJldHVybnMgLTEgaWYgZmFpbGVkLlxuICovXG5OYXJyb3dwaGFzZS5nZXRDbG9zZXN0RWRnZSA9IGZ1bmN0aW9uKGMsYW5nbGUsYXhpcyxmbGlwKXtcbiAgICB2YXIgbG9jYWxBeGlzID0gZ2NlX3RtcDEsXG4gICAgICAgIGVkZ2UgPSBnY2VfdG1wMixcbiAgICAgICAgbm9ybWFsID0gZ2NlX3RtcDM7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSBheGlzIHRvIGxvY2FsIGNvb3JkcyBvZiB0aGUgYm9keVxuICAgIHZlYzIucm90YXRlKGxvY2FsQXhpcywgYXhpcywgLWFuZ2xlKTtcbiAgICBpZihmbGlwKXtcbiAgICAgICAgdmVjMi5zY2FsZShsb2NhbEF4aXMsbG9jYWxBeGlzLC0xKTtcbiAgICB9XG5cbiAgICB2YXIgY2xvc2VzdEVkZ2UgPSAtMSxcbiAgICAgICAgTiA9IGMudmVydGljZXMubGVuZ3RoLFxuICAgICAgICBtYXhEb3QgPSAtMTtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIC8vIEdldCB0aGUgZWRnZVxuICAgICAgICBzdWIoZWRnZSwgYy52ZXJ0aWNlc1soaSsxKSVOXSwgYy52ZXJ0aWNlc1tpJU5dKTtcblxuICAgICAgICAvLyBHZXQgbm9ybWFsIC0ganVzdCByb3RhdGUgOTAgZGVncmVlcyBzaW5jZSB2ZXJ0aWNlcyBhcmUgZ2l2ZW4gaW4gQ0NXXG4gICAgICAgIHZlYzIucm90YXRlOTBjdyhub3JtYWwsIGVkZ2UpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTtcblxuICAgICAgICB2YXIgZCA9IGRvdChub3JtYWwsbG9jYWxBeGlzKTtcbiAgICAgICAgaWYoY2xvc2VzdEVkZ2UgPT09IC0xIHx8IGQgPiBtYXhEb3Qpe1xuICAgICAgICAgICAgY2xvc2VzdEVkZ2UgPSBpICUgTjtcbiAgICAgICAgICAgIG1heERvdCA9IGQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvc2VzdEVkZ2U7XG59O1xuXG52YXIgY2lyY2xlSGVpZ2h0ZmllbGRfY2FuZGlkYXRlID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF9kaXN0ID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjaXJjbGVIZWlnaHRmaWVsZF92MCA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfdjEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZSA9IHZlYzIuY3JlYXRlKCksXG4gICAgY2lyY2xlSGVpZ2h0ZmllbGRfd29ybGROb3JtYWwgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZU5vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjaXJjbGVIZWlnaHRmaWVsZFxuICogQHBhcmFtICB7Qm9keX0gICAgICAgICAgIGJpXG4gKiBAcGFyYW0gIHtDaXJjbGV9ICAgICAgICAgc2lcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICB4aVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgICAgIGJqXG4gKiBAcGFyYW0gIHtIZWlnaHRmaWVsZH0gICAgc2pcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICB4alxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgIGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5DSVJDTEUgfCBTaGFwZS5IRUlHSFRGSUVMRF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNpcmNsZUhlaWdodGZpZWxkID0gZnVuY3Rpb24oIGNpcmNsZUJvZHksY2lyY2xlU2hhcGUsY2lyY2xlUG9zLGNpcmNsZUFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhmQm9keSxoZlNoYXBlLGhmUG9zLGhmQW5nbGUsIGp1c3RUZXN0LCByYWRpdXMgKXtcbiAgICB2YXIgZGF0YSA9IGhmU2hhcGUuaGVpZ2h0cyxcbiAgICAgICAgcmFkaXVzID0gcmFkaXVzIHx8IGNpcmNsZVNoYXBlLnJhZGl1cyxcbiAgICAgICAgdyA9IGhmU2hhcGUuZWxlbWVudFdpZHRoLFxuICAgICAgICBkaXN0ID0gY2lyY2xlSGVpZ2h0ZmllbGRfZGlzdCxcbiAgICAgICAgY2FuZGlkYXRlID0gY2lyY2xlSGVpZ2h0ZmllbGRfY2FuZGlkYXRlLFxuICAgICAgICBtaW5DYW5kaWRhdGUgPSBjaXJjbGVIZWlnaHRmaWVsZF9taW5DYW5kaWRhdGUsXG4gICAgICAgIG1pbkNhbmRpZGF0ZU5vcm1hbCA9IGNpcmNsZUhlaWdodGZpZWxkX21pbkNhbmRpZGF0ZU5vcm1hbCxcbiAgICAgICAgd29ybGROb3JtYWwgPSBjaXJjbGVIZWlnaHRmaWVsZF93b3JsZE5vcm1hbCxcbiAgICAgICAgdjAgPSBjaXJjbGVIZWlnaHRmaWVsZF92MCxcbiAgICAgICAgdjEgPSBjaXJjbGVIZWlnaHRmaWVsZF92MTtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcbiAgICB2YXIgaWR4QSA9IE1hdGguZmxvb3IoIChjaXJjbGVQb3NbMF0gLSByYWRpdXMgLSBoZlBvc1swXSkgLyB3ICksXG4gICAgICAgIGlkeEIgPSBNYXRoLmNlaWwoICAoY2lyY2xlUG9zWzBdICsgcmFkaXVzIC0gaGZQb3NbMF0pIC8gdyApO1xuXG4gICAgLyppZihpZHhCIDwgMCB8fCBpZHhBID49IGRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4ganVzdFRlc3QgPyBmYWxzZSA6IDA7Ki9cblxuICAgIGlmKGlkeEEgPCAwKXtcbiAgICAgICAgaWR4QSA9IDA7XG4gICAgfVxuICAgIGlmKGlkeEIgPj0gZGF0YS5sZW5ndGgpe1xuICAgICAgICBpZHhCID0gZGF0YS5sZW5ndGgtMTtcbiAgICB9XG5cbiAgICAvLyBHZXQgbWF4IGFuZCBtaW5cbiAgICB2YXIgbWF4ID0gZGF0YVtpZHhBXSxcbiAgICAgICAgbWluID0gZGF0YVtpZHhCXTtcbiAgICBmb3IodmFyIGk9aWR4QTsgaTxpZHhCOyBpKyspe1xuICAgICAgICBpZihkYXRhW2ldIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IGRhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYoZGF0YVtpXSA+IG1heCl7XG4gICAgICAgICAgICBtYXggPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoY2lyY2xlUG9zWzFdLXJhZGl1cyA+IG1heCl7XG4gICAgICAgIHJldHVybiBqdXN0VGVzdCA/IGZhbHNlIDogMDtcbiAgICB9XG5cbiAgICAvKlxuICAgIGlmKGNpcmNsZVBvc1sxXStyYWRpdXMgPCBtaW4pe1xuICAgICAgICAvLyBCZWxvdyB0aGUgbWluaW11bSBwb2ludC4uLiBXZSBjYW4ganVzdCBndWVzcy5cbiAgICAgICAgLy8gVE9ET1xuICAgIH1cbiAgICAqL1xuXG4gICAgLy8gMS4gQ2hlY2sgc28gY2VudGVyIG9mIGNpcmNsZSBpcyBub3QgaW5zaWRlIHRoZSBmaWVsZC4gSWYgaXQgaXMsIHRoaXMgd29udCB3b3JrLi4uXG4gICAgLy8gMi4gRm9yIGVhY2ggZWRnZVxuICAgIC8vIDIuIDEuIEdldCBwb2ludCBvbiBjaXJjbGUgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBlZGdlIChzY2FsZSBub3JtYWwgd2l0aCAtcmFkaXVzKVxuICAgIC8vIDIuIDIuIENoZWNrIGlmIHBvaW50IGlzIGluc2lkZS5cblxuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYWxsIGVkZ2VzIGZpcnN0XG4gICAgZm9yKHZhciBpPWlkeEE7IGk8aWR4QjsgaSsrKXtcblxuICAgICAgICAvLyBHZXQgcG9pbnRzXG4gICAgICAgIHZlYzIuc2V0KHYwLCAgICAgaSp3LCBkYXRhW2ldICApO1xuICAgICAgICB2ZWMyLnNldCh2MSwgKGkrMSkqdywgZGF0YVtpKzFdKTtcbiAgICAgICAgdmVjMi5hZGQodjAsdjAsaGZQb3MpO1xuICAgICAgICB2ZWMyLmFkZCh2MSx2MSxoZlBvcyk7XG5cbiAgICAgICAgLy8gR2V0IG5vcm1hbFxuICAgICAgICB2ZWMyLnN1Yih3b3JsZE5vcm1hbCwgdjEsIHYwKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGROb3JtYWwsIHdvcmxkTm9ybWFsLCBNYXRoLlBJLzIpO1xuICAgICAgICB2ZWMyLm5vcm1hbGl6ZSh3b3JsZE5vcm1hbCx3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgLy8gR2V0IHBvaW50IG9uIGNpcmNsZSwgY2xvc2VzdCB0byB0aGUgZWRnZVxuICAgICAgICB2ZWMyLnNjYWxlKGNhbmRpZGF0ZSx3b3JsZE5vcm1hbCwtcmFkaXVzKTtcbiAgICAgICAgdmVjMi5hZGQoY2FuZGlkYXRlLGNhbmRpZGF0ZSxjaXJjbGVQb3MpO1xuXG4gICAgICAgIC8vIERpc3RhbmNlIGZyb20gdjAgdG8gdGhlIGNhbmRpZGF0ZSBwb2ludFxuICAgICAgICB2ZWMyLnN1YihkaXN0LGNhbmRpZGF0ZSx2MCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgaXMgaW4gdGhlIGVsZW1lbnQgXCJzdGlja1wiXG4gICAgICAgIHZhciBkID0gdmVjMi5kb3QoZGlzdCx3b3JsZE5vcm1hbCk7XG4gICAgICAgIGlmKGNhbmRpZGF0ZVswXSA+PSB2MFswXSAmJiBjYW5kaWRhdGVbMF0gPCB2MVswXSAmJiBkIDw9IDApe1xuXG4gICAgICAgICAgICBpZihqdXN0VGVzdCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGNhbmRpZGF0ZSBwb2ludCwgcHJvamVjdGVkIHRvIHRoZSBlZGdlXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGRpc3Qsd29ybGROb3JtYWwsLWQpO1xuICAgICAgICAgICAgdmVjMi5hZGQobWluQ2FuZGlkYXRlLGNhbmRpZGF0ZSxkaXN0KTtcbiAgICAgICAgICAgIHZlYzIuY29weShtaW5DYW5kaWRhdGVOb3JtYWwsd29ybGROb3JtYWwpO1xuXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGhmQm9keSxjaXJjbGVCb2R5LGhmU2hhcGUsY2lyY2xlU2hhcGUpO1xuXG4gICAgICAgICAgICAvLyBOb3JtYWwgaXMgb3V0IG9mIHRoZSBoZWlnaHRmaWVsZFxuICAgICAgICAgICAgdmVjMi5jb3B5KGMubm9ybWFsQSwgbWluQ2FuZGlkYXRlTm9ybWFsKTtcblxuICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gY2lyY2xlIHRvIGhlaWdodGZpZWxkXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGMuY29udGFjdFBvaW50QiwgIGMubm9ybWFsQSwgLXJhZGl1cyk7XG4gICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNpcmNsZVBvcyk7XG4gICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICB2ZWMyLmNvcHkoYy5jb250YWN0UG9pbnRBLCBtaW5DYW5kaWRhdGUpO1xuICAgICAgICAgICAgdmVjMi5zdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGhmQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucy5wdXNoKGMpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uKXtcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQ29udGFjdChjKSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgYWxsIHZlcnRpY2VzXG4gICAgZm91bmQgPSBmYWxzZTtcbiAgICBpZihyYWRpdXMgPiAwKXtcbiAgICAgICAgZm9yKHZhciBpPWlkeEE7IGk8PWlkeEI7IGkrKyl7XG5cbiAgICAgICAgICAgIC8vIEdldCBwb2ludFxuICAgICAgICAgICAgdmVjMi5zZXQodjAsIGkqdywgZGF0YVtpXSk7XG4gICAgICAgICAgICB2ZWMyLmFkZCh2MCx2MCxoZlBvcyk7XG5cbiAgICAgICAgICAgIHZlYzIuc3ViKGRpc3QsIGNpcmNsZVBvcywgdjApO1xuXG4gICAgICAgICAgICBpZih2ZWMyLnNxdWFyZWRMZW5ndGgoZGlzdCkgPCBNYXRoLnBvdyhyYWRpdXMsIDIpKXtcblxuICAgICAgICAgICAgICAgIGlmKGp1c3RUZXN0KXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihoZkJvZHksY2lyY2xlQm9keSxoZlNoYXBlLGNpcmNsZVNoYXBlKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCBub3JtYWwgLSBvdXQgb2YgaGVpZ2h0ZmllbGRcbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkoYy5ub3JtYWxBLCBkaXN0KTtcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShjLm5vcm1hbEEsYy5ub3JtYWxBKTtcblxuICAgICAgICAgICAgICAgIHZlYzIuc2NhbGUoYy5jb250YWN0UG9pbnRCLCBjLm5vcm1hbEEsIC1yYWRpdXMpO1xuICAgICAgICAgICAgICAgIGFkZChjLmNvbnRhY3RQb2ludEIsIGMuY29udGFjdFBvaW50QiwgY2lyY2xlUG9zKTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRCLCBjLmNvbnRhY3RQb2ludEIsIGNpcmNsZUJvZHkucG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgc3ViKGMuY29udGFjdFBvaW50QSwgdjAsIGhmUG9zKTtcbiAgICAgICAgICAgICAgICBhZGQoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGhmUG9zKTtcbiAgICAgICAgICAgICAgICBzdWIoYy5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEsIGhmQm9keS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvbnMucHVzaChjKTtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb24pe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2godGhpcy5jcmVhdGVGcmljdGlvbkZyb21Db250YWN0KGMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihmb3VuZCl7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuXG59O1xuXG52YXIgY29udmV4SGVpZ2h0ZmllbGRfdjAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGNvbnZleEhlaWdodGZpZWxkX3YxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjb252ZXhIZWlnaHRmaWVsZF90aWxlUG9zID0gdmVjMi5jcmVhdGUoKSxcbiAgICBjb252ZXhIZWlnaHRmaWVsZF90ZW1wQ29udmV4U2hhcGUgPSBuZXcgQ29udmV4KHsgdmVydGljZXM6IFt2ZWMyLmNyZWF0ZSgpLHZlYzIuY3JlYXRlKCksdmVjMi5jcmVhdGUoKSx2ZWMyLmNyZWF0ZSgpXSB9KTtcbi8qKlxuICogQG1ldGhvZCBjaXJjbGVIZWlnaHRmaWVsZFxuICogQHBhcmFtICB7Qm9keX0gICAgICAgICAgIGJpXG4gKiBAcGFyYW0gIHtDaXJjbGV9ICAgICAgICAgc2lcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICB4aVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgICAgIGJqXG4gKiBAcGFyYW0gIHtIZWlnaHRmaWVsZH0gICAgc2pcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgICAgICB4alxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgIGFqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS5CT1ggfCBTaGFwZS5IRUlHSFRGSUVMRF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLkNPTlZFWCB8IFNoYXBlLkhFSUdIVEZJRUxEXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4SGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiggY29udmV4Qm9keSxjb252ZXhTaGFwZSxjb252ZXhQb3MsY29udmV4QW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZCb2R5LGhmU2hhcGUsaGZQb3MsaGZBbmdsZSwganVzdFRlc3QgKXtcbiAgICB2YXIgZGF0YSA9IGhmU2hhcGUuaGVpZ2h0cyxcbiAgICAgICAgdyA9IGhmU2hhcGUuZWxlbWVudFdpZHRoLFxuICAgICAgICB2MCA9IGNvbnZleEhlaWdodGZpZWxkX3YwLFxuICAgICAgICB2MSA9IGNvbnZleEhlaWdodGZpZWxkX3YxLFxuICAgICAgICB0aWxlUG9zID0gY29udmV4SGVpZ2h0ZmllbGRfdGlsZVBvcyxcbiAgICAgICAgdGlsZUNvbnZleCA9IGNvbnZleEhlaWdodGZpZWxkX3RlbXBDb252ZXhTaGFwZTtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcbiAgICB2YXIgaWR4QSA9IE1hdGguZmxvb3IoIChjb252ZXhCb2R5LmFhYmIubG93ZXJCb3VuZFswXSAtIGhmUG9zWzBdKSAvIHcgKSxcbiAgICAgICAgaWR4QiA9IE1hdGguY2VpbCggIChjb252ZXhCb2R5LmFhYmIudXBwZXJCb3VuZFswXSAtIGhmUG9zWzBdKSAvIHcgKTtcblxuICAgIGlmKGlkeEEgPCAwKXtcbiAgICAgICAgaWR4QSA9IDA7XG4gICAgfVxuICAgIGlmKGlkeEIgPj0gZGF0YS5sZW5ndGgpe1xuICAgICAgICBpZHhCID0gZGF0YS5sZW5ndGgtMTtcbiAgICB9XG5cbiAgICAvLyBHZXQgbWF4IGFuZCBtaW5cbiAgICB2YXIgbWF4ID0gZGF0YVtpZHhBXSxcbiAgICAgICAgbWluID0gZGF0YVtpZHhCXTtcbiAgICBmb3IodmFyIGk9aWR4QTsgaTxpZHhCOyBpKyspe1xuICAgICAgICBpZihkYXRhW2ldIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IGRhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYoZGF0YVtpXSA+IG1heCl7XG4gICAgICAgICAgICBtYXggPSBkYXRhW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoY29udmV4Qm9keS5hYWJiLmxvd2VyQm91bmRbMV0gPiBtYXgpe1xuICAgICAgICByZXR1cm4ganVzdFRlc3QgPyBmYWxzZSA6IDA7XG4gICAgfVxuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgdmFyIG51bUNvbnRhY3RzID0gMDtcblxuICAgIC8vIExvb3Agb3ZlciBhbGwgZWRnZXNcbiAgICAvLyBUT0RPOiBJZiBwb3NzaWJsZSwgY29uc3RydWN0IGEgY29udmV4IGZyb20gc2V2ZXJhbCBkYXRhIHBvaW50cyAobmVlZCBvIGNoZWNrIGlmIHRoZSBwb2ludHMgbWFrZSBhIGNvbnZleCBzaGFwZSlcbiAgICBmb3IodmFyIGk9aWR4QTsgaTxpZHhCOyBpKyspe1xuXG4gICAgICAgIC8vIEdldCBwb2ludHNcbiAgICAgICAgdmVjMi5zZXQodjAsICAgICBpKncsIGRhdGFbaV0gICk7XG4gICAgICAgIHZlYzIuc2V0KHYxLCAoaSsxKSp3LCBkYXRhW2krMV0pO1xuICAgICAgICB2ZWMyLmFkZCh2MCx2MCxoZlBvcyk7XG4gICAgICAgIHZlYzIuYWRkKHYxLHYxLGhmUG9zKTtcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBjb252ZXhcbiAgICAgICAgdmFyIHRpbGVIZWlnaHQgPSAxMDA7IC8vIHRvZG9cbiAgICAgICAgdmVjMi5zZXQodGlsZVBvcywgKHYxWzBdICsgdjBbMF0pKjAuNSwgKHYxWzFdICsgdjBbMV0gLSB0aWxlSGVpZ2h0KSowLjUpO1xuXG4gICAgICAgIHZlYzIuc3ViKHRpbGVDb252ZXgudmVydGljZXNbMF0sIHYxLCB0aWxlUG9zKTtcbiAgICAgICAgdmVjMi5zdWIodGlsZUNvbnZleC52ZXJ0aWNlc1sxXSwgdjAsIHRpbGVQb3MpO1xuICAgICAgICB2ZWMyLmNvcHkodGlsZUNvbnZleC52ZXJ0aWNlc1syXSwgdGlsZUNvbnZleC52ZXJ0aWNlc1sxXSk7XG4gICAgICAgIHZlYzIuY29weSh0aWxlQ29udmV4LnZlcnRpY2VzWzNdLCB0aWxlQ29udmV4LnZlcnRpY2VzWzBdKTtcbiAgICAgICAgdGlsZUNvbnZleC52ZXJ0aWNlc1syXVsxXSAtPSB0aWxlSGVpZ2h0O1xuICAgICAgICB0aWxlQ29udmV4LnZlcnRpY2VzWzNdWzFdIC09IHRpbGVIZWlnaHQ7XG5cbiAgICAgICAgLy8gRG8gY29udmV4IGNvbGxpc2lvblxuICAgICAgICBudW1Db250YWN0cyArPSB0aGlzLmNvbnZleENvbnZleCggICBjb252ZXhCb2R5LCBjb252ZXhTaGFwZSwgY29udmV4UG9zLCBjb252ZXhBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZCb2R5LCB0aWxlQ29udmV4LCB0aWxlUG9zLCAwLCBqdXN0VGVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bUNvbnRhY3RzO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/collision/Narrowphase.js\n");

/***/ }),

/***/ "./node_modules/p2/src/collision/Ray.js":
/*!**********************************************!*\
  !*** ./node_modules/p2/src/collision/Ray.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = Ray;\n\nvar vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\nvar RaycastResult = __webpack_require__(/*! ../collision/RaycastResult */ \"./node_modules/p2/src/collision/RaycastResult.js\");\nvar Shape = __webpack_require__(/*! ../shapes/Shape */ \"./node_modules/p2/src/shapes/Shape.js\");\nvar AABB = __webpack_require__(/*! ../collision/AABB */ \"./node_modules/p2/src/collision/AABB.js\");\n\n/**\n * A line with a start and end point that is used to intersect shapes. For an example, see {{#crossLink \"World/raycast:method\"}}World.raycast{{/crossLink}}\n * @class Ray\n * @constructor\n * @param {object} [options]\n * @param {array} [options.from]\n * @param {array} [options.to]\n * @param {boolean} [options.checkCollisionResponse=true]\n * @param {boolean} [options.skipBackfaces=false]\n * @param {number} [options.collisionMask=-1]\n * @param {number} [options.collisionGroup=-1]\n * @param {number} [options.mode=Ray.ANY]\n * @param {number} [options.callback]\n */\nfunction Ray(options){\n    options = options || {};\n\n    /**\n     * Ray start point.\n     * @property {array} from\n     */\n    this.from = options.from ? vec2.fromValues(options.from[0], options.from[1]) : vec2.create();\n\n    /**\n     * Ray end point\n     * @property {array} to\n     */\n    this.to = options.to ? vec2.fromValues(options.to[0], options.to[1]) : vec2.create();\n\n    /**\n     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.\n     * @property {Boolean} checkCollisionResponse\n     */\n    this.checkCollisionResponse = options.checkCollisionResponse !== undefined ? options.checkCollisionResponse : true;\n\n    /**\n     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.\n     * @property {Boolean} skipBackfaces\n     */\n    this.skipBackfaces = !!options.skipBackfaces;\n\n    /**\n     * @property {number} collisionMask\n     * @default -1\n     */\n    this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : -1;\n\n    /**\n     * @property {number} collisionGroup\n     * @default -1\n     */\n    this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : -1;\n\n    /**\n     * The intersection mode. Should be {{#crossLink \"Ray/ANY:property\"}}Ray.ANY{{/crossLink}}, {{#crossLink \"Ray/ALL:property\"}}Ray.ALL{{/crossLink}} or {{#crossLink \"Ray/CLOSEST:property\"}}Ray.CLOSEST{{/crossLink}}.\n     * @property {number} mode\n     */\n    this.mode = options.mode !== undefined ? options.mode : Ray.ANY;\n\n    /**\n     * Current, user-provided result callback. Will be used if mode is Ray.ALL.\n     * @property {Function} callback\n     */\n    this.callback = options.callback || function(result){};\n\n    /**\n     * @readOnly\n     * @property {array} direction\n     */\n    this.direction = vec2.create();\n\n    /**\n     * Length of the ray\n     * @readOnly\n     * @property {number} length\n     */\n    this.length = 1;\n\n    this.update();\n}\nRay.prototype.constructor = Ray;\n\n/**\n * This raycasting mode will make the Ray traverse through all intersection points and only return the closest one.\n * @static\n * @property {Number} CLOSEST\n */\nRay.CLOSEST = 1;\n\n/**\n * This raycasting mode will make the Ray stop when it finds the first intersection point.\n * @static\n * @property {Number} ANY\n */\nRay.ANY = 2;\n\n/**\n * This raycasting mode will traverse all intersection points and executes a callback for each one.\n * @static\n * @property {Number} ALL\n */\nRay.ALL = 4;\n\n/**\n * Should be called if you change the from or to point.\n * @method update\n */\nRay.prototype.update = function(){\n\n    // Update .direction and .length\n    var d = this.direction;\n    vec2.sub(d, this.to, this.from);\n    this.length = vec2.length(d);\n    vec2.normalize(d, d);\n\n};\n\n/**\n * @method intersectBodies\n * @param {Array} bodies An array of Body objects.\n */\nRay.prototype.intersectBodies = function (result, bodies) {\n    for (var i = 0, l = bodies.length; !result.shouldStop(this) && i < l; i++) {\n        var body = bodies[i];\n        var aabb = body.getAABB();\n        if(aabb.overlapsRay(this) >= 0 || aabb.containsPoint(this.from)){\n            this.intersectBody(result, body);\n        }\n    }\n};\n\nvar intersectBody_worldPosition = vec2.create();\n\n/**\n * Shoot a ray at a body, get back information about the hit.\n * @method intersectBody\n * @private\n * @param {Body} body\n */\nRay.prototype.intersectBody = function (result, body) {\n    var checkCollisionResponse = this.checkCollisionResponse;\n\n    if(checkCollisionResponse && !body.collisionResponse){\n        return;\n    }\n\n    var worldPosition = intersectBody_worldPosition;\n\n    for (var i = 0, N = body.shapes.length; i < N; i++) {\n        var shape = body.shapes[i];\n\n        if(checkCollisionResponse && !shape.collisionResponse){\n            continue; // Skip\n        }\n\n        if((this.collisionGroup & shape.collisionMask) === 0 || (shape.collisionGroup & this.collisionMask) === 0){\n            continue;\n        }\n\n        // Get world angle and position of the shape\n        vec2.rotate(worldPosition, shape.position, body.angle);\n        vec2.add(worldPosition, worldPosition, body.position);\n        var worldAngle = shape.angle + body.angle;\n\n        this.intersectShape(\n            result,\n            shape,\n            worldAngle,\n            worldPosition,\n            body\n        );\n\n        if(result.shouldStop(this)){\n            break;\n        }\n    }\n};\n\n/**\n * @method intersectShape\n * @private\n * @param {Shape} shape\n * @param {number} angle\n * @param {array} position\n * @param {Body} body\n */\nRay.prototype.intersectShape = function(result, shape, angle, position, body){\n    var from = this.from;\n\n    // Checking radius\n    var distance = distanceFromIntersectionSquared(from, this.direction, position);\n    if (distance > shape.boundingRadius * shape.boundingRadius) {\n        return;\n    }\n\n    this._currentBody = body;\n    this._currentShape = shape;\n\n    shape.raycast(result, this, position, angle);\n\n    this._currentBody = this._currentShape = null;\n};\n\n/**\n * Get the AABB of the ray.\n * @method getAABB\n * @param  {AABB} aabb\n */\nRay.prototype.getAABB = function(result){\n    var to = this.to;\n    var from = this.from;\n    vec2.set(\n        result.lowerBound,\n        Math.min(to[0], from[0]),\n        Math.min(to[1], from[1])\n    );\n    vec2.set(\n        result.upperBound,\n        Math.max(to[0], from[0]),\n        Math.max(to[1], from[1])\n    );\n};\n\nvar hitPointWorld = vec2.create();\n\n/**\n * @method reportIntersection\n * @private\n * @param  {number} fraction\n * @param  {array} normal\n * @param  {number} [faceIndex=-1]\n * @return {boolean} True if the intersections should continue\n */\nRay.prototype.reportIntersection = function(result, fraction, normal, faceIndex){\n    var from = this.from;\n    var to = this.to;\n    var shape = this._currentShape;\n    var body = this._currentBody;\n\n    // Skip back faces?\n    if(this.skipBackfaces && vec2.dot(normal, this.direction) > 0){\n        return;\n    }\n\n    switch(this.mode){\n\n    case Ray.ALL:\n        result.set(\n            normal,\n            shape,\n            body,\n            fraction,\n            faceIndex\n        );\n        this.callback(result);\n        break;\n\n    case Ray.CLOSEST:\n\n        // Store if closer than current closest\n        if(fraction < result.fraction || !result.hasHit()){\n            result.set(\n                normal,\n                shape,\n                body,\n                fraction,\n                faceIndex\n            );\n        }\n        break;\n\n    case Ray.ANY:\n\n        // Report and stop.\n        result.set(\n            normal,\n            shape,\n            body,\n            fraction,\n            faceIndex\n        );\n        break;\n    }\n};\n\nvar v0 = vec2.create(),\n    intersect = vec2.create();\nfunction distanceFromIntersectionSquared(from, direction, position) {\n\n    // v0 is vector from from to position\n    vec2.sub(v0, position, from);\n    var dot = vec2.dot(v0, direction);\n\n    // intersect = direction * dot + from\n    vec2.scale(intersect, direction, dot);\n    vec2.add(intersect, intersect, from);\n\n    return vec2.squaredDistance(position, intersect);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbGxpc2lvbi9SYXkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbGxpc2lvbi9SYXkuanM/YTU3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFJheTtcblxudmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBSYXljYXN0UmVzdWx0ID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9TaGFwZScpO1xudmFyIEFBQkIgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQUFCQicpO1xuXG4vKipcbiAqIEEgbGluZSB3aXRoIGEgc3RhcnQgYW5kIGVuZCBwb2ludCB0aGF0IGlzIHVzZWQgdG8gaW50ZXJzZWN0IHNoYXBlcy4gRm9yIGFuIGV4YW1wbGUsIHNlZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9yYXljYXN0Om1ldGhvZFwifX1Xb3JsZC5yYXljYXN0e3svY3Jvc3NMaW5rfX1cbiAqIEBjbGFzcyBSYXlcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMuZnJvbV1cbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLnRvXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uTWFzaz0tMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25Hcm91cD0tMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tb2RlPVJheS5BTlldXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gKi9cbmZ1bmN0aW9uIFJheShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFJheSBzdGFydCBwb2ludC5cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBmcm9tXG4gICAgICovXG4gICAgdGhpcy5mcm9tID0gb3B0aW9ucy5mcm9tID8gdmVjMi5mcm9tVmFsdWVzKG9wdGlvbnMuZnJvbVswXSwgb3B0aW9ucy5mcm9tWzFdKSA6IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBSYXkgZW5kIHBvaW50XG4gICAgICogQHByb3BlcnR5IHthcnJheX0gdG9cbiAgICAgKi9cbiAgICB0aGlzLnRvID0gb3B0aW9ucy50byA/IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLnRvWzBdLCBvcHRpb25zLnRvWzFdKSA6IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGUgUmF5IHRvIHRha2UgLmNvbGxpc2lvblJlc3BvbnNlIGZsYWdzIGludG8gYWNjb3VudCBvbiBib2RpZXMgYW5kIHNoYXBlcy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNoZWNrQ29sbGlzaW9uUmVzcG9uc2VcbiAgICAgKi9cbiAgICB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSBvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZSA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHJheSBza2lwcyBhbnkgaGl0cyB3aXRoIG5vcm1hbC5kb3QocmF5RGlyZWN0aW9uKSA8IDAuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBza2lwQmFja2ZhY2VzXG4gICAgICovXG4gICAgdGhpcy5za2lwQmFja2ZhY2VzID0gISFvcHRpb25zLnNraXBCYWNrZmFjZXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY29sbGlzaW9uTWFza1xuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25NYXNrID0gb3B0aW9ucy5jb2xsaXNpb25NYXNrICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxpc2lvbk1hc2sgOiAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25Hcm91cFxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IG9wdGlvbnMuY29sbGlzaW9uR3JvdXAgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGlzaW9uR3JvdXAgOiAtMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnNlY3Rpb24gbW9kZS4gU2hvdWxkIGJlIHt7I2Nyb3NzTGluayBcIlJheS9BTlk6cHJvcGVydHlcIn19UmF5LkFOWXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJSYXkvQUxMOnByb3BlcnR5XCJ9fVJheS5BTEx7ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJSYXkvQ0xPU0VTVDpwcm9wZXJ0eVwifX1SYXkuQ0xPU0VTVHt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb2RlXG4gICAgICovXG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1vZGUgOiBSYXkuQU5ZO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCwgdXNlci1wcm92aWRlZCByZXN1bHQgY2FsbGJhY2suIFdpbGwgYmUgdXNlZCBpZiBtb2RlIGlzIFJheS5BTEwuXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbihyZXN1bHQpe307XG5cbiAgICAvKipcbiAgICAgKiBAcmVhZE9ubHlcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBkaXJlY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmRpcmVjdGlvbiA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBMZW5ndGggb2YgdGhlIHJheVxuICAgICAqIEByZWFkT25seVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xufVxuUmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJheTtcblxuLyoqXG4gKiBUaGlzIHJheWNhc3RpbmcgbW9kZSB3aWxsIG1ha2UgdGhlIFJheSB0cmF2ZXJzZSB0aHJvdWdoIGFsbCBpbnRlcnNlY3Rpb24gcG9pbnRzIGFuZCBvbmx5IHJldHVybiB0aGUgY2xvc2VzdCBvbmUuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQ0xPU0VTVFxuICovXG5SYXkuQ0xPU0VTVCA9IDE7XG5cbi8qKlxuICogVGhpcyByYXljYXN0aW5nIG1vZGUgd2lsbCBtYWtlIHRoZSBSYXkgc3RvcCB3aGVuIGl0IGZpbmRzIHRoZSBmaXJzdCBpbnRlcnNlY3Rpb24gcG9pbnQuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQU5ZXG4gKi9cblJheS5BTlkgPSAyO1xuXG4vKipcbiAqIFRoaXMgcmF5Y2FzdGluZyBtb2RlIHdpbGwgdHJhdmVyc2UgYWxsIGludGVyc2VjdGlvbiBwb2ludHMgYW5kIGV4ZWN1dGVzIGEgY2FsbGJhY2sgZm9yIGVhY2ggb25lLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IEFMTFxuICovXG5SYXkuQUxMID0gNDtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIGlmIHlvdSBjaGFuZ2UgdGhlIGZyb20gb3IgdG8gcG9pbnQuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5SYXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG5cbiAgICAvLyBVcGRhdGUgLmRpcmVjdGlvbiBhbmQgLmxlbmd0aFxuICAgIHZhciBkID0gdGhpcy5kaXJlY3Rpb247XG4gICAgdmVjMi5zdWIoZCwgdGhpcy50bywgdGhpcy5mcm9tKTtcbiAgICB0aGlzLmxlbmd0aCA9IHZlYzIubGVuZ3RoKGQpO1xuICAgIHZlYzIubm9ybWFsaXplKGQsIGQpO1xuXG59O1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9kaWVzXG4gKiBAcGFyYW0ge0FycmF5fSBib2RpZXMgQW4gYXJyYXkgb2YgQm9keSBvYmplY3RzLlxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZGllcyA9IGZ1bmN0aW9uIChyZXN1bHQsIGJvZGllcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYm9kaWVzLmxlbmd0aDsgIXJlc3VsdC5zaG91bGRTdG9wKHRoaXMpICYmIGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgIHZhciBhYWJiID0gYm9keS5nZXRBQUJCKCk7XG4gICAgICAgIGlmKGFhYmIub3ZlcmxhcHNSYXkodGhpcykgPj0gMCB8fCBhYWJiLmNvbnRhaW5zUG9pbnQodGhpcy5mcm9tKSl7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdEJvZHkocmVzdWx0LCBib2R5KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBpbnRlcnNlY3RCb2R5X3dvcmxkUG9zaXRpb24gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFNob290IGEgcmF5IGF0IGEgYm9keSwgZ2V0IGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdC5cbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9keVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZHkgPSBmdW5jdGlvbiAocmVzdWx0LCBib2R5KSB7XG4gICAgdmFyIGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U7XG5cbiAgICBpZihjaGVja0NvbGxpc2lvblJlc3BvbnNlICYmICFib2R5LmNvbGxpc2lvblJlc3BvbnNlKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3b3JsZFBvc2l0aW9uID0gaW50ZXJzZWN0Qm9keV93b3JsZFBvc2l0aW9uO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIE4gPSBib2R5LnNoYXBlcy5sZW5ndGg7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgdmFyIHNoYXBlID0gYm9keS5zaGFwZXNbaV07XG5cbiAgICAgICAgaWYoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhc2hhcGUuY29sbGlzaW9uUmVzcG9uc2Upe1xuICAgICAgICAgICAgY29udGludWU7IC8vIFNraXBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCh0aGlzLmNvbGxpc2lvbkdyb3VwICYgc2hhcGUuY29sbGlzaW9uTWFzaykgPT09IDAgfHwgKHNoYXBlLmNvbGxpc2lvbkdyb3VwICYgdGhpcy5jb2xsaXNpb25NYXNrKSA9PT0gMCl7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB3b3JsZCBhbmdsZSBhbmQgcG9zaXRpb24gb2YgdGhlIHNoYXBlXG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUG9zaXRpb24sIHNoYXBlLnBvc2l0aW9uLCBib2R5LmFuZ2xlKTtcbiAgICAgICAgdmVjMi5hZGQod29ybGRQb3NpdGlvbiwgd29ybGRQb3NpdGlvbiwgYm9keS5wb3NpdGlvbik7XG4gICAgICAgIHZhciB3b3JsZEFuZ2xlID0gc2hhcGUuYW5nbGUgKyBib2R5LmFuZ2xlO1xuXG4gICAgICAgIHRoaXMuaW50ZXJzZWN0U2hhcGUoXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgIHdvcmxkQW5nbGUsXG4gICAgICAgICAgICB3b3JsZFBvc2l0aW9uLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICApO1xuXG4gICAgICAgIGlmKHJlc3VsdC5zaG91bGRTdG9wKHRoaXMpKXtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFNoYXBlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFNoYXBlID0gZnVuY3Rpb24ocmVzdWx0LCBzaGFwZSwgYW5nbGUsIHBvc2l0aW9uLCBib2R5KXtcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcblxuICAgIC8vIENoZWNraW5nIHJhZGl1c1xuICAgIHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlRnJvbUludGVyc2VjdGlvblNxdWFyZWQoZnJvbSwgdGhpcy5kaXJlY3Rpb24sIHBvc2l0aW9uKTtcbiAgICBpZiAoZGlzdGFuY2UgPiBzaGFwZS5ib3VuZGluZ1JhZGl1cyAqIHNoYXBlLmJvdW5kaW5nUmFkaXVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50Qm9keSA9IGJvZHk7XG4gICAgdGhpcy5fY3VycmVudFNoYXBlID0gc2hhcGU7XG5cbiAgICBzaGFwZS5yYXljYXN0KHJlc3VsdCwgdGhpcywgcG9zaXRpb24sIGFuZ2xlKTtcblxuICAgIHRoaXMuX2N1cnJlbnRCb2R5ID0gdGhpcy5fY3VycmVudFNoYXBlID0gbnVsbDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBBQUJCIG9mIHRoZSByYXkuXG4gKiBAbWV0aG9kIGdldEFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuUmF5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHZlYzIuc2V0KFxuICAgICAgICByZXN1bHQubG93ZXJCb3VuZCxcbiAgICAgICAgTWF0aC5taW4odG9bMF0sIGZyb21bMF0pLFxuICAgICAgICBNYXRoLm1pbih0b1sxXSwgZnJvbVsxXSlcbiAgICApO1xuICAgIHZlYzIuc2V0KFxuICAgICAgICByZXN1bHQudXBwZXJCb3VuZCxcbiAgICAgICAgTWF0aC5tYXgodG9bMF0sIGZyb21bMF0pLFxuICAgICAgICBNYXRoLm1heCh0b1sxXSwgZnJvbVsxXSlcbiAgICApO1xufTtcblxudmFyIGhpdFBvaW50V29ybGQgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgcmVwb3J0SW50ZXJzZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7bnVtYmVyfSBmcmFjdGlvblxuICogQHBhcmFtICB7YXJyYXl9IG5vcm1hbFxuICogQHBhcmFtICB7bnVtYmVyfSBbZmFjZUluZGV4PS0xXVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgaW50ZXJzZWN0aW9ucyBzaG91bGQgY29udGludWVcbiAqL1xuUmF5LnByb3RvdHlwZS5yZXBvcnRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQsIGZyYWN0aW9uLCBub3JtYWwsIGZhY2VJbmRleCl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgc2hhcGUgPSB0aGlzLl9jdXJyZW50U2hhcGU7XG4gICAgdmFyIGJvZHkgPSB0aGlzLl9jdXJyZW50Qm9keTtcblxuICAgIC8vIFNraXAgYmFjayBmYWNlcz9cbiAgICBpZih0aGlzLnNraXBCYWNrZmFjZXMgJiYgdmVjMi5kb3Qobm9ybWFsLCB0aGlzLmRpcmVjdGlvbikgPiAwKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCh0aGlzLm1vZGUpe1xuXG4gICAgY2FzZSBSYXkuQUxMOlxuICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZnJhY3Rpb24sXG4gICAgICAgICAgICBmYWNlSW5kZXhcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICBicmVhaztcblxuICAgIGNhc2UgUmF5LkNMT1NFU1Q6XG5cbiAgICAgICAgLy8gU3RvcmUgaWYgY2xvc2VyIHRoYW4gY3VycmVudCBjbG9zZXN0XG4gICAgICAgIGlmKGZyYWN0aW9uIDwgcmVzdWx0LmZyYWN0aW9uIHx8ICFyZXN1bHQuaGFzSGl0KCkpe1xuICAgICAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBmcmFjdGlvbixcbiAgICAgICAgICAgICAgICBmYWNlSW5kZXhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFJheS5BTlk6XG5cbiAgICAgICAgLy8gUmVwb3J0IGFuZCBzdG9wLlxuICAgICAgICByZXN1bHQuc2V0KFxuICAgICAgICAgICAgbm9ybWFsLFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZnJhY3Rpb24sXG4gICAgICAgICAgICBmYWNlSW5kZXhcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxudmFyIHYwID0gdmVjMi5jcmVhdGUoKSxcbiAgICBpbnRlcnNlY3QgPSB2ZWMyLmNyZWF0ZSgpO1xuZnVuY3Rpb24gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uU3F1YXJlZChmcm9tLCBkaXJlY3Rpb24sIHBvc2l0aW9uKSB7XG5cbiAgICAvLyB2MCBpcyB2ZWN0b3IgZnJvbSBmcm9tIHRvIHBvc2l0aW9uXG4gICAgdmVjMi5zdWIodjAsIHBvc2l0aW9uLCBmcm9tKTtcbiAgICB2YXIgZG90ID0gdmVjMi5kb3QodjAsIGRpcmVjdGlvbik7XG5cbiAgICAvLyBpbnRlcnNlY3QgPSBkaXJlY3Rpb24gKiBkb3QgKyBmcm9tXG4gICAgdmVjMi5zY2FsZShpbnRlcnNlY3QsIGRpcmVjdGlvbiwgZG90KTtcbiAgICB2ZWMyLmFkZChpbnRlcnNlY3QsIGludGVyc2VjdCwgZnJvbSk7XG5cbiAgICByZXR1cm4gdmVjMi5zcXVhcmVkRGlzdGFuY2UocG9zaXRpb24sIGludGVyc2VjdCk7XG59XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/collision/Ray.js\n");

/***/ }),

/***/ "./node_modules/p2/src/collision/RaycastResult.js":
/*!********************************************************!*\
  !*** ./node_modules/p2/src/collision/RaycastResult.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\nvar Ray = __webpack_require__(/*! ../collision/Ray */ \"./node_modules/p2/src/collision/Ray.js\");\n\nmodule.exports = RaycastResult;\n\n/**\n * Storage for Ray casting hit data.\n * @class RaycastResult\n * @constructor\n */\nfunction RaycastResult(){\n\n\t/**\n\t * The normal of the hit, oriented in world space.\n\t * @property {array} normal\n\t */\n\tthis.normal = vec2.create();\n\n\t/**\n\t * The hit shape, or null.\n\t * @property {Shape} shape\n\t */\n\tthis.shape = null;\n\n\t/**\n\t * The hit body, or null.\n\t * @property {Body} body\n\t */\n\tthis.body = null;\n\n\t/**\n\t * The index of the hit triangle, if the hit shape was indexable.\n\t * @property {number} faceIndex\n\t * @default -1\n\t */\n\tthis.faceIndex = -1;\n\n\t/**\n\t * Distance to the hit, as a fraction. 0 is at the \"from\" point, 1 is at the \"to\" point. Will be set to -1 if there was no hit yet.\n\t * @property {number} fraction\n\t * @default -1\n\t */\n\tthis.fraction = -1;\n\n\t/**\n\t * If the ray should stop traversing.\n\t * @readonly\n\t * @property {Boolean} isStopped\n\t */\n\tthis.isStopped = false;\n}\n\n/**\n * Reset all result data. Must be done before re-using the result object.\n * @method reset\n */\nRaycastResult.prototype.reset = function () {\n\tvec2.set(this.normal, 0, 0);\n\tthis.shape = null;\n\tthis.body = null;\n\tthis.faceIndex = -1;\n\tthis.fraction = -1;\n\tthis.isStopped = false;\n};\n\n/**\n * Get the distance to the hit point.\n * @method getHitDistance\n * @param {Ray} ray\n */\nRaycastResult.prototype.getHitDistance = function (ray) {\n\treturn vec2.distance(ray.from, ray.to) * this.fraction;\n};\n\n/**\n * Returns true if the ray hit something since the last reset().\n * @method hasHit\n */\nRaycastResult.prototype.hasHit = function () {\n\treturn this.fraction !== -1;\n};\n\n/**\n * Get world hit point.\n * @method getHitPoint\n * @param {array} out\n * @param {Ray} ray\n */\nRaycastResult.prototype.getHitPoint = function (out, ray) {\n\tvec2.lerp(out, ray.from, ray.to, this.fraction);\n};\n\n/**\n * Can be called while iterating over hits to stop searching for hit points.\n * @method stop\n */\nRaycastResult.prototype.stop = function(){\n\tthis.isStopped = true;\n};\n\n/**\n * @method shouldStop\n * @private\n * @param {Ray} ray\n * @return {boolean}\n */\nRaycastResult.prototype.shouldStop = function(ray){\n\treturn this.isStopped || (this.fraction !== -1 && ray.mode === Ray.ANY);\n};\n\n/**\n * @method set\n * @private\n * @param {array} normal\n * @param {Shape} shape\n * @param {Body} body\n * @param {number} fraction\n */\nRaycastResult.prototype.set = function(\n\tnormal,\n\tshape,\n\tbody,\n\tfraction,\n\tfaceIndex\n){\n\tvec2.copy(this.normal, normal);\n\tthis.shape = shape;\n\tthis.body = body;\n\tthis.fraction = fraction;\n\tthis.faceIndex = faceIndex;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdC5qcz8zNDNmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJyk7XG52YXIgUmF5ID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL1JheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RSZXN1bHQ7XG5cbi8qKlxuICogU3RvcmFnZSBmb3IgUmF5IGNhc3RpbmcgaGl0IGRhdGEuXG4gKiBAY2xhc3MgUmF5Y2FzdFJlc3VsdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJheWNhc3RSZXN1bHQoKXtcblxuXHQvKipcblx0ICogVGhlIG5vcm1hbCBvZiB0aGUgaGl0LCBvcmllbnRlZCBpbiB3b3JsZCBzcGFjZS5cblx0ICogQHByb3BlcnR5IHthcnJheX0gbm9ybWFsXG5cdCAqL1xuXHR0aGlzLm5vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG5cblx0LyoqXG5cdCAqIFRoZSBoaXQgc2hhcGUsIG9yIG51bGwuXG5cdCAqIEBwcm9wZXJ0eSB7U2hhcGV9IHNoYXBlXG5cdCAqL1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblxuXHQvKipcblx0ICogVGhlIGhpdCBib2R5LCBvciBudWxsLlxuXHQgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlcblx0ICovXG5cdHRoaXMuYm9keSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBpbmRleCBvZiB0aGUgaGl0IHRyaWFuZ2xlLCBpZiB0aGUgaGl0IHNoYXBlIHdhcyBpbmRleGFibGUuXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmYWNlSW5kZXhcblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuZmFjZUluZGV4ID0gLTE7XG5cblx0LyoqXG5cdCAqIERpc3RhbmNlIHRvIHRoZSBoaXQsIGFzIGEgZnJhY3Rpb24uIDAgaXMgYXQgdGhlIFwiZnJvbVwiIHBvaW50LCAxIGlzIGF0IHRoZSBcInRvXCIgcG9pbnQuIFdpbGwgYmUgc2V0IHRvIC0xIGlmIHRoZXJlIHdhcyBubyBoaXQgeWV0LlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gZnJhY3Rpb25cblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuZnJhY3Rpb24gPSAtMTtcblxuXHQvKipcblx0ICogSWYgdGhlIHJheSBzaG91bGQgc3RvcCB0cmF2ZXJzaW5nLlxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHByb3BlcnR5IHtCb29sZWFufSBpc1N0b3BwZWRcblx0ICovXG5cdHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVzZXQgYWxsIHJlc3VsdCBkYXRhLiBNdXN0IGJlIGRvbmUgYmVmb3JlIHJlLXVzaW5nIHRoZSByZXN1bHQgb2JqZWN0LlxuICogQG1ldGhvZCByZXNldFxuICovXG5SYXljYXN0UmVzdWx0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblx0dmVjMi5zZXQodGhpcy5ub3JtYWwsIDAsIDApO1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblx0dGhpcy5ib2R5ID0gbnVsbDtcblx0dGhpcy5mYWNlSW5kZXggPSAtMTtcblx0dGhpcy5mcmFjdGlvbiA9IC0xO1xuXHR0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBoaXQgcG9pbnQuXG4gKiBAbWV0aG9kIGdldEhpdERpc3RhbmNlXG4gKiBAcGFyYW0ge1JheX0gcmF5XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLmdldEhpdERpc3RhbmNlID0gZnVuY3Rpb24gKHJheSkge1xuXHRyZXR1cm4gdmVjMi5kaXN0YW5jZShyYXkuZnJvbSwgcmF5LnRvKSAqIHRoaXMuZnJhY3Rpb247XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmF5IGhpdCBzb21ldGhpbmcgc2luY2UgdGhlIGxhc3QgcmVzZXQoKS5cbiAqIEBtZXRob2QgaGFzSGl0XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLmhhc0hpdCA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuZnJhY3Rpb24gIT09IC0xO1xufTtcblxuLyoqXG4gKiBHZXQgd29ybGQgaGl0IHBvaW50LlxuICogQG1ldGhvZCBnZXRIaXRQb2ludFxuICogQHBhcmFtIHthcnJheX0gb3V0XG4gKiBAcGFyYW0ge1JheX0gcmF5XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLmdldEhpdFBvaW50ID0gZnVuY3Rpb24gKG91dCwgcmF5KSB7XG5cdHZlYzIubGVycChvdXQsIHJheS5mcm9tLCByYXkudG8sIHRoaXMuZnJhY3Rpb24pO1xufTtcblxuLyoqXG4gKiBDYW4gYmUgY2FsbGVkIHdoaWxlIGl0ZXJhdGluZyBvdmVyIGhpdHMgdG8gc3RvcCBzZWFyY2hpbmcgZm9yIGhpdCBwb2ludHMuXG4gKiBAbWV0aG9kIHN0b3BcbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzaG91bGRTdG9wXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtSYXl9IHJheVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuc2hvdWxkU3RvcCA9IGZ1bmN0aW9uKHJheSl7XG5cdHJldHVybiB0aGlzLmlzU3RvcHBlZCB8fCAodGhpcy5mcmFjdGlvbiAhPT0gLTEgJiYgcmF5Lm1vZGUgPT09IFJheS5BTlkpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7YXJyYXl9IG5vcm1hbFxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtudW1iZXJ9IGZyYWN0aW9uXG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKFxuXHRub3JtYWwsXG5cdHNoYXBlLFxuXHRib2R5LFxuXHRmcmFjdGlvbixcblx0ZmFjZUluZGV4XG4pe1xuXHR2ZWMyLmNvcHkodGhpcy5ub3JtYWwsIG5vcm1hbCk7XG5cdHRoaXMuc2hhcGUgPSBzaGFwZTtcblx0dGhpcy5ib2R5ID0gYm9keTtcblx0dGhpcy5mcmFjdGlvbiA9IGZyYWN0aW9uO1xuXHR0aGlzLmZhY2VJbmRleCA9IGZhY2VJbmRleDtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/collision/RaycastResult.js\n");

/***/ }),

/***/ "./node_modules/p2/src/collision/SAPBroadphase.js":
/*!********************************************************!*\
  !*** ./node_modules/p2/src/collision/SAPBroadphase.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\")\n,   Broadphase = __webpack_require__(/*! ../collision/Broadphase */ \"./node_modules/p2/src/collision/Broadphase.js\");\n\nmodule.exports = SAPBroadphase;\n\n/**\n * Sweep and prune broadphase along one axis.\n *\n * @class SAPBroadphase\n * @constructor\n * @extends Broadphase\n */\nfunction SAPBroadphase(){\n    Broadphase.call(this,Broadphase.SAP);\n\n    /**\n     * List of bodies currently in the broadphase.\n     * @property axisList\n     * @type {Array}\n     */\n    this.axisList = [];\n\n    /**\n     * The axis to sort along. 0 means x-axis and 1 y-axis. If your bodies are more spread out over the X axis, set axisIndex to 0, and you will gain some performance.\n     * @property axisIndex\n     * @type {Number}\n     */\n    this.axisIndex = 0;\n\n    var that = this;\n    this._addBodyHandler = function(e){\n        that.axisList.push(e.body);\n    };\n\n    this._removeBodyHandler = function(e){\n        // Remove from list\n        var idx = that.axisList.indexOf(e.body);\n        if(idx !== -1){\n            that.axisList.splice(idx,1);\n        }\n    };\n}\nSAPBroadphase.prototype = new Broadphase();\nSAPBroadphase.prototype.constructor = SAPBroadphase;\n\n/**\n * Change the world\n * @method setWorld\n * @param {World} world\n */\nSAPBroadphase.prototype.setWorld = function(world){\n    // Clear the old axis array\n    this.axisList.length = 0;\n\n    // Add all bodies from the new world\n    Utils.appendArray(this.axisList, world.bodies);\n\n    // Remove old handlers, if any\n    world\n        .off(\"addBody\",this._addBodyHandler)\n        .off(\"removeBody\",this._removeBodyHandler);\n\n    // Add handlers to update the list of bodies.\n    world.on(\"addBody\",this._addBodyHandler).on(\"removeBody\",this._removeBodyHandler);\n\n    this.world = world;\n};\n\n/**\n * Sorts bodies along an axis.\n * @method sortAxisList\n * @param {Array} a\n * @param {number} axisIndex\n * @return {Array}\n */\nSAPBroadphase.sortAxisList = function(a, axisIndex){\n    axisIndex = axisIndex|0;\n    for(var i=1,l=a.length; i<l; i++) {\n        var v = a[i];\n        for(var j=i - 1;j>=0;j--) {\n            if(a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]){\n                break;\n            }\n            a[j+1] = a[j];\n        }\n        a[j+1] = v;\n    }\n    return a;\n};\n\nSAPBroadphase.prototype.sortList = function(){\n    var bodies = this.axisList,\n    axisIndex = this.axisIndex;\n\n    // Sort the lists\n    SAPBroadphase.sortAxisList(bodies, axisIndex);\n};\n\n/**\n * Get the colliding pairs\n * @method getCollisionPairs\n * @param  {World} world\n * @return {Array}\n */\nSAPBroadphase.prototype.getCollisionPairs = function(world){\n    var bodies = this.axisList,\n        result = this.result,\n        axisIndex = this.axisIndex;\n\n    result.length = 0;\n\n    // Update all AABBs if needed\n    var l = bodies.length;\n    while(l--){\n        var b = bodies[l];\n        if(b.aabbNeedsUpdate){\n            b.updateAABB();\n        }\n    }\n\n    // Sort the lists\n    this.sortList();\n\n    // Look through the X list\n    for(var i=0, N=bodies.length|0; i!==N; i++){\n        var bi = bodies[i];\n\n        for(var j=i+1; j<N; j++){\n            var bj = bodies[j];\n\n            // Bounds overlap?\n            var overlaps = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);\n            if(!overlaps){\n                break;\n            }\n\n            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){\n                result.push(bi,bj);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Returns all the bodies within an AABB.\n * @method aabbQuery\n * @param  {World} world\n * @param  {AABB} aabb\n * @param {array} result An array to store resulting bodies in.\n * @return {array}\n */\nSAPBroadphase.prototype.aabbQuery = function(world, aabb, result){\n    result = result || [];\n\n    this.sortList();\n\n    var axisIndex = this.axisIndex;\n    var axis = 'x';\n    if(axisIndex === 1){ axis = 'y'; }\n    if(axisIndex === 2){ axis = 'z'; }\n\n    var axisList = this.axisList;\n    var lower = aabb.lowerBound[axis];\n    var upper = aabb.upperBound[axis];\n    for(var i = 0; i < axisList.length; i++){\n        var b = axisList[i];\n\n        if(b.aabbNeedsUpdate){\n            b.updateAABB();\n        }\n\n        if(b.aabb.overlaps(aabb)){\n            result.push(b);\n        }\n    }\n\n    return result;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZS5qcz82MjllIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJylcbiwgICBCcm9hZHBoYXNlID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTQVBCcm9hZHBoYXNlO1xuXG4vKipcbiAqIFN3ZWVwIGFuZCBwcnVuZSBicm9hZHBoYXNlIGFsb25nIG9uZSBheGlzLlxuICpcbiAqIEBjbGFzcyBTQVBCcm9hZHBoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEJyb2FkcGhhc2VcbiAqL1xuZnVuY3Rpb24gU0FQQnJvYWRwaGFzZSgpe1xuICAgIEJyb2FkcGhhc2UuY2FsbCh0aGlzLEJyb2FkcGhhc2UuU0FQKTtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYm9kaWVzIGN1cnJlbnRseSBpbiB0aGUgYnJvYWRwaGFzZS5cbiAgICAgKiBAcHJvcGVydHkgYXhpc0xpc3RcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5heGlzTGlzdCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGF4aXMgdG8gc29ydCBhbG9uZy4gMCBtZWFucyB4LWF4aXMgYW5kIDEgeS1heGlzLiBJZiB5b3VyIGJvZGllcyBhcmUgbW9yZSBzcHJlYWQgb3V0IG92ZXIgdGhlIFggYXhpcywgc2V0IGF4aXNJbmRleCB0byAwLCBhbmQgeW91IHdpbGwgZ2FpbiBzb21lIHBlcmZvcm1hbmNlLlxuICAgICAqIEBwcm9wZXJ0eSBheGlzSW5kZXhcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYXhpc0luZGV4ID0gMDtcblxuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLl9hZGRCb2R5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB0aGF0LmF4aXNMaXN0LnB1c2goZS5ib2R5KTtcbiAgICB9O1xuXG4gICAgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gbGlzdFxuICAgICAgICB2YXIgaWR4ID0gdGhhdC5heGlzTGlzdC5pbmRleE9mKGUuYm9keSk7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgdGhhdC5heGlzTGlzdC5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU0FQQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHdvcmxkXG4gKiBAbWV0aG9kIHNldFdvcmxkXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICovXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICAvLyBDbGVhciB0aGUgb2xkIGF4aXMgYXJyYXlcbiAgICB0aGlzLmF4aXNMaXN0Lmxlbmd0aCA9IDA7XG5cbiAgICAvLyBBZGQgYWxsIGJvZGllcyBmcm9tIHRoZSBuZXcgd29ybGRcbiAgICBVdGlscy5hcHBlbmRBcnJheSh0aGlzLmF4aXNMaXN0LCB3b3JsZC5ib2RpZXMpO1xuXG4gICAgLy8gUmVtb3ZlIG9sZCBoYW5kbGVycywgaWYgYW55XG4gICAgd29ybGRcbiAgICAgICAgLm9mZihcImFkZEJvZHlcIix0aGlzLl9hZGRCb2R5SGFuZGxlcilcbiAgICAgICAgLm9mZihcInJlbW92ZUJvZHlcIix0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7XG5cbiAgICAvLyBBZGQgaGFuZGxlcnMgdG8gdXBkYXRlIHRoZSBsaXN0IG9mIGJvZGllcy5cbiAgICB3b3JsZC5vbihcImFkZEJvZHlcIix0aGlzLl9hZGRCb2R5SGFuZGxlcikub24oXCJyZW1vdmVCb2R5XCIsdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIpO1xuXG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xufTtcblxuLyoqXG4gKiBTb3J0cyBib2RpZXMgYWxvbmcgYW4gYXhpcy5cbiAqIEBtZXRob2Qgc29ydEF4aXNMaXN0XG4gKiBAcGFyYW0ge0FycmF5fSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYXhpc0luZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5zb3J0QXhpc0xpc3QgPSBmdW5jdGlvbihhLCBheGlzSW5kZXgpe1xuICAgIGF4aXNJbmRleCA9IGF4aXNJbmRleHwwO1xuICAgIGZvcih2YXIgaT0xLGw9YS5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgIHZhciB2ID0gYVtpXTtcbiAgICAgICAgZm9yKHZhciBqPWkgLSAxO2o+PTA7ai0tKSB7XG4gICAgICAgICAgICBpZihhW2pdLmFhYmIubG93ZXJCb3VuZFtheGlzSW5kZXhdIDw9IHYuYWFiYi5sb3dlckJvdW5kW2F4aXNJbmRleF0pe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVtqKzFdID0gYVtqXTtcbiAgICAgICAgfVxuICAgICAgICBhW2orMV0gPSB2O1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNvcnRMaXN0ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCxcbiAgICBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDtcblxuICAgIC8vIFNvcnQgdGhlIGxpc3RzXG4gICAgU0FQQnJvYWRwaGFzZS5zb3J0QXhpc0xpc3QoYm9kaWVzLCBheGlzSW5kZXgpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbGxpZGluZyBwYWlyc1xuICogQG1ldGhvZCBnZXRDb2xsaXNpb25QYWlyc1xuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuZ2V0Q29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYXhpc0xpc3QsXG4gICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0LFxuICAgICAgICBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDtcblxuICAgIHJlc3VsdC5sZW5ndGggPSAwO1xuXG4gICAgLy8gVXBkYXRlIGFsbCBBQUJCcyBpZiBuZWVkZWRcbiAgICB2YXIgbCA9IGJvZGllcy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGIgPSBib2RpZXNbbF07XG4gICAgICAgIGlmKGIuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGIudXBkYXRlQUFCQigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29ydCB0aGUgbGlzdHNcbiAgICB0aGlzLnNvcnRMaXN0KCk7XG5cbiAgICAvLyBMb29rIHRocm91Z2ggdGhlIFggbGlzdFxuICAgIGZvcih2YXIgaT0wLCBOPWJvZGllcy5sZW5ndGh8MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcblxuICAgICAgICBmb3IodmFyIGo9aSsxOyBqPE47IGorKyl7XG4gICAgICAgICAgICB2YXIgYmogPSBib2RpZXNbal07XG5cbiAgICAgICAgICAgIC8vIEJvdW5kcyBvdmVybGFwP1xuICAgICAgICAgICAgdmFyIG92ZXJsYXBzID0gKGJqLmFhYmIubG93ZXJCb3VuZFtheGlzSW5kZXhdIDw9IGJpLmFhYmIudXBwZXJCb3VuZFtheGlzSW5kZXhdKTtcbiAgICAgICAgICAgIGlmKCFvdmVybGFwcyl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKEJyb2FkcGhhc2UuY2FuQ29sbGlkZShiaSxiaikgJiYgdGhpcy5ib3VuZGluZ1ZvbHVtZUNoZWNrKGJpLGJqKSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmksYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gYW4gQUFCQi5cbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKHdvcmxkLCBhYWJiLCByZXN1bHQpe1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICAgIHRoaXMuc29ydExpc3QoKTtcblxuICAgIHZhciBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDtcbiAgICB2YXIgYXhpcyA9ICd4JztcbiAgICBpZihheGlzSW5kZXggPT09IDEpeyBheGlzID0gJ3knOyB9XG4gICAgaWYoYXhpc0luZGV4ID09PSAyKXsgYXhpcyA9ICd6JzsgfVxuXG4gICAgdmFyIGF4aXNMaXN0ID0gdGhpcy5heGlzTGlzdDtcbiAgICB2YXIgbG93ZXIgPSBhYWJiLmxvd2VyQm91bmRbYXhpc107XG4gICAgdmFyIHVwcGVyID0gYWFiYi51cHBlckJvdW5kW2F4aXNdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBheGlzTGlzdC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gYXhpc0xpc3RbaV07XG5cbiAgICAgICAgaWYoYi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICAgICAgYi51cGRhdGVBQUJCKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihiLmFhYmIub3ZlcmxhcHMoYWFiYikpe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/collision/SAPBroadphase.js\n");

/***/ }),

/***/ "./node_modules/p2/src/constraints/Constraint.js":
/*!*******************************************************!*\
  !*** ./node_modules/p2/src/constraints/Constraint.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = Constraint;\n\nvar Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\");\n\n/**\n * Base constraint class.\n *\n * @class Constraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} type\n * @param {Object} [options]\n * @param {Object} [options.collideConnected=true]\n */\nfunction Constraint(bodyA, bodyB, type, options){\n\n    /**\n     * The type of constraint. May be one of Constraint.DISTANCE, Constraint.GEAR, Constraint.LOCK, Constraint.PRISMATIC or Constraint.REVOLUTE.\n     * @property {number} type\n     */\n    this.type = type;\n\n    options = Utils.defaults(options,{\n        collideConnected : true,\n        wakeUpBodies : true,\n    });\n\n    /**\n     * Equations to be solved in this constraint\n     *\n     * @property equations\n     * @type {Array}\n     */\n    this.equations = [];\n\n    /**\n     * First body participating in the constraint.\n     * @property bodyA\n     * @type {Body}\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * Second body participating in the constraint.\n     * @property bodyB\n     * @type {Body}\n     */\n    this.bodyB = bodyB;\n\n    /**\n     * Set to true if you want the connected bodies to collide.\n     * @property collideConnected\n     * @type {Boolean}\n     * @default true\n     */\n    this.collideConnected = options.collideConnected;\n\n    // Wake up bodies when connected\n    if(options.wakeUpBodies){\n        if(bodyA){\n            bodyA.wakeUp();\n        }\n        if(bodyB){\n            bodyB.wakeUp();\n        }\n    }\n}\n\n/**\n * Updates the internal constraint parameters before solve.\n * @method update\n */\nConstraint.prototype.update = function(){\n    throw new Error(\"method update() not implmemented in this Constraint subclass!\");\n};\n\n/**\n * @static\n * @property {number} DISTANCE\n */\nConstraint.DISTANCE = 1;\n\n/**\n * @static\n * @property {number} GEAR\n */\nConstraint.GEAR = 2;\n\n/**\n * @static\n * @property {number} LOCK\n */\nConstraint.LOCK = 3;\n\n/**\n * @static\n * @property {number} PRISMATIC\n */\nConstraint.PRISMATIC = 4;\n\n/**\n * @static\n * @property {number} REVOLUTE\n */\nConstraint.REVOLUTE = 5;\n\n/**\n * Set stiffness for this constraint.\n * @method setStiffness\n * @param {Number} stiffness\n */\nConstraint.prototype.setStiffness = function(stiffness){\n    var eqs = this.equations;\n    for(var i=0; i !== eqs.length; i++){\n        var eq = eqs[i];\n        eq.stiffness = stiffness;\n        eq.needsUpdate = true;\n    }\n};\n\n/**\n * Set relaxation for this constraint.\n * @method setRelaxation\n * @param {Number} relaxation\n */\nConstraint.prototype.setRelaxation = function(relaxation){\n    var eqs = this.equations;\n    for(var i=0; i !== eqs.length; i++){\n        var eq = eqs[i];\n        eq.relaxation = relaxation;\n        eq.needsUpdate = true;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQuanM/OTQ3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IENvbnN0cmFpbnQ7XG5cbnZhciBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJyk7XG5cbi8qKlxuICogQmFzZSBjb25zdHJhaW50IGNsYXNzLlxuICpcbiAqIEBjbGFzcyBDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY29sbGlkZUNvbm5lY3RlZD10cnVlXVxuICovXG5mdW5jdGlvbiBDb25zdHJhaW50KGJvZHlBLCBib2R5QiwgdHlwZSwgb3B0aW9ucyl7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBjb25zdHJhaW50LiBNYXkgYmUgb25lIG9mIENvbnN0cmFpbnQuRElTVEFOQ0UsIENvbnN0cmFpbnQuR0VBUiwgQ29uc3RyYWludC5MT0NLLCBDb25zdHJhaW50LlBSSVNNQVRJQyBvciBDb25zdHJhaW50LlJFVk9MVVRFLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0eXBlXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcbiAgICAgICAgY29sbGlkZUNvbm5lY3RlZCA6IHRydWUsXG4gICAgICAgIHdha2VVcEJvZGllcyA6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBFcXVhdGlvbnMgdG8gYmUgc29sdmVkIGluIHRoaXMgY29uc3RyYWludFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb25zdHJhaW50LlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QVxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcblxuICAgIC8qKlxuICAgICAqIFNlY29uZCBib2R5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNvbnN0cmFpbnQuXG4gICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdGhlIGNvbm5lY3RlZCBib2RpZXMgdG8gY29sbGlkZS5cbiAgICAgKiBAcHJvcGVydHkgY29sbGlkZUNvbm5lY3RlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpZGVDb25uZWN0ZWQgPSBvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ7XG5cbiAgICAvLyBXYWtlIHVwIGJvZGllcyB3aGVuIGNvbm5lY3RlZFxuICAgIGlmKG9wdGlvbnMud2FrZVVwQm9kaWVzKXtcbiAgICAgICAgaWYoYm9keUEpe1xuICAgICAgICAgICAgYm9keUEud2FrZVVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoYm9keUIpe1xuICAgICAgICAgICAgYm9keUIud2FrZVVwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgY29uc3RyYWludCBwYXJhbWV0ZXJzIGJlZm9yZSBzb2x2ZS5cbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIHVwZGF0ZSgpIG5vdCBpbXBsbWVtZW50ZWQgaW4gdGhpcyBDb25zdHJhaW50IHN1YmNsYXNzIVwiKTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IERJU1RBTkNFXG4gKi9cbkNvbnN0cmFpbnQuRElTVEFOQ0UgPSAxO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBHRUFSXG4gKi9cbkNvbnN0cmFpbnQuR0VBUiA9IDI7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IExPQ0tcbiAqL1xuQ29uc3RyYWludC5MT0NLID0gMztcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gUFJJU01BVElDXG4gKi9cbkNvbnN0cmFpbnQuUFJJU01BVElDID0gNDtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gUkVWT0xVVEVcbiAqL1xuQ29uc3RyYWludC5SRVZPTFVURSA9IDU7XG5cbi8qKlxuICogU2V0IHN0aWZmbmVzcyBmb3IgdGhpcyBjb25zdHJhaW50LlxuICogQG1ldGhvZCBzZXRTdGlmZm5lc3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGlmZm5lc3NcbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUuc2V0U3RpZmZuZXNzID0gZnVuY3Rpb24oc3RpZmZuZXNzKXtcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgZm9yKHZhciBpPTA7IGkgIT09IGVxcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IGVxc1tpXTtcbiAgICAgICAgZXEuc3RpZmZuZXNzID0gc3RpZmZuZXNzO1xuICAgICAgICBlcS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgcmVsYXhhdGlvbiBmb3IgdGhpcyBjb25zdHJhaW50LlxuICogQG1ldGhvZCBzZXRSZWxheGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmVsYXhhdGlvblxuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS5zZXRSZWxheGF0aW9uID0gZnVuY3Rpb24ocmVsYXhhdGlvbil7XG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSBlcXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZXEgPSBlcXNbaV07XG4gICAgICAgIGVxLnJlbGF4YXRpb24gPSByZWxheGF0aW9uO1xuICAgICAgICBlcS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/constraints/Constraint.js\n");

/***/ }),

/***/ "./node_modules/p2/src/constraints/DistanceConstraint.js":
/*!***************************************************************!*\
  !*** ./node_modules/p2/src/constraints/DistanceConstraint.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Constraint = __webpack_require__(/*! ./Constraint */ \"./node_modules/p2/src/constraints/Constraint.js\")\n,   Equation = __webpack_require__(/*! ../equations/Equation */ \"./node_modules/p2/src/equations/Equation.js\")\n,   vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,   Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\");\n\nmodule.exports = DistanceConstraint;\n\n/**\n * Constraint that tries to keep the distance between two bodies constant.\n *\n * @class DistanceConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {object} [options]\n * @param {number} [options.distance] The distance to keep between the anchor points. Defaults to the current distance between the bodies.\n * @param {Array} [options.localAnchorA] The anchor point for bodyA, defined locally in bodyA frame. Defaults to [0,0].\n * @param {Array} [options.localAnchorB] The anchor point for bodyB, defined locally in bodyB frame. Defaults to [0,0].\n * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.\n * @extends Constraint\n *\n * @example\n *     // If distance is not given as an option, then the current distance between the bodies is used.\n *     // In this example, the bodies will be constrained to have a distance of 2 between their centers.\n *     var bodyA = new Body({ mass: 1, position: [-1, 0] });\n *     var bodyB = new Body({ mass: 1, position: [1, 0] });\n *     var constraint = new DistanceConstraint(bodyA, bodyB);\n *     world.addConstraint(constraint);\n *\n * @example\n *     // Manually set the distance and anchors\n *     var constraint = new DistanceConstraint(bodyA, bodyB, {\n *         distance: 1,          // Distance to keep between the points\n *         localAnchorA: [1, 0], // Point on bodyA\n *         localAnchorB: [-1, 0] // Point on bodyB\n *     });\n *     world.addConstraint(constraint);\n */\nfunction DistanceConstraint(bodyA,bodyB,options){\n    options = Utils.defaults(options,{\n        localAnchorA:[0,0],\n        localAnchorB:[0,0]\n    });\n\n    Constraint.call(this,bodyA,bodyB,Constraint.DISTANCE,options);\n\n    /**\n     * Local anchor in body A.\n     * @property localAnchorA\n     * @type {Array}\n     */\n    this.localAnchorA = vec2.fromValues(options.localAnchorA[0], options.localAnchorA[1]);\n\n    /**\n     * Local anchor in body B.\n     * @property localAnchorB\n     * @type {Array}\n     */\n    this.localAnchorB = vec2.fromValues(options.localAnchorB[0], options.localAnchorB[1]);\n\n    var localAnchorA = this.localAnchorA;\n    var localAnchorB = this.localAnchorB;\n\n    /**\n     * The distance to keep.\n     * @property distance\n     * @type {Number}\n     */\n    this.distance = 0;\n\n    if(typeof(options.distance) === 'number'){\n        this.distance = options.distance;\n    } else {\n        // Use the current world distance between the world anchor points.\n        var worldAnchorA = vec2.create(),\n            worldAnchorB = vec2.create(),\n            r = vec2.create();\n\n        // Transform local anchors to world\n        vec2.rotate(worldAnchorA, localAnchorA, bodyA.angle);\n        vec2.rotate(worldAnchorB, localAnchorB, bodyB.angle);\n\n        vec2.add(r, bodyB.position, worldAnchorB);\n        vec2.sub(r, r, worldAnchorA);\n        vec2.sub(r, r, bodyA.position);\n\n        this.distance = vec2.length(r);\n    }\n\n    var maxForce;\n    if(typeof(options.maxForce)===\"undefined\" ){\n        maxForce = Number.MAX_VALUE;\n    } else {\n        maxForce = options.maxForce;\n    }\n\n    var normal = new Equation(bodyA,bodyB,-maxForce,maxForce); // Just in the normal direction\n    this.equations = [ normal ];\n\n    /**\n     * Max force to apply.\n     * @property {number} maxForce\n     */\n    this.maxForce = maxForce;\n\n    // g = (xi - xj).dot(n)\n    // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'\n\n    // ...and if we were to include offset points:\n    // g =\n    //      (xj + rj - xi - ri).dot(n) - distance\n    //\n    // dg/dt =\n    //      (vj + wj x rj - vi - wi x ri).dot(n) =\n    //      { term 2 is near zero } =\n    //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =\n    //      G * W\n    //\n    // => G = [-n -rixn n rjxn]\n\n    var r = vec2.create();\n    var ri = vec2.create(); // worldAnchorA\n    var rj = vec2.create(); // worldAnchorB\n    var that = this;\n    normal.computeGq = function(){\n        var bodyA = this.bodyA,\n            bodyB = this.bodyB,\n            xi = bodyA.position,\n            xj = bodyB.position;\n\n        // Transform local anchors to world\n        vec2.rotate(ri, localAnchorA, bodyA.angle);\n        vec2.rotate(rj, localAnchorB, bodyB.angle);\n\n        vec2.add(r, xj, rj);\n        vec2.sub(r, r, ri);\n        vec2.sub(r, r, xi);\n\n        //vec2.sub(r, bodyB.position, bodyA.position);\n        return vec2.length(r) - that.distance;\n    };\n\n    // Make the contact constraint bilateral\n    this.setMaxForce(maxForce);\n\n    /**\n     * If the upper limit is enabled or not.\n     * @property {Boolean} upperLimitEnabled\n     */\n    this.upperLimitEnabled = false;\n\n    /**\n     * The upper constraint limit.\n     * @property {number} upperLimit\n     */\n    this.upperLimit = 1;\n\n    /**\n     * If the lower limit is enabled or not.\n     * @property {Boolean} lowerLimitEnabled\n     */\n    this.lowerLimitEnabled = false;\n\n    /**\n     * The lower constraint limit.\n     * @property {number} lowerLimit\n     */\n    this.lowerLimit = 0;\n\n    /**\n     * Current constraint position. This is equal to the current distance between the world anchor points.\n     * @property {number} position\n     */\n    this.position = 0;\n}\nDistanceConstraint.prototype = new Constraint();\nDistanceConstraint.prototype.constructor = DistanceConstraint;\n\n/**\n * Update the constraint equations. Should be done if any of the bodies changed position, before solving.\n * @method update\n */\nvar n = vec2.create();\nvar ri = vec2.create(); // worldAnchorA\nvar rj = vec2.create(); // worldAnchorB\nDistanceConstraint.prototype.update = function(){\n    var normal = this.equations[0],\n        bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        distance = this.distance,\n        xi = bodyA.position,\n        xj = bodyB.position,\n        normalEquation = this.equations[0],\n        G = normal.G;\n\n    // Transform local anchors to world\n    vec2.rotate(ri, this.localAnchorA, bodyA.angle);\n    vec2.rotate(rj, this.localAnchorB, bodyB.angle);\n\n    // Get world anchor points and normal\n    vec2.add(n, xj, rj);\n    vec2.sub(n, n, ri);\n    vec2.sub(n, n, xi);\n    this.position = vec2.length(n);\n\n    var violating = false;\n    if(this.upperLimitEnabled){\n        if(this.position > this.upperLimit){\n            normalEquation.maxForce = 0;\n            normalEquation.minForce = -this.maxForce;\n            this.distance = this.upperLimit;\n            violating = true;\n        }\n    }\n\n    if(this.lowerLimitEnabled){\n        if(this.position < this.lowerLimit){\n            normalEquation.maxForce = this.maxForce;\n            normalEquation.minForce = 0;\n            this.distance = this.lowerLimit;\n            violating = true;\n        }\n    }\n\n    if((this.lowerLimitEnabled || this.upperLimitEnabled) && !violating){\n        // No constraint needed.\n        normalEquation.enabled = false;\n        return;\n    }\n\n    normalEquation.enabled = true;\n\n    vec2.normalize(n,n);\n\n    // Caluclate cross products\n    var rixn = vec2.crossLength(ri, n),\n        rjxn = vec2.crossLength(rj, n);\n\n    // G = [-n -rixn n rjxn]\n    G[0] = -n[0];\n    G[1] = -n[1];\n    G[2] = -rixn;\n    G[3] = n[0];\n    G[4] = n[1];\n    G[5] = rjxn;\n};\n\n/**\n * Set the max force to be used\n * @method setMaxForce\n * @param {Number} maxForce\n */\nDistanceConstraint.prototype.setMaxForce = function(maxForce){\n    var normal = this.equations[0];\n    normal.minForce = -maxForce;\n    normal.maxForce =  maxForce;\n};\n\n/**\n * Get the max force\n * @method getMaxForce\n * @return {Number}\n */\nDistanceConstraint.prototype.getMaxForce = function(){\n    var normal = this.equations[0];\n    return normal.maxForce;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50LmpzP2QyNzMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKVxuLCAgIEVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0VxdWF0aW9uJylcbiwgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJylcbiwgICBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VDb25zdHJhaW50O1xuXG4vKipcbiAqIENvbnN0cmFpbnQgdGhhdCB0cmllcyB0byBrZWVwIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBib2RpZXMgY29uc3RhbnQuXG4gKlxuICogQGNsYXNzIERpc3RhbmNlQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGlzdGFuY2VdIFRoZSBkaXN0YW5jZSB0byBrZWVwIGJldHdlZW4gdGhlIGFuY2hvciBwb2ludHMuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvZGllcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gVGhlIGFuY2hvciBwb2ludCBmb3IgYm9keUEsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5QSBmcmFtZS4gRGVmYXVsdHMgdG8gWzAsMF0uXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5sb2NhbEFuY2hvckJdIFRoZSBhbmNob3IgcG9pbnQgZm9yIGJvZHlCLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUIgZnJhbWUuIERlZmF1bHRzIHRvIFswLDBdLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm1heEZvcmNlPU51bWJlci5NQVhfVkFMVUVdIE1heGltdW0gZm9yY2UgdG8gYXBwbHkuXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBJZiBkaXN0YW5jZSBpcyBub3QgZ2l2ZW4gYXMgYW4gb3B0aW9uLCB0aGVuIHRoZSBjdXJyZW50IGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvZGllcyBpcyB1c2VkLlxuICogICAgIC8vIEluIHRoaXMgZXhhbXBsZSwgdGhlIGJvZGllcyB3aWxsIGJlIGNvbnN0cmFpbmVkIHRvIGhhdmUgYSBkaXN0YW5jZSBvZiAyIGJldHdlZW4gdGhlaXIgY2VudGVycy5cbiAqICAgICB2YXIgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEsIHBvc2l0aW9uOiBbLTEsIDBdIH0pO1xuICogICAgIHZhciBib2R5QiA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFsxLCAwXSB9KTtcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCKTtcbiAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gTWFudWFsbHkgc2V0IHRoZSBkaXN0YW5jZSBhbmQgYW5jaG9yc1xuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IERpc3RhbmNlQ29uc3RyYWludChib2R5QSwgYm9keUIsIHtcbiAqICAgICAgICAgZGlzdGFuY2U6IDEsICAgICAgICAgIC8vIERpc3RhbmNlIHRvIGtlZXAgYmV0d2VlbiB0aGUgcG9pbnRzXG4gKiAgICAgICAgIGxvY2FsQW5jaG9yQTogWzEsIDBdLCAvLyBQb2ludCBvbiBib2R5QVxuICogICAgICAgICBsb2NhbEFuY2hvckI6IFstMSwgMF0gLy8gUG9pbnQgb24gYm9keUJcbiAqICAgICB9KTtcbiAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xuICovXG5mdW5jdGlvbiBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsYm9keUIsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMse1xuICAgICAgICBsb2NhbEFuY2hvckE6WzAsMF0sXG4gICAgICAgIGxvY2FsQW5jaG9yQjpbMCwwXVxuICAgIH0pO1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIsQ29uc3RyYWludC5ESVNUQU5DRSxvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIExvY2FsIGFuY2hvciBpbiBib2R5IEEuXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IHZlYzIuZnJvbVZhbHVlcyhvcHRpb25zLmxvY2FsQW5jaG9yQVswXSwgb3B0aW9ucy5sb2NhbEFuY2hvckFbMV0pO1xuXG4gICAgLyoqXG4gICAgICogTG9jYWwgYW5jaG9yIGluIGJvZHkgQi5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JCXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JCID0gdmVjMi5mcm9tVmFsdWVzKG9wdGlvbnMubG9jYWxBbmNob3JCWzBdLCBvcHRpb25zLmxvY2FsQW5jaG9yQlsxXSk7XG5cbiAgICB2YXIgbG9jYWxBbmNob3JBID0gdGhpcy5sb2NhbEFuY2hvckE7XG4gICAgdmFyIGxvY2FsQW5jaG9yQiA9IHRoaXMubG9jYWxBbmNob3JCO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRpc3RhbmNlIHRvIGtlZXAuXG4gICAgICogQHByb3BlcnR5IGRpc3RhbmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRpc3RhbmNlID0gMDtcblxuICAgIGlmKHR5cGVvZihvcHRpb25zLmRpc3RhbmNlKSA9PT0gJ251bWJlcicpe1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2UgdGhlIGN1cnJlbnQgd29ybGQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgd29ybGQgYW5jaG9yIHBvaW50cy5cbiAgICAgICAgdmFyIHdvcmxkQW5jaG9yQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgICAgICB3b3JsZEFuY2hvckIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgICAgICAgICAgciA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIGxvY2FsIGFuY2hvcnMgdG8gd29ybGRcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRBbmNob3JBLCBsb2NhbEFuY2hvckEsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRBbmNob3JCLCBsb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcblxuICAgICAgICB2ZWMyLmFkZChyLCBib2R5Qi5wb3NpdGlvbiwgd29ybGRBbmNob3JCKTtcbiAgICAgICAgdmVjMi5zdWIociwgciwgd29ybGRBbmNob3JBKTtcbiAgICAgICAgdmVjMi5zdWIociwgciwgYm9keUEucG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSB2ZWMyLmxlbmd0aChyKTtcbiAgICB9XG5cbiAgICB2YXIgbWF4Rm9yY2U7XG4gICAgaWYodHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIiApe1xuICAgICAgICBtYXhGb3JjZSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWF4Rm9yY2UgPSBvcHRpb25zLm1heEZvcmNlO1xuICAgIH1cblxuICAgIHZhciBub3JtYWwgPSBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTsgLy8gSnVzdCBpbiB0aGUgbm9ybWFsIGRpcmVjdGlvblxuICAgIHRoaXMuZXF1YXRpb25zID0gWyBub3JtYWwgXTtcblxuICAgIC8qKlxuICAgICAqIE1heCBmb3JjZSB0byBhcHBseS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4Rm9yY2VcbiAgICAgKi9cbiAgICB0aGlzLm1heEZvcmNlID0gbWF4Rm9yY2U7XG5cbiAgICAvLyBnID0gKHhpIC0geGopLmRvdChuKVxuICAgIC8vIGRnL2R0ID0gKHZpIC0gdmopLmRvdChuKSA9IEcqVyA9IFtuIDAgLW4gMF0gKiBbdmkgd2kgdmogd2pdJ1xuXG4gICAgLy8gLi4uYW5kIGlmIHdlIHdlcmUgdG8gaW5jbHVkZSBvZmZzZXQgcG9pbnRzOlxuICAgIC8vIGcgPVxuICAgIC8vICAgICAgKHhqICsgcmogLSB4aSAtIHJpKS5kb3QobikgLSBkaXN0YW5jZVxuICAgIC8vXG4gICAgLy8gZGcvZHQgPVxuICAgIC8vICAgICAgKHZqICsgd2ogeCByaiAtIHZpIC0gd2kgeCByaSkuZG90KG4pID1cbiAgICAvLyAgICAgIHsgdGVybSAyIGlzIG5lYXIgemVybyB9ID1cbiAgICAvLyAgICAgIFstbiAgIC1yaSB4IG4gICBuICAgcmogeCBuXSAqIFt2aSB3aSB2aiB3al0nID1cbiAgICAvLyAgICAgIEcgKiBXXG4gICAgLy9cbiAgICAvLyA9PiBHID0gWy1uIC1yaXhuIG4gcmp4bl1cblxuICAgIHZhciByID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgcmkgPSB2ZWMyLmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckFcbiAgICB2YXIgcmogPSB2ZWMyLmNyZWF0ZSgpOyAvLyB3b3JsZEFuY2hvckJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgbm9ybWFsLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgICAgICB4aSA9IGJvZHlBLnBvc2l0aW9uLFxuICAgICAgICAgICAgeGogPSBib2R5Qi5wb3NpdGlvbjtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gbG9jYWwgYW5jaG9ycyB0byB3b3JsZFxuICAgICAgICB2ZWMyLnJvdGF0ZShyaSwgbG9jYWxBbmNob3JBLCBib2R5QS5hbmdsZSk7XG4gICAgICAgIHZlYzIucm90YXRlKHJqLCBsb2NhbEFuY2hvckIsIGJvZHlCLmFuZ2xlKTtcblxuICAgICAgICB2ZWMyLmFkZChyLCB4aiwgcmopO1xuICAgICAgICB2ZWMyLnN1YihyLCByLCByaSk7XG4gICAgICAgIHZlYzIuc3ViKHIsIHIsIHhpKTtcblxuICAgICAgICAvL3ZlYzIuc3ViKHIsIGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB2ZWMyLmxlbmd0aChyKSAtIHRoYXQuZGlzdGFuY2U7XG4gICAgfTtcblxuICAgIC8vIE1ha2UgdGhlIGNvbnRhY3QgY29uc3RyYWludCBiaWxhdGVyYWxcbiAgICB0aGlzLnNldE1heEZvcmNlKG1heEZvcmNlKTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSB1cHBlciBsaW1pdCBpcyBlbmFibGVkIG9yIG5vdC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVwcGVyTGltaXRFbmFibGVkXG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVwcGVyIGNvbnN0cmFpbnQgbGltaXQuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHVwcGVyTGltaXRcbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXQgPSAxO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGxvd2VyIGxpbWl0IGlzIGVuYWJsZWQgb3Igbm90LlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbG93ZXJMaW1pdEVuYWJsZWRcbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG93ZXIgY29uc3RyYWludCBsaW1pdC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbG93ZXJMaW1pdFxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGNvbnN0cmFpbnQgcG9zaXRpb24uIFRoaXMgaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgd29ybGQgYW5jaG9yIHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcG9zaXRpb25cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcbn1cbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpc3RhbmNlQ29uc3RyYWludDtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGNvbnN0cmFpbnQgZXF1YXRpb25zLiBTaG91bGQgYmUgZG9uZSBpZiBhbnkgb2YgdGhlIGJvZGllcyBjaGFuZ2VkIHBvc2l0aW9uLCBiZWZvcmUgc29sdmluZy5cbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbnZhciBuID0gdmVjMi5jcmVhdGUoKTtcbnZhciByaSA9IHZlYzIuY3JlYXRlKCk7IC8vIHdvcmxkQW5jaG9yQVxudmFyIHJqID0gdmVjMi5jcmVhdGUoKTsgLy8gd29ybGRBbmNob3JCXG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG5vcm1hbCA9IHRoaXMuZXF1YXRpb25zWzBdLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlLFxuICAgICAgICB4aSA9IGJvZHlBLnBvc2l0aW9uLFxuICAgICAgICB4aiA9IGJvZHlCLnBvc2l0aW9uLFxuICAgICAgICBub3JtYWxFcXVhdGlvbiA9IHRoaXMuZXF1YXRpb25zWzBdLFxuICAgICAgICBHID0gbm9ybWFsLkc7XG5cbiAgICAvLyBUcmFuc2Zvcm0gbG9jYWwgYW5jaG9ycyB0byB3b3JsZFxuICAgIHZlYzIucm90YXRlKHJpLCB0aGlzLmxvY2FsQW5jaG9yQSwgYm9keUEuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHJqLCB0aGlzLmxvY2FsQW5jaG9yQiwgYm9keUIuYW5nbGUpO1xuXG4gICAgLy8gR2V0IHdvcmxkIGFuY2hvciBwb2ludHMgYW5kIG5vcm1hbFxuICAgIHZlYzIuYWRkKG4sIHhqLCByaik7XG4gICAgdmVjMi5zdWIobiwgbiwgcmkpO1xuICAgIHZlYzIuc3ViKG4sIG4sIHhpKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gdmVjMi5sZW5ndGgobik7XG5cbiAgICB2YXIgdmlvbGF0aW5nID0gZmFsc2U7XG4gICAgaWYodGhpcy51cHBlckxpbWl0RW5hYmxlZCl7XG4gICAgICAgIGlmKHRoaXMucG9zaXRpb24gPiB0aGlzLnVwcGVyTGltaXQpe1xuICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWF4Rm9yY2UgPSAwO1xuICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWluRm9yY2UgPSAtdGhpcy5tYXhGb3JjZTtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLnVwcGVyTGltaXQ7XG4gICAgICAgICAgICB2aW9sYXRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5sb3dlckxpbWl0RW5hYmxlZCl7XG4gICAgICAgIGlmKHRoaXMucG9zaXRpb24gPCB0aGlzLmxvd2VyTGltaXQpe1xuICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWF4Rm9yY2UgPSB0aGlzLm1heEZvcmNlO1xuICAgICAgICAgICAgbm9ybWFsRXF1YXRpb24ubWluRm9yY2UgPSAwO1xuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IHRoaXMubG93ZXJMaW1pdDtcbiAgICAgICAgICAgIHZpb2xhdGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZigodGhpcy5sb3dlckxpbWl0RW5hYmxlZCB8fCB0aGlzLnVwcGVyTGltaXRFbmFibGVkKSAmJiAhdmlvbGF0aW5nKXtcbiAgICAgICAgLy8gTm8gY29uc3RyYWludCBuZWVkZWQuXG4gICAgICAgIG5vcm1hbEVxdWF0aW9uLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5vcm1hbEVxdWF0aW9uLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgdmVjMi5ub3JtYWxpemUobixuKTtcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIHZhciByaXhuID0gdmVjMi5jcm9zc0xlbmd0aChyaSwgbiksXG4gICAgICAgIHJqeG4gPSB2ZWMyLmNyb3NzTGVuZ3RoKHJqLCBuKTtcblxuICAgIC8vIEcgPSBbLW4gLXJpeG4gbiByanhuXVxuICAgIEdbMF0gPSAtblswXTtcbiAgICBHWzFdID0gLW5bMV07XG4gICAgR1syXSA9IC1yaXhuO1xuICAgIEdbM10gPSBuWzBdO1xuICAgIEdbNF0gPSBuWzFdO1xuICAgIEdbNV0gPSByanhuO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCBmb3JjZSB0byBiZSB1c2VkXG4gKiBAbWV0aG9kIHNldE1heEZvcmNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4Rm9yY2VcbiAqL1xuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKG1heEZvcmNlKXtcbiAgICB2YXIgbm9ybWFsID0gdGhpcy5lcXVhdGlvbnNbMF07XG4gICAgbm9ybWFsLm1pbkZvcmNlID0gLW1heEZvcmNlO1xuICAgIG5vcm1hbC5tYXhGb3JjZSA9ICBtYXhGb3JjZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXggZm9yY2VcbiAqIEBtZXRob2QgZ2V0TWF4Rm9yY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG5vcm1hbCA9IHRoaXMuZXF1YXRpb25zWzBdO1xuICAgIHJldHVybiBub3JtYWwubWF4Rm9yY2U7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/constraints/DistanceConstraint.js\n");

/***/ }),

/***/ "./node_modules/p2/src/constraints/GearConstraint.js":
/*!***********************************************************!*\
  !*** ./node_modules/p2/src/constraints/GearConstraint.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Constraint = __webpack_require__(/*! ./Constraint */ \"./node_modules/p2/src/constraints/Constraint.js\")\n,   Equation = __webpack_require__(/*! ../equations/Equation */ \"./node_modules/p2/src/equations/Equation.js\")\n,   AngleLockEquation = __webpack_require__(/*! ../equations/AngleLockEquation */ \"./node_modules/p2/src/equations/AngleLockEquation.js\")\n,   vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\n\nmodule.exports = GearConstraint;\n\n/**\n * Constrains the angle of two bodies to each other to be equal. If a gear ratio is not one, the angle of bodyA must be a multiple of the angle of bodyB.\n * @class GearConstraint\n * @constructor\n * @author schteppe\n * @param {Body}            bodyA\n * @param {Body}            bodyB\n * @param {Object}          [options]\n * @param {Number}          [options.angle=0] Relative angle between the bodies. Will be set to the current angle between the bodies (the gear ratio is accounted for).\n * @param {Number}          [options.ratio=1] Gear ratio.\n * @param {Number}          [options.maxTorque] Maximum torque to apply.\n * @extends Constraint\n *\n * @example\n *     var constraint = new GearConstraint(bodyA, bodyB);\n *     world.addConstraint(constraint);\n *\n * @example\n *     var constraint = new GearConstraint(bodyA, bodyB, {\n *         ratio: 2,\n *         maxTorque: 1000\n *     });\n *     world.addConstraint(constraint);\n */\nfunction GearConstraint(bodyA, bodyB, options){\n    options = options || {};\n\n    Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);\n\n    /**\n     * The gear ratio.\n     * @property ratio\n     * @type {Number}\n     */\n    this.ratio = options.ratio !== undefined ? options.ratio : 1;\n\n    /**\n     * The relative angle\n     * @property angle\n     * @type {Number}\n     */\n    this.angle = options.angle !== undefined ? options.angle : bodyB.angle - this.ratio * bodyA.angle;\n\n    // Send same parameters to the equation\n    options.angle = this.angle;\n    options.ratio = this.ratio;\n\n    this.equations = [\n        new AngleLockEquation(bodyA,bodyB,options),\n    ];\n\n    // Set max torque\n    if(options.maxTorque !== undefined){\n        this.setMaxTorque(options.maxTorque);\n    }\n}\nGearConstraint.prototype = new Constraint();\nGearConstraint.prototype.constructor = GearConstraint;\n\nGearConstraint.prototype.update = function(){\n    var eq = this.equations[0];\n    if(eq.ratio !== this.ratio){\n        eq.setRatio(this.ratio);\n    }\n    eq.angle = this.angle;\n};\n\n/**\n * Set the max torque for the constraint.\n * @method setMaxTorque\n * @param {Number} torque\n */\nGearConstraint.prototype.setMaxTorque = function(torque){\n    this.equations[0].setMaxTorque(torque);\n};\n\n/**\n * Get the max torque for the constraint.\n * @method getMaxTorque\n * @return {Number}\n */\nGearConstraint.prototype.getMaxTorque = function(torque){\n    return this.equations[0].maxForce;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbnN0cmFpbnRzL0dlYXJDb25zdHJhaW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9jb25zdHJhaW50cy9HZWFyQ29uc3RyYWludC5qcz81ODdjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50JylcbiwgICBFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpXG4sICAgQW5nbGVMb2NrRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvQW5nbGVMb2NrRXF1YXRpb24nKVxuLCAgIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZWFyQ29uc3RyYWludDtcblxuLyoqXG4gKiBDb25zdHJhaW5zIHRoZSBhbmdsZSBvZiB0d28gYm9kaWVzIHRvIGVhY2ggb3RoZXIgdG8gYmUgZXF1YWwuIElmIGEgZ2VhciByYXRpbyBpcyBub3Qgb25lLCB0aGUgYW5nbGUgb2YgYm9keUEgbXVzdCBiZSBhIG11bHRpcGxlIG9mIHRoZSBhbmdsZSBvZiBib2R5Qi5cbiAqIEBjbGFzcyBHZWFyQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9ICAgICAgICAgICAgYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gICAgICAgICAgICBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIFtvcHRpb25zLmFuZ2xlPTBdIFJlbGF0aXZlIGFuZ2xlIGJldHdlZW4gdGhlIGJvZGllcy4gV2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnQgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzICh0aGUgZ2VhciByYXRpbyBpcyBhY2NvdW50ZWQgZm9yKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgICAgICAgICBbb3B0aW9ucy5yYXRpbz0xXSBHZWFyIHJhdGlvLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgICAgIFtvcHRpb25zLm1heFRvcnF1ZV0gTWF4aW11bSB0b3JxdWUgdG8gYXBwbHkuXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBHZWFyQ29uc3RyYWludChib2R5QSwgYm9keUIpO1xuICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgY29uc3RyYWludCA9IG5ldyBHZWFyQ29uc3RyYWludChib2R5QSwgYm9keUIsIHtcbiAqICAgICAgICAgcmF0aW86IDIsXG4gKiAgICAgICAgIG1heFRvcnF1ZTogMTAwMFxuICogICAgIH0pO1xuICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG4gKi9cbmZ1bmN0aW9uIEdlYXJDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBDb25zdHJhaW50LkdFQVIsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGdlYXIgcmF0aW8uXG4gICAgICogQHByb3BlcnR5IHJhdGlvXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJhdGlvID0gb3B0aW9ucy5yYXRpbyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yYXRpbyA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVsYXRpdmUgYW5nbGVcbiAgICAgKiBAcHJvcGVydHkgYW5nbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmFuZ2xlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuZ2xlIDogYm9keUIuYW5nbGUgLSB0aGlzLnJhdGlvICogYm9keUEuYW5nbGU7XG5cbiAgICAvLyBTZW5kIHNhbWUgcGFyYW1ldGVycyB0byB0aGUgZXF1YXRpb25cbiAgICBvcHRpb25zLmFuZ2xlID0gdGhpcy5hbmdsZTtcbiAgICBvcHRpb25zLnJhdGlvID0gdGhpcy5yYXRpbztcblxuICAgIHRoaXMuZXF1YXRpb25zID0gW1xuICAgICAgICBuZXcgQW5nbGVMb2NrRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyksXG4gICAgXTtcblxuICAgIC8vIFNldCBtYXggdG9ycXVlXG4gICAgaWYob3B0aW9ucy5tYXhUb3JxdWUgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgIHRoaXMuc2V0TWF4VG9ycXVlKG9wdGlvbnMubWF4VG9ycXVlKTtcbiAgICB9XG59XG5HZWFyQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VhckNvbnN0cmFpbnQ7XG5cbkdlYXJDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlcSA9IHRoaXMuZXF1YXRpb25zWzBdO1xuICAgIGlmKGVxLnJhdGlvICE9PSB0aGlzLnJhdGlvKXtcbiAgICAgICAgZXEuc2V0UmF0aW8odGhpcy5yYXRpbyk7XG4gICAgfVxuICAgIGVxLmFuZ2xlID0gdGhpcy5hbmdsZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggdG9ycXVlIGZvciB0aGUgY29uc3RyYWludC5cbiAqIEBtZXRob2Qgc2V0TWF4VG9ycXVlXG4gKiBAcGFyYW0ge051bWJlcn0gdG9ycXVlXG4gKi9cbkdlYXJDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNYXhUb3JxdWUgPSBmdW5jdGlvbih0b3JxdWUpe1xuICAgIHRoaXMuZXF1YXRpb25zWzBdLnNldE1heFRvcnF1ZSh0b3JxdWUpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1heCB0b3JxdWUgZm9yIHRoZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBnZXRNYXhUb3JxdWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuR2VhckNvbnN0cmFpbnQucHJvdG90eXBlLmdldE1heFRvcnF1ZSA9IGZ1bmN0aW9uKHRvcnF1ZSl7XG4gICAgcmV0dXJuIHRoaXMuZXF1YXRpb25zWzBdLm1heEZvcmNlO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/constraints/GearConstraint.js\n");

/***/ }),

/***/ "./node_modules/p2/src/constraints/LockConstraint.js":
/*!***********************************************************!*\
  !*** ./node_modules/p2/src/constraints/LockConstraint.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Constraint = __webpack_require__(/*! ./Constraint */ \"./node_modules/p2/src/constraints/Constraint.js\")\n,   vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,   Equation = __webpack_require__(/*! ../equations/Equation */ \"./node_modules/p2/src/equations/Equation.js\");\n\nmodule.exports = LockConstraint;\n\n/**\n * Locks the relative position and rotation between two bodies.\n *\n * @class LockConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. If not given the offset is computed from current positions.\n * @param {number} [options.localAngleB] The angle of bodyB in bodyA's frame. If not given, the angle is computed from current angles.\n * @param {number} [options.maxForce]\n * @extends Constraint\n *\n * @example\n *     // Locks the relative position and rotation between bodyA and bodyB\n *     var constraint = new LockConstraint(bodyA, bodyB);\n *     world.addConstraint(constraint);\n */\nfunction LockConstraint(bodyA, bodyB, options){\n    options = options || {};\n\n    Constraint.call(this,bodyA,bodyB,Constraint.LOCK,options);\n\n    var maxForce = ( typeof(options.maxForce)===\"undefined\" ? Number.MAX_VALUE : options.maxForce );\n\n    var localAngleB = options.localAngleB || 0;\n\n    // Use 3 equations:\n    // gx =   (xj - xi - l) * xhat = 0\n    // gy =   (xj - xi - l) * yhat = 0\n    // gr =   (xi - xj + r) * that = 0\n    //\n    // ...where:\n    //   l is the localOffsetB vector rotated to world in bodyA frame\n    //   r is the same vector but reversed and rotated from bodyB frame\n    //   xhat, yhat are world axis vectors\n    //   that is the tangent of r\n    //\n    // For the first two constraints, we get\n    // G*W = (vj - vi - ldot  ) * xhat\n    //     = (vj - vi - wi x l) * xhat\n    //\n    // Since (wi x l) * xhat = (l x xhat) * wi, we get\n    // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]\n    //\n    // The last constraint gives\n    // GW = (vi - vj + wj x r) * that\n    //    = [  that   0  -that  (r x t) ]\n\n    var x =     new Equation(bodyA,bodyB,-maxForce,maxForce),\n        y =     new Equation(bodyA,bodyB,-maxForce,maxForce),\n        rot =   new Equation(bodyA,bodyB,-maxForce,maxForce);\n\n    var l = vec2.create(),\n        g = vec2.create(),\n        that = this;\n    x.computeGq = function(){\n        vec2.rotate(l, that.localOffsetB, bodyA.angle);\n        vec2.sub(g, bodyB.position, bodyA.position);\n        vec2.sub(g, g, l);\n        return g[0];\n    };\n    y.computeGq = function(){\n        vec2.rotate(l, that.localOffsetB, bodyA.angle);\n        vec2.sub(g, bodyB.position, bodyA.position);\n        vec2.sub(g, g, l);\n        return g[1];\n    };\n    var r = vec2.create(),\n        t = vec2.create();\n    rot.computeGq = function(){\n        vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);\n        vec2.scale(r,r,-1);\n        vec2.sub(g,bodyA.position,bodyB.position);\n        vec2.add(g,g,r);\n        vec2.rotate(t,r,-Math.PI/2);\n        vec2.normalize(t,t);\n        return vec2.dot(g,t);\n    };\n\n    /**\n     * The offset of bodyB in bodyA's frame.\n     * @property {Array} localOffsetB\n     */\n    this.localOffsetB = vec2.create();\n    if(options.localOffsetB){\n        vec2.copy(this.localOffsetB, options.localOffsetB);\n    } else {\n        // Construct from current positions\n        vec2.sub(this.localOffsetB, bodyB.position, bodyA.position);\n        vec2.rotate(this.localOffsetB, this.localOffsetB, -bodyA.angle);\n    }\n\n    /**\n     * The offset angle of bodyB in bodyA's frame.\n     * @property {Number} localAngleB\n     */\n    this.localAngleB = 0;\n    if(typeof(options.localAngleB) === 'number'){\n        this.localAngleB = options.localAngleB;\n    } else {\n        // Construct\n        this.localAngleB = bodyB.angle - bodyA.angle;\n    }\n\n    this.equations.push(x, y, rot);\n    this.setMaxForce(maxForce);\n}\nLockConstraint.prototype = new Constraint();\nLockConstraint.prototype.constructor = LockConstraint;\n\n/**\n * Set the maximum force to be applied.\n * @method setMaxForce\n * @param {Number} force\n */\nLockConstraint.prototype.setMaxForce = function(force){\n    var eqs = this.equations;\n    for(var i=0; i<this.equations.length; i++){\n        eqs[i].maxForce =  force;\n        eqs[i].minForce = -force;\n    }\n};\n\n/**\n * Get the max force.\n * @method getMaxForce\n * @return {Number}\n */\nLockConstraint.prototype.getMaxForce = function(){\n    return this.equations[0].maxForce;\n};\n\nvar l = vec2.create();\nvar r = vec2.create();\nvar t = vec2.create();\nvar xAxis = vec2.fromValues(1,0);\nvar yAxis = vec2.fromValues(0,1);\nLockConstraint.prototype.update = function(){\n    var x =   this.equations[0],\n        y =   this.equations[1],\n        rot = this.equations[2],\n        bodyA = this.bodyA,\n        bodyB = this.bodyB;\n\n    vec2.rotate(l,this.localOffsetB,bodyA.angle);\n    vec2.rotate(r,this.localOffsetB,bodyB.angle - this.localAngleB);\n    vec2.scale(r,r,-1);\n\n    vec2.rotate(t,r,Math.PI/2);\n    vec2.normalize(t,t);\n\n    x.G[0] = -1;\n    x.G[1] =  0;\n    x.G[2] = -vec2.crossLength(l,xAxis);\n    x.G[3] =  1;\n\n    y.G[0] =  0;\n    y.G[1] = -1;\n    y.G[2] = -vec2.crossLength(l,yAxis);\n    y.G[4] =  1;\n\n    rot.G[0] =  -t[0];\n    rot.G[1] =  -t[1];\n    rot.G[3] =  t[0];\n    rot.G[4] =  t[1];\n    rot.G[5] =  vec2.crossLength(r,t);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9jb25zdHJhaW50cy9Mb2NrQ29uc3RyYWludC5qcz9lMjZiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50JylcbiwgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJylcbiwgICBFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9FcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2tDb25zdHJhaW50O1xuXG4vKipcbiAqIExvY2tzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBhbmQgcm90YXRpb24gYmV0d2VlbiB0d28gYm9kaWVzLlxuICpcbiAqIEBjbGFzcyBMb2NrQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxPZmZzZXRCXSBUaGUgb2Zmc2V0IG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuIElmIG5vdCBnaXZlbiB0aGUgb2Zmc2V0IGlzIGNvbXB1dGVkIGZyb20gY3VycmVudCBwb3NpdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubG9jYWxBbmdsZUJdIFRoZSBhbmdsZSBvZiBib2R5QiBpbiBib2R5QSdzIGZyYW1lLiBJZiBub3QgZ2l2ZW4sIHRoZSBhbmdsZSBpcyBjb21wdXRlZCBmcm9tIGN1cnJlbnQgYW5nbGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlXVxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gTG9ja3MgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGFuZCByb3RhdGlvbiBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5QlxuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IExvY2tDb25zdHJhaW50KGJvZHlBLCBib2R5Qik7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqL1xuZnVuY3Rpb24gTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCLENvbnN0cmFpbnQuTE9DSyxvcHRpb25zKTtcblxuICAgIHZhciBtYXhGb3JjZSA9ICggdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IE51bWJlci5NQVhfVkFMVUUgOiBvcHRpb25zLm1heEZvcmNlICk7XG5cbiAgICB2YXIgbG9jYWxBbmdsZUIgPSBvcHRpb25zLmxvY2FsQW5nbGVCIHx8IDA7XG5cbiAgICAvLyBVc2UgMyBlcXVhdGlvbnM6XG4gICAgLy8gZ3ggPSAgICh4aiAtIHhpIC0gbCkgKiB4aGF0ID0gMFxuICAgIC8vIGd5ID0gICAoeGogLSB4aSAtIGwpICogeWhhdCA9IDBcbiAgICAvLyBnciA9ICAgKHhpIC0geGogKyByKSAqIHRoYXQgPSAwXG4gICAgLy9cbiAgICAvLyAuLi53aGVyZTpcbiAgICAvLyAgIGwgaXMgdGhlIGxvY2FsT2Zmc2V0QiB2ZWN0b3Igcm90YXRlZCB0byB3b3JsZCBpbiBib2R5QSBmcmFtZVxuICAgIC8vICAgciBpcyB0aGUgc2FtZSB2ZWN0b3IgYnV0IHJldmVyc2VkIGFuZCByb3RhdGVkIGZyb20gYm9keUIgZnJhbWVcbiAgICAvLyAgIHhoYXQsIHloYXQgYXJlIHdvcmxkIGF4aXMgdmVjdG9yc1xuICAgIC8vICAgdGhhdCBpcyB0aGUgdGFuZ2VudCBvZiByXG4gICAgLy9cbiAgICAvLyBGb3IgdGhlIGZpcnN0IHR3byBjb25zdHJhaW50cywgd2UgZ2V0XG4gICAgLy8gRypXID0gKHZqIC0gdmkgLSBsZG90ICApICogeGhhdFxuICAgIC8vICAgICA9ICh2aiAtIHZpIC0gd2kgeCBsKSAqIHhoYXRcbiAgICAvL1xuICAgIC8vIFNpbmNlICh3aSB4IGwpICogeGhhdCA9IChsIHggeGhhdCkgKiB3aSwgd2UgZ2V0XG4gICAgLy8gRypXID0gWyAtMSAgIDAgICAoLWwgeCB4aGF0KSAgMSAgIDAgICAwXSAqIFt2aSB3aSB2aiB3al1cbiAgICAvL1xuICAgIC8vIFRoZSBsYXN0IGNvbnN0cmFpbnQgZ2l2ZXNcbiAgICAvLyBHVyA9ICh2aSAtIHZqICsgd2ogeCByKSAqIHRoYXRcbiAgICAvLyAgICA9IFsgIHRoYXQgICAwICAtdGhhdCAgKHIgeCB0KSBdXG5cbiAgICB2YXIgeCA9ICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICAgICAgeSA9ICAgICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKSxcbiAgICAgICAgcm90ID0gICBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTtcblxuICAgIHZhciBsID0gdmVjMi5jcmVhdGUoKSxcbiAgICAgICAgZyA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHRoYXQgPSB0aGlzO1xuICAgIHguY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmVjMi5yb3RhdGUobCwgdGhhdC5sb2NhbE9mZnNldEIsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5zdWIoZywgYm9keUIucG9zaXRpb24sIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgbCk7XG4gICAgICAgIHJldHVybiBnWzBdO1xuICAgIH07XG4gICAgeS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZShsLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnN1YihnLCBib2R5Qi5wb3NpdGlvbiwgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCBsKTtcbiAgICAgICAgcmV0dXJuIGdbMV07XG4gICAgfTtcbiAgICB2YXIgciA9IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHQgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIHJvdC5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZShyLCB0aGF0LmxvY2FsT2Zmc2V0QiwgYm9keUIuYW5nbGUgLSB0aGF0LmxvY2FsQW5nbGVCKTtcbiAgICAgICAgdmVjMi5zY2FsZShyLHIsLTEpO1xuICAgICAgICB2ZWMyLnN1YihnLGJvZHlBLnBvc2l0aW9uLGJvZHlCLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5hZGQoZyxnLHIpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh0LHIsLU1hdGguUEkvMik7XG4gICAgICAgIHZlYzIubm9ybWFsaXplKHQsdCk7XG4gICAgICAgIHJldHVybiB2ZWMyLmRvdChnLHQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbG9jYWxPZmZzZXRCXG4gICAgICovXG4gICAgdGhpcy5sb2NhbE9mZnNldEIgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgIGlmKG9wdGlvbnMubG9jYWxPZmZzZXRCKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMubG9jYWxPZmZzZXRCLCBvcHRpb25zLmxvY2FsT2Zmc2V0Qik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IGZyb20gY3VycmVudCBwb3NpdGlvbnNcbiAgICAgICAgdmVjMi5zdWIodGhpcy5sb2NhbE9mZnNldEIsIGJvZHlCLnBvc2l0aW9uLCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIucm90YXRlKHRoaXMubG9jYWxPZmZzZXRCLCB0aGlzLmxvY2FsT2Zmc2V0QiwgLWJvZHlBLmFuZ2xlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IGFuZ2xlIG9mIGJvZHlCIGluIGJvZHlBJ3MgZnJhbWUuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxvY2FsQW5nbGVCXG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuZ2xlQiA9IDA7XG4gICAgaWYodHlwZW9mKG9wdGlvbnMubG9jYWxBbmdsZUIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMubG9jYWxBbmdsZUIgPSBvcHRpb25zLmxvY2FsQW5nbGVCO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnN0cnVjdFxuICAgICAgICB0aGlzLmxvY2FsQW5nbGVCID0gYm9keUIuYW5nbGUgLSBib2R5QS5hbmdsZTtcbiAgICB9XG5cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHgsIHksIHJvdCk7XG4gICAgdGhpcy5zZXRNYXhGb3JjZShtYXhGb3JjZSk7XG59XG5Mb2NrQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9ja0NvbnN0cmFpbnQ7XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGZvcmNlIHRvIGJlIGFwcGxpZWQuXG4gKiBAbWV0aG9kIHNldE1heEZvcmNlXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yY2VcbiAqL1xuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnNldE1heEZvcmNlID0gZnVuY3Rpb24oZm9yY2Upe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmVxdWF0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGVxc1tpXS5tYXhGb3JjZSA9ICBmb3JjZTtcbiAgICAgICAgZXFzW2ldLm1pbkZvcmNlID0gLWZvcmNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXggZm9yY2UuXG4gKiBAbWV0aG9kIGdldE1heEZvcmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNYXhGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZXF1YXRpb25zWzBdLm1heEZvcmNlO1xufTtcblxudmFyIGwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHIgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHhBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDEsMCk7XG52YXIgeUF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMCwxKTtcbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciB4ID0gICB0aGlzLmVxdWF0aW9uc1swXSxcbiAgICAgICAgeSA9ICAgdGhpcy5lcXVhdGlvbnNbMV0sXG4gICAgICAgIHJvdCA9IHRoaXMuZXF1YXRpb25zWzJdLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QjtcblxuICAgIHZlYzIucm90YXRlKGwsdGhpcy5sb2NhbE9mZnNldEIsYm9keUEuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHIsdGhpcy5sb2NhbE9mZnNldEIsYm9keUIuYW5nbGUgLSB0aGlzLmxvY2FsQW5nbGVCKTtcbiAgICB2ZWMyLnNjYWxlKHIsciwtMSk7XG5cbiAgICB2ZWMyLnJvdGF0ZSh0LHIsTWF0aC5QSS8yKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZSh0LHQpO1xuXG4gICAgeC5HWzBdID0gLTE7XG4gICAgeC5HWzFdID0gIDA7XG4gICAgeC5HWzJdID0gLXZlYzIuY3Jvc3NMZW5ndGgobCx4QXhpcyk7XG4gICAgeC5HWzNdID0gIDE7XG5cbiAgICB5LkdbMF0gPSAgMDtcbiAgICB5LkdbMV0gPSAtMTtcbiAgICB5LkdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChsLHlBeGlzKTtcbiAgICB5LkdbNF0gPSAgMTtcblxuICAgIHJvdC5HWzBdID0gIC10WzBdO1xuICAgIHJvdC5HWzFdID0gIC10WzFdO1xuICAgIHJvdC5HWzNdID0gIHRbMF07XG4gICAgcm90LkdbNF0gPSAgdFsxXTtcbiAgICByb3QuR1s1XSA9ICB2ZWMyLmNyb3NzTGVuZ3RoKHIsdCk7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/constraints/LockConstraint.js\n");

/***/ }),

/***/ "./node_modules/p2/src/constraints/PrismaticConstraint.js":
/*!****************************************************************!*\
  !*** ./node_modules/p2/src/constraints/PrismaticConstraint.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Constraint = __webpack_require__(/*! ./Constraint */ \"./node_modules/p2/src/constraints/Constraint.js\")\n,   ContactEquation = __webpack_require__(/*! ../equations/ContactEquation */ \"./node_modules/p2/src/equations/ContactEquation.js\")\n,   Equation = __webpack_require__(/*! ../equations/Equation */ \"./node_modules/p2/src/equations/Equation.js\")\n,   vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,   RotationalLockEquation = __webpack_require__(/*! ../equations/RotationalLockEquation */ \"./node_modules/p2/src/equations/RotationalLockEquation.js\");\n\nmodule.exports = PrismaticConstraint;\n\n/**\n * Constraint that only allows bodies to move along a line, relative to each other. See <a href=\"http://www.iforce2d.net/b2dtut/joints-prismatic\">this tutorial</a>. Also called \"slider constraint\".\n *\n * @class PrismaticConstraint\n * @constructor\n * @extends Constraint\n * @author schteppe\n * @param {Body}    bodyA\n * @param {Body}    bodyB\n * @param {Object}  [options]\n * @param {Number}  [options.maxForce]                Max force to be applied by the constraint\n * @param {Array}   [options.localAnchorA]            Body A's anchor point, defined in its own local frame.\n * @param {Array}   [options.localAnchorB]            Body B's anchor point, defined in its own local frame.\n * @param {Array}   [options.localAxisA]              An axis, defined in body A frame, that body B's anchor point may slide along.\n * @param {Boolean} [options.disableRotationalLock]   If set to true, bodyB will be free to rotate around its anchor point.\n * @param {Number}  [options.upperLimit]\n * @param {Number}  [options.lowerLimit]\n * @todo Ability to create using only a point and a worldAxis\n */\nfunction PrismaticConstraint(bodyA, bodyB, options){\n    options = options || {};\n    Constraint.call(this,bodyA,bodyB,Constraint.PRISMATIC,options);\n\n    // Get anchors\n    var localAnchorA = vec2.fromValues(0,0),\n        localAxisA = vec2.fromValues(1,0),\n        localAnchorB = vec2.fromValues(0,0);\n    if(options.localAnchorA){ vec2.copy(localAnchorA, options.localAnchorA); }\n    if(options.localAxisA){ vec2.copy(localAxisA,   options.localAxisA); }\n    if(options.localAnchorB){ vec2.copy(localAnchorB, options.localAnchorB); }\n\n    /**\n     * @property localAnchorA\n     * @type {Array}\n     */\n    this.localAnchorA = localAnchorA;\n\n    /**\n     * @property localAnchorB\n     * @type {Array}\n     */\n    this.localAnchorB = localAnchorB;\n\n    /**\n     * @property localAxisA\n     * @type {Array}\n     */\n    this.localAxisA = localAxisA;\n\n    /*\n\n    The constraint violation for the common axis point is\n\n        g = ( xj + rj - xi - ri ) * t   :=  gg*t\n\n    where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.\n\n        gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )\n\n    Note the use of the chain rule. Now we identify the jacobian\n\n        G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]\n\n    The rotational part is just a rotation lock.\n\n     */\n\n    var maxForce = this.maxForce = typeof(options.maxForce)!==\"undefined\" ? options.maxForce : Number.MAX_VALUE;\n\n    // Translational part\n    var trans = new Equation(bodyA,bodyB,-maxForce,maxForce);\n    var ri = new vec2.create(),\n        rj = new vec2.create(),\n        gg = new vec2.create(),\n        t =  new vec2.create();\n    trans.computeGq = function(){\n        // g = ( xj + rj - xi - ri ) * t\n        return vec2.dot(gg,t);\n    };\n    trans.updateJacobian = function(){\n        var G = this.G,\n            xi = bodyA.position,\n            xj = bodyB.position;\n        vec2.rotate(ri,localAnchorA,bodyA.angle);\n        vec2.rotate(rj,localAnchorB,bodyB.angle);\n        vec2.add(gg,xj,rj);\n        vec2.sub(gg,gg,xi);\n        vec2.sub(gg,gg,ri);\n        vec2.rotate(t,localAxisA,bodyA.angle+Math.PI/2);\n\n        G[0] = -t[0];\n        G[1] = -t[1];\n        G[2] = -vec2.crossLength(ri,t) + vec2.crossLength(t,gg);\n        G[3] = t[0];\n        G[4] = t[1];\n        G[5] = vec2.crossLength(rj,t);\n    };\n    this.equations.push(trans);\n\n    // Rotational part\n    if(!options.disableRotationalLock){\n        var rot = new RotationalLockEquation(bodyA,bodyB,-maxForce,maxForce);\n        this.equations.push(rot);\n    }\n\n    /**\n     * The position of anchor A relative to anchor B, along the constraint axis.\n     * @property position\n     * @type {Number}\n     */\n    this.position = 0;\n\n    // Is this one used at all?\n    this.velocity = 0;\n\n    /**\n     * Set to true to enable lower limit.\n     * @property lowerLimitEnabled\n     * @type {Boolean}\n     */\n    this.lowerLimitEnabled = typeof(options.lowerLimit)!==\"undefined\" ? true : false;\n\n    /**\n     * Set to true to enable upper limit.\n     * @property upperLimitEnabled\n     * @type {Boolean}\n     */\n    this.upperLimitEnabled = typeof(options.upperLimit)!==\"undefined\" ? true : false;\n\n    /**\n     * Lower constraint limit. The constraint position is forced to be larger than this value.\n     * @property lowerLimit\n     * @type {Number}\n     */\n    this.lowerLimit = typeof(options.lowerLimit)!==\"undefined\" ? options.lowerLimit : 0;\n\n    /**\n     * Upper constraint limit. The constraint position is forced to be smaller than this value.\n     * @property upperLimit\n     * @type {Number}\n     */\n    this.upperLimit = typeof(options.upperLimit)!==\"undefined\" ? options.upperLimit : 1;\n\n    // Equations used for limits\n    this.upperLimitEquation = new ContactEquation(bodyA,bodyB);\n    this.lowerLimitEquation = new ContactEquation(bodyA,bodyB);\n\n    // Set max/min forces\n    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;\n    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;\n\n    /**\n     * Equation used for the motor.\n     * @property motorEquation\n     * @type {Equation}\n     */\n    this.motorEquation = new Equation(bodyA,bodyB);\n\n    /**\n     * The current motor state. Enable or disable the motor using .enableMotor\n     * @property motorEnabled\n     * @type {Boolean}\n     */\n    this.motorEnabled = false;\n\n    /**\n     * Set the target speed for the motor.\n     * @property motorSpeed\n     * @type {Number}\n     */\n    this.motorSpeed = 0;\n\n    var that = this;\n    var motorEquation = this.motorEquation;\n    var old = motorEquation.computeGW;\n    motorEquation.computeGq = function(){ return 0; };\n    motorEquation.computeGW = function(){\n        var G = this.G,\n            bi = this.bodyA,\n            bj = this.bodyB,\n            vi = bi.velocity,\n            vj = bj.velocity,\n            wi = bi.angularVelocity,\n            wj = bj.angularVelocity;\n        return this.gmult(G,vi,wi,vj,wj) + that.motorSpeed;\n    };\n}\n\nPrismaticConstraint.prototype = new Constraint();\nPrismaticConstraint.prototype.constructor = PrismaticConstraint;\n\nvar worldAxisA = vec2.create(),\n    worldAnchorA = vec2.create(),\n    worldAnchorB = vec2.create(),\n    orientedAnchorA = vec2.create(),\n    orientedAnchorB = vec2.create(),\n    tmp = vec2.create();\n\n/**\n * Update the constraint equations. Should be done if any of the bodies changed position, before solving.\n * @method update\n */\nPrismaticConstraint.prototype.update = function(){\n    var eqs = this.equations,\n        trans = eqs[0],\n        upperLimit = this.upperLimit,\n        lowerLimit = this.lowerLimit,\n        upperLimitEquation = this.upperLimitEquation,\n        lowerLimitEquation = this.lowerLimitEquation,\n        bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        localAxisA = this.localAxisA,\n        localAnchorA = this.localAnchorA,\n        localAnchorB = this.localAnchorB;\n\n    trans.updateJacobian();\n\n    // Transform local things to world\n    vec2.rotate(worldAxisA,      localAxisA,      bodyA.angle);\n    vec2.rotate(orientedAnchorA, localAnchorA,    bodyA.angle);\n    vec2.add(worldAnchorA,       orientedAnchorA, bodyA.position);\n    vec2.rotate(orientedAnchorB, localAnchorB,    bodyB.angle);\n    vec2.add(worldAnchorB,       orientedAnchorB, bodyB.position);\n\n    var relPosition = this.position = vec2.dot(worldAnchorB,worldAxisA) - vec2.dot(worldAnchorA,worldAxisA);\n\n    // Motor\n    if(this.motorEnabled){\n        // G = [ a     a x ri   -a   -a x rj ]\n        var G = this.motorEquation.G;\n        G[0] = worldAxisA[0];\n        G[1] = worldAxisA[1];\n        G[2] = vec2.crossLength(worldAxisA,orientedAnchorB);\n        G[3] = -worldAxisA[0];\n        G[4] = -worldAxisA[1];\n        G[5] = -vec2.crossLength(worldAxisA,orientedAnchorA);\n    }\n\n    /*\n        Limits strategy:\n        Add contact equation, with normal along the constraint axis.\n        min/maxForce is set so the constraint is repulsive in the correct direction.\n        Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.\n\n                 ^\n                 |\n      upperLimit x\n                 |    ------\n         anchorB x<---|  B |\n                 |    |    |\n        ------   |    ------\n        |    |   |\n        |  A |-->x anchorA\n        ------   |\n                 x lowerLimit\n                 |\n                axis\n     */\n\n\n    if(this.upperLimitEnabled && relPosition > upperLimit){\n        // Update contact constraint normal, etc\n        vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);\n        vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);\n        vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);\n        vec2.scale(tmp,worldAxisA,upperLimit);\n        vec2.add(upperLimitEquation.contactPointA,upperLimitEquation.contactPointA,tmp);\n        if(eqs.indexOf(upperLimitEquation) === -1){\n            eqs.push(upperLimitEquation);\n        }\n    } else {\n        var idx = eqs.indexOf(upperLimitEquation);\n        if(idx !== -1){\n            eqs.splice(idx,1);\n        }\n    }\n\n    if(this.lowerLimitEnabled && relPosition < lowerLimit){\n        // Update contact constraint normal, etc\n        vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);\n        vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);\n        vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);\n        vec2.scale(tmp,worldAxisA,lowerLimit);\n        vec2.sub(lowerLimitEquation.contactPointB,lowerLimitEquation.contactPointB,tmp);\n        if(eqs.indexOf(lowerLimitEquation) === -1){\n            eqs.push(lowerLimitEquation);\n        }\n    } else {\n        var idx = eqs.indexOf(lowerLimitEquation);\n        if(idx !== -1){\n            eqs.splice(idx,1);\n        }\n    }\n};\n\n/**\n * Enable the motor\n * @method enableMotor\n */\nPrismaticConstraint.prototype.enableMotor = function(){\n    if(this.motorEnabled){\n        return;\n    }\n    this.equations.push(this.motorEquation);\n    this.motorEnabled = true;\n};\n\n/**\n * Disable the rotational motor\n * @method disableMotor\n */\nPrismaticConstraint.prototype.disableMotor = function(){\n    if(!this.motorEnabled){\n        return;\n    }\n    var i = this.equations.indexOf(this.motorEquation);\n    this.equations.splice(i,1);\n    this.motorEnabled = false;\n};\n\n/**\n * Set the constraint limits.\n * @method setLimits\n * @param {number} lower Lower limit.\n * @param {number} upper Upper limit.\n */\nPrismaticConstraint.prototype.setLimits = function (lower, upper) {\n    if(typeof(lower) === 'number'){\n        this.lowerLimit = lower;\n        this.lowerLimitEnabled = true;\n    } else {\n        this.lowerLimit = lower;\n        this.lowerLimitEnabled = false;\n    }\n\n    if(typeof(upper) === 'number'){\n        this.upperLimit = upper;\n        this.upperLimitEnabled = true;\n    } else {\n        this.upperLimit = upper;\n        this.upperLimitEnabled = false;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnQuanM/YWVmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4vQ29uc3RyYWludCcpXG4sICAgQ29udGFjdEVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpXG4sICAgRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvRXF1YXRpb24nKVxuLCAgIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFJvdGF0aW9uYWxMb2NrRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbExvY2tFcXVhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByaXNtYXRpY0NvbnN0cmFpbnQ7XG5cbi8qKlxuICogQ29uc3RyYWludCB0aGF0IG9ubHkgYWxsb3dzIGJvZGllcyB0byBtb3ZlIGFsb25nIGEgbGluZSwgcmVsYXRpdmUgdG8gZWFjaCBvdGhlci4gU2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3Lmlmb3JjZTJkLm5ldC9iMmR0dXQvam9pbnRzLXByaXNtYXRpY1wiPnRoaXMgdHV0b3JpYWw8L2E+LiBBbHNvIGNhbGxlZCBcInNsaWRlciBjb25zdHJhaW50XCIuXG4gKlxuICogQGNsYXNzIFByaXNtYXRpY0NvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSAgICBib2R5QVxuICogQHBhcmFtIHtCb2R5fSAgICBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSAgW29wdGlvbnMubWF4Rm9yY2VdICAgICAgICAgICAgICAgIE1heCBmb3JjZSB0byBiZSBhcHBsaWVkIGJ5IHRoZSBjb25zdHJhaW50XG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gICAgICAgICAgICBCb2R5IEEncyBhbmNob3IgcG9pbnQsIGRlZmluZWQgaW4gaXRzIG93biBsb2NhbCBmcmFtZS5cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxBbmNob3JCXSAgICAgICAgICAgIEJvZHkgQidzIGFuY2hvciBwb2ludCwgZGVmaW5lZCBpbiBpdHMgb3duIGxvY2FsIGZyYW1lLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5sb2NhbEF4aXNBXSAgICAgICAgICAgICAgQW4gYXhpcywgZGVmaW5lZCBpbiBib2R5IEEgZnJhbWUsIHRoYXQgYm9keSBCJ3MgYW5jaG9yIHBvaW50IG1heSBzbGlkZSBhbG9uZy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGlzYWJsZVJvdGF0aW9uYWxMb2NrXSAgIElmIHNldCB0byB0cnVlLCBib2R5QiB3aWxsIGJlIGZyZWUgdG8gcm90YXRlIGFyb3VuZCBpdHMgYW5jaG9yIHBvaW50LlxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy51cHBlckxpbWl0XVxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy5sb3dlckxpbWl0XVxuICogQHRvZG8gQWJpbGl0eSB0byBjcmVhdGUgdXNpbmcgb25seSBhIHBvaW50IGFuZCBhIHdvcmxkQXhpc1xuICovXG5mdW5jdGlvbiBQcmlzbWF0aWNDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIsQ29uc3RyYWludC5QUklTTUFUSUMsb3B0aW9ucyk7XG5cbiAgICAvLyBHZXQgYW5jaG9yc1xuICAgIHZhciBsb2NhbEFuY2hvckEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICAgICAgbG9jYWxBeGlzQSA9IHZlYzIuZnJvbVZhbHVlcygxLDApLFxuICAgICAgICBsb2NhbEFuY2hvckIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcbiAgICBpZihvcHRpb25zLmxvY2FsQW5jaG9yQSl7IHZlYzIuY29weShsb2NhbEFuY2hvckEsIG9wdGlvbnMubG9jYWxBbmNob3JBKTsgfVxuICAgIGlmKG9wdGlvbnMubG9jYWxBeGlzQSl7IHZlYzIuY29weShsb2NhbEF4aXNBLCAgIG9wdGlvbnMubG9jYWxBeGlzQSk7IH1cbiAgICBpZihvcHRpb25zLmxvY2FsQW5jaG9yQil7IHZlYzIuY29weShsb2NhbEFuY2hvckIsIG9wdGlvbnMubG9jYWxBbmNob3JCKTsgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGxvY2FsQW5jaG9yQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQW5jaG9yQSA9IGxvY2FsQW5jaG9yQTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckIgPSBsb2NhbEFuY2hvckI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBeGlzQVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsQXhpc0EgPSBsb2NhbEF4aXNBO1xuXG4gICAgLypcblxuICAgIFRoZSBjb25zdHJhaW50IHZpb2xhdGlvbiBmb3IgdGhlIGNvbW1vbiBheGlzIHBvaW50IGlzXG5cbiAgICAgICAgZyA9ICggeGogKyByaiAtIHhpIC0gcmkgKSAqIHQgICA6PSAgZ2cqdFxuXG4gICAgd2hlcmUgciBhcmUgYm9keS1sb2NhbCBhbmNob3IgcG9pbnRzLCBhbmQgdCBpcyBhIHRhbmdlbnQgdG8gdGhlIGNvbnN0cmFpbnQgYXhpcyBkZWZpbmVkIGluIGJvZHkgaSBmcmFtZS5cblxuICAgICAgICBnZG90ID0gICggdmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpICkgKiB0ICsgKCB4aiArIHJqIC0geGkgLSByaSApICogKCB3aSB4IHQgKVxuXG4gICAgTm90ZSB0aGUgdXNlIG9mIHRoZSBjaGFpbiBydWxlLiBOb3cgd2UgaWRlbnRpZnkgdGhlIGphY29iaWFuXG5cbiAgICAgICAgRypXID0gWyAtdCAgICAgIC1yaSB4IHQgKyB0IHggZ2cgICAgIHQgICAgcmogeCB0IF0gKiBbdmkgd2kgdmogd2pdXG5cbiAgICBUaGUgcm90YXRpb25hbCBwYXJ0IGlzIGp1c3QgYSByb3RhdGlvbiBsb2NrLlxuXG4gICAgICovXG5cbiAgICB2YXIgbWF4Rm9yY2UgPSB0aGlzLm1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpIT09XCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMubWF4Rm9yY2UgOiBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgLy8gVHJhbnNsYXRpb25hbCBwYXJ0XG4gICAgdmFyIHRyYW5zID0gbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7XG4gICAgdmFyIHJpID0gbmV3IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHJqID0gbmV3IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIGdnID0gbmV3IHZlYzIuY3JlYXRlKCksXG4gICAgICAgIHQgPSAgbmV3IHZlYzIuY3JlYXRlKCk7XG4gICAgdHJhbnMuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gZyA9ICggeGogKyByaiAtIHhpIC0gcmkgKSAqIHRcbiAgICAgICAgcmV0dXJuIHZlYzIuZG90KGdnLHQpO1xuICAgIH07XG4gICAgdHJhbnMudXBkYXRlSmFjb2JpYW4gPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgICAgIHhpID0gYm9keUEucG9zaXRpb24sXG4gICAgICAgICAgICB4aiA9IGJvZHlCLnBvc2l0aW9uO1xuICAgICAgICB2ZWMyLnJvdGF0ZShyaSxsb2NhbEFuY2hvckEsYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZShyaixsb2NhbEFuY2hvckIsYm9keUIuYW5nbGUpO1xuICAgICAgICB2ZWMyLmFkZChnZyx4aixyaik7XG4gICAgICAgIHZlYzIuc3ViKGdnLGdnLHhpKTtcbiAgICAgICAgdmVjMi5zdWIoZ2csZ2cscmkpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh0LGxvY2FsQXhpc0EsYm9keUEuYW5nbGUrTWF0aC5QSS8yKTtcblxuICAgICAgICBHWzBdID0gLXRbMF07XG4gICAgICAgIEdbMV0gPSAtdFsxXTtcbiAgICAgICAgR1syXSA9IC12ZWMyLmNyb3NzTGVuZ3RoKHJpLHQpICsgdmVjMi5jcm9zc0xlbmd0aCh0LGdnKTtcbiAgICAgICAgR1szXSA9IHRbMF07XG4gICAgICAgIEdbNF0gPSB0WzFdO1xuICAgICAgICBHWzVdID0gdmVjMi5jcm9zc0xlbmd0aChyaix0KTtcbiAgICB9O1xuICAgIHRoaXMuZXF1YXRpb25zLnB1c2godHJhbnMpO1xuXG4gICAgLy8gUm90YXRpb25hbCBwYXJ0XG4gICAgaWYoIW9wdGlvbnMuZGlzYWJsZVJvdGF0aW9uYWxMb2NrKXtcbiAgICAgICAgdmFyIHJvdCA9IG5ldyBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2gocm90KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgYW5jaG9yIEEgcmVsYXRpdmUgdG8gYW5jaG9yIEIsIGFsb25nIHRoZSBjb25zdHJhaW50IGF4aXMuXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gMDtcblxuICAgIC8vIElzIHRoaXMgb25lIHVzZWQgYXQgYWxsP1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIGxvd2VyIGxpbWl0LlxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0RW5hYmxlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSB0eXBlb2Yob3B0aW9ucy5sb3dlckxpbWl0KSE9PVwidW5kZWZpbmVkXCIgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgdXBwZXIgbGltaXQuXG4gICAgICogQHByb3BlcnR5IHVwcGVyTGltaXRFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IHR5cGVvZihvcHRpb25zLnVwcGVyTGltaXQpIT09XCJ1bmRlZmluZWRcIiA/IHRydWUgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIExvd2VyIGNvbnN0cmFpbnQgbGltaXQuIFRoZSBjb25zdHJhaW50IHBvc2l0aW9uIGlzIGZvcmNlZCB0byBiZSBsYXJnZXIgdGhhbiB0aGlzIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSBsb3dlckxpbWl0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXQgPSB0eXBlb2Yob3B0aW9ucy5sb3dlckxpbWl0KSE9PVwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmxvd2VyTGltaXQgOiAwO1xuXG4gICAgLyoqXG4gICAgICogVXBwZXIgY29uc3RyYWludCBsaW1pdC4gVGhlIGNvbnN0cmFpbnQgcG9zaXRpb24gaXMgZm9yY2VkIHRvIGJlIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLlxuICAgICAqIEBwcm9wZXJ0eSB1cHBlckxpbWl0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXQgPSB0eXBlb2Yob3B0aW9ucy51cHBlckxpbWl0KSE9PVwidW5kZWZpbmVkXCIgPyBvcHRpb25zLnVwcGVyTGltaXQgOiAxO1xuXG4gICAgLy8gRXF1YXRpb25zIHVzZWQgZm9yIGxpbWl0c1xuICAgIHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5Qik7XG4gICAgdGhpcy5sb3dlckxpbWl0RXF1YXRpb24gPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcblxuICAgIC8vIFNldCBtYXgvbWluIGZvcmNlc1xuICAgIHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLm1pbkZvcmNlID0gdGhpcy5sb3dlckxpbWl0RXF1YXRpb24ubWluRm9yY2UgPSAwO1xuICAgIHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLm1heEZvcmNlID0gdGhpcy5sb3dlckxpbWl0RXF1YXRpb24ubWF4Rm9yY2UgPSBtYXhGb3JjZTtcblxuICAgIC8qKlxuICAgICAqIEVxdWF0aW9uIHVzZWQgZm9yIHRoZSBtb3Rvci5cbiAgICAgKiBAcHJvcGVydHkgbW90b3JFcXVhdGlvblxuICAgICAqIEB0eXBlIHtFcXVhdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLm1vdG9yRXF1YXRpb24gPSBuZXcgRXF1YXRpb24oYm9keUEsYm9keUIpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgbW90b3Igc3RhdGUuIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBtb3RvciB1c2luZyAuZW5hYmxlTW90b3JcbiAgICAgKiBAcHJvcGVydHkgbW90b3JFbmFibGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGFyZ2V0IHNwZWVkIGZvciB0aGUgbW90b3IuXG4gICAgICogQHByb3BlcnR5IG1vdG9yU3BlZWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubW90b3JTcGVlZCA9IDA7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIG1vdG9yRXF1YXRpb24gPSB0aGlzLm1vdG9yRXF1YXRpb247XG4gICAgdmFyIG9sZCA9IG1vdG9yRXF1YXRpb24uY29tcHV0ZUdXO1xuICAgIG1vdG9yRXF1YXRpb24uY29tcHV0ZUdxID0gZnVuY3Rpb24oKXsgcmV0dXJuIDA7IH07XG4gICAgbW90b3JFcXVhdGlvbi5jb21wdXRlR1cgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgICAgIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgICAgIHZpID0gYmkudmVsb2NpdHksXG4gICAgICAgICAgICB2aiA9IGJqLnZlbG9jaXR5LFxuICAgICAgICAgICAgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHksXG4gICAgICAgICAgICB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ211bHQoRyx2aSx3aSx2aix3aikgKyB0aGF0Lm1vdG9yU3BlZWQ7XG4gICAgfTtcbn1cblxuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcmlzbWF0aWNDb25zdHJhaW50O1xuXG52YXIgd29ybGRBeGlzQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgd29ybGRBbmNob3JBID0gdmVjMi5jcmVhdGUoKSxcbiAgICB3b3JsZEFuY2hvckIgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIG9yaWVudGVkQW5jaG9yQSA9IHZlYzIuY3JlYXRlKCksXG4gICAgb3JpZW50ZWRBbmNob3JCID0gdmVjMi5jcmVhdGUoKSxcbiAgICB0bXAgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgY29uc3RyYWludCBlcXVhdGlvbnMuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgYm9kaWVzIGNoYW5nZWQgcG9zaXRpb24sIGJlZm9yZSBzb2x2aW5nLlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnMsXG4gICAgICAgIHRyYW5zID0gZXFzWzBdLFxuICAgICAgICB1cHBlckxpbWl0ID0gdGhpcy51cHBlckxpbWl0LFxuICAgICAgICBsb3dlckxpbWl0ID0gdGhpcy5sb3dlckxpbWl0LFxuICAgICAgICB1cHBlckxpbWl0RXF1YXRpb24gPSB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbixcbiAgICAgICAgbG93ZXJMaW1pdEVxdWF0aW9uID0gdGhpcy5sb3dlckxpbWl0RXF1YXRpb24sXG4gICAgICAgIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICBsb2NhbEF4aXNBID0gdGhpcy5sb2NhbEF4aXNBLFxuICAgICAgICBsb2NhbEFuY2hvckEgPSB0aGlzLmxvY2FsQW5jaG9yQSxcbiAgICAgICAgbG9jYWxBbmNob3JCID0gdGhpcy5sb2NhbEFuY2hvckI7XG5cbiAgICB0cmFucy51cGRhdGVKYWNvYmlhbigpO1xuXG4gICAgLy8gVHJhbnNmb3JtIGxvY2FsIHRoaW5ncyB0byB3b3JsZFxuICAgIHZlYzIucm90YXRlKHdvcmxkQXhpc0EsICAgICAgbG9jYWxBeGlzQSwgICAgICBib2R5QS5hbmdsZSk7XG4gICAgdmVjMi5yb3RhdGUob3JpZW50ZWRBbmNob3JBLCBsb2NhbEFuY2hvckEsICAgIGJvZHlBLmFuZ2xlKTtcbiAgICB2ZWMyLmFkZCh3b3JsZEFuY2hvckEsICAgICAgIG9yaWVudGVkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xuICAgIHZlYzIucm90YXRlKG9yaWVudGVkQW5jaG9yQiwgbG9jYWxBbmNob3JCLCAgICBib2R5Qi5hbmdsZSk7XG4gICAgdmVjMi5hZGQod29ybGRBbmNob3JCLCAgICAgICBvcmllbnRlZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcblxuICAgIHZhciByZWxQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gPSB2ZWMyLmRvdCh3b3JsZEFuY2hvckIsd29ybGRBeGlzQSkgLSB2ZWMyLmRvdCh3b3JsZEFuY2hvckEsd29ybGRBeGlzQSk7XG5cbiAgICAvLyBNb3RvclxuICAgIGlmKHRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgLy8gRyA9IFsgYSAgICAgYSB4IHJpICAgLWEgICAtYSB4IHJqIF1cbiAgICAgICAgdmFyIEcgPSB0aGlzLm1vdG9yRXF1YXRpb24uRztcbiAgICAgICAgR1swXSA9IHdvcmxkQXhpc0FbMF07XG4gICAgICAgIEdbMV0gPSB3b3JsZEF4aXNBWzFdO1xuICAgICAgICBHWzJdID0gdmVjMi5jcm9zc0xlbmd0aCh3b3JsZEF4aXNBLG9yaWVudGVkQW5jaG9yQik7XG4gICAgICAgIEdbM10gPSAtd29ybGRBeGlzQVswXTtcbiAgICAgICAgR1s0XSA9IC13b3JsZEF4aXNBWzFdO1xuICAgICAgICBHWzVdID0gLXZlYzIuY3Jvc3NMZW5ndGgod29ybGRBeGlzQSxvcmllbnRlZEFuY2hvckEpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICAgIExpbWl0cyBzdHJhdGVneTpcbiAgICAgICAgQWRkIGNvbnRhY3QgZXF1YXRpb24sIHdpdGggbm9ybWFsIGFsb25nIHRoZSBjb25zdHJhaW50IGF4aXMuXG4gICAgICAgIG1pbi9tYXhGb3JjZSBpcyBzZXQgc28gdGhlIGNvbnN0cmFpbnQgaXMgcmVwdWxzaXZlIGluIHRoZSBjb3JyZWN0IGRpcmVjdGlvbi5cbiAgICAgICAgU29tZSBvZmZzZXQgaXMgYWRkZWQgdG8gZWl0aGVyIGVxdWF0aW9uLmNvbnRhY3RQb2ludEEgb3IgLmNvbnRhY3RQb2ludEIgdG8gZ2V0IHRoZSBjb3JyZWN0IHVwcGVyL2xvd2VyIGxpbWl0LlxuXG4gICAgICAgICAgICAgICAgIF5cbiAgICAgICAgICAgICAgICAgfFxuICAgICAgdXBwZXJMaW1pdCB4XG4gICAgICAgICAgICAgICAgIHwgICAgLS0tLS0tXG4gICAgICAgICBhbmNob3JCIHg8LS0tfCAgQiB8XG4gICAgICAgICAgICAgICAgIHwgICAgfCAgICB8XG4gICAgICAgIC0tLS0tLSAgIHwgICAgLS0tLS0tXG4gICAgICAgIHwgICAgfCAgIHxcbiAgICAgICAgfCAgQSB8LS0+eCBhbmNob3JBXG4gICAgICAgIC0tLS0tLSAgIHxcbiAgICAgICAgICAgICAgICAgeCBsb3dlckxpbWl0XG4gICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICBheGlzXG4gICAgICovXG5cblxuICAgIGlmKHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgJiYgcmVsUG9zaXRpb24gPiB1cHBlckxpbWl0KXtcbiAgICAgICAgLy8gVXBkYXRlIGNvbnRhY3QgY29uc3RyYWludCBub3JtYWwsIGV0Y1xuICAgICAgICB2ZWMyLnNjYWxlKHVwcGVyTGltaXRFcXVhdGlvbi5ub3JtYWxBLCB3b3JsZEF4aXNBLCAtMSk7XG4gICAgICAgIHZlYzIuc3ViKHVwcGVyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLCB3b3JsZEFuY2hvckEsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIodXBwZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIHdvcmxkQW5jaG9yQiwgYm9keUIucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnNjYWxlKHRtcCx3b3JsZEF4aXNBLHVwcGVyTGltaXQpO1xuICAgICAgICB2ZWMyLmFkZCh1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSx1cHBlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50QSx0bXApO1xuICAgICAgICBpZihlcXMuaW5kZXhPZih1cHBlckxpbWl0RXF1YXRpb24pID09PSAtMSl7XG4gICAgICAgICAgICBlcXMucHVzaCh1cHBlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IGVxcy5pbmRleE9mKHVwcGVyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgZXFzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLmxvd2VyTGltaXRFbmFibGVkICYmIHJlbFBvc2l0aW9uIDwgbG93ZXJMaW1pdCl7XG4gICAgICAgIC8vIFVwZGF0ZSBjb250YWN0IGNvbnN0cmFpbnQgbm9ybWFsLCBldGNcbiAgICAgICAgdmVjMi5zY2FsZShsb3dlckxpbWl0RXF1YXRpb24ubm9ybWFsQSwgd29ybGRBeGlzQSwgMSk7XG4gICAgICAgIHZlYzIuc3ViKGxvd2VyTGltaXRFcXVhdGlvbi5jb250YWN0UG9pbnRBLCB3b3JsZEFuY2hvckEsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIobG93ZXJMaW1pdEVxdWF0aW9uLmNvbnRhY3RQb2ludEIsIHdvcmxkQW5jaG9yQiwgYm9keUIucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnNjYWxlKHRtcCx3b3JsZEF4aXNBLGxvd2VyTGltaXQpO1xuICAgICAgICB2ZWMyLnN1Yihsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qixsb3dlckxpbWl0RXF1YXRpb24uY29udGFjdFBvaW50Qix0bXApO1xuICAgICAgICBpZihlcXMuaW5kZXhPZihsb3dlckxpbWl0RXF1YXRpb24pID09PSAtMSl7XG4gICAgICAgICAgICBlcXMucHVzaChsb3dlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IGVxcy5pbmRleE9mKGxvd2VyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgZXFzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0aGUgbW90b3JcbiAqIEBtZXRob2QgZW5hYmxlTW90b3JcbiAqL1xuUHJpc21hdGljQ29uc3RyYWludC5wcm90b3R5cGUuZW5hYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMubW90b3JFbmFibGVkKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIHRoZSByb3RhdGlvbmFsIG1vdG9yXG4gKiBAbWV0aG9kIGRpc2FibGVNb3RvclxuICovXG5QcmlzbWF0aWNDb25zdHJhaW50LnByb3RvdHlwZS5kaXNhYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIGlmKCF0aGlzLm1vdG9yRW5hYmxlZCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmVxdWF0aW9ucy5pbmRleE9mKHRoaXMubW90b3JFcXVhdGlvbik7XG4gICAgdGhpcy5lcXVhdGlvbnMuc3BsaWNlKGksMSk7XG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb25zdHJhaW50IGxpbWl0cy5cbiAqIEBtZXRob2Qgc2V0TGltaXRzXG4gKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgTG93ZXIgbGltaXQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVXBwZXIgbGltaXQuXG4gKi9cblByaXNtYXRpY0NvbnN0cmFpbnQucHJvdG90eXBlLnNldExpbWl0cyA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcbiAgICBpZih0eXBlb2YobG93ZXIpID09PSAnbnVtYmVyJyl7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdCA9IGxvd2VyO1xuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvd2VyTGltaXQgPSBsb3dlcjtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0RW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZih1cHBlcikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXI7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdCA9IHVwcGVyO1xuICAgICAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/constraints/PrismaticConstraint.js\n");

/***/ }),

/***/ "./node_modules/p2/src/constraints/RevoluteConstraint.js":
/*!***************************************************************!*\
  !*** ./node_modules/p2/src/constraints/RevoluteConstraint.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Constraint = __webpack_require__(/*! ./Constraint */ \"./node_modules/p2/src/constraints/Constraint.js\")\n,   Equation = __webpack_require__(/*! ../equations/Equation */ \"./node_modules/p2/src/equations/Equation.js\")\n,   RotationalVelocityEquation = __webpack_require__(/*! ../equations/RotationalVelocityEquation */ \"./node_modules/p2/src/equations/RotationalVelocityEquation.js\")\n,   RotationalLockEquation = __webpack_require__(/*! ../equations/RotationalLockEquation */ \"./node_modules/p2/src/equations/RotationalLockEquation.js\")\n,   vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\n\nmodule.exports = RevoluteConstraint;\n\nvar worldPivotA = vec2.create(),\n    worldPivotB = vec2.create(),\n    xAxis = vec2.fromValues(1,0),\n    yAxis = vec2.fromValues(0,1),\n    g = vec2.create();\n\n/**\n * Connects two bodies at given offset points, letting them rotate relative to each other around this point.\n * @class RevoluteConstraint\n * @constructor\n * @author schteppe\n * @param {Body}    bodyA\n * @param {Body}    bodyB\n * @param {Object}  [options]\n * @param {Array}   [options.worldPivot] A pivot point given in world coordinates. If specified, localPivotA and localPivotB are automatically computed from this value.\n * @param {Array}   [options.localPivotA] The point relative to the center of mass of bodyA which bodyA is constrained to.\n * @param {Array}   [options.localPivotB] See localPivotA.\n * @param {Number}  [options.maxForce] The maximum force that should be applied to constrain the bodies.\n * @extends Constraint\n *\n * @example\n *     // This will create a revolute constraint between two bodies with pivot point in between them.\n *     var bodyA = new Body({ mass: 1, position: [-1, 0] });\n *     var bodyB = new Body({ mass: 1, position: [1, 0] });\n *     var constraint = new RevoluteConstraint(bodyA, bodyB, {\n *         worldPivot: [0, 0]\n *     });\n *     world.addConstraint(constraint);\n *\n *     // Using body-local pivot points, the constraint could have been constructed like this:\n *     var constraint = new RevoluteConstraint(bodyA, bodyB, {\n *         localPivotA: [1, 0],\n *         localPivotB: [-1, 0]\n *     });\n */\nfunction RevoluteConstraint(bodyA, bodyB, options){\n    options = options || {};\n    Constraint.call(this,bodyA,bodyB,Constraint.REVOLUTE,options);\n\n    var maxForce = this.maxForce = typeof(options.maxForce) !== \"undefined\" ? options.maxForce : Number.MAX_VALUE;\n\n    /**\n     * @property {Array} pivotA\n     */\n    this.pivotA = vec2.create();\n\n    /**\n     * @property {Array} pivotB\n     */\n    this.pivotB = vec2.create();\n\n    if(options.worldPivot){\n        // Compute pivotA and pivotB\n        vec2.sub(this.pivotA, options.worldPivot, bodyA.position);\n        vec2.sub(this.pivotB, options.worldPivot, bodyB.position);\n        // Rotate to local coordinate system\n        vec2.rotate(this.pivotA, this.pivotA, -bodyA.angle);\n        vec2.rotate(this.pivotB, this.pivotB, -bodyB.angle);\n    } else {\n        // Get pivotA and pivotB\n        vec2.copy(this.pivotA, options.localPivotA);\n        vec2.copy(this.pivotB, options.localPivotB);\n    }\n\n    // Equations to be fed to the solver\n    var eqs = this.equations = [\n        new Equation(bodyA,bodyB,-maxForce,maxForce),\n        new Equation(bodyA,bodyB,-maxForce,maxForce),\n    ];\n\n    var x = eqs[0];\n    var y = eqs[1];\n    var that = this;\n\n    x.computeGq = function(){\n        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);\n        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);\n        vec2.add(g, bodyB.position, worldPivotB);\n        vec2.sub(g, g, bodyA.position);\n        vec2.sub(g, g, worldPivotA);\n        return vec2.dot(g,xAxis);\n    };\n\n    y.computeGq = function(){\n        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);\n        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);\n        vec2.add(g, bodyB.position, worldPivotB);\n        vec2.sub(g, g, bodyA.position);\n        vec2.sub(g, g, worldPivotA);\n        return vec2.dot(g,yAxis);\n    };\n\n    y.minForce = x.minForce = -maxForce;\n    y.maxForce = x.maxForce =  maxForce;\n\n    this.motorEquation = new RotationalVelocityEquation(bodyA,bodyB);\n\n    /**\n     * Indicates whether the motor is enabled. Use .enableMotor() to enable the constraint motor.\n     * @property {Boolean} motorEnabled\n     * @readOnly\n     */\n    this.motorEnabled = false;\n\n    /**\n     * The constraint position.\n     * @property angle\n     * @type {Number}\n     * @readOnly\n     */\n    this.angle = 0;\n\n    /**\n     * Set to true to enable lower limit\n     * @property lowerLimitEnabled\n     * @type {Boolean}\n     */\n    this.lowerLimitEnabled = false;\n\n    /**\n     * Set to true to enable upper limit\n     * @property upperLimitEnabled\n     * @type {Boolean}\n     */\n    this.upperLimitEnabled = false;\n\n    /**\n     * The lower limit on the constraint angle.\n     * @property lowerLimit\n     * @type {Boolean}\n     */\n    this.lowerLimit = 0;\n\n    /**\n     * The upper limit on the constraint angle.\n     * @property upperLimit\n     * @type {Boolean}\n     */\n    this.upperLimit = 0;\n\n    this.upperLimitEquation = new RotationalLockEquation(bodyA,bodyB);\n    this.lowerLimitEquation = new RotationalLockEquation(bodyA,bodyB);\n    this.upperLimitEquation.minForce = 0;\n    this.lowerLimitEquation.maxForce = 0;\n}\nRevoluteConstraint.prototype = new Constraint();\nRevoluteConstraint.prototype.constructor = RevoluteConstraint;\n\n/**\n * Set the constraint angle limits.\n * @method setLimits\n * @param {number} lower Lower angle limit.\n * @param {number} upper Upper angle limit.\n */\nRevoluteConstraint.prototype.setLimits = function (lower, upper) {\n    if(typeof(lower) === 'number'){\n        this.lowerLimit = lower;\n        this.lowerLimitEnabled = true;\n    } else {\n        this.lowerLimit = lower;\n        this.lowerLimitEnabled = false;\n    }\n\n    if(typeof(upper) === 'number'){\n        this.upperLimit = upper;\n        this.upperLimitEnabled = true;\n    } else {\n        this.upperLimit = upper;\n        this.upperLimitEnabled = false;\n    }\n};\n\nRevoluteConstraint.prototype.update = function(){\n    var bodyA =  this.bodyA,\n        bodyB =  this.bodyB,\n        pivotA = this.pivotA,\n        pivotB = this.pivotB,\n        eqs =    this.equations,\n        normal = eqs[0],\n        tangent= eqs[1],\n        x = eqs[0],\n        y = eqs[1],\n        upperLimit = this.upperLimit,\n        lowerLimit = this.lowerLimit,\n        upperLimitEquation = this.upperLimitEquation,\n        lowerLimitEquation = this.lowerLimitEquation;\n\n    var relAngle = this.angle = bodyB.angle - bodyA.angle;\n\n    if(this.upperLimitEnabled && relAngle > upperLimit){\n        upperLimitEquation.angle = upperLimit;\n        if(eqs.indexOf(upperLimitEquation) === -1){\n            eqs.push(upperLimitEquation);\n        }\n    } else {\n        var idx = eqs.indexOf(upperLimitEquation);\n        if(idx !== -1){\n            eqs.splice(idx,1);\n        }\n    }\n\n    if(this.lowerLimitEnabled && relAngle < lowerLimit){\n        lowerLimitEquation.angle = lowerLimit;\n        if(eqs.indexOf(lowerLimitEquation) === -1){\n            eqs.push(lowerLimitEquation);\n        }\n    } else {\n        var idx = eqs.indexOf(lowerLimitEquation);\n        if(idx !== -1){\n            eqs.splice(idx,1);\n        }\n    }\n\n    /*\n\n    The constraint violation is\n\n        g = xj + rj - xi - ri\n\n    ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:\n\n        gdot = vj + wj x rj - vi - wi x ri\n\n    We split this into x and y directions. (let x and y be unit vectors along the respective axes)\n\n        gdot * x = ( vj + wj x rj - vi - wi x ri ) * x\n                 = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x\n                 = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi\n                 = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]\n                 = G*W\n\n    ...and similar for y. We have then identified the jacobian entries for x and y directions:\n\n        Gx = [ x   (rj x x)   -x   -(ri x x)]\n        Gy = [ y   (rj x y)   -y   -(ri x y)]\n\n     */\n\n    vec2.rotate(worldPivotA, pivotA, bodyA.angle);\n    vec2.rotate(worldPivotB, pivotB, bodyB.angle);\n\n    // todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc\n\n    x.G[0] = -1;\n    x.G[1] =  0;\n    x.G[2] = -vec2.crossLength(worldPivotA,xAxis);\n    x.G[3] =  1;\n    x.G[4] =  0;\n    x.G[5] =  vec2.crossLength(worldPivotB,xAxis);\n\n    y.G[0] =  0;\n    y.G[1] = -1;\n    y.G[2] = -vec2.crossLength(worldPivotA,yAxis);\n    y.G[3] =  0;\n    y.G[4] =  1;\n    y.G[5] =  vec2.crossLength(worldPivotB,yAxis);\n};\n\n/**\n * Enable the rotational motor\n * @method enableMotor\n */\nRevoluteConstraint.prototype.enableMotor = function(){\n    if(this.motorEnabled){\n        return;\n    }\n    this.equations.push(this.motorEquation);\n    this.motorEnabled = true;\n};\n\n/**\n * Disable the rotational motor\n * @method disableMotor\n */\nRevoluteConstraint.prototype.disableMotor = function(){\n    if(!this.motorEnabled){\n        return;\n    }\n    var i = this.equations.indexOf(this.motorEquation);\n    this.equations.splice(i,1);\n    this.motorEnabled = false;\n};\n\n/**\n * Check if the motor is enabled.\n * @method motorIsEnabled\n * @deprecated use property motorEnabled instead.\n * @return {Boolean}\n */\nRevoluteConstraint.prototype.motorIsEnabled = function(){\n    return !!this.motorEnabled;\n};\n\n/**\n * Set the speed of the rotational constraint motor\n * @method setMotorSpeed\n * @param  {Number} speed\n */\nRevoluteConstraint.prototype.setMotorSpeed = function(speed){\n    if(!this.motorEnabled){\n        return;\n    }\n    var i = this.equations.indexOf(this.motorEquation);\n    this.equations[i].relativeVelocity = speed;\n};\n\n/**\n * Get the speed of the rotational constraint motor\n * @method getMotorSpeed\n * @return {Number} The current speed, or false if the motor is not enabled.\n */\nRevoluteConstraint.prototype.getMotorSpeed = function(){\n    if(!this.motorEnabled){\n        return false;\n    }\n    return this.motorEquation.relativeVelocity;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2NvbnN0cmFpbnRzL1Jldm9sdXRlQ29uc3RyYWludC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvY29uc3RyYWludHMvUmV2b2x1dGVDb25zdHJhaW50LmpzPzE4NjciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKVxuLCAgIEVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0VxdWF0aW9uJylcbiwgICBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbicpXG4sICAgUm90YXRpb25hbExvY2tFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uJylcbiwgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmV2b2x1dGVDb25zdHJhaW50O1xuXG52YXIgd29ybGRQaXZvdEEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHdvcmxkUGl2b3RCID0gdmVjMi5jcmVhdGUoKSxcbiAgICB4QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygxLDApLFxuICAgIHlBeGlzID0gdmVjMi5mcm9tVmFsdWVzKDAsMSksXG4gICAgZyA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQ29ubmVjdHMgdHdvIGJvZGllcyBhdCBnaXZlbiBvZmZzZXQgcG9pbnRzLCBsZXR0aW5nIHRoZW0gcm90YXRlIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIgYXJvdW5kIHRoaXMgcG9pbnQuXG4gKiBAY2xhc3MgUmV2b2x1dGVDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gICAgYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gICAgYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSAgW29wdGlvbnNdXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLndvcmxkUGl2b3RdIEEgcGl2b3QgcG9pbnQgZ2l2ZW4gaW4gd29ybGQgY29vcmRpbmF0ZXMuIElmIHNwZWNpZmllZCwgbG9jYWxQaXZvdEEgYW5kIGxvY2FsUGl2b3RCIGFyZSBhdXRvbWF0aWNhbGx5IGNvbXB1dGVkIGZyb20gdGhpcyB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9ICAgW29wdGlvbnMubG9jYWxQaXZvdEFdIFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgd2hpY2ggYm9keUEgaXMgY29uc3RyYWluZWQgdG8uXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmxvY2FsUGl2b3RCXSBTZWUgbG9jYWxQaXZvdEEuXG4gKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLm1heEZvcmNlXSBUaGUgbWF4aW11bSBmb3JjZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGNvbnN0cmFpbiB0aGUgYm9kaWVzLlxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBhIHJldm9sdXRlIGNvbnN0cmFpbnQgYmV0d2VlbiB0d28gYm9kaWVzIHdpdGggcGl2b3QgcG9pbnQgaW4gYmV0d2VlbiB0aGVtLlxuICogICAgIHZhciBib2R5QSA9IG5ldyBCb2R5KHsgbWFzczogMSwgcG9zaXRpb246IFstMSwgMF0gfSk7XG4gKiAgICAgdmFyIGJvZHlCID0gbmV3IEJvZHkoeyBtYXNzOiAxLCBwb3NpdGlvbjogWzEsIDBdIH0pO1xuICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IFJldm9sdXRlQ29uc3RyYWludChib2R5QSwgYm9keUIsIHtcbiAqICAgICAgICAgd29ybGRQaXZvdDogWzAsIDBdXG4gKiAgICAgfSk7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqXG4gKiAgICAgLy8gVXNpbmcgYm9keS1sb2NhbCBwaXZvdCBwb2ludHMsIHRoZSBjb25zdHJhaW50IGNvdWxkIGhhdmUgYmVlbiBjb25zdHJ1Y3RlZCBsaWtlIHRoaXM6XG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgUmV2b2x1dGVDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwge1xuICogICAgICAgICBsb2NhbFBpdm90QTogWzEsIDBdLFxuICogICAgICAgICBsb2NhbFBpdm90QjogWy0xLCAwXVxuICogICAgIH0pO1xuICovXG5mdW5jdGlvbiBSZXZvbHV0ZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBDb25zdHJhaW50LmNhbGwodGhpcyxib2R5QSxib2R5QixDb25zdHJhaW50LlJFVk9MVVRFLG9wdGlvbnMpO1xuXG4gICAgdmFyIG1heEZvcmNlID0gdGhpcy5tYXhGb3JjZSA9IHR5cGVvZihvcHRpb25zLm1heEZvcmNlKSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMubWF4Rm9yY2UgOiBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gcGl2b3RBXG4gICAgICovXG4gICAgdGhpcy5waXZvdEEgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gcGl2b3RCXG4gICAgICovXG4gICAgdGhpcy5waXZvdEIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgaWYob3B0aW9ucy53b3JsZFBpdm90KXtcbiAgICAgICAgLy8gQ29tcHV0ZSBwaXZvdEEgYW5kIHBpdm90QlxuICAgICAgICB2ZWMyLnN1Yih0aGlzLnBpdm90QSwgb3B0aW9ucy53b3JsZFBpdm90LCBib2R5QS5wb3NpdGlvbik7XG4gICAgICAgIHZlYzIuc3ViKHRoaXMucGl2b3RCLCBvcHRpb25zLndvcmxkUGl2b3QsIGJvZHlCLnBvc2l0aW9uKTtcbiAgICAgICAgLy8gUm90YXRlIHRvIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICAgIHZlYzIucm90YXRlKHRoaXMucGl2b3RBLCB0aGlzLnBpdm90QSwgLWJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUodGhpcy5waXZvdEIsIHRoaXMucGl2b3RCLCAtYm9keUIuYW5nbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCBwaXZvdEEgYW5kIHBpdm90QlxuICAgICAgICB2ZWMyLmNvcHkodGhpcy5waXZvdEEsIG9wdGlvbnMubG9jYWxQaXZvdEEpO1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5waXZvdEIsIG9wdGlvbnMubG9jYWxQaXZvdEIpO1xuICAgIH1cblxuICAgIC8vIEVxdWF0aW9ucyB0byBiZSBmZWQgdG8gdGhlIHNvbHZlclxuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucyA9IFtcbiAgICAgICAgbmV3IEVxdWF0aW9uKGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSksXG4gICAgICAgIG5ldyBFcXVhdGlvbihib2R5QSxib2R5QiwtbWF4Rm9yY2UsbWF4Rm9yY2UpLFxuICAgIF07XG5cbiAgICB2YXIgeCA9IGVxc1swXTtcbiAgICB2YXIgeSA9IGVxc1sxXTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICB4LmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RBLCB0aGF0LnBpdm90QSwgYm9keUEuYW5nbGUpO1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QiwgdGhhdC5waXZvdEIsIGJvZHlCLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5hZGQoZywgYm9keUIucG9zaXRpb24sIHdvcmxkUGl2b3RCKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgYm9keUEucG9zaXRpb24pO1xuICAgICAgICB2ZWMyLnN1YihnLCBnLCB3b3JsZFBpdm90QSk7XG4gICAgICAgIHJldHVybiB2ZWMyLmRvdChnLHhBeGlzKTtcbiAgICB9O1xuXG4gICAgeS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZFBpdm90QSwgdGhhdC5waXZvdEEsIGJvZHlBLmFuZ2xlKTtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEIsIHRoYXQucGl2b3RCLCBib2R5Qi5hbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKGcsIGJvZHlCLnBvc2l0aW9uLCB3b3JsZFBpdm90Qik7XG4gICAgICAgIHZlYzIuc3ViKGcsIGcsIGJvZHlBLnBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5zdWIoZywgZywgd29ybGRQaXZvdEEpO1xuICAgICAgICByZXR1cm4gdmVjMi5kb3QoZyx5QXhpcyk7XG4gICAgfTtcblxuICAgIHkubWluRm9yY2UgPSB4Lm1pbkZvcmNlID0gLW1heEZvcmNlO1xuICAgIHkubWF4Rm9yY2UgPSB4Lm1heEZvcmNlID0gIG1heEZvcmNlO1xuXG4gICAgdGhpcy5tb3RvckVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtb3RvciBpcyBlbmFibGVkLiBVc2UgLmVuYWJsZU1vdG9yKCkgdG8gZW5hYmxlIHRoZSBjb25zdHJhaW50IG1vdG9yLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbW90b3JFbmFibGVkXG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5tb3RvckVuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJhaW50IHBvc2l0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSBhbmdsZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5hbmdsZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgbG93ZXIgbGltaXRcbiAgICAgKiBAcHJvcGVydHkgbG93ZXJMaW1pdEVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgdXBwZXIgbGltaXRcbiAgICAgKiBAcHJvcGVydHkgdXBwZXJMaW1pdEVuYWJsZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyTGltaXRFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG93ZXIgbGltaXQgb24gdGhlIGNvbnN0cmFpbnQgYW5nbGUuXG4gICAgICogQHByb3BlcnR5IGxvd2VyTGltaXRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyTGltaXQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHVwcGVyIGxpbWl0IG9uIHRoZSBjb25zdHJhaW50IGFuZ2xlLlxuICAgICAqIEBwcm9wZXJ0eSB1cHBlckxpbWl0XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51cHBlckxpbWl0ID0gMDtcblxuICAgIHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxMb2NrRXF1YXRpb24oYm9keUEsYm9keUIpO1xuICAgIHRoaXMubG93ZXJMaW1pdEVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxMb2NrRXF1YXRpb24oYm9keUEsYm9keUIpO1xuICAgIHRoaXMudXBwZXJMaW1pdEVxdWF0aW9uLm1pbkZvcmNlID0gMDtcbiAgICB0aGlzLmxvd2VyTGltaXRFcXVhdGlvbi5tYXhGb3JjZSA9IDA7XG59XG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXZvbHV0ZUNvbnN0cmFpbnQ7XG5cbi8qKlxuICogU2V0IHRoZSBjb25zdHJhaW50IGFuZ2xlIGxpbWl0cy5cbiAqIEBtZXRob2Qgc2V0TGltaXRzXG4gKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgTG93ZXIgYW5nbGUgbGltaXQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVXBwZXIgYW5nbGUgbGltaXQuXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TGltaXRzID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlcikge1xuICAgIGlmKHR5cGVvZihsb3dlcikgPT09ICdudW1iZXInKXtcbiAgICAgICAgdGhpcy5sb3dlckxpbWl0ID0gbG93ZXI7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdEVuYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG93ZXJMaW1pdCA9IGxvd2VyO1xuICAgICAgICB0aGlzLmxvd2VyTGltaXRFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mKHVwcGVyKSA9PT0gJ251bWJlcicpe1xuICAgICAgICB0aGlzLnVwcGVyTGltaXQgPSB1cHBlcjtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0RW5hYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cHBlckxpbWl0ID0gdXBwZXI7XG4gICAgICAgIHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5SZXZvbHV0ZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gIHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gIHRoaXMuYm9keUIsXG4gICAgICAgIHBpdm90QSA9IHRoaXMucGl2b3RBLFxuICAgICAgICBwaXZvdEIgPSB0aGlzLnBpdm90QixcbiAgICAgICAgZXFzID0gICAgdGhpcy5lcXVhdGlvbnMsXG4gICAgICAgIG5vcm1hbCA9IGVxc1swXSxcbiAgICAgICAgdGFuZ2VudD0gZXFzWzFdLFxuICAgICAgICB4ID0gZXFzWzBdLFxuICAgICAgICB5ID0gZXFzWzFdLFxuICAgICAgICB1cHBlckxpbWl0ID0gdGhpcy51cHBlckxpbWl0LFxuICAgICAgICBsb3dlckxpbWl0ID0gdGhpcy5sb3dlckxpbWl0LFxuICAgICAgICB1cHBlckxpbWl0RXF1YXRpb24gPSB0aGlzLnVwcGVyTGltaXRFcXVhdGlvbixcbiAgICAgICAgbG93ZXJMaW1pdEVxdWF0aW9uID0gdGhpcy5sb3dlckxpbWl0RXF1YXRpb247XG5cbiAgICB2YXIgcmVsQW5nbGUgPSB0aGlzLmFuZ2xlID0gYm9keUIuYW5nbGUgLSBib2R5QS5hbmdsZTtcblxuICAgIGlmKHRoaXMudXBwZXJMaW1pdEVuYWJsZWQgJiYgcmVsQW5nbGUgPiB1cHBlckxpbWl0KXtcbiAgICAgICAgdXBwZXJMaW1pdEVxdWF0aW9uLmFuZ2xlID0gdXBwZXJMaW1pdDtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YodXBwZXJMaW1pdEVxdWF0aW9uKSA9PT0gLTEpe1xuICAgICAgICAgICAgZXFzLnB1c2godXBwZXJMaW1pdEVxdWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpZHggPSBlcXMuaW5kZXhPZih1cHBlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5sb3dlckxpbWl0RW5hYmxlZCAmJiByZWxBbmdsZSA8IGxvd2VyTGltaXQpe1xuICAgICAgICBsb3dlckxpbWl0RXF1YXRpb24uYW5nbGUgPSBsb3dlckxpbWl0O1xuICAgICAgICBpZihlcXMuaW5kZXhPZihsb3dlckxpbWl0RXF1YXRpb24pID09PSAtMSl7XG4gICAgICAgICAgICBlcXMucHVzaChsb3dlckxpbWl0RXF1YXRpb24pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlkeCA9IGVxcy5pbmRleE9mKGxvd2VyTGltaXRFcXVhdGlvbik7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgZXFzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuXG4gICAgVGhlIGNvbnN0cmFpbnQgdmlvbGF0aW9uIGlzXG5cbiAgICAgICAgZyA9IHhqICsgcmogLSB4aSAtIHJpXG5cbiAgICAuLi53aGVyZSB4aSBhbmQgeGogYXJlIHRoZSBib2R5IHBvc2l0aW9ucyBhbmQgcmkgYW5kIHJqIHdvcmxkLW9yaWVudGVkIG9mZnNldCB2ZWN0b3JzLiBEaWZmZXJlbnRpYXRlOlxuXG4gICAgICAgIGdkb3QgPSB2aiArIHdqIHggcmogLSB2aSAtIHdpIHggcmlcblxuICAgIFdlIHNwbGl0IHRoaXMgaW50byB4IGFuZCB5IGRpcmVjdGlvbnMuIChsZXQgeCBhbmQgeSBiZSB1bml0IHZlY3RvcnMgYWxvbmcgdGhlIHJlc3BlY3RpdmUgYXhlcylcblxuICAgICAgICBnZG90ICogeCA9ICggdmogKyB3aiB4IHJqIC0gdmkgLSB3aSB4IHJpICkgKiB4XG4gICAgICAgICAgICAgICAgID0gKCB2aip4ICsgKHdqIHggcmopKnggLXZpKnggLSh3aSB4IHJpKSp4XG4gICAgICAgICAgICAgICAgID0gKCB2aip4ICsgKHJqIHggeCkqd2ogLXZpKnggLShyaSB4IHgpKndpXG4gICAgICAgICAgICAgICAgID0gWyAteCAgIC0ocmkgeCB4KSAgIHggICAocmogeCB4KV0gKiBbdmkgd2kgdmogd2pdXG4gICAgICAgICAgICAgICAgID0gRypXXG5cbiAgICAuLi5hbmQgc2ltaWxhciBmb3IgeS4gV2UgaGF2ZSB0aGVuIGlkZW50aWZpZWQgdGhlIGphY29iaWFuIGVudHJpZXMgZm9yIHggYW5kIHkgZGlyZWN0aW9uczpcblxuICAgICAgICBHeCA9IFsgeCAgIChyaiB4IHgpICAgLXggICAtKHJpIHggeCldXG4gICAgICAgIEd5ID0gWyB5ICAgKHJqIHggeSkgICAteSAgIC0ocmkgeCB5KV1cblxuICAgICAqL1xuXG4gICAgdmVjMi5yb3RhdGUod29ybGRQaXZvdEEsIHBpdm90QSwgYm9keUEuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHdvcmxkUGl2b3RCLCBwaXZvdEIsIGJvZHlCLmFuZ2xlKTtcblxuICAgIC8vIHRvZG86IHRoZXNlIGFyZSBhIGJpdCBzcGFyc2UuIFdlIGNvdWxkIHNhdmUgc29tZSBjb21wdXRhdGlvbnMgb24gbWFraW5nIGN1c3RvbSBlcS5jb21wdXRlR1cgZnVuY3Rpb25zLCBldGNcblxuICAgIHguR1swXSA9IC0xO1xuICAgIHguR1sxXSA9ICAwO1xuICAgIHguR1syXSA9IC12ZWMyLmNyb3NzTGVuZ3RoKHdvcmxkUGl2b3RBLHhBeGlzKTtcbiAgICB4LkdbM10gPSAgMTtcbiAgICB4LkdbNF0gPSAgMDtcbiAgICB4LkdbNV0gPSAgdmVjMi5jcm9zc0xlbmd0aCh3b3JsZFBpdm90Qix4QXhpcyk7XG5cbiAgICB5LkdbMF0gPSAgMDtcbiAgICB5LkdbMV0gPSAtMTtcbiAgICB5LkdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aCh3b3JsZFBpdm90QSx5QXhpcyk7XG4gICAgeS5HWzNdID0gIDA7XG4gICAgeS5HWzRdID0gIDE7XG4gICAgeS5HWzVdID0gIHZlYzIuY3Jvc3NMZW5ndGgod29ybGRQaXZvdEIseUF4aXMpO1xufTtcblxuLyoqXG4gKiBFbmFibGUgdGhlIHJvdGF0aW9uYWwgbW90b3JcbiAqIEBtZXRob2QgZW5hYmxlTW90b3JcbiAqL1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5lbmFibGVNb3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2godGhpcy5tb3RvckVxdWF0aW9uKTtcbiAgICB0aGlzLm1vdG9yRW5hYmxlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIERpc2FibGUgdGhlIHJvdGF0aW9uYWwgbW90b3JcbiAqIEBtZXRob2QgZGlzYWJsZU1vdG9yXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICBpZighdGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5lcXVhdGlvbnMuaW5kZXhPZih0aGlzLm1vdG9yRXF1YXRpb24pO1xuICAgIHRoaXMuZXF1YXRpb25zLnNwbGljZShpLDEpO1xuICAgIHRoaXMubW90b3JFbmFibGVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBtb3RvciBpcyBlbmFibGVkLlxuICogQG1ldGhvZCBtb3RvcklzRW5hYmxlZFxuICogQGRlcHJlY2F0ZWQgdXNlIHByb3BlcnR5IG1vdG9yRW5hYmxlZCBpbnN0ZWFkLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5tb3RvcklzRW5hYmxlZCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICEhdGhpcy5tb3RvckVuYWJsZWQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3BlZWQgb2YgdGhlIHJvdGF0aW9uYWwgY29uc3RyYWludCBtb3RvclxuICogQG1ldGhvZCBzZXRNb3RvclNwZWVkXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHNwZWVkXG4gKi9cblJldm9sdXRlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uKHNwZWVkKXtcbiAgICBpZighdGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5lcXVhdGlvbnMuaW5kZXhPZih0aGlzLm1vdG9yRXF1YXRpb24pO1xuICAgIHRoaXMuZXF1YXRpb25zW2ldLnJlbGF0aXZlVmVsb2NpdHkgPSBzcGVlZDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzcGVlZCBvZiB0aGUgcm90YXRpb25hbCBjb25zdHJhaW50IG1vdG9yXG4gKiBAbWV0aG9kIGdldE1vdG9yU3BlZWRcbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgc3BlZWQsIG9yIGZhbHNlIGlmIHRoZSBtb3RvciBpcyBub3QgZW5hYmxlZC5cbiAqL1xuUmV2b2x1dGVDb25zdHJhaW50LnByb3RvdHlwZS5nZXRNb3RvclNwZWVkID0gZnVuY3Rpb24oKXtcbiAgICBpZighdGhpcy5tb3RvckVuYWJsZWQpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1vdG9yRXF1YXRpb24ucmVsYXRpdmVWZWxvY2l0eTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/constraints/RevoluteConstraint.js\n");

/***/ }),

/***/ "./node_modules/p2/src/equations/AngleLockEquation.js":
/*!************************************************************!*\
  !*** ./node_modules/p2/src/equations/AngleLockEquation.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Equation = __webpack_require__(/*! ./Equation */ \"./node_modules/p2/src/equations/Equation.js\"),\n    vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\n\nmodule.exports = AngleLockEquation;\n\n/**\n * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.\n *\n * @class AngleLockEquation\n * @constructor\n * @extends Equation\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {Number} [options.angle] Angle to add to the local vector in body A.\n * @param {Number} [options.ratio] Gear ratio\n */\nfunction AngleLockEquation(bodyA, bodyB, options){\n    options = options || {};\n    Equation.call(this,bodyA,bodyB,-Number.MAX_VALUE,Number.MAX_VALUE);\n    this.angle = options.angle || 0;\n\n    /**\n     * The gear ratio.\n     * @property {Number} ratio\n     * @private\n     * @see setRatio\n     */\n    this.ratio = typeof(options.ratio)===\"number\" ? options.ratio : 1;\n\n    this.setRatio(this.ratio);\n}\nAngleLockEquation.prototype = new Equation();\nAngleLockEquation.prototype.constructor = AngleLockEquation;\n\nAngleLockEquation.prototype.computeGq = function(){\n    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;\n};\n\n/**\n * Set the gear ratio for this equation\n * @method setRatio\n * @param {Number} ratio\n */\nAngleLockEquation.prototype.setRatio = function(ratio){\n    var G = this.G;\n    G[2] =  ratio;\n    G[5] = -1;\n    this.ratio = ratio;\n};\n\n/**\n * Set the max force for the equation.\n * @method setMaxTorque\n * @param {Number} torque\n */\nAngleLockEquation.prototype.setMaxTorque = function(torque){\n    this.maxForce =  torque;\n    this.minForce = -torque;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2VxdWF0aW9ucy9BbmdsZUxvY2tFcXVhdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvZXF1YXRpb25zL0FuZ2xlTG9ja0VxdWF0aW9uLmpzPzIxNmYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEVxdWF0aW9uID0gcmVxdWlyZShcIi4vRXF1YXRpb25cIiksXG4gICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuZ2xlTG9ja0VxdWF0aW9uO1xuXG4vKipcbiAqIExvY2tzIHRoZSByZWxhdGl2ZSBhbmdsZSBiZXR3ZWVuIHR3byBib2RpZXMuIFRoZSBjb25zdHJhaW50IHRyaWVzIHRvIGtlZXAgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdHdvIHZlY3RvcnMsIGxvY2FsIGluIGVhY2ggYm9keSwgdG8gemVyby4gVGhlIGxvY2FsIGFuZ2xlIGluIGJvZHkgaSBpcyBhIHBhcmFtZXRlci5cbiAqXG4gKiBAY2xhc3MgQW5nbGVMb2NrRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZV0gQW5nbGUgdG8gYWRkIHRvIHRoZSBsb2NhbCB2ZWN0b3IgaW4gYm9keSBBLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhdGlvXSBHZWFyIHJhdGlvXG4gKi9cbmZ1bmN0aW9uIEFuZ2xlTG9ja0VxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLGJvZHlBLGJvZHlCLC1OdW1iZXIuTUFYX1ZBTFVFLE51bWJlci5NQVhfVkFMVUUpO1xuICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmFuZ2xlIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZ2VhciByYXRpby5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmF0aW9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUgc2V0UmF0aW9cbiAgICAgKi9cbiAgICB0aGlzLnJhdGlvID0gdHlwZW9mKG9wdGlvbnMucmF0aW8pPT09XCJudW1iZXJcIiA/IG9wdGlvbnMucmF0aW8gOiAxO1xuXG4gICAgdGhpcy5zZXRSYXRpbyh0aGlzLnJhdGlvKTtcbn1cbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQW5nbGVMb2NrRXF1YXRpb247XG5cbkFuZ2xlTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnJhdGlvICogdGhpcy5ib2R5QS5hbmdsZSAtIHRoaXMuYm9keUIuYW5nbGUgKyB0aGlzLmFuZ2xlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGdlYXIgcmF0aW8gZm9yIHRoaXMgZXF1YXRpb25cbiAqIEBtZXRob2Qgc2V0UmF0aW9cbiAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xuICovXG5BbmdsZUxvY2tFcXVhdGlvbi5wcm90b3R5cGUuc2V0UmF0aW8gPSBmdW5jdGlvbihyYXRpbyl7XG4gICAgdmFyIEcgPSB0aGlzLkc7XG4gICAgR1syXSA9ICByYXRpbztcbiAgICBHWzVdID0gLTE7XG4gICAgdGhpcy5yYXRpbyA9IHJhdGlvO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCBmb3JjZSBmb3IgdGhlIGVxdWF0aW9uLlxuICogQG1ldGhvZCBzZXRNYXhUb3JxdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3JxdWVcbiAqL1xuQW5nbGVMb2NrRXF1YXRpb24ucHJvdG90eXBlLnNldE1heFRvcnF1ZSA9IGZ1bmN0aW9uKHRvcnF1ZSl7XG4gICAgdGhpcy5tYXhGb3JjZSA9ICB0b3JxdWU7XG4gICAgdGhpcy5taW5Gb3JjZSA9IC10b3JxdWU7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/equations/AngleLockEquation.js\n");

/***/ }),

/***/ "./node_modules/p2/src/equations/ContactEquation.js":
/*!**********************************************************!*\
  !*** ./node_modules/p2/src/equations/ContactEquation.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Equation = __webpack_require__(/*! ./Equation */ \"./node_modules/p2/src/equations/Equation.js\"),\n    vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\n\nmodule.exports = ContactEquation;\n\n/**\n * Non-penetration constraint equation. Tries to make the contactPointA and contactPointB vectors coincide, while keeping the applied force repulsive.\n *\n * @class ContactEquation\n * @constructor\n * @extends Equation\n * @param {Body} bodyA\n * @param {Body} bodyB\n */\nfunction ContactEquation(bodyA, bodyB){\n    Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);\n\n    /**\n     * Vector from body i center of mass to the contact point.\n     * @property contactPointA\n     * @type {Array}\n     */\n    this.contactPointA = vec2.create();\n    this.penetrationVec = vec2.create();\n\n    /**\n     * World-oriented vector from body A center of mass to the contact point.\n     * @property contactPointB\n     * @type {Array}\n     */\n    this.contactPointB = vec2.create();\n\n    /**\n     * The normal vector, pointing out of body i\n     * @property normalA\n     * @type {Array}\n     */\n    this.normalA = vec2.create();\n\n    /**\n     * The restitution to use (0=no bounciness, 1=max bounciness).\n     * @property restitution\n     * @type {Number}\n     */\n    this.restitution = 0;\n\n    /**\n     * This property is set to true if this is the first impact between the bodies (not persistant contact).\n     * @property firstImpact\n     * @type {Boolean}\n     * @readOnly\n     */\n    this.firstImpact = false;\n\n    /**\n     * The shape in body i that triggered this contact.\n     * @property shapeA\n     * @type {Shape}\n     */\n    this.shapeA = null;\n\n    /**\n     * The shape in body j that triggered this contact.\n     * @property shapeB\n     * @type {Shape}\n     */\n    this.shapeB = null;\n}\nContactEquation.prototype = new Equation();\nContactEquation.prototype.constructor = ContactEquation;\nContactEquation.prototype.computeB = function(a,b,h){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        ri = this.contactPointA,\n        rj = this.contactPointB,\n        xi = bi.position,\n        xj = bj.position;\n\n    var penetrationVec = this.penetrationVec,\n        n = this.normalA,\n        G = this.G;\n\n    // Caluclate cross products\n    var rixn = vec2.crossLength(ri,n),\n        rjxn = vec2.crossLength(rj,n);\n\n    // G = [-n -rixn n rjxn]\n    G[0] = -n[0];\n    G[1] = -n[1];\n    G[2] = -rixn;\n    G[3] = n[0];\n    G[4] = n[1];\n    G[5] = rjxn;\n\n    // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector\n    vec2.add(penetrationVec,xj,rj);\n    vec2.sub(penetrationVec,penetrationVec,xi);\n    vec2.sub(penetrationVec,penetrationVec,ri);\n\n    // Compute iteration\n    var GW, Gq;\n    if(this.firstImpact && this.restitution !== 0){\n        Gq = 0;\n        GW = (1/b)*(1+this.restitution) * this.computeGW();\n    } else {\n        Gq = vec2.dot(n,penetrationVec) + this.offset;\n        GW = this.computeGW();\n    }\n\n    var GiMf = this.computeGiMf();\n    var B = - Gq * a - GW * b - h*GiMf;\n\n    return B;\n};\n\nvar vi = vec2.create();\nvar vj = vec2.create();\nvar relVel = vec2.create();\n\n/**\n * Get the relative velocity along the normal vector.\n * @return {number}\n */\nContactEquation.prototype.getVelocityAlongNormal = function(){\n\n    this.bodyA.getVelocityAtPoint(vi, this.contactPointA);\n    this.bodyB.getVelocityAtPoint(vj, this.contactPointB);\n\n    vec2.subtract(relVel, vi, vj);\n\n    return vec2.dot(this.normalA, relVel);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24uanM/YmIyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRXF1YXRpb24gPSByZXF1aXJlKFwiLi9FcXVhdGlvblwiKSxcbiAgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFjdEVxdWF0aW9uO1xuXG4vKipcbiAqIE5vbi1wZW5ldHJhdGlvbiBjb25zdHJhaW50IGVxdWF0aW9uLiBUcmllcyB0byBtYWtlIHRoZSBjb250YWN0UG9pbnRBIGFuZCBjb250YWN0UG9pbnRCIHZlY3RvcnMgY29pbmNpZGUsIHdoaWxlIGtlZXBpbmcgdGhlIGFwcGxpZWQgZm9yY2UgcmVwdWxzaXZlLlxuICpcbiAqIEBjbGFzcyBDb250YWN0RXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqL1xuZnVuY3Rpb24gQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIDAsIE51bWJlci5NQVhfVkFMVUUpO1xuXG4gICAgLyoqXG4gICAgICogVmVjdG9yIGZyb20gYm9keSBpIGNlbnRlciBvZiBtYXNzIHRvIHRoZSBjb250YWN0IHBvaW50LlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFBvaW50QSA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdGhpcy5wZW5ldHJhdGlvblZlYyA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgZnJvbSBib2R5IEEgY2VudGVyIG9mIG1hc3MgdG8gdGhlIGNvbnRhY3QgcG9pbnQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RQb2ludEJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0UG9pbnRCID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBub3JtYWwgdmVjdG9yLCBwb2ludGluZyBvdXQgb2YgYm9keSBpXG4gICAgICogQHByb3BlcnR5IG5vcm1hbEFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ub3JtYWxBID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN0aXR1dGlvbiB0byB1c2UgKDA9bm8gYm91bmNpbmVzcywgMT1tYXggYm91bmNpbmVzcykuXG4gICAgICogQHByb3BlcnR5IHJlc3RpdHV0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIHRydWUgaWYgdGhpcyBpcyB0aGUgZmlyc3QgaW1wYWN0IGJldHdlZW4gdGhlIGJvZGllcyAobm90IHBlcnNpc3RhbnQgY29udGFjdCkuXG4gICAgICogQHByb3BlcnR5IGZpcnN0SW1wYWN0XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHJlYWRPbmx5XG4gICAgICovXG4gICAgdGhpcy5maXJzdEltcGFjdCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYXBlIGluIGJvZHkgaSB0aGF0IHRyaWdnZXJlZCB0aGlzIGNvbnRhY3QuXG4gICAgICogQHByb3BlcnR5IHNoYXBlQVxuICAgICAqIEB0eXBlIHtTaGFwZX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGUgaW4gYm9keSBqIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY29udGFjdC5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVCXG4gICAgICogQHR5cGUge1NoYXBlfVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVCID0gbnVsbDtcbn1cbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb250YWN0RXF1YXRpb247XG5Db250YWN0RXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oYSxiLGgpe1xuICAgIHZhciBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgcmkgPSB0aGlzLmNvbnRhY3RQb2ludEEsXG4gICAgICAgIHJqID0gdGhpcy5jb250YWN0UG9pbnRCLFxuICAgICAgICB4aSA9IGJpLnBvc2l0aW9uLFxuICAgICAgICB4aiA9IGJqLnBvc2l0aW9uO1xuXG4gICAgdmFyIHBlbmV0cmF0aW9uVmVjID0gdGhpcy5wZW5ldHJhdGlvblZlYyxcbiAgICAgICAgbiA9IHRoaXMubm9ybWFsQSxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIHZhciByaXhuID0gdmVjMi5jcm9zc0xlbmd0aChyaSxuKSxcbiAgICAgICAgcmp4biA9IHZlYzIuY3Jvc3NMZW5ndGgocmosbik7XG5cbiAgICAvLyBHID0gWy1uIC1yaXhuIG4gcmp4bl1cbiAgICBHWzBdID0gLW5bMF07XG4gICAgR1sxXSA9IC1uWzFdO1xuICAgIEdbMl0gPSAtcml4bjtcbiAgICBHWzNdID0gblswXTtcbiAgICBHWzRdID0gblsxXTtcbiAgICBHWzVdID0gcmp4bjtcblxuICAgIC8vIENhbGN1bGF0ZSBxID0geGorcmogLSh4aStyaSkgaS5lLiB0aGUgcGVuZXRyYXRpb24gdmVjdG9yXG4gICAgdmVjMi5hZGQocGVuZXRyYXRpb25WZWMseGoscmopO1xuICAgIHZlYzIuc3ViKHBlbmV0cmF0aW9uVmVjLHBlbmV0cmF0aW9uVmVjLHhpKTtcbiAgICB2ZWMyLnN1YihwZW5ldHJhdGlvblZlYyxwZW5ldHJhdGlvblZlYyxyaSk7XG5cbiAgICAvLyBDb21wdXRlIGl0ZXJhdGlvblxuICAgIHZhciBHVywgR3E7XG4gICAgaWYodGhpcy5maXJzdEltcGFjdCAmJiB0aGlzLnJlc3RpdHV0aW9uICE9PSAwKXtcbiAgICAgICAgR3EgPSAwO1xuICAgICAgICBHVyA9ICgxL2IpKigxK3RoaXMucmVzdGl0dXRpb24pICogdGhpcy5jb21wdXRlR1coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBHcSA9IHZlYzIuZG90KG4scGVuZXRyYXRpb25WZWMpICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgIEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICB9XG5cbiAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcbiAgICB2YXIgQiA9IC0gR3EgKiBhIC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuXG52YXIgdmkgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHZqID0gdmVjMi5jcmVhdGUoKTtcbnZhciByZWxWZWwgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEdldCB0aGUgcmVsYXRpdmUgdmVsb2NpdHkgYWxvbmcgdGhlIG5vcm1hbCB2ZWN0b3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuZ2V0VmVsb2NpdHlBbG9uZ05vcm1hbCA9IGZ1bmN0aW9uKCl7XG5cbiAgICB0aGlzLmJvZHlBLmdldFZlbG9jaXR5QXRQb2ludCh2aSwgdGhpcy5jb250YWN0UG9pbnRBKTtcbiAgICB0aGlzLmJvZHlCLmdldFZlbG9jaXR5QXRQb2ludCh2aiwgdGhpcy5jb250YWN0UG9pbnRCKTtcblxuICAgIHZlYzIuc3VidHJhY3QocmVsVmVsLCB2aSwgdmopO1xuXG4gICAgcmV0dXJuIHZlYzIuZG90KHRoaXMubm9ybWFsQSwgcmVsVmVsKTtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/equations/ContactEquation.js\n");

/***/ }),

/***/ "./node_modules/p2/src/equations/Equation.js":
/*!***************************************************!*\
  !*** ./node_modules/p2/src/equations/Equation.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = Equation;\n\nvar vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\"),\n    Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\"),\n    Body = __webpack_require__(/*! ../objects/Body */ \"./node_modules/p2/src/objects/Body.js\");\n\n/**\n * Base class for constraint equations.\n * @class Equation\n * @constructor\n * @param {Body} bodyA First body participating in the equation\n * @param {Body} bodyB Second body participating in the equation\n * @param {number} minForce Minimum force to apply. Default: -Number.MAX_VALUE\n * @param {number} maxForce Maximum force to apply. Default: Number.MAX_VALUE\n */\nfunction Equation(bodyA, bodyB, minForce, maxForce){\n\n    /**\n     * Minimum force to apply when solving.\n     * @property minForce\n     * @type {Number}\n     */\n    this.minForce = typeof(minForce)===\"undefined\" ? -Number.MAX_VALUE : minForce;\n\n    /**\n     * Max force to apply when solving.\n     * @property maxForce\n     * @type {Number}\n     */\n    this.maxForce = typeof(maxForce)===\"undefined\" ? Number.MAX_VALUE : maxForce;\n\n    /**\n     * First body participating in the constraint\n     * @property bodyA\n     * @type {Body}\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * Second body participating in the constraint\n     * @property bodyB\n     * @type {Body}\n     */\n    this.bodyB = bodyB;\n\n    /**\n     * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.\n     * @property stiffness\n     * @type {Number}\n     */\n    this.stiffness = Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.\n     * @property relaxation\n     * @type {Number}\n     */\n    this.relaxation = Equation.DEFAULT_RELAXATION;\n\n    /**\n     * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).\n     * @property G\n     * @type {Array}\n     */\n    this.G = new Utils.ARRAY_TYPE(6);\n    for(var i=0; i<6; i++){\n        this.G[i]=0;\n    }\n\n    this.offset = 0;\n\n    this.a = 0;\n    this.b = 0;\n    this.epsilon = 0;\n    this.timeStep = 1/60;\n\n    /**\n     * Indicates if stiffness or relaxation was changed.\n     * @property {Boolean} needsUpdate\n     */\n    this.needsUpdate = true;\n\n    /**\n     * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.\n     * @property multiplier\n     * @type {Number}\n     */\n    this.multiplier = 0;\n\n    /**\n     * Relative velocity.\n     * @property {Number} relativeVelocity\n     */\n    this.relativeVelocity = 0;\n\n    /**\n     * Whether this equation is enabled or not. If true, it will be added to the solver.\n     * @property {Boolean} enabled\n     */\n    this.enabled = true;\n}\nEquation.prototype.constructor = Equation;\n\n/**\n * The default stiffness when creating a new Equation.\n * @static\n * @property {Number} DEFAULT_STIFFNESS\n * @default 1e6\n */\nEquation.DEFAULT_STIFFNESS = 1e6;\n\n/**\n * The default relaxation when creating a new Equation.\n * @static\n * @property {Number} DEFAULT_RELAXATION\n * @default 4\n */\nEquation.DEFAULT_RELAXATION = 4;\n\n/**\n * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href=\"http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf\">SPOOK notes</a>.\n * @method update\n */\nEquation.prototype.update = function(){\n    var k = this.stiffness,\n        d = this.relaxation,\n        h = this.timeStep;\n\n    this.a = 4.0 / (h * (1 + 4 * d));\n    this.b = (4.0 * d) / (1 + 4 * d);\n    this.epsilon = 4.0 / (h * h * k * (1 + 4 * d));\n\n    this.needsUpdate = false;\n};\n\n/**\n * Multiply a jacobian entry with corresponding positions or velocities\n * @method gmult\n * @return {Number}\n */\nEquation.prototype.gmult = function(G,vi,wi,vj,wj){\n    return  G[0] * vi[0] +\n            G[1] * vi[1] +\n            G[2] * wi +\n            G[3] * vj[0] +\n            G[4] * vj[1] +\n            G[5] * wj;\n};\n\n/**\n * Computes the RHS of the SPOOK equation\n * @method computeB\n * @return {Number}\n */\nEquation.prototype.computeB = function(a,b,h){\n    var GW = this.computeGW();\n    var Gq = this.computeGq();\n    var GiMf = this.computeGiMf();\n    return - Gq * a - GW * b - GiMf*h;\n};\n\n/**\n * Computes G\\*q, where q are the generalized body coordinates\n * @method computeGq\n * @return {Number}\n */\nvar qi = vec2.create(),\n    qj = vec2.create();\nEquation.prototype.computeGq = function(){\n    var G = this.G,\n        bi = this.bodyA,\n        bj = this.bodyB,\n        xi = bi.position,\n        xj = bj.position,\n        ai = bi.angle,\n        aj = bj.angle;\n\n    return this.gmult(G, qi, ai, qj, aj) + this.offset;\n};\n\n/**\n * Computes G\\*W, where W are the body velocities\n * @method computeGW\n * @return {Number}\n */\nEquation.prototype.computeGW = function(){\n    var G = this.G,\n        bi = this.bodyA,\n        bj = this.bodyB,\n        vi = bi.velocity,\n        vj = bj.velocity,\n        wi = bi.angularVelocity,\n        wj = bj.angularVelocity;\n    return this.gmult(G,vi,wi,vj,wj) + this.relativeVelocity;\n};\n\n/**\n * Computes G\\*Wlambda, where W are the body velocities\n * @method computeGWlambda\n * @return {Number}\n */\nEquation.prototype.computeGWlambda = function(){\n    var G = this.G,\n        bi = this.bodyA,\n        bj = this.bodyB,\n        vi = bi.vlambda,\n        vj = bj.vlambda,\n        wi = bi.wlambda,\n        wj = bj.wlambda;\n    return this.gmult(G,vi,wi,vj,wj);\n};\n\n/**\n * Computes G\\*inv(M)\\*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.\n * @method computeGiMf\n * @return {Number}\n */\nvar iMfi = vec2.create(),\n    iMfj = vec2.create();\nEquation.prototype.computeGiMf = function(){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        fi = bi.force,\n        ti = bi.angularForce,\n        fj = bj.force,\n        tj = bj.angularForce,\n        invMassi = bi.invMassSolve,\n        invMassj = bj.invMassSolve,\n        invIi = bi.invInertiaSolve,\n        invIj = bj.invInertiaSolve,\n        G = this.G;\n\n    vec2.scale(iMfi, fi, invMassi);\n    vec2.multiply(iMfi, bi.massMultiplier, iMfi);\n    vec2.scale(iMfj, fj,invMassj);\n    vec2.multiply(iMfj, bj.massMultiplier, iMfj);\n\n    return this.gmult(G,iMfi,ti*invIi,iMfj,tj*invIj);\n};\n\n/**\n * Computes G\\*inv(M)\\*G'\n * @method computeGiMGt\n * @return {Number}\n */\nEquation.prototype.computeGiMGt = function(){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        invMassi = bi.invMassSolve,\n        invMassj = bj.invMassSolve,\n        invIi = bi.invInertiaSolve,\n        invIj = bj.invInertiaSolve,\n        G = this.G;\n\n    return  G[0] * G[0] * invMassi * bi.massMultiplier[0] +\n            G[1] * G[1] * invMassi * bi.massMultiplier[1] +\n            G[2] * G[2] *    invIi +\n            G[3] * G[3] * invMassj * bj.massMultiplier[0] +\n            G[4] * G[4] * invMassj * bj.massMultiplier[1] +\n            G[5] * G[5] *    invIj;\n};\n\nvar addToWlambda_temp = vec2.create(),\n    addToWlambda_Gi = vec2.create(),\n    addToWlambda_Gj = vec2.create(),\n    addToWlambda_ri = vec2.create(),\n    addToWlambda_rj = vec2.create(),\n    addToWlambda_Mdiag = vec2.create();\n\n/**\n * Add constraint velocity to the bodies.\n * @method addToWlambda\n * @param {Number} deltalambda\n */\nEquation.prototype.addToWlambda = function(deltalambda){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        temp = addToWlambda_temp,\n        Gi = addToWlambda_Gi,\n        Gj = addToWlambda_Gj,\n        ri = addToWlambda_ri,\n        rj = addToWlambda_rj,\n        invMassi = bi.invMassSolve,\n        invMassj = bj.invMassSolve,\n        invIi = bi.invInertiaSolve,\n        invIj = bj.invInertiaSolve,\n        Mdiag = addToWlambda_Mdiag,\n        G = this.G;\n\n    Gi[0] = G[0];\n    Gi[1] = G[1];\n    Gj[0] = G[3];\n    Gj[1] = G[4];\n\n    // Add to linear velocity\n    // v_lambda += inv(M) * delta_lamba * G\n    vec2.scale(temp, Gi, invMassi*deltalambda);\n    vec2.multiply(temp, temp, bi.massMultiplier);\n    vec2.add( bi.vlambda, bi.vlambda, temp);\n    // This impulse is in the offset frame\n    // Also add contribution to angular\n    //bi.wlambda -= vec2.crossLength(temp,ri);\n    bi.wlambda += invIi * G[2] * deltalambda;\n\n\n    vec2.scale(temp, Gj, invMassj*deltalambda);\n    vec2.multiply(temp, temp, bj.massMultiplier);\n    vec2.add( bj.vlambda, bj.vlambda, temp);\n    //bj.wlambda -= vec2.crossLength(temp,rj);\n    bj.wlambda += invIj * G[5] * deltalambda;\n};\n\n/**\n * Compute the denominator part of the SPOOK equation: C = G\\*inv(M)\\*G' + eps\n * @method computeInvC\n * @param  {Number} eps\n * @return {Number}\n */\nEquation.prototype.computeInvC = function(eps){\n    return 1.0 / (this.computeGiMGt() + eps);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2VxdWF0aW9ucy9FcXVhdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvZXF1YXRpb25zL0VxdWF0aW9uLmpzPzEyMTkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBFcXVhdGlvbjtcblxudmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKSxcbiAgICBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJyksXG4gICAgQm9keSA9IHJlcXVpcmUoJy4uL29iamVjdHMvQm9keScpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNvbnN0cmFpbnQgZXF1YXRpb25zLlxuICogQGNsYXNzIEVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUEgRmlyc3QgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBlcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QiBTZWNvbmQgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBlcXVhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IG1pbkZvcmNlIE1pbmltdW0gZm9yY2UgdG8gYXBwbHkuIERlZmF1bHQ6IC1OdW1iZXIuTUFYX1ZBTFVFXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4Rm9yY2UgTWF4aW11bSBmb3JjZSB0byBhcHBseS4gRGVmYXVsdDogTnVtYmVyLk1BWF9WQUxVRVxuICovXG5mdW5jdGlvbiBFcXVhdGlvbihib2R5QSwgYm9keUIsIG1pbkZvcmNlLCBtYXhGb3JjZSl7XG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGZvcmNlIHRvIGFwcGx5IHdoZW4gc29sdmluZy5cbiAgICAgKiBAcHJvcGVydHkgbWluRm9yY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluRm9yY2UgPSB0eXBlb2YobWluRm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IC1OdW1iZXIuTUFYX1ZBTFVFIDogbWluRm9yY2U7XG5cbiAgICAvKipcbiAgICAgKiBNYXggZm9yY2UgdG8gYXBwbHkgd2hlbiBzb2x2aW5nLlxuICAgICAqIEBwcm9wZXJ0eSBtYXhGb3JjZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhGb3JjZSA9IHR5cGVvZihtYXhGb3JjZSk9PT1cInVuZGVmaW5lZFwiID8gTnVtYmVyLk1BWF9WQUxVRSA6IG1heEZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QgYm9keSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb25zdHJhaW50XG4gICAgICogQHByb3BlcnR5IGJvZHlBXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuXG4gICAgLyoqXG4gICAgICogU2Vjb25kIGJvZHkgcGFydGljaXBhdGluZyBpbiB0aGUgY29uc3RyYWludFxuICAgICAqIEBwcm9wZXJ0eSBib2R5QlxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGlmZm5lc3Mgb2YgdGhpcyBlcXVhdGlvbi4gVHlwaWNhbGx5IGNob3NlbiB0byBhIGxhcmdlIG51bWJlciAofjFlNyksIGJ1dCBjYW4gYmUgY2hvc2VuIHNvbWV3aGF0IGZyZWVseSB0byBnZXQgYSBzdGFibGUgc2ltdWxhdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9IEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiB0aW1lIHN0ZXBzIG5lZWRlZCB0byBzdGFiaWxpemUgdGhlIGNvbnN0cmFpbnQgZXF1YXRpb24uIFR5cGljYWxseSBiZXR3ZWVuIDMgYW5kIDUgdGltZSBzdGVwcy5cbiAgICAgKiBAcHJvcGVydHkgcmVsYXhhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZWxheGF0aW9uID0gRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OO1xuXG4gICAgLyoqXG4gICAgICogVGhlIEphY29iaWFuIGVudHJ5IG9mIHRoaXMgZXF1YXRpb24uIDYgbnVtYmVycywgMyBwZXIgYm9keSAoeCx5LGFuZ2xlKS5cbiAgICAgKiBAcHJvcGVydHkgR1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLkcgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSg2KTtcbiAgICBmb3IodmFyIGk9MDsgaTw2OyBpKyspe1xuICAgICAgICB0aGlzLkdbaV09MDtcbiAgICB9XG5cbiAgICB0aGlzLm9mZnNldCA9IDA7XG5cbiAgICB0aGlzLmEgPSAwO1xuICAgIHRoaXMuYiA9IDA7XG4gICAgdGhpcy5lcHNpbG9uID0gMDtcbiAgICB0aGlzLnRpbWVTdGVwID0gMS82MDtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBzdGlmZm5lc3Mgb3IgcmVsYXhhdGlvbiB3YXMgY2hhbmdlZC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG5lZWRzVXBkYXRlXG4gICAgICovXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdWx0aW5nIGNvbnN0cmFpbnQgbXVsdGlwbGllciBmcm9tIHRoZSBsYXN0IHNvbHZlLiBUaGlzIGlzIG1vc3RseSBlcXVpdmFsZW50IHRvIHRoZSBmb3JjZSBwcm9kdWNlZCBieSB0aGUgY29uc3RyYWludC5cbiAgICAgKiBAcHJvcGVydHkgbXVsdGlwbGllclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tdWx0aXBsaWVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHZlbG9jaXR5LlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZWxhdGl2ZVZlbG9jaXR5XG4gICAgICovXG4gICAgdGhpcy5yZWxhdGl2ZVZlbG9jaXR5ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBlcXVhdGlvbiBpcyBlbmFibGVkIG9yIG5vdC4gSWYgdHJ1ZSwgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgc29sdmVyLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqL1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG59XG5FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcXVhdGlvbjtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdGlmZm5lc3Mgd2hlbiBjcmVhdGluZyBhIG5ldyBFcXVhdGlvbi5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBERUZBVUxUX1NUSUZGTkVTU1xuICogQGRlZmF1bHQgMWU2XG4gKi9cbkVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTID0gMWU2O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHJlbGF4YXRpb24gd2hlbiBjcmVhdGluZyBhIG5ldyBFcXVhdGlvbi5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBERUZBVUxUX1JFTEFYQVRJT05cbiAqIEBkZWZhdWx0IDRcbiAqL1xuRXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9OID0gNDtcblxuLyoqXG4gKiBDb21wdXRlIFNQT09LIHBhcmFtZXRlcnMgLmEsIC5iIGFuZCAuZXBzaWxvbiBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFyYW1ldGVycy4gU2VlIGVxdWF0aW9ucyA5LCAxMCBhbmQgMTEgaW4gdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyLzVEVjA1OC9WVDA5L2xlY3R1cmVzL3Nwb29rbm90ZXMucGRmXCI+U1BPT0sgbm90ZXM8L2E+LlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGsgPSB0aGlzLnN0aWZmbmVzcyxcbiAgICAgICAgZCA9IHRoaXMucmVsYXhhdGlvbixcbiAgICAgICAgaCA9IHRoaXMudGltZVN0ZXA7XG5cbiAgICB0aGlzLmEgPSA0LjAgLyAoaCAqICgxICsgNCAqIGQpKTtcbiAgICB0aGlzLmIgPSAoNC4wICogZCkgLyAoMSArIDQgKiBkKTtcbiAgICB0aGlzLmVwc2lsb24gPSA0LjAgLyAoaCAqIGggKiBrICogKDEgKyA0ICogZCkpO1xuXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSBhIGphY29iaWFuIGVudHJ5IHdpdGggY29ycmVzcG9uZGluZyBwb3NpdGlvbnMgb3IgdmVsb2NpdGllc1xuICogQG1ldGhvZCBnbXVsdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuZ211bHQgPSBmdW5jdGlvbihHLHZpLHdpLHZqLHdqKXtcbiAgICByZXR1cm4gIEdbMF0gKiB2aVswXSArXG4gICAgICAgICAgICBHWzFdICogdmlbMV0gK1xuICAgICAgICAgICAgR1syXSAqIHdpICtcbiAgICAgICAgICAgIEdbM10gKiB2alswXSArXG4gICAgICAgICAgICBHWzRdICogdmpbMV0gK1xuICAgICAgICAgICAgR1s1XSAqIHdqO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUkhTIG9mIHRoZSBTUE9PSyBlcXVhdGlvblxuICogQG1ldGhvZCBjb21wdXRlQlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihhLGIsaCl7XG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICB2YXIgR3EgPSB0aGlzLmNvbXB1dGVHcSgpO1xuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIHJldHVybiAtIEdxICogYSAtIEdXICogYiAtIEdpTWYqaDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgR1xcKnEsIHdoZXJlIHEgYXJlIHRoZSBnZW5lcmFsaXplZCBib2R5IGNvb3JkaW5hdGVzXG4gKiBAbWV0aG9kIGNvbXB1dGVHcVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52YXIgcWkgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHFqID0gdmVjMi5jcmVhdGUoKTtcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR3EgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHID0gdGhpcy5HLFxuICAgICAgICBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgeGkgPSBiaS5wb3NpdGlvbixcbiAgICAgICAgeGogPSBiai5wb3NpdGlvbixcbiAgICAgICAgYWkgPSBiaS5hbmdsZSxcbiAgICAgICAgYWogPSBiai5hbmdsZTtcblxuICAgIHJldHVybiB0aGlzLmdtdWx0KEcsIHFpLCBhaSwgcWosIGFqKSArIHRoaXMub2Zmc2V0O1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqVywgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllc1xuICogQG1ldGhvZCBjb21wdXRlR1dcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHVyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEcgPSB0aGlzLkcsXG4gICAgICAgIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICB2aSA9IGJpLnZlbG9jaXR5LFxuICAgICAgICB2aiA9IGJqLnZlbG9jaXR5LFxuICAgICAgICB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eSxcbiAgICAgICAgd2ogPSBiai5hbmd1bGFyVmVsb2NpdHk7XG4gICAgcmV0dXJuIHRoaXMuZ211bHQoRyx2aSx3aSx2aix3aikgKyB0aGlzLnJlbGF0aXZlVmVsb2NpdHk7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEdcXCpXbGFtYmRhLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzXG4gKiBAbWV0aG9kIGNvbXB1dGVHV2xhbWJkYVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdXbGFtYmRhID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgRyA9IHRoaXMuRyxcbiAgICAgICAgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHZpID0gYmkudmxhbWJkYSxcbiAgICAgICAgdmogPSBiai52bGFtYmRhLFxuICAgICAgICB3aSA9IGJpLndsYW1iZGEsXG4gICAgICAgIHdqID0gYmoud2xhbWJkYTtcbiAgICByZXR1cm4gdGhpcy5nbXVsdChHLHZpLHdpLHZqLHdqKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgR1xcKmludihNKVxcKmYsIHdoZXJlIE0gaXMgdGhlIG1hc3MgbWF0cml4IHdpdGggZGlhZ29uYWwgYmxvY2tzIGZvciBlYWNoIGJvZHksIGFuZCBmIGFyZSB0aGUgZm9yY2VzIG9uIHRoZSBib2RpZXMuXG4gKiBAbWV0aG9kIGNvbXB1dGVHaU1mXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZhciBpTWZpID0gdmVjMi5jcmVhdGUoKSxcbiAgICBpTWZqID0gdmVjMi5jcmVhdGUoKTtcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR2lNZiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJpID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYmogPSB0aGlzLmJvZHlCLFxuICAgICAgICBmaSA9IGJpLmZvcmNlLFxuICAgICAgICB0aSA9IGJpLmFuZ3VsYXJGb3JjZSxcbiAgICAgICAgZmogPSBiai5mb3JjZSxcbiAgICAgICAgdGogPSBiai5hbmd1bGFyRm9yY2UsXG4gICAgICAgIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52SWkgPSBiaS5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIGludklqID0gYmouaW52SW5lcnRpYVNvbHZlLFxuICAgICAgICBHID0gdGhpcy5HO1xuXG4gICAgdmVjMi5zY2FsZShpTWZpLCBmaSwgaW52TWFzc2kpO1xuICAgIHZlYzIubXVsdGlwbHkoaU1maSwgYmkubWFzc011bHRpcGxpZXIsIGlNZmkpO1xuICAgIHZlYzIuc2NhbGUoaU1maiwgZmosaW52TWFzc2opO1xuICAgIHZlYzIubXVsdGlwbHkoaU1maiwgYmoubWFzc011bHRpcGxpZXIsIGlNZmopO1xuXG4gICAgcmV0dXJuIHRoaXMuZ211bHQoRyxpTWZpLHRpKmludklpLGlNZmosdGoqaW52SWopO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHXFwqaW52KE0pXFwqRydcbiAqIEBtZXRob2QgY29tcHV0ZUdpTUd0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR2lNR3QgPSBmdW5jdGlvbigpe1xuICAgIHZhciBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZJaSA9IGJpLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgaW52SWogPSBiai5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIEcgPSB0aGlzLkc7XG5cbiAgICByZXR1cm4gIEdbMF0gKiBHWzBdICogaW52TWFzc2kgKiBiaS5tYXNzTXVsdGlwbGllclswXSArXG4gICAgICAgICAgICBHWzFdICogR1sxXSAqIGludk1hc3NpICogYmkubWFzc011bHRpcGxpZXJbMV0gK1xuICAgICAgICAgICAgR1syXSAqIEdbMl0gKiAgICBpbnZJaSArXG4gICAgICAgICAgICBHWzNdICogR1szXSAqIGludk1hc3NqICogYmoubWFzc011bHRpcGxpZXJbMF0gK1xuICAgICAgICAgICAgR1s0XSAqIEdbNF0gKiBpbnZNYXNzaiAqIGJqLm1hc3NNdWx0aXBsaWVyWzFdICtcbiAgICAgICAgICAgIEdbNV0gKiBHWzVdICogICAgaW52SWo7XG59O1xuXG52YXIgYWRkVG9XbGFtYmRhX3RlbXAgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFkZFRvV2xhbWJkYV9HaSA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX0dqID0gdmVjMi5jcmVhdGUoKSxcbiAgICBhZGRUb1dsYW1iZGFfcmkgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFkZFRvV2xhbWJkYV9yaiA9IHZlYzIuY3JlYXRlKCksXG4gICAgYWRkVG9XbGFtYmRhX01kaWFnID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBBZGQgY29uc3RyYWludCB2ZWxvY2l0eSB0byB0aGUgYm9kaWVzLlxuICogQG1ldGhvZCBhZGRUb1dsYW1iZGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YWxhbWJkYVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuYWRkVG9XbGFtYmRhID0gZnVuY3Rpb24oZGVsdGFsYW1iZGEpe1xuICAgIHZhciBiaSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJqID0gdGhpcy5ib2R5QixcbiAgICAgICAgdGVtcCA9IGFkZFRvV2xhbWJkYV90ZW1wLFxuICAgICAgICBHaSA9IGFkZFRvV2xhbWJkYV9HaSxcbiAgICAgICAgR2ogPSBhZGRUb1dsYW1iZGFfR2osXG4gICAgICAgIHJpID0gYWRkVG9XbGFtYmRhX3JpLFxuICAgICAgICByaiA9IGFkZFRvV2xhbWJkYV9yaixcbiAgICAgICAgaW52TWFzc2kgPSBiaS5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludk1hc3NqID0gYmouaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZJaSA9IGJpLmludkluZXJ0aWFTb2x2ZSxcbiAgICAgICAgaW52SWogPSBiai5pbnZJbmVydGlhU29sdmUsXG4gICAgICAgIE1kaWFnID0gYWRkVG9XbGFtYmRhX01kaWFnLFxuICAgICAgICBHID0gdGhpcy5HO1xuXG4gICAgR2lbMF0gPSBHWzBdO1xuICAgIEdpWzFdID0gR1sxXTtcbiAgICBHalswXSA9IEdbM107XG4gICAgR2pbMV0gPSBHWzRdO1xuXG4gICAgLy8gQWRkIHRvIGxpbmVhciB2ZWxvY2l0eVxuICAgIC8vIHZfbGFtYmRhICs9IGludihNKSAqIGRlbHRhX2xhbWJhICogR1xuICAgIHZlYzIuc2NhbGUodGVtcCwgR2ksIGludk1hc3NpKmRlbHRhbGFtYmRhKTtcbiAgICB2ZWMyLm11bHRpcGx5KHRlbXAsIHRlbXAsIGJpLm1hc3NNdWx0aXBsaWVyKTtcbiAgICB2ZWMyLmFkZCggYmkudmxhbWJkYSwgYmkudmxhbWJkYSwgdGVtcCk7XG4gICAgLy8gVGhpcyBpbXB1bHNlIGlzIGluIHRoZSBvZmZzZXQgZnJhbWVcbiAgICAvLyBBbHNvIGFkZCBjb250cmlidXRpb24gdG8gYW5ndWxhclxuICAgIC8vYmkud2xhbWJkYSAtPSB2ZWMyLmNyb3NzTGVuZ3RoKHRlbXAscmkpO1xuICAgIGJpLndsYW1iZGEgKz0gaW52SWkgKiBHWzJdICogZGVsdGFsYW1iZGE7XG5cblxuICAgIHZlYzIuc2NhbGUodGVtcCwgR2osIGludk1hc3NqKmRlbHRhbGFtYmRhKTtcbiAgICB2ZWMyLm11bHRpcGx5KHRlbXAsIHRlbXAsIGJqLm1hc3NNdWx0aXBsaWVyKTtcbiAgICB2ZWMyLmFkZCggYmoudmxhbWJkYSwgYmoudmxhbWJkYSwgdGVtcCk7XG4gICAgLy9iai53bGFtYmRhIC09IHZlYzIuY3Jvc3NMZW5ndGgodGVtcCxyaik7XG4gICAgYmoud2xhbWJkYSArPSBpbnZJaiAqIEdbNV0gKiBkZWx0YWxhbWJkYTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgZGVub21pbmF0b3IgcGFydCBvZiB0aGUgU1BPT0sgZXF1YXRpb246IEMgPSBHXFwqaW52KE0pXFwqRycgKyBlcHNcbiAqIEBtZXRob2QgY29tcHV0ZUludkNcbiAqIEBwYXJhbSAge051bWJlcn0gZXBzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlSW52QyA9IGZ1bmN0aW9uKGVwcyl7XG4gICAgcmV0dXJuIDEuMCAvICh0aGlzLmNvbXB1dGVHaU1HdCgpICsgZXBzKTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/equations/Equation.js\n");

/***/ }),

/***/ "./node_modules/p2/src/equations/FrictionEquation.js":
/*!***********************************************************!*\
  !*** ./node_modules/p2/src/equations/FrictionEquation.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,   Equation = __webpack_require__(/*! ./Equation */ \"./node_modules/p2/src/equations/Equation.js\")\n,   Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\");\n\nmodule.exports = FrictionEquation;\n\n/**\n * Constrains the slipping in a contact along a tangent\n *\n * @class FrictionEquation\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} slipForce\n * @extends Equation\n */\nfunction FrictionEquation(bodyA, bodyB, slipForce){\n    Equation.call(this, bodyA, bodyB, -slipForce, slipForce);\n\n    /**\n     * Relative vector from center of body A to the contact point, world oriented.\n     * @property contactPointA\n     * @type {Array}\n     */\n    this.contactPointA = vec2.create();\n\n    /**\n     * Relative vector from center of body B to the contact point, world oriented.\n     * @property contactPointB\n     * @type {Array}\n     */\n    this.contactPointB = vec2.create();\n\n    /**\n     * Tangent vector that the friction force will act along. World oriented.\n     * @property t\n     * @type {Array}\n     */\n    this.t = vec2.create();\n\n    /**\n     * ContactEquations connected to this friction equation. The contact equations can be used to rescale the max force for the friction. If more than one contact equation is given, then the max force can be set to the average.\n     * @property contactEquations\n     * @type {ContactEquation}\n     */\n    this.contactEquations = [];\n\n    /**\n     * The shape in body i that triggered this friction.\n     * @property shapeA\n     * @type {Shape}\n     * @todo Needed? The shape can be looked up via contactEquation.shapeA...\n     */\n    this.shapeA = null;\n\n    /**\n     * The shape in body j that triggered this friction.\n     * @property shapeB\n     * @type {Shape}\n     * @todo Needed? The shape can be looked up via contactEquation.shapeB...\n     */\n    this.shapeB = null;\n\n    /**\n     * The friction coefficient to use.\n     * @property frictionCoefficient\n     * @type {Number}\n     */\n    this.frictionCoefficient = 0.3;\n}\nFrictionEquation.prototype = new Equation();\nFrictionEquation.prototype.constructor = FrictionEquation;\n\n/**\n * Set the slipping condition for the constraint. The friction force cannot be\n * larger than this value.\n * @method setSlipForce\n * @param  {Number} slipForce\n */\nFrictionEquation.prototype.setSlipForce = function(slipForce){\n    this.maxForce = slipForce;\n    this.minForce = -slipForce;\n};\n\n/**\n * Get the max force for the constraint.\n * @method getSlipForce\n * @return {Number}\n */\nFrictionEquation.prototype.getSlipForce = function(){\n    return this.maxForce;\n};\n\nFrictionEquation.prototype.computeB = function(a,b,h){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        ri = this.contactPointA,\n        rj = this.contactPointB,\n        t = this.t,\n        G = this.G;\n\n    // G = [-t -rixt t rjxt]\n    // And remember, this is a pure velocity constraint, g is always zero!\n    G[0] = -t[0];\n    G[1] = -t[1];\n    G[2] = -vec2.crossLength(ri,t);\n    G[3] = t[0];\n    G[4] = t[1];\n    G[5] = vec2.crossLength(rj,t);\n\n    var GW = this.computeGW(),\n        GiMf = this.computeGiMf();\n\n    var B = /* - g * a  */ - GW * b - h*GiMf;\n\n    return B;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbi5qcz9iZjY1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJylcbiwgICBFcXVhdGlvbiA9IHJlcXVpcmUoJy4vRXF1YXRpb24nKVxuLCAgIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGcmljdGlvbkVxdWF0aW9uO1xuXG4vKipcbiAqIENvbnN0cmFpbnMgdGhlIHNsaXBwaW5nIGluIGEgY29udGFjdCBhbG9uZyBhIHRhbmdlbnRcbiAqXG4gKiBAY2xhc3MgRnJpY3Rpb25FcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge051bWJlcn0gc2xpcEZvcmNlXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICovXG5mdW5jdGlvbiBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKXtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgLXNsaXBGb3JjZSwgc2xpcEZvcmNlKTtcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHZlY3RvciBmcm9tIGNlbnRlciBvZiBib2R5IEEgdG8gdGhlIGNvbnRhY3QgcG9pbnQsIHdvcmxkIG9yaWVudGVkLlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0UG9pbnRBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdFBvaW50QSA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGl2ZSB2ZWN0b3IgZnJvbSBjZW50ZXIgb2YgYm9keSBCIHRvIHRoZSBjb250YWN0IHBvaW50LCB3b3JsZCBvcmllbnRlZC5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFBvaW50QlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RQb2ludEIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGFuZ2VudCB2ZWN0b3IgdGhhdCB0aGUgZnJpY3Rpb24gZm9yY2Ugd2lsbCBhY3QgYWxvbmcuIFdvcmxkIG9yaWVudGVkLlxuICAgICAqIEBwcm9wZXJ0eSB0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudCA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWN0RXF1YXRpb25zIGNvbm5lY3RlZCB0byB0aGlzIGZyaWN0aW9uIGVxdWF0aW9uLiBUaGUgY29udGFjdCBlcXVhdGlvbnMgY2FuIGJlIHVzZWQgdG8gcmVzY2FsZSB0aGUgbWF4IGZvcmNlIGZvciB0aGUgZnJpY3Rpb24uIElmIG1vcmUgdGhhbiBvbmUgY29udGFjdCBlcXVhdGlvbiBpcyBnaXZlbiwgdGhlbiB0aGUgbWF4IGZvcmNlIGNhbiBiZSBzZXQgdG8gdGhlIGF2ZXJhZ2UuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RFcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7Q29udGFjdEVxdWF0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdEVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNoYXBlIGluIGJvZHkgaSB0aGF0IHRyaWdnZXJlZCB0aGlzIGZyaWN0aW9uLlxuICAgICAqIEBwcm9wZXJ0eSBzaGFwZUFcbiAgICAgKiBAdHlwZSB7U2hhcGV9XG4gICAgICogQHRvZG8gTmVlZGVkPyBUaGUgc2hhcGUgY2FuIGJlIGxvb2tlZCB1cCB2aWEgY29udGFjdEVxdWF0aW9uLnNoYXBlQS4uLlxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVBID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaGFwZSBpbiBib2R5IGogdGhhdCB0cmlnZ2VyZWQgdGhpcyBmcmljdGlvbi5cbiAgICAgKiBAcHJvcGVydHkgc2hhcGVCXG4gICAgICogQHR5cGUge1NoYXBlfVxuICAgICAqIEB0b2RvIE5lZWRlZD8gVGhlIHNoYXBlIGNhbiBiZSBsb29rZWQgdXAgdmlhIGNvbnRhY3RFcXVhdGlvbi5zaGFwZUIuLi5cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlQiA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJpY3Rpb24gY29lZmZpY2llbnQgdG8gdXNlLlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvbkNvZWZmaWNpZW50XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uQ29lZmZpY2llbnQgPSAwLjM7XG59XG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGcmljdGlvbkVxdWF0aW9uO1xuXG4vKipcbiAqIFNldCB0aGUgc2xpcHBpbmcgY29uZGl0aW9uIGZvciB0aGUgY29uc3RyYWludC4gVGhlIGZyaWN0aW9uIGZvcmNlIGNhbm5vdCBiZVxuICogbGFyZ2VyIHRoYW4gdGhpcyB2YWx1ZS5cbiAqIEBtZXRob2Qgc2V0U2xpcEZvcmNlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHNsaXBGb3JjZVxuICovXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5zZXRTbGlwRm9yY2UgPSBmdW5jdGlvbihzbGlwRm9yY2Upe1xuICAgIHRoaXMubWF4Rm9yY2UgPSBzbGlwRm9yY2U7XG4gICAgdGhpcy5taW5Gb3JjZSA9IC1zbGlwRm9yY2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4IGZvcmNlIGZvciB0aGUgY29uc3RyYWludC5cbiAqIEBtZXRob2QgZ2V0U2xpcEZvcmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmdldFNsaXBGb3JjZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubWF4Rm9yY2U7XG59O1xuXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgYmkgPSB0aGlzLmJvZHlBLFxuICAgICAgICBiaiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHJpID0gdGhpcy5jb250YWN0UG9pbnRBLFxuICAgICAgICByaiA9IHRoaXMuY29udGFjdFBvaW50QixcbiAgICAgICAgdCA9IHRoaXMudCxcbiAgICAgICAgRyA9IHRoaXMuRztcblxuICAgIC8vIEcgPSBbLXQgLXJpeHQgdCByanh0XVxuICAgIC8vIEFuZCByZW1lbWJlciwgdGhpcyBpcyBhIHB1cmUgdmVsb2NpdHkgY29uc3RyYWludCwgZyBpcyBhbHdheXMgemVybyFcbiAgICBHWzBdID0gLXRbMF07XG4gICAgR1sxXSA9IC10WzFdO1xuICAgIEdbMl0gPSAtdmVjMi5jcm9zc0xlbmd0aChyaSx0KTtcbiAgICBHWzNdID0gdFswXTtcbiAgICBHWzRdID0gdFsxXTtcbiAgICBHWzVdID0gdmVjMi5jcm9zc0xlbmd0aChyaix0KTtcblxuICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICB2YXIgQiA9IC8qIC0gZyAqIGEgICovIC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/equations/FrictionEquation.js\n");

/***/ }),

/***/ "./node_modules/p2/src/equations/RotationalLockEquation.js":
/*!*****************************************************************!*\
  !*** ./node_modules/p2/src/equations/RotationalLockEquation.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Equation = __webpack_require__(/*! ./Equation */ \"./node_modules/p2/src/equations/Equation.js\"),\n    vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\n\nmodule.exports = RotationalLockEquation;\n\n/**\n * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.\n *\n * @class RotationalLockEquation\n * @constructor\n * @extends Equation\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {Number} [options.angle] Angle to add to the local vector in bodyA.\n */\nfunction RotationalLockEquation(bodyA, bodyB, options){\n    options = options || {};\n    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);\n\n    /**\n     * @property {number} angle\n     */\n    this.angle = options.angle || 0;\n\n    var G = this.G;\n    G[2] =  1;\n    G[5] = -1;\n}\nRotationalLockEquation.prototype = new Equation();\nRotationalLockEquation.prototype.constructor = RotationalLockEquation;\n\nvar worldVectorA = vec2.create(),\n    worldVectorB = vec2.create(),\n    xAxis = vec2.fromValues(1,0),\n    yAxis = vec2.fromValues(0,1);\nRotationalLockEquation.prototype.computeGq = function(){\n    vec2.rotate(worldVectorA,xAxis,this.bodyA.angle+this.angle);\n    vec2.rotate(worldVectorB,yAxis,this.bodyB.angle);\n    return vec2.dot(worldVectorA,worldVectorB);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9lcXVhdGlvbnMvUm90YXRpb25hbExvY2tFcXVhdGlvbi5qcz83MmZjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBFcXVhdGlvbiA9IHJlcXVpcmUoXCIuL0VxdWF0aW9uXCIpLFxuICAgIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsTG9ja0VxdWF0aW9uO1xuXG4vKipcbiAqIExvY2tzIHRoZSByZWxhdGl2ZSBhbmdsZSBiZXR3ZWVuIHR3byBib2RpZXMuIFRoZSBjb25zdHJhaW50IHRyaWVzIHRvIGtlZXAgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdHdvIHZlY3RvcnMsIGxvY2FsIGluIGVhY2ggYm9keSwgdG8gemVyby4gVGhlIGxvY2FsIGFuZ2xlIGluIGJvZHkgaSBpcyBhIHBhcmFtZXRlci5cbiAqXG4gKiBAY2xhc3MgUm90YXRpb25hbExvY2tFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlXSBBbmdsZSB0byBhZGQgdG8gdGhlIGxvY2FsIHZlY3RvciBpbiBib2R5QS5cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbExvY2tFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAtTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYW5nbGVcbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZSB8fCAwO1xuXG4gICAgdmFyIEcgPSB0aGlzLkc7XG4gICAgR1syXSA9ICAxO1xuICAgIEdbNV0gPSAtMTtcbn1cblJvdGF0aW9uYWxMb2NrRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Sb3RhdGlvbmFsTG9ja0VxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uYWxMb2NrRXF1YXRpb247XG5cbnZhciB3b3JsZFZlY3RvckEgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHdvcmxkVmVjdG9yQiA9IHZlYzIuY3JlYXRlKCksXG4gICAgeEF4aXMgPSB2ZWMyLmZyb21WYWx1ZXMoMSwwKSxcbiAgICB5QXhpcyA9IHZlYzIuZnJvbVZhbHVlcygwLDEpO1xuUm90YXRpb25hbExvY2tFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlY3RvckEseEF4aXMsdGhpcy5ib2R5QS5hbmdsZSt0aGlzLmFuZ2xlKTtcbiAgICB2ZWMyLnJvdGF0ZSh3b3JsZFZlY3RvckIseUF4aXMsdGhpcy5ib2R5Qi5hbmdsZSk7XG4gICAgcmV0dXJuIHZlYzIuZG90KHdvcmxkVmVjdG9yQSx3b3JsZFZlY3RvckIpO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/equations/RotationalLockEquation.js\n");

/***/ }),

/***/ "./node_modules/p2/src/equations/RotationalVelocityEquation.js":
/*!*********************************************************************!*\
  !*** ./node_modules/p2/src/equations/RotationalVelocityEquation.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Equation = __webpack_require__(/*! ./Equation */ \"./node_modules/p2/src/equations/Equation.js\"),\n    vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\n\nmodule.exports = RotationalVelocityEquation;\n\n/**\n * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).\n *\n * @class RotationalVelocityEquation\n * @constructor\n * @extends Equation\n * @param {Body} bodyA\n * @param {Body} bodyB\n */\nfunction RotationalVelocityEquation(bodyA, bodyB){\n    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);\n    this.relativeVelocity = 1;\n    this.ratio = 1;\n}\nRotationalVelocityEquation.prototype = new Equation();\nRotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;\nRotationalVelocityEquation.prototype.computeB = function(a,b,h){\n    var G = this.G;\n    G[2] = -1;\n    G[5] = this.ratio;\n\n    var GiMf = this.computeGiMf();\n    var GW = this.computeGW();\n    var B = - GW * b - h*GiMf;\n\n    return B;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2VxdWF0aW9ucy9Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvZXF1YXRpb25zL1JvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uLmpzP2U2N2EiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEVxdWF0aW9uID0gcmVxdWlyZShcIi4vRXF1YXRpb25cIiksXG4gICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uO1xuXG4vKipcbiAqIFN5bmNzIHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdHdvIGJvZGllcywgb3Igc2V0cyBhIHJlbGF0aXZlIHZlbG9jaXR5IChtb3RvcikuXG4gKlxuICogQGNsYXNzIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbmZ1bmN0aW9uIFJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1OdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICB0aGlzLnJlbGF0aXZlVmVsb2NpdHkgPSAxO1xuICAgIHRoaXMucmF0aW8gPSAxO1xufVxuUm90YXRpb25hbFZlbG9jaXR5RXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Sb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbjtcblJvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgRyA9IHRoaXMuRztcbiAgICBHWzJdID0gLTE7XG4gICAgR1s1XSA9IHRoaXMucmF0aW87XG5cbiAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcbiAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xuICAgIHZhciBCID0gLSBHVyAqIGIgLSBoKkdpTWY7XG5cbiAgICByZXR1cm4gQjtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/equations/RotationalVelocityEquation.js\n");

/***/ }),

/***/ "./node_modules/p2/src/events/EventEmitter.js":
/*!****************************************************!*\
  !*** ./node_modules/p2/src/events/EventEmitter.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("/**\n * Base class for objects that dispatches events.\n * @class EventEmitter\n * @constructor\n */\nvar EventEmitter = function () {};\n\nmodule.exports = EventEmitter;\n\nEventEmitter.prototype = {\n    constructor: EventEmitter,\n\n    /**\n     * Add an event listener\n     * @method on\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {EventEmitter} The self object, for chainability.\n     */\n    on: function ( type, listener, context ) {\n        listener.context = context || this;\n        if ( this._listeners === undefined ){\n            this._listeners = {};\n        }\n        var listeners = this._listeners;\n        if ( listeners[ type ] === undefined ) {\n            listeners[ type ] = [];\n        }\n        if ( listeners[ type ].indexOf( listener ) === - 1 ) {\n            listeners[ type ].push( listener );\n        }\n        return this;\n    },\n\n    /**\n     * Check if an event listener is added\n     * @method has\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {Boolean}\n     */\n    has: function ( type, listener ) {\n        if ( this._listeners === undefined ){\n            return false;\n        }\n        var listeners = this._listeners;\n        if(listener){\n            if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n                return true;\n            }\n        } else {\n            if ( listeners[ type ] !== undefined ) {\n                return true;\n            }\n        }\n\n        return false;\n    },\n\n    /**\n     * Remove an event listener\n     * @method off\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {EventEmitter} The self object, for chainability.\n     */\n    off: function ( type, listener ) {\n        if ( this._listeners === undefined ){\n            return this;\n        }\n        var listeners = this._listeners;\n        var index = listeners[ type ].indexOf( listener );\n        if ( index !== - 1 ) {\n            listeners[ type ].splice( index, 1 );\n        }\n        return this;\n    },\n\n    /**\n     * Emit an event.\n     * @method emit\n     * @param  {Object} event\n     * @param  {String} event.type\n     * @return {EventEmitter} The self object, for chainability.\n     */\n    emit: function ( event ) {\n        if ( this._listeners === undefined ){\n            return this;\n        }\n        var listeners = this._listeners;\n        var listenerArray = listeners[ event.type ];\n        if ( listenerArray !== undefined ) {\n            event.target = this;\n            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {\n                var listener = listenerArray[ i ];\n                listener.call( listener.context, event );\n            }\n        }\n        return this;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL2V2ZW50cy9FdmVudEVtaXR0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL2V2ZW50cy9FdmVudEVtaXR0ZXIuanM/M2RjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJhc2UgY2xhc3MgZm9yIG9iamVjdHMgdGhhdCBkaXNwYXRjaGVzIGV2ZW50cy5cbiAqIEBjbGFzcyBFdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24gKCkge307XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBFdmVudEVtaXR0ZXIsXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAbWV0aG9kIG9uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIsIGNvbnRleHQgKSB7XG4gICAgICAgIGxpc3RlbmVyLmNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBldmVudCBsaXN0ZW5lciBpcyBhZGRlZFxuICAgICAqIEBtZXRob2QgaGFzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXM6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICBpZihsaXN0ZW5lcil7XG4gICAgICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKTtcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0uc3BsaWNlKCBpbmRleCwgMSApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbWl0IGFuIGV2ZW50LlxuICAgICAqIEBtZXRob2QgZW1pdFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50LnR5cGVcbiAgICAgKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICB2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xuICAgICAgICBpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBcnJheVsgaSBdO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoIGxpc3RlbmVyLmNvbnRleHQsIGV2ZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/events/EventEmitter.js\n");

/***/ }),

/***/ "./node_modules/p2/src/material/ContactMaterial.js":
/*!*********************************************************!*\
  !*** ./node_modules/p2/src/material/ContactMaterial.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Material = __webpack_require__(/*! ./Material */ \"./node_modules/p2/src/material/Material.js\");\nvar Equation = __webpack_require__(/*! ../equations/Equation */ \"./node_modules/p2/src/equations/Equation.js\");\n\nmodule.exports = ContactMaterial;\n\n/**\n * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters.\n * @class ContactMaterial\n * @constructor\n * @param {Material} materialA\n * @param {Material} materialB\n * @param {Object}   [options]\n * @param {Number}   [options.friction=0.3]       Friction coefficient.\n * @param {Number}   [options.restitution=0]      Restitution coefficient aka \"bounciness\".\n * @param {Number}   [options.stiffness]          ContactEquation stiffness.\n * @param {Number}   [options.relaxation]         ContactEquation relaxation.\n * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.\n * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.\n * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.\n * @author schteppe\n */\nfunction ContactMaterial(materialA, materialB, options){\n    options = options || {};\n\n    if(!(materialA instanceof Material) || !(materialB instanceof Material)){\n        throw new Error(\"First two arguments must be Material instances.\");\n    }\n\n    /**\n     * The contact material identifier\n     * @property id\n     * @type {Number}\n     */\n    this.id = ContactMaterial.idCounter++;\n\n    /**\n     * First material participating in the contact material\n     * @property materialA\n     * @type {Material}\n     */\n    this.materialA = materialA;\n\n    /**\n     * Second material participating in the contact material\n     * @property materialB\n     * @type {Material}\n     */\n    this.materialB = materialB;\n\n    /**\n     * Friction coefficient to use in the contact of these two materials. Friction = 0 will make the involved objects super slippery, and friction = 1 will make it much less slippery. A friction coefficient larger than 1 will allow for very large friction forces, which can be convenient for preventing car tires not slip on the ground.\n     * @property friction\n     * @type {Number}\n     * @default 0.3\n     */\n    this.friction = typeof(options.friction) !== \"undefined\" ? Number(options.friction) : 0.3;\n\n    /**\n     * Restitution, or \"bounciness\" to use in the contact of these two materials. A restitution of 0 will make no bounce, while restitution=1 will approximately bounce back with the same velocity the object came with.\n     * @property restitution\n     * @type {Number}\n     * @default 0\n     */\n    this.restitution = typeof(options.restitution) !== \"undefined\" ? Number(options.restitution) : 0;\n\n    /**\n     * Hardness of the contact. Less stiffness will make the objects penetrate more, and will make the contact act more like a spring than a contact force. Default value is {{#crossLink \"Equation/DEFAULT_STIFFNESS:property\"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.\n     * @property stiffness\n     * @type {Number}\n     */\n    this.stiffness = typeof(options.stiffness) !== \"undefined\" ? Number(options.stiffness) : Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * Relaxation of the resulting ContactEquation that this ContactMaterial generate. Default value is {{#crossLink \"Equation/DEFAULT_RELAXATION:property\"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.\n     * @property relaxation\n     * @type {Number}\n     */\n    this.relaxation = typeof(options.relaxation) !== \"undefined\" ? Number(options.relaxation) : Equation.DEFAULT_RELAXATION;\n\n    /**\n     * Stiffness of the resulting friction force. For most cases, the value of this property should be a large number. I cannot think of any case where you would want less frictionStiffness. Default value is {{#crossLink \"Equation/DEFAULT_STIFFNESS:property\"}}Equation.DEFAULT_STIFFNESS{{/crossLink}}.\n     * @property frictionStiffness\n     * @type {Number}\n     */\n    this.frictionStiffness = typeof(options.frictionStiffness) !== \"undefined\" ? Number(options.frictionStiffness) : Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * Relaxation of the resulting friction force. The default value should be good for most simulations. Default value is {{#crossLink \"Equation/DEFAULT_RELAXATION:property\"}}Equation.DEFAULT_RELAXATION{{/crossLink}}.\n     * @property frictionRelaxation\n     * @type {Number}\n     */\n    this.frictionRelaxation = typeof(options.frictionRelaxation) !== \"undefined\" ? Number(options.frictionRelaxation)  : Equation.DEFAULT_RELAXATION;\n\n    /**\n     * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.\n     * @property {Number} surfaceVelocity\n     * @default 0\n     */\n    this.surfaceVelocity = typeof(options.surfaceVelocity) !== \"undefined\" ? Number(options.surfaceVelocity) : 0;\n\n    /**\n     * Offset to be set on ContactEquations. A positive value will make the bodies penetrate more into each other. Can be useful in scenes where contacts need to be more persistent, for example when stacking. Aka \"cure for nervous contacts\".\n     * @property contactSkinSize\n     * @type {Number}\n     */\n    this.contactSkinSize = 0.005;\n}\n\nContactMaterial.idCounter = 0;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsLmpzP2VjOGUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIE1hdGVyaWFsID0gcmVxdWlyZSgnLi9NYXRlcmlhbCcpO1xudmFyIEVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0VxdWF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFjdE1hdGVyaWFsO1xuXG4vKipcbiAqIERlZmluZXMgd2hhdCBoYXBwZW5zIHdoZW4gdHdvIG1hdGVyaWFscyBtZWV0LCBzdWNoIGFzIHdoYXQgZnJpY3Rpb24gY29lZmZpY2llbnQgdG8gdXNlLiBZb3UgY2FuIGFsc28gc2V0IG90aGVyIHRoaW5ncyBzdWNoIGFzIHJlc3RpdHV0aW9uLCBzdXJmYWNlIHZlbG9jaXR5IGFuZCBjb25zdHJhaW50IHBhcmFtZXRlcnMuXG4gKiBAY2xhc3MgQ29udGFjdE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsQVxuICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxCXG4gKiBAcGFyYW0ge09iamVjdH0gICBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLmZyaWN0aW9uPTAuM10gICAgICAgRnJpY3Rpb24gY29lZmZpY2llbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5yZXN0aXR1dGlvbj0wXSAgICAgIFJlc3RpdHV0aW9uIGNvZWZmaWNpZW50IGFrYSBcImJvdW5jaW5lc3NcIi5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnN0aWZmbmVzc10gICAgICAgICAgQ29udGFjdEVxdWF0aW9uIHN0aWZmbmVzcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgIFtvcHRpb25zLnJlbGF4YXRpb25dICAgICAgICAgQ29udGFjdEVxdWF0aW9uIHJlbGF4YXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5mcmljdGlvblN0aWZmbmVzc10gIEZyaWN0aW9uRXF1YXRpb24gc3RpZmZuZXNzLlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgW29wdGlvbnMuZnJpY3Rpb25SZWxheGF0aW9uXSBGcmljdGlvbkVxdWF0aW9uIHJlbGF4YXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gICBbb3B0aW9ucy5zdXJmYWNlVmVsb2NpdHk9MF0gIFN1cmZhY2UgdmVsb2NpdHkuXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIENvbnRhY3RNYXRlcmlhbChtYXRlcmlhbEEsIG1hdGVyaWFsQiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZighKG1hdGVyaWFsQSBpbnN0YW5jZW9mIE1hdGVyaWFsKSB8fCAhKG1hdGVyaWFsQiBpbnN0YW5jZW9mIE1hdGVyaWFsKSl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IHR3byBhcmd1bWVudHMgbXVzdCBiZSBNYXRlcmlhbCBpbnN0YW5jZXMuXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250YWN0IG1hdGVyaWFsIGlkZW50aWZpZXJcbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBDb250YWN0TWF0ZXJpYWwuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBtYXRlcmlhbCBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb250YWN0IG1hdGVyaWFsXG4gICAgICogQHByb3BlcnR5IG1hdGVyaWFsQVxuICAgICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsQSA9IG1hdGVyaWFsQTtcblxuICAgIC8qKlxuICAgICAqIFNlY29uZCBtYXRlcmlhbCBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjb250YWN0IG1hdGVyaWFsXG4gICAgICogQHByb3BlcnR5IG1hdGVyaWFsQlxuICAgICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsQiA9IG1hdGVyaWFsQjtcblxuICAgIC8qKlxuICAgICAqIEZyaWN0aW9uIGNvZWZmaWNpZW50IHRvIHVzZSBpbiB0aGUgY29udGFjdCBvZiB0aGVzZSB0d28gbWF0ZXJpYWxzLiBGcmljdGlvbiA9IDAgd2lsbCBtYWtlIHRoZSBpbnZvbHZlZCBvYmplY3RzIHN1cGVyIHNsaXBwZXJ5LCBhbmQgZnJpY3Rpb24gPSAxIHdpbGwgbWFrZSBpdCBtdWNoIGxlc3Mgc2xpcHBlcnkuIEEgZnJpY3Rpb24gY29lZmZpY2llbnQgbGFyZ2VyIHRoYW4gMSB3aWxsIGFsbG93IGZvciB2ZXJ5IGxhcmdlIGZyaWN0aW9uIGZvcmNlcywgd2hpY2ggY2FuIGJlIGNvbnZlbmllbnQgZm9yIHByZXZlbnRpbmcgY2FyIHRpcmVzIG5vdCBzbGlwIG9uIHRoZSBncm91bmQuXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjNcbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uID0gdHlwZW9mKG9wdGlvbnMuZnJpY3Rpb24pICE9PSBcInVuZGVmaW5lZFwiID8gTnVtYmVyKG9wdGlvbnMuZnJpY3Rpb24pIDogMC4zO1xuXG4gICAgLyoqXG4gICAgICogUmVzdGl0dXRpb24sIG9yIFwiYm91bmNpbmVzc1wiIHRvIHVzZSBpbiB0aGUgY29udGFjdCBvZiB0aGVzZSB0d28gbWF0ZXJpYWxzLiBBIHJlc3RpdHV0aW9uIG9mIDAgd2lsbCBtYWtlIG5vIGJvdW5jZSwgd2hpbGUgcmVzdGl0dXRpb249MSB3aWxsIGFwcHJveGltYXRlbHkgYm91bmNlIGJhY2sgd2l0aCB0aGUgc2FtZSB2ZWxvY2l0eSB0aGUgb2JqZWN0IGNhbWUgd2l0aC5cbiAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnJlc3RpdHV0aW9uID0gdHlwZW9mKG9wdGlvbnMucmVzdGl0dXRpb24pICE9PSBcInVuZGVmaW5lZFwiID8gTnVtYmVyKG9wdGlvbnMucmVzdGl0dXRpb24pIDogMDtcblxuICAgIC8qKlxuICAgICAqIEhhcmRuZXNzIG9mIHRoZSBjb250YWN0LiBMZXNzIHN0aWZmbmVzcyB3aWxsIG1ha2UgdGhlIG9iamVjdHMgcGVuZXRyYXRlIG1vcmUsIGFuZCB3aWxsIG1ha2UgdGhlIGNvbnRhY3QgYWN0IG1vcmUgbGlrZSBhIHNwcmluZyB0aGFuIGEgY29udGFjdCBmb3JjZS4gRGVmYXVsdCB2YWx1ZSBpcyB7eyNjcm9zc0xpbmsgXCJFcXVhdGlvbi9ERUZBVUxUX1NUSUZGTkVTUzpwcm9wZXJ0eVwifX1FcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTU3t7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RpZmZuZXNzID0gdHlwZW9mKG9wdGlvbnMuc3RpZmZuZXNzKSAhPT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlcihvcHRpb25zLnN0aWZmbmVzcykgOiBFcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTUztcblxuICAgIC8qKlxuICAgICAqIFJlbGF4YXRpb24gb2YgdGhlIHJlc3VsdGluZyBDb250YWN0RXF1YXRpb24gdGhhdCB0aGlzIENvbnRhY3RNYXRlcmlhbCBnZW5lcmF0ZS4gRGVmYXVsdCB2YWx1ZSBpcyB7eyNjcm9zc0xpbmsgXCJFcXVhdGlvbi9ERUZBVUxUX1JFTEFYQVRJT046cHJvcGVydHlcIn19RXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9Oe3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHJlbGF4YXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVsYXhhdGlvbiA9IHR5cGVvZihvcHRpb25zLnJlbGF4YXRpb24pICE9PSBcInVuZGVmaW5lZFwiID8gTnVtYmVyKG9wdGlvbnMucmVsYXhhdGlvbikgOiBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHJlc3VsdGluZyBmcmljdGlvbiBmb3JjZS4gRm9yIG1vc3QgY2FzZXMsIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IHNob3VsZCBiZSBhIGxhcmdlIG51bWJlci4gSSBjYW5ub3QgdGhpbmsgb2YgYW55IGNhc2Ugd2hlcmUgeW91IHdvdWxkIHdhbnQgbGVzcyBmcmljdGlvblN0aWZmbmVzcy4gRGVmYXVsdCB2YWx1ZSBpcyB7eyNjcm9zc0xpbmsgXCJFcXVhdGlvbi9ERUZBVUxUX1NUSUZGTkVTUzpwcm9wZXJ0eVwifX1FcXVhdGlvbi5ERUZBVUxUX1NUSUZGTkVTU3t7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSBmcmljdGlvblN0aWZmbmVzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvblN0aWZmbmVzcyA9IHR5cGVvZihvcHRpb25zLmZyaWN0aW9uU3RpZmZuZXNzKSAhPT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlcihvcHRpb25zLmZyaWN0aW9uU3RpZmZuZXNzKSA6IEVxdWF0aW9uLkRFRkFVTFRfU1RJRkZORVNTO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXhhdGlvbiBvZiB0aGUgcmVzdWx0aW5nIGZyaWN0aW9uIGZvcmNlLiBUaGUgZGVmYXVsdCB2YWx1ZSBzaG91bGQgYmUgZ29vZCBmb3IgbW9zdCBzaW11bGF0aW9ucy4gRGVmYXVsdCB2YWx1ZSBpcyB7eyNjcm9zc0xpbmsgXCJFcXVhdGlvbi9ERUZBVUxUX1JFTEFYQVRJT046cHJvcGVydHlcIn19RXF1YXRpb24uREVGQVVMVF9SRUxBWEFUSU9Oe3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IGZyaWN0aW9uUmVsYXhhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvblJlbGF4YXRpb24gPSB0eXBlb2Yob3B0aW9ucy5mcmljdGlvblJlbGF4YXRpb24pICE9PSBcInVuZGVmaW5lZFwiID8gTnVtYmVyKG9wdGlvbnMuZnJpY3Rpb25SZWxheGF0aW9uKSAgOiBFcXVhdGlvbi5ERUZBVUxUX1JFTEFYQVRJT047XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGFkZCBzdXJmYWNlIHZlbG9jaXR5IHRvIHRoaXMgbWF0ZXJpYWwuIElmIGJvZHlBIHJlc3RzIG9uIHRvcCBpZiBib2R5QiwgYW5kIHRoZSBzdXJmYWNlIHZlbG9jaXR5IGlzIHBvc2l0aXZlLCBib2R5QSB3aWxsIHNsaWRlIHRvIHRoZSByaWdodC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc3VyZmFjZVZlbG9jaXR5XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMuc3VyZmFjZVZlbG9jaXR5ID0gdHlwZW9mKG9wdGlvbnMuc3VyZmFjZVZlbG9jaXR5KSAhPT0gXCJ1bmRlZmluZWRcIiA/IE51bWJlcihvcHRpb25zLnN1cmZhY2VWZWxvY2l0eSkgOiAwO1xuXG4gICAgLyoqXG4gICAgICogT2Zmc2V0IHRvIGJlIHNldCBvbiBDb250YWN0RXF1YXRpb25zLiBBIHBvc2l0aXZlIHZhbHVlIHdpbGwgbWFrZSB0aGUgYm9kaWVzIHBlbmV0cmF0ZSBtb3JlIGludG8gZWFjaCBvdGhlci4gQ2FuIGJlIHVzZWZ1bCBpbiBzY2VuZXMgd2hlcmUgY29udGFjdHMgbmVlZCB0byBiZSBtb3JlIHBlcnNpc3RlbnQsIGZvciBleGFtcGxlIHdoZW4gc3RhY2tpbmcuIEFrYSBcImN1cmUgZm9yIG5lcnZvdXMgY29udGFjdHNcIi5cbiAgICAgKiBAcHJvcGVydHkgY29udGFjdFNraW5TaXplXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RTa2luU2l6ZSA9IDAuMDA1O1xufVxuXG5Db250YWN0TWF0ZXJpYWwuaWRDb3VudGVyID0gMDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/material/ContactMaterial.js\n");

/***/ }),

/***/ "./node_modules/p2/src/material/Material.js":
/*!**************************************************!*\
  !*** ./node_modules/p2/src/material/Material.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = Material;\n\n/**\n * Defines a physics material.\n * @class Material\n * @constructor\n * @param {number} id Material identifier\n * @author schteppe\n */\nfunction Material(id){\n    /**\n     * The material identifier\n     * @property id\n     * @type {Number}\n     */\n    this.id = id || Material.idCounter++;\n}\n\nMaterial.idCounter = 0;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL21hdGVyaWFsL01hdGVyaWFsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9tYXRlcmlhbC9NYXRlcmlhbC5qcz85YjJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gTWF0ZXJpYWw7XG5cbi8qKlxuICogRGVmaW5lcyBhIHBoeXNpY3MgbWF0ZXJpYWwuXG4gKiBAY2xhc3MgTWF0ZXJpYWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGlkIE1hdGVyaWFsIGlkZW50aWZpZXJcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gTWF0ZXJpYWwoaWQpe1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXRlcmlhbCBpZGVudGlmaWVyXG4gICAgICogQHByb3BlcnR5IGlkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gaWQgfHwgTWF0ZXJpYWwuaWRDb3VudGVyKys7XG59XG5cbk1hdGVyaWFsLmlkQ291bnRlciA9IDA7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/material/Material.js\n");

/***/ }),

/***/ "./node_modules/p2/src/math/polyk.js":
/*!*******************************************!*\
  !*** ./node_modules/p2/src/math/polyk.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("\n    /*\n        PolyK library\n        url: http://polyk.ivank.net\n        Released under MIT licence.\n\n        Copyright (c) 2012 Ivan Kuckir\n\n        Permission is hereby granted, free of charge, to any person\n        obtaining a copy of this software and associated documentation\n        files (the \"Software\"), to deal in the Software without\n        restriction, including without limitation the rights to use,\n        copy, modify, merge, publish, distribute, sublicense, and/or sell\n        copies of the Software, and to permit persons to whom the\n        Software is furnished to do so, subject to the following\n        conditions:\n\n        The above copyright notice and this permission notice shall be\n        included in all copies or substantial portions of the Software.\n\n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n        OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n        HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n        WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n        FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n        OTHER DEALINGS IN THE SOFTWARE.\n    */\n\n    var PolyK = {};\n\n    /*\n        Is Polygon self-intersecting?\n\n        O(n^2)\n    */\n    /*\n    PolyK.IsSimple = function(p)\n    {\n        var n = p.length>>1;\n        if(n<4) return true;\n        var a1 = new PolyK._P(), a2 = new PolyK._P();\n        var b1 = new PolyK._P(), b2 = new PolyK._P();\n        var c = new PolyK._P();\n\n        for(var i=0; i<n; i++)\n        {\n            a1.x = p[2*i  ];\n            a1.y = p[2*i+1];\n            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }\n            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }\n\n            for(var j=0; j<n; j++)\n            {\n                if(Math.abs(i-j) < 2) continue;\n                if(j==n-1 && i==0) continue;\n                if(i==n-1 && j==0) continue;\n\n                b1.x = p[2*j  ];\n                b1.y = p[2*j+1];\n                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }\n                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }\n\n                if(PolyK._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;\n            }\n        }\n        return true;\n    }\n\n    PolyK.IsConvex = function(p)\n    {\n        if(p.length<6) return true;\n        var l = p.length - 4;\n        for(var i=0; i<l; i+=2)\n            if(!PolyK._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;\n        if(!PolyK._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;\n        if(!PolyK._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;\n        return true;\n    }\n    */\n    PolyK.GetArea = function(p)\n    {\n        if(p.length <6) return 0;\n        var l = p.length - 2;\n        var sum = 0;\n        for(var i=0; i<l; i+=2)\n            sum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);\n        sum += (p[0]-p[l]) * (p[l+1]+p[1]);\n        return - sum * 0.5;\n    }\n    /*\n    PolyK.GetAABB = function(p)\n    {\n        var minx = Infinity;\n        var miny = Infinity;\n        var maxx = -minx;\n        var maxy = -miny;\n        for(var i=0; i<p.length; i+=2)\n        {\n            minx = Math.min(minx, p[i  ]);\n            maxx = Math.max(maxx, p[i  ]);\n            miny = Math.min(miny, p[i+1]);\n            maxy = Math.max(maxy, p[i+1]);\n        }\n        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};\n    }\n    */\n\n    PolyK.Triangulate = function(p)\n    {\n        var n = p.length>>1;\n        if(n<3) return [];\n        var tgs = [];\n        var avl = [];\n        for(var i=0; i<n; i++) avl.push(i);\n\n        var i = 0;\n        var al = n;\n        while(al > 3)\n        {\n            var i0 = avl[(i+0)%al];\n            var i1 = avl[(i+1)%al];\n            var i2 = avl[(i+2)%al];\n\n            var ax = p[2*i0],  ay = p[2*i0+1];\n            var bx = p[2*i1],  by = p[2*i1+1];\n            var cx = p[2*i2],  cy = p[2*i2+1];\n\n            var earFound = false;\n            if(PolyK._convex(ax, ay, bx, by, cx, cy))\n            {\n                earFound = true;\n                for(var j=0; j<al; j++)\n                {\n                    var vi = avl[j];\n                    if(vi==i0 || vi==i1 || vi==i2) continue;\n                    if(PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {earFound = false; break;}\n                }\n            }\n            if(earFound)\n            {\n                tgs.push(i0, i1, i2);\n                avl.splice((i+1)%al, 1);\n                al--;\n                i= 0;\n            }\n            else if(i++ > 3*al) break;      // no convex angles :(\n        }\n        tgs.push(avl[0], avl[1], avl[2]);\n        return tgs;\n    }\n    /*\n    PolyK.ContainsPoint = function(p, px, py)\n    {\n        var n = p.length>>1;\n        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;\n        var depth = 0;\n        for(var i=0; i<n; i++)\n        {\n            ax = bx;  ay = by;\n            bx = p[2*i  ] - px;\n            by = p[2*i+1] - py;\n            if(ay< 0 && by< 0) continue;    // both \"up\" or both \"donw\"\n            if(ay>=0 && by>=0) continue;    // both \"up\" or both \"donw\"\n            if(ax< 0 && bx< 0) continue;\n\n            var lx = ax + (bx-ax)*(-ay)/(by-ay);\n            if(lx>0) depth++;\n        }\n        return (depth & 1) == 1;\n    }\n\n    PolyK.Slice = function(p, ax, ay, bx, by)\n    {\n        if(PolyK.ContainsPoint(p, ax, ay) || PolyK.ContainsPoint(p, bx, by)) return [p.slice(0)];\n\n        var a = new PolyK._P(ax, ay);\n        var b = new PolyK._P(bx, by);\n        var iscs = [];  // intersections\n        var ps = [];    // points\n        for(var i=0; i<p.length; i+=2) ps.push(new PolyK._P(p[i], p[i+1]));\n\n        for(var i=0; i<ps.length; i++)\n        {\n            var isc = new PolyK._P(0,0);\n            isc = PolyK._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);\n\n            if(isc)\n            {\n                isc.flag = true;\n                iscs.push(isc);\n                ps.splice(i+1,0,isc);\n                i++;\n            }\n        }\n        if(iscs.length == 0) return [p.slice(0)];\n        var comp = function(u,v) {return PolyK._P.dist(a,u) - PolyK._P.dist(a,v); }\n        iscs.sort(comp);\n\n        var pgs = [];\n        var dir = 0;\n        while(iscs.length > 0)\n        {\n            var n = ps.length;\n            var i0 = iscs[0];\n            var i1 = iscs[1];\n            var ind0 = ps.indexOf(i0);\n            var ind1 = ps.indexOf(i1);\n            var solved = false;\n\n            if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;\n            else\n            {\n                i0 = iscs[1];\n                i1 = iscs[0];\n                ind0 = ps.indexOf(i0);\n                ind1 = ps.indexOf(i1);\n                if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;\n            }\n            if(solved)\n            {\n                dir--;\n                var pgn = PolyK._getPoints(ps, ind0, ind1);\n                pgs.push(pgn);\n                ps = PolyK._getPoints(ps, ind1, ind0);\n                i0.flag = i1.flag = false;\n                iscs.splice(0,2);\n                if(iscs.length == 0) pgs.push(ps);\n            }\n            else { dir++; iscs.reverse(); }\n            if(dir>1) break;\n        }\n        var result = [];\n        for(var i=0; i<pgs.length; i++)\n        {\n            var pg = pgs[i];\n            var npg = [];\n            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);\n            result.push(npg);\n        }\n        return result;\n    }\n\n    PolyK.Raycast = function(p, x, y, dx, dy, isc)\n    {\n        var l = p.length - 2;\n        var tp = PolyK._tp;\n        var a1 = tp[0], a2 = tp[1],\n        b1 = tp[2], b2 = tp[3], c = tp[4];\n        a1.x = x; a1.y = y;\n        a2.x = x+dx; a2.y = y+dy;\n\n        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};\n        isc.dist = Infinity;\n\n        for(var i=0; i<l; i+=2)\n        {\n            b1.x = p[i  ];  b1.y = p[i+1];\n            b2.x = p[i+2];  b2.y = p[i+3];\n            var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);\n            if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);\n        }\n        b1.x = b2.x;  b1.y = b2.y;\n        b2.x = p[0];  b2.y = p[1];\n        var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);\n        if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);\n\n        return (isc.dist != Infinity) ? isc : null;\n    }\n\n    PolyK.ClosestEdge = function(p, x, y, isc)\n    {\n        var l = p.length - 2;\n        var tp = PolyK._tp;\n        var a1 = tp[0],\n        b1 = tp[2], b2 = tp[3], c = tp[4];\n        a1.x = x; a1.y = y;\n\n        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};\n        isc.dist = Infinity;\n\n        for(var i=0; i<l; i+=2)\n        {\n            b1.x = p[i  ];  b1.y = p[i+1];\n            b2.x = p[i+2];  b2.y = p[i+3];\n            PolyK._pointLineDist(a1, b1, b2, i>>1, isc);\n        }\n        b1.x = b2.x;  b1.y = b2.y;\n        b2.x = p[0];  b2.y = p[1];\n        PolyK._pointLineDist(a1, b1, b2, l>>1, isc);\n\n        var idst = 1/isc.dist;\n        isc.norm.x = (x-isc.point.x)*idst;\n        isc.norm.y = (y-isc.point.y)*idst;\n        return isc;\n    }\n\n    PolyK._pointLineDist = function(p, a, b, edge, isc)\n    {\n        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;\n\n        var A = x - x1;\n        var B = y - y1;\n        var C = x2 - x1;\n        var D = y2 - y1;\n\n        var dot = A * C + B * D;\n        var len_sq = C * C + D * D;\n        var param = dot / len_sq;\n\n        var xx, yy;\n\n        if (param < 0 || (x1 == x2 && y1 == y2)) {\n            xx = x1;\n            yy = y1;\n        }\n        else if (param > 1) {\n            xx = x2;\n            yy = y2;\n        }\n        else {\n            xx = x1 + param * C;\n            yy = y1 + param * D;\n        }\n\n        var dx = x - xx;\n        var dy = y - yy;\n        var dst = Math.sqrt(dx * dx + dy * dy);\n        if(dst<isc.dist)\n        {\n            isc.dist = dst;\n            isc.edge = edge;\n            isc.point.x = xx;\n            isc.point.y = yy;\n        }\n    }\n\n    PolyK._updateISC = function(dx, dy, a1, b1, b2, c, edge, isc)\n    {\n        var nrl = PolyK._P.dist(a1, c);\n        if(nrl<isc.dist)\n        {\n            var ibl = 1/PolyK._P.dist(b1, b2);\n            var nx = -(b2.y-b1.y)*ibl;\n            var ny =  (b2.x-b1.x)*ibl;\n            var ddot = 2*(dx*nx+dy*ny);\n            isc.dist = nrl;\n            isc.norm.x = nx;\n            isc.norm.y = ny;\n            isc.refl.x = -ddot*nx+dx;\n            isc.refl.y = -ddot*ny+dy;\n            isc.edge = edge;\n        }\n    }\n\n    PolyK._getPoints = function(ps, ind0, ind1)\n    {\n        var n = ps.length;\n        var nps = [];\n        if(ind1<ind0) ind1 += n;\n        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);\n        return nps;\n    }\n\n    PolyK._firstWithFlag = function(ps, ind)\n    {\n        var n = ps.length;\n        while(true)\n        {\n            ind = (ind+1)%n;\n            if(ps[ind].flag) return ind;\n        }\n    }\n    */\n    PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)\n    {\n        var v0x = cx-ax;\n        var v0y = cy-ay;\n        var v1x = bx-ax;\n        var v1y = by-ay;\n        var v2x = px-ax;\n        var v2y = py-ay;\n\n        var dot00 = v0x*v0x+v0y*v0y;\n        var dot01 = v0x*v1x+v0y*v1y;\n        var dot02 = v0x*v2x+v0y*v2y;\n        var dot11 = v1x*v1x+v1y*v1y;\n        var dot12 = v1x*v2x+v1y*v2y;\n\n        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n        // Check if point is in triangle\n        return (u >= 0) && (v >= 0) && (u + v < 1);\n    }\n    /*\n    PolyK._RayLineIntersection = function(a1, a2, b1, b2, c)\n    {\n        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);\n        var day = (a1.y-a2.y), dby = (b1.y-b2.y);\n\n        var Den = dax*dby - day*dbx;\n        if (Den == 0) return null;  // parallel\n\n        var A = (a1.x * a2.y - a1.y * a2.x);\n        var B = (b1.x * b2.y - b1.y * b2.x);\n\n        var I = c;\n        var iDen = 1/Den;\n        I.x = ( A*dbx - dax*B ) * iDen;\n        I.y = ( A*dby - day*B ) * iDen;\n\n        if(!PolyK._InRect(I, b1, b2)) return null;\n        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;\n        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;\n        return I;\n    }\n\n    PolyK._GetLineIntersection = function(a1, a2, b1, b2, c)\n    {\n        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);\n        var day = (a1.y-a2.y), dby = (b1.y-b2.y);\n\n        var Den = dax*dby - day*dbx;\n        if (Den == 0) return null;  // parallel\n\n        var A = (a1.x * a2.y - a1.y * a2.x);\n        var B = (b1.x * b2.y - b1.y * b2.x);\n\n        var I = c;\n        I.x = ( A*dbx - dax*B ) / Den;\n        I.y = ( A*dby - day*B ) / Den;\n\n        if(PolyK._InRect(I, a1, a2) && PolyK._InRect(I, b1, b2)) return I;\n        return null;\n    }\n\n    PolyK._InRect = function(a, b, c)\n    {\n        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));\n        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));\n\n        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)\n        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))\n        return true;\n        return false;\n    }\n    */\n    PolyK._convex = function(ax, ay, bx, by, cx, cy)\n    {\n        return (ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0;\n    }\n    /*\n    PolyK._P = function(x,y)\n    {\n        this.x = x;\n        this.y = y;\n        this.flag = false;\n    }\n    PolyK._P.prototype.toString = function()\n    {\n        return \"Point [\"+this.x+\", \"+this.y+\"]\";\n    }\n    PolyK._P.dist = function(a,b)\n    {\n        var dx = b.x-a.x;\n        var dy = b.y-a.y;\n        return Math.sqrt(dx*dx + dy*dy);\n    }\n\n    PolyK._tp = [];\n    for(var i=0; i<10; i++) PolyK._tp.push(new PolyK._P(0,0));\n        */\n\nmodule.exports = PolyK;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL21hdGgvcG9seWsuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL21hdGgvcG9seWsuanM/ZWRkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAvKlxuICAgICAgICBQb2x5SyBsaWJyYXJ5XG4gICAgICAgIHVybDogaHR0cDovL3BvbHlrLml2YW5rLm5ldFxuICAgICAgICBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5jZS5cblxuICAgICAgICBDb3B5cmlnaHQgKGMpIDIwMTIgSXZhbiBLdWNraXJcblxuICAgICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgICAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICAgICAgICBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAgICAgICAgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gICAgICAgIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICAgICAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICAgICAgICBjb25kaXRpb25zOlxuXG4gICAgICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICAgICAgICBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgICAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICAgICAgICBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAgICAgICAgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gICAgICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAgICAgICAgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgICovXG5cbiAgICB2YXIgUG9seUsgPSB7fTtcblxuICAgIC8qXG4gICAgICAgIElzIFBvbHlnb24gc2VsZi1pbnRlcnNlY3Rpbmc/XG5cbiAgICAgICAgTyhuXjIpXG4gICAgKi9cbiAgICAvKlxuICAgIFBvbHlLLklzU2ltcGxlID0gZnVuY3Rpb24ocClcbiAgICB7XG4gICAgICAgIHZhciBuID0gcC5sZW5ndGg+PjE7XG4gICAgICAgIGlmKG48NCkgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBhMSA9IG5ldyBQb2x5Sy5fUCgpLCBhMiA9IG5ldyBQb2x5Sy5fUCgpO1xuICAgICAgICB2YXIgYjEgPSBuZXcgUG9seUsuX1AoKSwgYjIgPSBuZXcgUG9seUsuX1AoKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgUG9seUsuX1AoKTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGExLnggPSBwWzIqaSAgXTtcbiAgICAgICAgICAgIGExLnkgPSBwWzIqaSsxXTtcbiAgICAgICAgICAgIGlmKGk9PW4tMSkgIHsgYTIueCA9IHBbMCAgICBdOyAgYTIueSA9IHBbMSAgICBdOyB9XG4gICAgICAgICAgICBlbHNlICAgICAgICB7IGEyLnggPSBwWzIqaSsyXTsgIGEyLnkgPSBwWzIqaSszXTsgfVxuXG4gICAgICAgICAgICBmb3IodmFyIGo9MDsgajxuOyBqKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoaS1qKSA8IDIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmKGo9PW4tMSAmJiBpPT0wKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZihpPT1uLTEgJiYgaj09MCkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBiMS54ID0gcFsyKmogIF07XG4gICAgICAgICAgICAgICAgYjEueSA9IHBbMipqKzFdO1xuICAgICAgICAgICAgICAgIGlmKGo9PW4tMSkgIHsgYjIueCA9IHBbMCAgICBdOyAgYjIueSA9IHBbMSAgICBdOyB9XG4gICAgICAgICAgICAgICAgZWxzZSAgICAgICAgeyBiMi54ID0gcFsyKmorMl07ICBiMi55ID0gcFsyKmorM107IH1cblxuICAgICAgICAgICAgICAgIGlmKFBvbHlLLl9HZXRMaW5lSW50ZXJzZWN0aW9uKGExLGEyLGIxLGIyLGMpICE9IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBQb2x5Sy5Jc0NvbnZleCA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICBpZihwLmxlbmd0aDw2KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDQ7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgICAgICBpZighUG9seUsuX2NvbnZleChwW2ldLCBwW2krMV0sIHBbaSsyXSwgcFtpKzNdLCBwW2krNF0sIHBbaSs1XSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYoIVBvbHlLLl9jb252ZXgocFtsICBdLCBwW2wrMV0sIHBbbCsyXSwgcFtsKzNdLCBwWzBdLCBwWzFdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZighUG9seUsuX2NvbnZleChwW2wrMl0sIHBbbCszXSwgcFswICBdLCBwWzEgIF0sIHBbMl0sIHBbM10pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAqL1xuICAgIFBvbHlLLkdldEFyZWEgPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgaWYocC5sZW5ndGggPDYpIHJldHVybiAwO1xuICAgICAgICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgICAgICBzdW0gKz0gKHBbaSsyXS1wW2ldKSAqIChwW2krMV0rcFtpKzNdKTtcbiAgICAgICAgc3VtICs9IChwWzBdLXBbbF0pICogKHBbbCsxXStwWzFdKTtcbiAgICAgICAgcmV0dXJuIC0gc3VtICogMC41O1xuICAgIH1cbiAgICAvKlxuICAgIFBvbHlLLkdldEFBQkIgPSBmdW5jdGlvbihwKVxuICAgIHtcbiAgICAgICAgdmFyIG1pbnggPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1pbnkgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1heHggPSAtbWlueDtcbiAgICAgICAgdmFyIG1heHkgPSAtbWlueTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1pbnggPSBNYXRoLm1pbihtaW54LCBwW2kgIF0pO1xuICAgICAgICAgICAgbWF4eCA9IE1hdGgubWF4KG1heHgsIHBbaSAgXSk7XG4gICAgICAgICAgICBtaW55ID0gTWF0aC5taW4obWlueSwgcFtpKzFdKTtcbiAgICAgICAgICAgIG1heHkgPSBNYXRoLm1heChtYXh5LCBwW2krMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7eDptaW54LCB5Om1pbnksIHdpZHRoOm1heHgtbWlueCwgaGVpZ2h0Om1heHktbWlueX07XG4gICAgfVxuICAgICovXG5cbiAgICBQb2x5Sy5Ucmlhbmd1bGF0ZSA9IGZ1bmN0aW9uKHApXG4gICAge1xuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xuICAgICAgICBpZihuPDMpIHJldHVybiBbXTtcbiAgICAgICAgdmFyIHRncyA9IFtdO1xuICAgICAgICB2YXIgYXZsID0gW107XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKykgYXZsLnB1c2goaSk7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgYWwgPSBuO1xuICAgICAgICB3aGlsZShhbCA+IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpMCA9IGF2bFsoaSswKSVhbF07XG4gICAgICAgICAgICB2YXIgaTEgPSBhdmxbKGkrMSklYWxdO1xuICAgICAgICAgICAgdmFyIGkyID0gYXZsWyhpKzIpJWFsXTtcblxuICAgICAgICAgICAgdmFyIGF4ID0gcFsyKmkwXSwgIGF5ID0gcFsyKmkwKzFdO1xuICAgICAgICAgICAgdmFyIGJ4ID0gcFsyKmkxXSwgIGJ5ID0gcFsyKmkxKzFdO1xuICAgICAgICAgICAgdmFyIGN4ID0gcFsyKmkyXSwgIGN5ID0gcFsyKmkyKzFdO1xuXG4gICAgICAgICAgICB2YXIgZWFyRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKFBvbHlLLl9jb252ZXgoYXgsIGF5LCBieCwgYnksIGN4LCBjeSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWFyRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPGFsOyBqKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmkgPSBhdmxbal07XG4gICAgICAgICAgICAgICAgICAgIGlmKHZpPT1pMCB8fCB2aT09aTEgfHwgdmk9PWkyKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYoUG9seUsuX1BvaW50SW5UcmlhbmdsZShwWzIqdmldLCBwWzIqdmkrMV0sIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpKSB7ZWFyRm91bmQgPSBmYWxzZTsgYnJlYWs7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGVhckZvdW5kKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRncy5wdXNoKGkwLCBpMSwgaTIpO1xuICAgICAgICAgICAgICAgIGF2bC5zcGxpY2UoKGkrMSklYWwsIDEpO1xuICAgICAgICAgICAgICAgIGFsLS07XG4gICAgICAgICAgICAgICAgaT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaSsrID4gMyphbCkgYnJlYWs7ICAgICAgLy8gbm8gY29udmV4IGFuZ2xlcyA6KFxuICAgICAgICB9XG4gICAgICAgIHRncy5wdXNoKGF2bFswXSwgYXZsWzFdLCBhdmxbMl0pO1xuICAgICAgICByZXR1cm4gdGdzO1xuICAgIH1cbiAgICAvKlxuICAgIFBvbHlLLkNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbihwLCBweCwgcHkpXG4gICAge1xuICAgICAgICB2YXIgbiA9IHAubGVuZ3RoPj4xO1xuICAgICAgICB2YXIgYXgsIGF5LCBieCA9IHBbMipuLTJdLXB4LCBieSA9IHBbMipuLTFdLXB5O1xuICAgICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGF4ID0gYng7ICBheSA9IGJ5O1xuICAgICAgICAgICAgYnggPSBwWzIqaSAgXSAtIHB4O1xuICAgICAgICAgICAgYnkgPSBwWzIqaSsxXSAtIHB5O1xuICAgICAgICAgICAgaWYoYXk8IDAgJiYgYnk8IDApIGNvbnRpbnVlOyAgICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG9ud1wiXG4gICAgICAgICAgICBpZihheT49MCAmJiBieT49MCkgY29udGludWU7ICAgIC8vIGJvdGggXCJ1cFwiIG9yIGJvdGggXCJkb253XCJcbiAgICAgICAgICAgIGlmKGF4PCAwICYmIGJ4PCAwKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGx4ID0gYXggKyAoYngtYXgpKigtYXkpLyhieS1heSk7XG4gICAgICAgICAgICBpZihseD4wKSBkZXB0aCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZGVwdGggJiAxKSA9PSAxO1xuICAgIH1cblxuICAgIFBvbHlLLlNsaWNlID0gZnVuY3Rpb24ocCwgYXgsIGF5LCBieCwgYnkpXG4gICAge1xuICAgICAgICBpZihQb2x5Sy5Db250YWluc1BvaW50KHAsIGF4LCBheSkgfHwgUG9seUsuQ29udGFpbnNQb2ludChwLCBieCwgYnkpKSByZXR1cm4gW3Auc2xpY2UoMCldO1xuXG4gICAgICAgIHZhciBhID0gbmV3IFBvbHlLLl9QKGF4LCBheSk7XG4gICAgICAgIHZhciBiID0gbmV3IFBvbHlLLl9QKGJ4LCBieSk7XG4gICAgICAgIHZhciBpc2NzID0gW107ICAvLyBpbnRlcnNlY3Rpb25zXG4gICAgICAgIHZhciBwcyA9IFtdOyAgICAvLyBwb2ludHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrPTIpIHBzLnB1c2gobmV3IFBvbHlLLl9QKHBbaV0sIHBbaSsxXSkpO1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHBzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaXNjID0gbmV3IFBvbHlLLl9QKDAsMCk7XG4gICAgICAgICAgICBpc2MgPSBQb2x5Sy5fR2V0TGluZUludGVyc2VjdGlvbihhLCBiLCBwc1tpXSwgcHNbKGkrMSklcHMubGVuZ3RoXSwgaXNjKTtcblxuICAgICAgICAgICAgaWYoaXNjKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlzYy5mbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpc2NzLnB1c2goaXNjKTtcbiAgICAgICAgICAgICAgICBwcy5zcGxpY2UoaSsxLDAsaXNjKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoaXNjcy5sZW5ndGggPT0gMCkgcmV0dXJuIFtwLnNsaWNlKDApXTtcbiAgICAgICAgdmFyIGNvbXAgPSBmdW5jdGlvbih1LHYpIHtyZXR1cm4gUG9seUsuX1AuZGlzdChhLHUpIC0gUG9seUsuX1AuZGlzdChhLHYpOyB9XG4gICAgICAgIGlzY3Muc29ydChjb21wKTtcblxuICAgICAgICB2YXIgcGdzID0gW107XG4gICAgICAgIHZhciBkaXIgPSAwO1xuICAgICAgICB3aGlsZShpc2NzLmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGkwID0gaXNjc1swXTtcbiAgICAgICAgICAgIHZhciBpMSA9IGlzY3NbMV07XG4gICAgICAgICAgICB2YXIgaW5kMCA9IHBzLmluZGV4T2YoaTApO1xuICAgICAgICAgICAgdmFyIGluZDEgPSBwcy5pbmRleE9mKGkxKTtcbiAgICAgICAgICAgIHZhciBzb2x2ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYoUG9seUsuX2ZpcnN0V2l0aEZsYWcocHMsIGluZDApID09IGluZDEpIHNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaTAgPSBpc2NzWzFdO1xuICAgICAgICAgICAgICAgIGkxID0gaXNjc1swXTtcbiAgICAgICAgICAgICAgICBpbmQwID0gcHMuaW5kZXhPZihpMCk7XG4gICAgICAgICAgICAgICAgaW5kMSA9IHBzLmluZGV4T2YoaTEpO1xuICAgICAgICAgICAgICAgIGlmKFBvbHlLLl9maXJzdFdpdGhGbGFnKHBzLCBpbmQwKSA9PSBpbmQxKSBzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc29sdmVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpci0tO1xuICAgICAgICAgICAgICAgIHZhciBwZ24gPSBQb2x5Sy5fZ2V0UG9pbnRzKHBzLCBpbmQwLCBpbmQxKTtcbiAgICAgICAgICAgICAgICBwZ3MucHVzaChwZ24pO1xuICAgICAgICAgICAgICAgIHBzID0gUG9seUsuX2dldFBvaW50cyhwcywgaW5kMSwgaW5kMCk7XG4gICAgICAgICAgICAgICAgaTAuZmxhZyA9IGkxLmZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc2NzLnNwbGljZSgwLDIpO1xuICAgICAgICAgICAgICAgIGlmKGlzY3MubGVuZ3RoID09IDApIHBncy5wdXNoKHBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyBkaXIrKzsgaXNjcy5yZXZlcnNlKCk7IH1cbiAgICAgICAgICAgIGlmKGRpcj4xKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHBncy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBnID0gcGdzW2ldO1xuICAgICAgICAgICAgdmFyIG5wZyA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8cGcubGVuZ3RoOyBqKyspIG5wZy5wdXNoKHBnW2pdLngsIHBnW2pdLnkpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnBnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIFBvbHlLLlJheWNhc3QgPSBmdW5jdGlvbihwLCB4LCB5LCBkeCwgZHksIGlzYylcbiAgICB7XG4gICAgICAgIHZhciBsID0gcC5sZW5ndGggLSAyO1xuICAgICAgICB2YXIgdHAgPSBQb2x5Sy5fdHA7XG4gICAgICAgIHZhciBhMSA9IHRwWzBdLCBhMiA9IHRwWzFdLFxuICAgICAgICBiMSA9IHRwWzJdLCBiMiA9IHRwWzNdLCBjID0gdHBbNF07XG4gICAgICAgIGExLnggPSB4OyBhMS55ID0geTtcbiAgICAgICAgYTIueCA9IHgrZHg7IGEyLnkgPSB5K2R5O1xuXG4gICAgICAgIGlmKGlzYz09bnVsbCkgaXNjID0ge2Rpc3Q6MCwgZWRnZTowLCBub3JtOnt4OjAsIHk6MH0sIHJlZmw6e3g6MCwgeTowfX07XG4gICAgICAgIGlzYy5kaXN0ID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bDsgaSs9MilcbiAgICAgICAge1xuICAgICAgICAgICAgYjEueCA9IHBbaSAgXTsgIGIxLnkgPSBwW2krMV07XG4gICAgICAgICAgICBiMi54ID0gcFtpKzJdOyAgYjIueSA9IHBbaSszXTtcbiAgICAgICAgICAgIHZhciBuaXNjID0gUG9seUsuX1JheUxpbmVJbnRlcnNlY3Rpb24oYTEsIGEyLCBiMSwgYjIsIGMpO1xuICAgICAgICAgICAgaWYobmlzYykgUG9seUsuX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIGkvMiwgaXNjKTtcbiAgICAgICAgfVxuICAgICAgICBiMS54ID0gYjIueDsgIGIxLnkgPSBiMi55O1xuICAgICAgICBiMi54ID0gcFswXTsgIGIyLnkgPSBwWzFdO1xuICAgICAgICB2YXIgbmlzYyA9IFBvbHlLLl9SYXlMaW5lSW50ZXJzZWN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKTtcbiAgICAgICAgaWYobmlzYykgUG9seUsuX3VwZGF0ZUlTQyhkeCwgZHksIGExLCBiMSwgYjIsIGMsIHAubGVuZ3RoLzIsIGlzYyk7XG5cbiAgICAgICAgcmV0dXJuIChpc2MuZGlzdCAhPSBJbmZpbml0eSkgPyBpc2MgOiBudWxsO1xuICAgIH1cblxuICAgIFBvbHlLLkNsb3Nlc3RFZGdlID0gZnVuY3Rpb24ocCwgeCwgeSwgaXNjKVxuICAgIHtcbiAgICAgICAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XG4gICAgICAgIHZhciB0cCA9IFBvbHlLLl90cDtcbiAgICAgICAgdmFyIGExID0gdHBbMF0sXG4gICAgICAgIGIxID0gdHBbMl0sIGIyID0gdHBbM10sIGMgPSB0cFs0XTtcbiAgICAgICAgYTEueCA9IHg7IGExLnkgPSB5O1xuXG4gICAgICAgIGlmKGlzYz09bnVsbCkgaXNjID0ge2Rpc3Q6MCwgZWRnZTowLCBwb2ludDp7eDowLCB5OjB9LCBub3JtOnt4OjAsIHk6MH19O1xuICAgICAgICBpc2MuZGlzdCA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGw7IGkrPTIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGIxLnggPSBwW2kgIF07ICBiMS55ID0gcFtpKzFdO1xuICAgICAgICAgICAgYjIueCA9IHBbaSsyXTsgIGIyLnkgPSBwW2krM107XG4gICAgICAgICAgICBQb2x5Sy5fcG9pbnRMaW5lRGlzdChhMSwgYjEsIGIyLCBpPj4xLCBpc2MpO1xuICAgICAgICB9XG4gICAgICAgIGIxLnggPSBiMi54OyAgYjEueSA9IGIyLnk7XG4gICAgICAgIGIyLnggPSBwWzBdOyAgYjIueSA9IHBbMV07XG4gICAgICAgIFBvbHlLLl9wb2ludExpbmVEaXN0KGExLCBiMSwgYjIsIGw+PjEsIGlzYyk7XG5cbiAgICAgICAgdmFyIGlkc3QgPSAxL2lzYy5kaXN0O1xuICAgICAgICBpc2Mubm9ybS54ID0gKHgtaXNjLnBvaW50LngpKmlkc3Q7XG4gICAgICAgIGlzYy5ub3JtLnkgPSAoeS1pc2MucG9pbnQueSkqaWRzdDtcbiAgICAgICAgcmV0dXJuIGlzYztcbiAgICB9XG5cbiAgICBQb2x5Sy5fcG9pbnRMaW5lRGlzdCA9IGZ1bmN0aW9uKHAsIGEsIGIsIGVkZ2UsIGlzYylcbiAgICB7XG4gICAgICAgIHZhciB4ID0gcC54LCB5ID0gcC55LCB4MSA9IGEueCwgeTEgPSBhLnksIHgyID0gYi54LCB5MiA9IGIueTtcblxuICAgICAgICB2YXIgQSA9IHggLSB4MTtcbiAgICAgICAgdmFyIEIgPSB5IC0geTE7XG4gICAgICAgIHZhciBDID0geDIgLSB4MTtcbiAgICAgICAgdmFyIEQgPSB5MiAtIHkxO1xuXG4gICAgICAgIHZhciBkb3QgPSBBICogQyArIEIgKiBEO1xuICAgICAgICB2YXIgbGVuX3NxID0gQyAqIEMgKyBEICogRDtcbiAgICAgICAgdmFyIHBhcmFtID0gZG90IC8gbGVuX3NxO1xuXG4gICAgICAgIHZhciB4eCwgeXk7XG5cbiAgICAgICAgaWYgKHBhcmFtIDwgMCB8fCAoeDEgPT0geDIgJiYgeTEgPT0geTIpKSB7XG4gICAgICAgICAgICB4eCA9IHgxO1xuICAgICAgICAgICAgeXkgPSB5MTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbSA+IDEpIHtcbiAgICAgICAgICAgIHh4ID0geDI7XG4gICAgICAgICAgICB5eSA9IHkyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeHggPSB4MSArIHBhcmFtICogQztcbiAgICAgICAgICAgIHl5ID0geTEgKyBwYXJhbSAqIEQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSB4IC0geHg7XG4gICAgICAgIHZhciBkeSA9IHkgLSB5eTtcbiAgICAgICAgdmFyIGRzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIGlmKGRzdDxpc2MuZGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgaXNjLmRpc3QgPSBkc3Q7XG4gICAgICAgICAgICBpc2MuZWRnZSA9IGVkZ2U7XG4gICAgICAgICAgICBpc2MucG9pbnQueCA9IHh4O1xuICAgICAgICAgICAgaXNjLnBvaW50LnkgPSB5eTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFBvbHlLLl91cGRhdGVJU0MgPSBmdW5jdGlvbihkeCwgZHksIGExLCBiMSwgYjIsIGMsIGVkZ2UsIGlzYylcbiAgICB7XG4gICAgICAgIHZhciBucmwgPSBQb2x5Sy5fUC5kaXN0KGExLCBjKTtcbiAgICAgICAgaWYobnJsPGlzYy5kaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaWJsID0gMS9Qb2x5Sy5fUC5kaXN0KGIxLCBiMik7XG4gICAgICAgICAgICB2YXIgbnggPSAtKGIyLnktYjEueSkqaWJsO1xuICAgICAgICAgICAgdmFyIG55ID0gIChiMi54LWIxLngpKmlibDtcbiAgICAgICAgICAgIHZhciBkZG90ID0gMiooZHgqbngrZHkqbnkpO1xuICAgICAgICAgICAgaXNjLmRpc3QgPSBucmw7XG4gICAgICAgICAgICBpc2Mubm9ybS54ID0gbng7XG4gICAgICAgICAgICBpc2Mubm9ybS55ID0gbnk7XG4gICAgICAgICAgICBpc2MucmVmbC54ID0gLWRkb3QqbngrZHg7XG4gICAgICAgICAgICBpc2MucmVmbC55ID0gLWRkb3QqbnkrZHk7XG4gICAgICAgICAgICBpc2MuZWRnZSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBQb2x5Sy5fZ2V0UG9pbnRzID0gZnVuY3Rpb24ocHMsIGluZDAsIGluZDEpXG4gICAge1xuICAgICAgICB2YXIgbiA9IHBzLmxlbmd0aDtcbiAgICAgICAgdmFyIG5wcyA9IFtdO1xuICAgICAgICBpZihpbmQxPGluZDApIGluZDEgKz0gbjtcbiAgICAgICAgZm9yKHZhciBpPWluZDA7IGk8PSBpbmQxOyBpKyspIG5wcy5wdXNoKHBzW2klbl0pO1xuICAgICAgICByZXR1cm4gbnBzO1xuICAgIH1cblxuICAgIFBvbHlLLl9maXJzdFdpdGhGbGFnID0gZnVuY3Rpb24ocHMsIGluZClcbiAgICB7XG4gICAgICAgIHZhciBuID0gcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSh0cnVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbmQgPSAoaW5kKzEpJW47XG4gICAgICAgICAgICBpZihwc1tpbmRdLmZsYWcpIHJldHVybiBpbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKi9cbiAgICBQb2x5Sy5fUG9pbnRJblRyaWFuZ2xlID0gZnVuY3Rpb24ocHgsIHB5LCBheCwgYXksIGJ4LCBieSwgY3gsIGN5KVxuICAgIHtcbiAgICAgICAgdmFyIHYweCA9IGN4LWF4O1xuICAgICAgICB2YXIgdjB5ID0gY3ktYXk7XG4gICAgICAgIHZhciB2MXggPSBieC1heDtcbiAgICAgICAgdmFyIHYxeSA9IGJ5LWF5O1xuICAgICAgICB2YXIgdjJ4ID0gcHgtYXg7XG4gICAgICAgIHZhciB2MnkgPSBweS1heTtcblxuICAgICAgICB2YXIgZG90MDAgPSB2MHgqdjB4K3YweSp2MHk7XG4gICAgICAgIHZhciBkb3QwMSA9IHYweCp2MXgrdjB5KnYxeTtcbiAgICAgICAgdmFyIGRvdDAyID0gdjB4KnYyeCt2MHkqdjJ5O1xuICAgICAgICB2YXIgZG90MTEgPSB2MXgqdjF4K3YxeSp2MXk7XG4gICAgICAgIHZhciBkb3QxMiA9IHYxeCp2MngrdjF5KnYyeTtcblxuICAgICAgICB2YXIgaW52RGVub20gPSAxIC8gKGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxKTtcbiAgICAgICAgdmFyIHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XG4gICAgICAgIHZhciB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHBvaW50IGlzIGluIHRyaWFuZ2xlXG4gICAgICAgIHJldHVybiAodSA+PSAwKSAmJiAodiA+PSAwKSAmJiAodSArIHYgPCAxKTtcbiAgICB9XG4gICAgLypcbiAgICBQb2x5Sy5fUmF5TGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKVxuICAgIHtcbiAgICAgICAgdmFyIGRheCA9IChhMS54LWEyLngpLCBkYnggPSAoYjEueC1iMi54KTtcbiAgICAgICAgdmFyIGRheSA9IChhMS55LWEyLnkpLCBkYnkgPSAoYjEueS1iMi55KTtcblxuICAgICAgICB2YXIgRGVuID0gZGF4KmRieSAtIGRheSpkYng7XG4gICAgICAgIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGw7ICAvLyBwYXJhbGxlbFxuXG4gICAgICAgIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xuICAgICAgICB2YXIgQiA9IChiMS54ICogYjIueSAtIGIxLnkgKiBiMi54KTtcblxuICAgICAgICB2YXIgSSA9IGM7XG4gICAgICAgIHZhciBpRGVuID0gMS9EZW47XG4gICAgICAgIEkueCA9ICggQSpkYnggLSBkYXgqQiApICogaURlbjtcbiAgICAgICAgSS55ID0gKCBBKmRieSAtIGRheSpCICkgKiBpRGVuO1xuXG4gICAgICAgIGlmKCFQb2x5Sy5fSW5SZWN0KEksIGIxLCBiMikpIHJldHVybiBudWxsO1xuICAgICAgICBpZigoZGF5PjAgJiYgSS55PmExLnkpIHx8IChkYXk8MCAmJiBJLnk8YTEueSkpIHJldHVybiBudWxsO1xuICAgICAgICBpZigoZGF4PjAgJiYgSS54PmExLngpIHx8IChkYXg8MCAmJiBJLng8YTEueCkpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gSTtcbiAgICB9XG5cbiAgICBQb2x5Sy5fR2V0TGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKVxuICAgIHtcbiAgICAgICAgdmFyIGRheCA9IChhMS54LWEyLngpLCBkYnggPSAoYjEueC1iMi54KTtcbiAgICAgICAgdmFyIGRheSA9IChhMS55LWEyLnkpLCBkYnkgPSAoYjEueS1iMi55KTtcblxuICAgICAgICB2YXIgRGVuID0gZGF4KmRieSAtIGRheSpkYng7XG4gICAgICAgIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGw7ICAvLyBwYXJhbGxlbFxuXG4gICAgICAgIHZhciBBID0gKGExLnggKiBhMi55IC0gYTEueSAqIGEyLngpO1xuICAgICAgICB2YXIgQiA9IChiMS54ICogYjIueSAtIGIxLnkgKiBiMi54KTtcblxuICAgICAgICB2YXIgSSA9IGM7XG4gICAgICAgIEkueCA9ICggQSpkYnggLSBkYXgqQiApIC8gRGVuO1xuICAgICAgICBJLnkgPSAoIEEqZGJ5IC0gZGF5KkIgKSAvIERlbjtcblxuICAgICAgICBpZihQb2x5Sy5fSW5SZWN0KEksIGExLCBhMikgJiYgUG9seUsuX0luUmVjdChJLCBiMSwgYjIpKSByZXR1cm4gSTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgUG9seUsuX0luUmVjdCA9IGZ1bmN0aW9uKGEsIGIsIGMpXG4gICAge1xuICAgICAgICBpZiAgKGIueCA9PSBjLngpIHJldHVybiAoYS55Pj1NYXRoLm1pbihiLnksIGMueSkgJiYgYS55PD1NYXRoLm1heChiLnksIGMueSkpO1xuICAgICAgICBpZiAgKGIueSA9PSBjLnkpIHJldHVybiAoYS54Pj1NYXRoLm1pbihiLngsIGMueCkgJiYgYS54PD1NYXRoLm1heChiLngsIGMueCkpO1xuXG4gICAgICAgIGlmKGEueCA+PSBNYXRoLm1pbihiLngsIGMueCkgJiYgYS54IDw9IE1hdGgubWF4KGIueCwgYy54KVxuICAgICAgICAmJiBhLnkgPj0gTWF0aC5taW4oYi55LCBjLnkpICYmIGEueSA8PSBNYXRoLm1heChiLnksIGMueSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgICovXG4gICAgUG9seUsuX2NvbnZleCA9IGZ1bmN0aW9uKGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpXG4gICAge1xuICAgICAgICByZXR1cm4gKGF5LWJ5KSooY3gtYngpICsgKGJ4LWF4KSooY3ktYnkpID49IDA7XG4gICAgfVxuICAgIC8qXG4gICAgUG9seUsuX1AgPSBmdW5jdGlvbih4LHkpXG4gICAge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLmZsYWcgPSBmYWxzZTtcbiAgICB9XG4gICAgUG9seUsuX1AucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIFwiUG9pbnQgW1wiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiXVwiO1xuICAgIH1cbiAgICBQb2x5Sy5fUC5kaXN0ID0gZnVuY3Rpb24oYSxiKVxuICAgIHtcbiAgICAgICAgdmFyIGR4ID0gYi54LWEueDtcbiAgICAgICAgdmFyIGR5ID0gYi55LWEueTtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCpkeCArIGR5KmR5KTtcbiAgICB9XG5cbiAgICBQb2x5Sy5fdHAgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTwxMDsgaSsrKSBQb2x5Sy5fdHAucHVzaChuZXcgUG9seUsuX1AoMCwwKSk7XG4gICAgICAgICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9seUs7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/math/polyk.js\n");

/***/ }),

/***/ "./node_modules/p2/src/math/vec2.js":
/*!******************************************!*\
  !*** ./node_modules/p2/src/math/vec2.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n/**\n * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net.\n * @class vec2\n */\n\nvar vec2 = module.exports = {};\n\nvar Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\");\n\n/**\n * Make a cross product and only return the z component\n * @method crossLength\n * @static\n * @param  {Array} a\n * @param  {Array} b\n * @return {Number}\n */\nvec2.crossLength = function(a,b){\n    return a[0] * b[1] - a[1] * b[0];\n};\n\n/**\n * Cross product between a vector and the Z component of a vector\n * @method crossVZ\n * @static\n * @param  {Array} out\n * @param  {Array} vec\n * @param  {Number} zcomp\n * @return {Number}\n */\nvec2.crossVZ = function(out, vec, zcomp){\n    vec2.rotate(out,vec,-Math.PI/2);// Rotate according to the right hand rule\n    vec2.scale(out,out,zcomp);      // Scale with z\n    return out;\n};\n\n/**\n * Cross product between a vector and the Z component of a vector\n * @method crossZV\n * @static\n * @param  {Array} out\n * @param  {Number} zcomp\n * @param  {Array} vec\n * @return {Number}\n */\nvec2.crossZV = function(out, zcomp, vec){\n    vec2.rotate(out,vec,Math.PI/2); // Rotate according to the right hand rule\n    vec2.scale(out,out,zcomp);      // Scale with z\n    return out;\n};\n\n/**\n * Rotate a vector by an angle\n * @method rotate\n * @static\n * @param  {Array} out\n * @param  {Array} a\n * @param  {Number} angle\n */\nvec2.rotate = function(out,a,angle){\n    if(angle !== 0){\n        var c = Math.cos(angle),\n            s = Math.sin(angle),\n            x = a[0],\n            y = a[1];\n        out[0] = c*x -s*y;\n        out[1] = s*x +c*y;\n    } else {\n        out[0] = a[0];\n        out[1] = a[1];\n    }\n};\n\n/**\n * Rotate a vector 90 degrees clockwise\n * @method rotate90cw\n * @static\n * @param  {Array} out\n * @param  {Array} a\n * @param  {Number} angle\n */\nvec2.rotate90cw = function(out, a) {\n    var x = a[0];\n    var y = a[1];\n    out[0] = y;\n    out[1] = -x;\n};\n\n/**\n * Transform a point position to local frame.\n * @method toLocalFrame\n * @param  {Array} out\n * @param  {Array} worldPoint\n * @param  {Array} framePosition\n * @param  {Number} frameAngle\n */\nvec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle){\n    vec2.copy(out, worldPoint);\n    vec2.sub(out, out, framePosition);\n    vec2.rotate(out, out, -frameAngle);\n};\n\n/**\n * Transform a point position to global frame.\n * @method toGlobalFrame\n * @param  {Array} out\n * @param  {Array} localPoint\n * @param  {Array} framePosition\n * @param  {Number} frameAngle\n */\nvec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle){\n    vec2.copy(out, localPoint);\n    vec2.rotate(out, out, frameAngle);\n    vec2.add(out, out, framePosition);\n};\n\n/**\n * Transform a vector to local frame.\n * @method vectorToLocalFrame\n * @param  {Array} out\n * @param  {Array} worldVector\n * @param  {Number} frameAngle\n */\nvec2.vectorToLocalFrame = function(out, worldVector, frameAngle){\n    vec2.rotate(out, worldVector, -frameAngle);\n};\n\n/**\n * Transform a point position to global frame.\n * @method toGlobalFrame\n * @param  {Array} out\n * @param  {Array} localVector\n * @param  {Number} frameAngle\n */\nvec2.vectorToGlobalFrame = function(out, localVector, frameAngle){\n    vec2.rotate(out, localVector, frameAngle);\n};\n\n/**\n * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php\n * @method centroid\n * @static\n * @param  {Array} out\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return  {Array} The out object\n */\nvec2.centroid = function(out, a, b, c){\n    vec2.add(out, a, b);\n    vec2.add(out, out, c);\n    vec2.scale(out, out, 1/3);\n    return out;\n};\n\n/**\n * Creates a new, empty vec2\n * @static\n * @method create\n * @return {Array} a new 2D vector\n */\nvec2.create = function() {\n    var out = new Utils.ARRAY_TYPE(2);\n    out[0] = 0;\n    out[1] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n * @static\n * @method clone\n * @param {Array} a vector to clone\n * @return {Array} a new 2D vector\n */\nvec2.clone = function(a) {\n    var out = new Utils.ARRAY_TYPE(2);\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with the given values\n * @static\n * @method fromValues\n * @param {Number} x X component\n * @param {Number} y Y component\n * @return {Array} a new 2D vector\n */\nvec2.fromValues = function(x, y) {\n    var out = new Utils.ARRAY_TYPE(2);\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Copy the values from one vec2 to another\n * @static\n * @method copy\n * @param {Array} out the receiving vector\n * @param {Array} a the source vector\n * @return {Array} out\n */\nvec2.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Set the components of a vec2 to the given values\n * @static\n * @method set\n * @param {Array} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @return {Array} out\n */\nvec2.set = function(out, x, y) {\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Adds two vec2's\n * @static\n * @method add\n * @param {Array} out the receiving vector\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Array} out\n */\nvec2.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    return out;\n};\n\n/**\n * Subtracts two vec2's\n * @static\n * @method subtract\n * @param {Array} out the receiving vector\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Array} out\n */\nvec2.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    return out;\n};\n\n/**\n * Alias for vec2.subtract\n * @static\n * @method sub\n */\nvec2.sub = vec2.subtract;\n\n/**\n * Multiplies two vec2's\n * @static\n * @method multiply\n * @param {Array} out the receiving vector\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Array} out\n */\nvec2.multiply = function(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    return out;\n};\n\n/**\n * Alias for vec2.multiply\n * @static\n * @method mul\n */\nvec2.mul = vec2.multiply;\n\n/**\n * Divides two vec2's\n * @static\n * @method divide\n * @param {Array} out the receiving vector\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Array} out\n */\nvec2.divide = function(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    return out;\n};\n\n/**\n * Alias for vec2.divide\n * @static\n * @method div\n */\nvec2.div = vec2.divide;\n\n/**\n * Scales a vec2 by a scalar number\n * @static\n * @method scale\n * @param {Array} out the receiving vector\n * @param {Array} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @return {Array} out\n */\nvec2.scale = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec2's\n * @static\n * @method distance\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Number} distance between a and b\n */\nvec2.distance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return Math.sqrt(x*x + y*y);\n};\n\n/**\n * Alias for vec2.distance\n * @static\n * @method dist\n */\nvec2.dist = vec2.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n * @static\n * @method squaredDistance\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Number} squared distance between a and b\n */\nvec2.squaredDistance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return x*x + y*y;\n};\n\n/**\n * Alias for vec2.squaredDistance\n * @static\n * @method sqrDist\n */\nvec2.sqrDist = vec2.squaredDistance;\n\n/**\n * Calculates the length of a vec2\n * @static\n * @method length\n * @param {Array} a vector to calculate length of\n * @return {Number} length of a\n */\nvec2.length = function (a) {\n    var x = a[0],\n        y = a[1];\n    return Math.sqrt(x*x + y*y);\n};\n\n/**\n * Alias for vec2.length\n * @method len\n * @static\n */\nvec2.len = vec2.length;\n\n/**\n * Calculates the squared length of a vec2\n * @static\n * @method squaredLength\n * @param {Array} a vector to calculate squared length of\n * @return {Number} squared length of a\n */\nvec2.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1];\n    return x*x + y*y;\n};\n\n/**\n * Alias for vec2.squaredLength\n * @static\n * @method sqrLen\n */\nvec2.sqrLen = vec2.squaredLength;\n\n/**\n * Negates the components of a vec2\n * @static\n * @method negate\n * @param {Array} out the receiving vector\n * @param {Array} a vector to negate\n * @return {Array} out\n */\nvec2.negate = function(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    return out;\n};\n\n/**\n * Normalize a vec2\n * @static\n * @method normalize\n * @param {Array} out the receiving vector\n * @param {Array} a vector to normalize\n * @return {Array} out\n */\nvec2.normalize = function(out, a) {\n    var x = a[0],\n        y = a[1];\n    var len = x*x + y*y;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n        out[0] = a[0] * len;\n        out[1] = a[1] * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec2's\n * @static\n * @method dot\n * @param {Array} a the first operand\n * @param {Array} b the second operand\n * @return {Number} dot product of a and b\n */\nvec2.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n};\n\n/**\n * Returns a string representation of a vector\n * @static\n * @method str\n * @param {Array} vec vector to represent as a string\n * @return {String} string representation of the vector\n */\nvec2.str = function (a) {\n    return 'vec2(' + a[0] + ', ' + a[1] + ')';\n};\n\n/**\n * Linearly interpolate/mix two vectors.\n * @static\n * @method lerp\n * @param {Array} out\n * @param {Array} a First vector\n * @param {Array} b Second vector\n * @param {number} t Lerp factor\n */\nvec2.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    return out;\n};\n\n/**\n * Reflect a vector along a normal.\n * @static\n * @method reflect\n * @param {Array} out\n * @param {Array} vector\n * @param {Array} normal\n */\nvec2.reflect = function(out, vector, normal){\n    var dot = vector[0] * normal[0] + vector[1] * normal[1];\n    out[0] = vector[0] - 2 * normal[0] * dot;\n    out[1] = vector[1] - 2 * normal[1] * dot;\n};\n\n/**\n * Get the intersection point between two line segments.\n * @static\n * @method getLineSegmentsIntersection\n * @param  {Array} out\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {Array} p2\n * @param  {Array} p3\n * @return {boolean} True if there was an intersection, otherwise false.\n */\nvec2.getLineSegmentsIntersection = function(out, p0, p1, p2, p3) {\n    var t = vec2.getLineSegmentsIntersectionFraction(p0, p1, p2, p3);\n    if(t < 0){\n        return false;\n    } else {\n        out[0] = p0[0] + (t * (p1[0] - p0[0]));\n        out[1] = p0[1] + (t * (p1[1] - p0[1]));\n        return true;\n    }\n};\n\n/**\n * Get the intersection fraction between two line segments. If successful, the intersection is at p0 + t * (p1 - p0)\n * @static\n * @method getLineSegmentsIntersectionFraction\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {Array} p2\n * @param  {Array} p3\n * @return {number} A number between 0 and 1 if there was an intersection, otherwise -1.\n */\nvec2.getLineSegmentsIntersectionFraction = function(p0, p1, p2, p3) {\n    var s1_x = p1[0] - p0[0];\n    var s1_y = p1[1] - p0[1];\n    var s2_x = p3[0] - p2[0];\n    var s2_y = p3[1] - p2[1];\n\n    var s, t;\n    s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);\n    t = ( s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) { // Collision detected\n        return t;\n    }\n    return -1; // No collision\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL21hdGgvdmVjMi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvbWF0aC92ZWMyLmpzP2M3M2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogVGhlIHZlYzIgb2JqZWN0IGZyb20gZ2xNYXRyaXgsIHdpdGggc29tZSBleHRlbnNpb25zIGFuZCBzb21lIHJlbW92ZWQgbWV0aG9kcy4gU2VlIGh0dHA6Ly9nbG1hdHJpeC5uZXQuXG4gKiBAY2xhc3MgdmVjMlxuICovXG5cbnZhciB2ZWMyID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudmFyIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKTtcblxuLyoqXG4gKiBNYWtlIGEgY3Jvc3MgcHJvZHVjdCBhbmQgb25seSByZXR1cm4gdGhlIHogY29tcG9uZW50XG4gKiBAbWV0aG9kIGNyb3NzTGVuZ3RoXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7QXJyYXl9IGJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmVjMi5jcm9zc0xlbmd0aCA9IGZ1bmN0aW9uKGEsYil7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG59O1xuXG4vKipcbiAqIENyb3NzIHByb2R1Y3QgYmV0d2VlbiBhIHZlY3RvciBhbmQgdGhlIFogY29tcG9uZW50IG9mIGEgdmVjdG9yXG4gKiBAbWV0aG9kIGNyb3NzVlpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSB2ZWNcbiAqIEBwYXJhbSAge051bWJlcn0gemNvbXBcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmVjMi5jcm9zc1ZaID0gZnVuY3Rpb24ob3V0LCB2ZWMsIHpjb21wKXtcbiAgICB2ZWMyLnJvdGF0ZShvdXQsdmVjLC1NYXRoLlBJLzIpOy8vIFJvdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIHJpZ2h0IGhhbmQgcnVsZVxuICAgIHZlYzIuc2NhbGUob3V0LG91dCx6Y29tcCk7ICAgICAgLy8gU2NhbGUgd2l0aCB6XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIGEgdmVjdG9yIGFuZCB0aGUgWiBjb21wb25lbnQgb2YgYSB2ZWN0b3JcbiAqIEBtZXRob2QgY3Jvc3NaVlxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7TnVtYmVyfSB6Y29tcFxuICogQHBhcmFtICB7QXJyYXl9IHZlY1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52ZWMyLmNyb3NzWlYgPSBmdW5jdGlvbihvdXQsIHpjb21wLCB2ZWMpe1xuICAgIHZlYzIucm90YXRlKG91dCx2ZWMsTWF0aC5QSS8yKTsgLy8gUm90YXRlIGFjY29yZGluZyB0byB0aGUgcmlnaHQgaGFuZCBydWxlXG4gICAgdmVjMi5zY2FsZShvdXQsb3V0LHpjb21wKTsgICAgICAvLyBTY2FsZSB3aXRoIHpcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSB2ZWN0b3IgYnkgYW4gYW5nbGVcbiAqIEBtZXRob2Qgcm90YXRlXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG52ZWMyLnJvdGF0ZSA9IGZ1bmN0aW9uKG91dCxhLGFuZ2xlKXtcbiAgICBpZihhbmdsZSAhPT0gMCl7XG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgcyA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIHggPSBhWzBdLFxuICAgICAgICAgICAgeSA9IGFbMV07XG4gICAgICAgIG91dFswXSA9IGMqeCAtcyp5O1xuICAgICAgICBvdXRbMV0gPSBzKnggK2MqeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzFdO1xuICAgIH1cbn07XG5cbi8qKlxuICogUm90YXRlIGEgdmVjdG9yIDkwIGRlZ3JlZXMgY2xvY2t3aXNlXG4gKiBAbWV0aG9kIHJvdGF0ZTkwY3dcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbnZlYzIucm90YXRlOTBjdyA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXTtcbiAgICB2YXIgeSA9IGFbMV07XG4gICAgb3V0WzBdID0geTtcbiAgICBvdXRbMV0gPSAteDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcG9pbnQgcG9zaXRpb24gdG8gbG9jYWwgZnJhbWUuXG4gKiBAbWV0aG9kIHRvTG9jYWxGcmFtZVxuICogQHBhcmFtICB7QXJyYXl9IG91dFxuICogQHBhcmFtICB7QXJyYXl9IHdvcmxkUG9pbnRcbiAqIEBwYXJhbSAge0FycmF5fSBmcmFtZVBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGZyYW1lQW5nbGVcbiAqL1xudmVjMi50b0xvY2FsRnJhbWUgPSBmdW5jdGlvbihvdXQsIHdvcmxkUG9pbnQsIGZyYW1lUG9zaXRpb24sIGZyYW1lQW5nbGUpe1xuICAgIHZlYzIuY29weShvdXQsIHdvcmxkUG9pbnQpO1xuICAgIHZlYzIuc3ViKG91dCwgb3V0LCBmcmFtZVBvc2l0aW9uKTtcbiAgICB2ZWMyLnJvdGF0ZShvdXQsIG91dCwgLWZyYW1lQW5nbGUpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBwb2ludCBwb3NpdGlvbiB0byBnbG9iYWwgZnJhbWUuXG4gKiBAbWV0aG9kIHRvR2xvYmFsRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSBsb2NhbFBvaW50XG4gKiBAcGFyYW0gIHtBcnJheX0gZnJhbWVQb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXG4gKi9cbnZlYzIudG9HbG9iYWxGcmFtZSA9IGZ1bmN0aW9uKG91dCwgbG9jYWxQb2ludCwgZnJhbWVQb3NpdGlvbiwgZnJhbWVBbmdsZSl7XG4gICAgdmVjMi5jb3B5KG91dCwgbG9jYWxQb2ludCk7XG4gICAgdmVjMi5yb3RhdGUob3V0LCBvdXQsIGZyYW1lQW5nbGUpO1xuICAgIHZlYzIuYWRkKG91dCwgb3V0LCBmcmFtZVBvc2l0aW9uKTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgdmVjdG9yIHRvIGxvY2FsIGZyYW1lLlxuICogQG1ldGhvZCB2ZWN0b3JUb0xvY2FsRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSB3b3JsZFZlY3RvclxuICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXG4gKi9cbnZlYzIudmVjdG9yVG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ob3V0LCB3b3JsZFZlY3RvciwgZnJhbWVBbmdsZSl7XG4gICAgdmVjMi5yb3RhdGUob3V0LCB3b3JsZFZlY3RvciwgLWZyYW1lQW5nbGUpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBwb2ludCBwb3NpdGlvbiB0byBnbG9iYWwgZnJhbWUuXG4gKiBAbWV0aG9kIHRvR2xvYmFsRnJhbWVcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSBsb2NhbFZlY3RvclxuICogQHBhcmFtICB7TnVtYmVyfSBmcmFtZUFuZ2xlXG4gKi9cbnZlYzIudmVjdG9yVG9HbG9iYWxGcmFtZSA9IGZ1bmN0aW9uKG91dCwgbG9jYWxWZWN0b3IsIGZyYW1lQW5nbGUpe1xuICAgIHZlYzIucm90YXRlKG91dCwgbG9jYWxWZWN0b3IsIGZyYW1lQW5nbGUpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIGNlbnRyb2lkIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB2ZWN0b3JzIGEsYixjLiBTZWUgaHR0cDovL2Vhc3ljYWxjdWxhdGlvbi5jb20vYW5hbHl0aWNhbC9sZWFybi1jZW50cm9pZC5waHBcbiAqIEBtZXRob2QgY2VudHJvaWRcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEByZXR1cm4gIHtBcnJheX0gVGhlIG91dCBvYmplY3RcbiAqL1xudmVjMi5jZW50cm9pZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gICAgdmVjMi5hZGQob3V0LCBhLCBiKTtcbiAgICB2ZWMyLmFkZChvdXQsIG91dCwgYyk7XG4gICAgdmVjMi5zY2FsZShvdXQsIG91dCwgMS8zKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNyZWF0ZVxuICogQHJldHVybiB7QXJyYXl9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybiB7QXJyYXl9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBmcm9tVmFsdWVzXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBvdXQgPSBuZXcgVXRpbHMuQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdHdvIHZlYzInc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBzdWJ0cmFjdFxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIuc3VidHJhY3RcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgc3ViXG4gKi9cbnZlYzIuc3ViID0gdmVjMi5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbXVsdGlwbHlcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRcbiAqL1xudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLm11bHRpcGx5XG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG11bFxuICovXG52ZWMyLm11bCA9IHZlYzIubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRpdmlkZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLmRpdmlkZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXZcbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzY2FsZVxuICogQHBhcmFtIHtBcnJheX0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKi9cbnZlYzIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRpc3RhbmNlXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgdmVjMi5kaXN0YW5jZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBkaXN0XG4gKi9cbnZlYzIuZGlzdCA9IHZlYzIuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHNxdWFyZWREaXN0YW5jZVxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm4ge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB2ZWMyLnNxdWFyZWREaXN0YW5jZVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXJEaXN0XG4gKi9cbnZlYzIuc3FyRGlzdCA9IHZlYzIuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbGVuZ3RoXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIubGVuZ3RoXG4gKiBAbWV0aG9kIGxlblxuICogQHN0YXRpY1xuICovXG52ZWMyLmxlbiA9IHZlYzIubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXVhcmVkTGVuZ3RoXG4gKiBAcGFyYW0ge0FycmF5fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm4ge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMyLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHZlYzIuc3F1YXJlZExlbmd0aFxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzcXJMZW5cbiAqL1xudmVjMi5zcXJMZW4gPSB2ZWMyLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgbmVnYXRlXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICovXG52ZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZG90XG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge0FycmF5fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybiB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzIuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzdHJcbiAqIEBwYXJhbSB7QXJyYXl9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzIuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcpJztcbn07XG5cbi8qKlxuICogTGluZWFybHkgaW50ZXJwb2xhdGUvbWl4IHR3byB2ZWN0b3JzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBsZXJwXG4gKiBAcGFyYW0ge0FycmF5fSBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IGEgRmlyc3QgdmVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBiIFNlY29uZCB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSB0IExlcnAgZmFjdG9yXG4gKi9cbnZlYzIubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmVmbGVjdCBhIHZlY3RvciBhbG9uZyBhIG5vcm1hbC5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgcmVmbGVjdFxuICogQHBhcmFtIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0ge0FycmF5fSB2ZWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IG5vcm1hbFxuICovXG52ZWMyLnJlZmxlY3QgPSBmdW5jdGlvbihvdXQsIHZlY3Rvciwgbm9ybWFsKXtcbiAgICB2YXIgZG90ID0gdmVjdG9yWzBdICogbm9ybWFsWzBdICsgdmVjdG9yWzFdICogbm9ybWFsWzFdO1xuICAgIG91dFswXSA9IHZlY3RvclswXSAtIDIgKiBub3JtYWxbMF0gKiBkb3Q7XG4gICAgb3V0WzFdID0gdmVjdG9yWzFdIC0gMiAqIG5vcm1hbFsxXSAqIGRvdDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgYmV0d2VlbiB0d28gbGluZSBzZWdtZW50cy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gcDBcbiAqIEBwYXJhbSAge0FycmF5fSBwMVxuICogQHBhcmFtICB7QXJyYXl9IHAyXG4gKiBAcGFyYW0gIHtBcnJheX0gcDNcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlcmUgd2FzIGFuIGludGVyc2VjdGlvbiwgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG52ZWMyLmdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKG91dCwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgICB2YXIgdCA9IHZlYzIuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb24ocDAsIHAxLCBwMiwgcDMpO1xuICAgIGlmKHQgPCAwKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IHAwWzBdICsgKHQgKiAocDFbMF0gLSBwMFswXSkpO1xuICAgICAgICBvdXRbMV0gPSBwMFsxXSArICh0ICogKHAxWzFdIC0gcDBbMV0pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGludGVyc2VjdGlvbiBmcmFjdGlvbiBiZXR3ZWVuIHR3byBsaW5lIHNlZ21lbnRzLiBJZiBzdWNjZXNzZnVsLCB0aGUgaW50ZXJzZWN0aW9uIGlzIGF0IHAwICsgdCAqIChwMSAtIHAwKVxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvblxuICogQHBhcmFtICB7QXJyYXl9IHAwXG4gKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAqIEBwYXJhbSAge0FycmF5fSBwMlxuICogQHBhcmFtICB7QXJyYXl9IHAzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJzZWN0aW9uLCBvdGhlcndpc2UgLTEuXG4gKi9cbnZlYzIuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb24gPSBmdW5jdGlvbihwMCwgcDEsIHAyLCBwMykge1xuICAgIHZhciBzMV94ID0gcDFbMF0gLSBwMFswXTtcbiAgICB2YXIgczFfeSA9IHAxWzFdIC0gcDBbMV07XG4gICAgdmFyIHMyX3ggPSBwM1swXSAtIHAyWzBdO1xuICAgIHZhciBzMl95ID0gcDNbMV0gLSBwMlsxXTtcblxuICAgIHZhciBzLCB0O1xuICAgIHMgPSAoLXMxX3kgKiAocDBbMF0gLSBwMlswXSkgKyBzMV94ICogKHAwWzFdIC0gcDJbMV0pKSAvICgtczJfeCAqIHMxX3kgKyBzMV94ICogczJfeSk7XG4gICAgdCA9ICggczJfeCAqIChwMFsxXSAtIHAyWzFdKSAtIHMyX3kgKiAocDBbMF0gLSBwMlswXSkpIC8gKC1zMl94ICogczFfeSArIHMxX3ggKiBzMl95KTtcbiAgICBpZiAocyA+PSAwICYmIHMgPD0gMSAmJiB0ID49IDAgJiYgdCA8PSAxKSB7IC8vIENvbGxpc2lvbiBkZXRlY3RlZFxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgcmV0dXJuIC0xOyAvLyBObyBjb2xsaXNpb25cbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/math/vec2.js\n");

/***/ }),

/***/ "./node_modules/p2/src/objects/Body.js":
/*!*********************************************!*\
  !*** ./node_modules/p2/src/objects/Body.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,   decomp = __webpack_require__(/*! poly-decomp */ \"./node_modules/poly-decomp/src/index.js\")\n,   Convex = __webpack_require__(/*! ../shapes/Convex */ \"./node_modules/p2/src/shapes/Convex.js\")\n,   RaycastResult = __webpack_require__(/*! ../collision/RaycastResult */ \"./node_modules/p2/src/collision/RaycastResult.js\")\n,   Ray = __webpack_require__(/*! ../collision/Ray */ \"./node_modules/p2/src/collision/Ray.js\")\n,   AABB = __webpack_require__(/*! ../collision/AABB */ \"./node_modules/p2/src/collision/AABB.js\")\n,   EventEmitter = __webpack_require__(/*! ../events/EventEmitter */ \"./node_modules/p2/src/events/EventEmitter.js\");\n\nmodule.exports = Body;\n\n/**\n * A rigid body. Has got a center of mass, position, velocity and a number of\n * shapes that are used for collisions.\n *\n * @class Body\n * @constructor\n * @extends EventEmitter\n * @param {Object} [options]\n * @param {Array} [options.force]\n * @param {Array} [options.position]\n * @param {Array} [options.velocity]\n * @param {Boolean} [options.allowSleep]\n * @param {Boolean} [options.collisionResponse]\n * @param {Number} [options.angle=0]\n * @param {Number} [options.angularForce=0]\n * @param {Number} [options.angularVelocity=0]\n * @param {Number} [options.ccdIterations=10]\n * @param {Number} [options.ccdSpeedThreshold=-1]\n * @param {Number} [options.fixedRotation=false]\n * @param {Number} [options.gravityScale]\n * @param {Number} [options.id]\n * @param {Number} [options.mass=0] A number >= 0. If zero, the .type will be set to Body.STATIC.\n * @param {Number} [options.sleepSpeedLimit]\n * @param {Number} [options.sleepTimeLimit]\n *\n * @example\n *\n *     // Create a typical dynamic body\n *     var body = new Body({\n *         mass: 1,\n *         position: [0, 0],\n *         angle: 0,\n *         velocity: [0, 0],\n *         angularVelocity: 0\n *     });\n *\n *     // Add a circular shape to the body\n *     body.addShape(new Circle({ radius: 1 }));\n *\n *     // Add the body to the world\n *     world.addBody(body);\n */\nfunction Body(options){\n    options = options || {};\n\n    EventEmitter.call(this);\n\n    /**\n     * The body identifyer\n     * @property id\n     * @type {Number}\n     */\n    this.id = options.id || ++Body._idCounter;\n\n    /**\n     * The world that this body is added to. This property is set to NULL if the body is not added to any world.\n     * @property world\n     * @type {World}\n     */\n    this.world = null;\n\n    /**\n     * The shapes of the body.\n     *\n     * @property shapes\n     * @type {Array}\n     */\n    this.shapes = [];\n\n    /**\n     * The mass of the body.\n     * @property mass\n     * @type {number}\n     */\n    this.mass = options.mass || 0;\n\n    /**\n     * The inverse mass of the body.\n     * @property invMass\n     * @type {number}\n     */\n    this.invMass = 0;\n\n    /**\n     * The inertia of the body around the Z axis.\n     * @property inertia\n     * @type {number}\n     */\n    this.inertia = 0;\n\n    /**\n     * The inverse inertia of the body.\n     * @property invInertia\n     * @type {number}\n     */\n    this.invInertia = 0;\n\n    this.invMassSolve = 0;\n    this.invInertiaSolve = 0;\n\n    /**\n     * Set to true if you want to fix the rotation of the body.\n     * @property fixedRotation\n     * @type {Boolean}\n     */\n    this.fixedRotation = !!options.fixedRotation;\n\n    /**\n     * Set to true if you want to fix the body movement along the X axis. The body will still be able to move along Y.\n     * @property {Boolean} fixedX\n     */\n    this.fixedX = !!options.fixedX;\n\n    /**\n     * Set to true if you want to fix the body movement along the Y axis. The body will still be able to move along X.\n     * @property {Boolean} fixedY\n     */\n    this.fixedY = !!options.fixedY;\n\n    /**\n     * @private\n     * @property {array} massMultiplier\n     */\n    this.massMultiplier = vec2.create();\n\n    /**\n     * The position of the body\n     * @property position\n     * @type {Array}\n     */\n    this.position = vec2.fromValues(0,0);\n    if(options.position){\n        vec2.copy(this.position, options.position);\n    }\n\n    /**\n     * The interpolated position of the body. Use this for rendering.\n     * @property interpolatedPosition\n     * @type {Array}\n     */\n    this.interpolatedPosition = vec2.fromValues(0,0);\n\n    /**\n     * The interpolated angle of the body. Use this for rendering.\n     * @property interpolatedAngle\n     * @type {Number}\n     */\n    this.interpolatedAngle = 0;\n\n    /**\n     * The previous position of the body.\n     * @property previousPosition\n     * @type {Array}\n     */\n    this.previousPosition = vec2.fromValues(0,0);\n\n    /**\n     * The previous angle of the body.\n     * @property previousAngle\n     * @type {Number}\n     */\n    this.previousAngle = 0;\n\n    /**\n     * The current velocity of the body.\n     * @property velocity\n     * @type {Array}\n     */\n    this.velocity = vec2.fromValues(0,0);\n    if(options.velocity){\n        vec2.copy(this.velocity, options.velocity);\n    }\n\n    /**\n     * Constraint velocity that was added to the body during the last step.\n     * @property vlambda\n     * @type {Array}\n     */\n    this.vlambda = vec2.fromValues(0,0);\n\n    /**\n     * Angular constraint velocity that was added to the body during last step.\n     * @property wlambda\n     * @type {Array}\n     */\n    this.wlambda = 0;\n\n    /**\n     * The angle of the body, in radians.\n     * @property angle\n     * @type {number}\n     * @example\n     *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.\n     *     // If you need a value between 0 and 2*pi, use the following function to normalize it.\n     *     function normalizeAngle(angle){\n     *         angle = angle % (2*Math.PI);\n     *         if(angle < 0){\n     *             angle += (2*Math.PI);\n     *         }\n     *         return angle;\n     *     }\n     */\n    this.angle = options.angle || 0;\n\n    /**\n     * The angular velocity of the body, in radians per second.\n     * @property angularVelocity\n     * @type {number}\n     */\n    this.angularVelocity = options.angularVelocity || 0;\n\n    /**\n     * The force acting on the body. Since the body force (and {{#crossLink \"Body/angularForce:property\"}}{{/crossLink}}) will be zeroed after each step, so you need to set the force before each step.\n     * @property force\n     * @type {Array}\n     *\n     * @example\n     *     // This produces a forcefield of 1 Newton in the positive x direction.\n     *     for(var i=0; i<numSteps; i++){\n     *         body.force[0] = 1;\n     *         world.step(1/60);\n     *     }\n     *\n     * @example\n     *     // This will apply a rotational force on the body\n     *     for(var i=0; i<numSteps; i++){\n     *         body.angularForce = -3;\n     *         world.step(1/60);\n     *     }\n     */\n    this.force = vec2.create();\n    if(options.force){\n        vec2.copy(this.force, options.force);\n    }\n\n    /**\n     * The angular force acting on the body. See {{#crossLink \"Body/force:property\"}}{{/crossLink}}.\n     * @property angularForce\n     * @type {number}\n     */\n    this.angularForce = options.angularForce || 0;\n\n    /**\n     * The linear damping acting on the body in the velocity direction. Should be a value between 0 and 1.\n     * @property damping\n     * @type {Number}\n     * @default 0.1\n     */\n    this.damping = typeof(options.damping) === \"number\" ? options.damping : 0.1;\n\n    /**\n     * The angular force acting on the body. Should be a value between 0 and 1.\n     * @property angularDamping\n     * @type {Number}\n     * @default 0.1\n     */\n    this.angularDamping = typeof(options.angularDamping) === \"number\" ? options.angularDamping : 0.1;\n\n    /**\n     * The type of motion this body has. Should be one of: {{#crossLink \"Body/STATIC:property\"}}Body.STATIC{{/crossLink}}, {{#crossLink \"Body/DYNAMIC:property\"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink \"Body/KINEMATIC:property\"}}Body.KINEMATIC{{/crossLink}}.\n     *\n     * * Static bodies do not move, and they do not respond to forces or collision.\n     * * Dynamic bodies body can move and respond to collisions and forces.\n     * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.\n     *\n     * @property type\n     * @type {number}\n     *\n     * @example\n     *     // Bodies are static by default. Static bodies will never move.\n     *     var body = new Body();\n     *     console.log(body.type == Body.STATIC); // true\n     *\n     * @example\n     *     // By setting the mass of a body to a nonzero number, the body\n     *     // will become dynamic and will move and interact with other bodies.\n     *     var dynamicBody = new Body({\n     *         mass : 1\n     *     });\n     *     console.log(dynamicBody.type == Body.DYNAMIC); // true\n     *\n     * @example\n     *     // Kinematic bodies will only move if you change their velocity.\n     *     var kinematicBody = new Body({\n     *         type: Body.KINEMATIC // Type can be set via the options object.\n     *     });\n     */\n    this.type = Body.STATIC;\n\n    if(typeof(options.type) !== 'undefined'){\n        this.type = options.type;\n    } else if(!options.mass){\n        this.type = Body.STATIC;\n    } else {\n        this.type = Body.DYNAMIC;\n    }\n\n    /**\n     * Bounding circle radius.\n     * @property boundingRadius\n     * @type {Number}\n     */\n    this.boundingRadius = 0;\n\n    /**\n     * Bounding box of this body.\n     * @property aabb\n     * @type {AABB}\n     */\n    this.aabb = new AABB();\n\n    /**\n     * Indicates if the AABB needs update. Update it with {{#crossLink \"Body/updateAABB:method\"}}.updateAABB(){{/crossLink}}.\n     * @property aabbNeedsUpdate\n     * @type {Boolean}\n     * @see updateAABB\n     *\n     * @example\n     *     // Force update the AABB\n     *     body.aabbNeedsUpdate = true;\n     *     body.updateAABB();\n     *     console.log(body.aabbNeedsUpdate); // false\n     */\n    this.aabbNeedsUpdate = true;\n\n    /**\n     * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink \"World\"}}{{/crossLink}} before anything will happen.\n     * @property allowSleep\n     * @type {Boolean}\n     * @default true\n     */\n    this.allowSleep = options.allowSleep !== undefined ? options.allowSleep : true;\n\n    this.wantsToSleep = false;\n\n    /**\n     * One of {{#crossLink \"Body/AWAKE:property\"}}Body.AWAKE{{/crossLink}}, {{#crossLink \"Body/SLEEPY:property\"}}Body.SLEEPY{{/crossLink}} and {{#crossLink \"Body/SLEEPING:property\"}}Body.SLEEPING{{/crossLink}}.\n     *\n     * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).\n     *\n     * @property sleepState\n     * @type {Number}\n     * @default Body.AWAKE\n     */\n    this.sleepState = Body.AWAKE;\n\n    /**\n     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.\n     * @property sleepSpeedLimit\n     * @type {Number}\n     * @default 0.2\n     */\n    this.sleepSpeedLimit = options.sleepSpeedLimit !== undefined ? options.sleepSpeedLimit : 0.2;\n\n    /**\n     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.\n     * @property sleepTimeLimit\n     * @type {Number}\n     * @default 1\n     */\n    this.sleepTimeLimit = options.sleepTimeLimit !== undefined ? options.sleepTimeLimit : 1;\n\n    /**\n     * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.\n     * @property {Number} gravityScale\n     * @default 1\n     */\n    this.gravityScale = options.gravityScale !== undefined ? options.gravityScale : 1;\n\n    /**\n     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this body will move through other bodies, but it will still trigger contact events, etc.\n     * @property {Boolean} collisionResponse\n     */\n    this.collisionResponse = options.collisionResponse !== undefined ? options.collisionResponse : true;\n\n    /**\n     * How long the body has been sleeping.\n     * @property {Number} idleTime\n     */\n    this.idleTime = 0;\n\n    /**\n     * The last time when the body went to SLEEPY state.\n     * @property {Number} timeLastSleepy\n     * @private\n     */\n    this.timeLastSleepy = 0;\n\n    /**\n     * If the body speed exceeds this threshold, CCD (continuous collision detection) will be enabled. Set it to a negative number to disable CCD completely for this body.\n     * @property {number} ccdSpeedThreshold\n     * @default -1\n     */\n    this.ccdSpeedThreshold = options.ccdSpeedThreshold !== undefined ? options.ccdSpeedThreshold : -1;\n\n    /**\n     * The number of iterations that should be used when searching for the time of impact during CCD. A larger number will assure that there's a small penetration on CCD collision, but a small number will give more performance.\n     * @property {number} ccdIterations\n     * @default 10\n     */\n    this.ccdIterations = options.ccdIterations !== undefined ? options.ccdIterations : 10;\n\n    this.concavePath = null;\n\n    this._wakeUpAfterNarrowphase = false;\n\n    this.updateMassProperties();\n}\nBody.prototype = new EventEmitter();\nBody.prototype.constructor = Body;\n\nBody._idCounter = 0;\n\n/**\n * @private\n * @method updateSolveMassProperties\n */\nBody.prototype.updateSolveMassProperties = function(){\n    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){\n        this.invMassSolve = 0;\n        this.invInertiaSolve = 0;\n    } else {\n        this.invMassSolve = this.invMass;\n        this.invInertiaSolve = this.invInertia;\n    }\n};\n\n/**\n * Set the total density of the body\n * @method setDensity\n * @param {number} density\n */\nBody.prototype.setDensity = function(density) {\n    var totalArea = this.getArea();\n    this.mass = totalArea * density;\n    this.updateMassProperties();\n};\n\n/**\n * Get the total area of all shapes in the body\n * @method getArea\n * @return {Number}\n */\nBody.prototype.getArea = function() {\n    var totalArea = 0;\n    for(var i=0; i<this.shapes.length; i++){\n        totalArea += this.shapes[i].area;\n    }\n    return totalArea;\n};\n\n/**\n * Get the AABB from the body. The AABB is updated if necessary.\n * @method getAABB\n * @return {AABB} The AABB instance (this.aabb)\n */\nBody.prototype.getAABB = function(){\n    if(this.aabbNeedsUpdate){\n        this.updateAABB();\n    }\n    return this.aabb;\n};\n\nvar shapeAABB = new AABB(),\n    tmp = vec2.create();\n\n/**\n * Updates the AABB of the Body, and set .aabbNeedsUpdate = false.\n * @method updateAABB\n */\nBody.prototype.updateAABB = function() {\n    var shapes = this.shapes,\n        N = shapes.length,\n        offset = tmp,\n        bodyAngle = this.angle;\n\n    for(var i=0; i!==N; i++){\n        var shape = shapes[i],\n            angle = shape.angle + bodyAngle;\n\n        // Get shape world offset\n        vec2.rotate(offset, shape.position, bodyAngle);\n        vec2.add(offset, offset, this.position);\n\n        // Get shape AABB\n        shape.computeAABB(shapeAABB, offset, angle);\n\n        if(i===0){\n            this.aabb.copy(shapeAABB);\n        } else {\n            this.aabb.extend(shapeAABB);\n        }\n    }\n\n    this.aabbNeedsUpdate = false;\n};\n\n/**\n * Update the bounding radius of the body (this.boundingRadius). Should be done if any of the shape dimensions or positions are changed.\n * @method updateBoundingRadius\n */\nBody.prototype.updateBoundingRadius = function(){\n    var shapes = this.shapes,\n        N = shapes.length,\n        radius = 0;\n\n    for(var i=0; i!==N; i++){\n        var shape = shapes[i],\n            offset = vec2.length(shape.position),\n            r = shape.boundingRadius;\n        if(offset + r > radius){\n            radius = offset + r;\n        }\n    }\n\n    this.boundingRadius = radius;\n};\n\n/**\n * Add a shape to the body. You can pass a local transform when adding a shape,\n * so that the shape gets an offset and angle relative to the body center of mass.\n * Will automatically update the mass properties and bounding radius.\n *\n * @method addShape\n * @param  {Shape}              shape\n * @param  {Array} [offset] Local body offset of the shape.\n * @param  {Number}             [angle]  Local body angle.\n *\n * @example\n *     var body = new Body(),\n *         shape = new Circle({ radius: 1 });\n *\n *     // Add the shape to the body, positioned in the center\n *     body.addShape(shape);\n *\n *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.\n *     body.addShape(shape,[1,0]);\n *\n *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.\n *     body.addShape(shape,[0,1],Math.PI/2);\n */\nBody.prototype.addShape = function(shape, offset, angle){\n    if(shape.body){\n        throw new Error('A shape can only be added to one body.');\n    }\n    shape.body = this;\n\n    // Copy the offset vector\n    if(offset){\n        vec2.copy(shape.position, offset);\n    } else {\n        vec2.set(shape.position, 0, 0);\n    }\n\n    shape.angle = angle || 0;\n\n    this.shapes.push(shape);\n    this.updateMassProperties();\n    this.updateBoundingRadius();\n\n    this.aabbNeedsUpdate = true;\n};\n\n/**\n * Remove a shape\n * @method removeShape\n * @param  {Shape} shape\n * @return {Boolean} True if the shape was found and removed, else false.\n */\nBody.prototype.removeShape = function(shape){\n    var idx = this.shapes.indexOf(shape);\n\n    if(idx !== -1){\n        this.shapes.splice(idx,1);\n        this.aabbNeedsUpdate = true;\n        shape.body = null;\n        return true;\n    } else {\n        return false;\n    }\n};\n\n/**\n * Updates .inertia, .invMass, .invInertia for this Body. Should be called when\n * changing the structure or mass of the Body.\n *\n * @method updateMassProperties\n *\n * @example\n *     body.mass += 1;\n *     body.updateMassProperties();\n */\nBody.prototype.updateMassProperties = function(){\n    if(this.type === Body.STATIC || this.type === Body.KINEMATIC){\n\n        this.mass = Number.MAX_VALUE;\n        this.invMass = 0;\n        this.inertia = Number.MAX_VALUE;\n        this.invInertia = 0;\n\n    } else {\n\n        var shapes = this.shapes,\n            N = shapes.length,\n            m = this.mass / N,\n            I = 0;\n\n        if(!this.fixedRotation){\n            for(var i=0; i<N; i++){\n                var shape = shapes[i],\n                    r2 = vec2.squaredLength(shape.position),\n                    Icm = shape.computeMomentOfInertia(m);\n                I += Icm + m*r2;\n            }\n            this.inertia = I;\n            this.invInertia = I>0 ? 1/I : 0;\n\n        } else {\n            this.inertia = Number.MAX_VALUE;\n            this.invInertia = 0;\n        }\n\n        // Inverse mass properties are easy\n        this.invMass = 1 / this.mass;\n\n        vec2.set(\n            this.massMultiplier,\n            this.fixedX ? 0 : 1,\n            this.fixedY ? 0 : 1\n        );\n    }\n};\n\nvar Body_applyForce_r = vec2.create();\n\n/**\n * Apply force to a point relative to the center of mass of the body. This could for example be a point on the RigidBody surface. Applying force this way will add to Body.force and Body.angularForce. If relativePoint is zero, the force will be applied directly on the center of mass, and the torque produced will be zero.\n * @method applyForce\n * @param {Array} force The force to add.\n * @param {Array} [relativePoint] A world point to apply the force on.\n */\nBody.prototype.applyForce = function(force, relativePoint){\n\n    // Add linear force\n    vec2.add(this.force, this.force, force);\n\n    if(relativePoint){\n\n        // Compute produced rotational force\n        var rotForce = vec2.crossLength(relativePoint,force);\n\n        // Add rotational force\n        this.angularForce += rotForce;\n    }\n};\n\n/**\n * Apply force to a body-local point.\n * @method applyForceLocal\n * @param  {Array} localForce The force vector to add, oriented in local body space.\n * @param  {Array} [localPoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.\n */\nvar Body_applyForce_forceWorld = vec2.create();\nvar Body_applyForce_pointWorld = vec2.create();\nvar Body_applyForce_pointLocal = vec2.create();\nBody.prototype.applyForceLocal = function(localForce, localPoint){\n    localPoint = localPoint || Body_applyForce_pointLocal;\n    var worldForce = Body_applyForce_forceWorld;\n    var worldPoint = Body_applyForce_pointWorld;\n    this.vectorToWorldFrame(worldForce, localForce);\n    this.vectorToWorldFrame(worldPoint, localPoint);\n    this.applyForce(worldForce, worldPoint);\n};\n\n/**\n * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.\n * @method applyImpulse\n * @param  {Array} impulse The impulse vector to add, oriented in world space.\n * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.\n */\nvar Body_applyImpulse_velo = vec2.create();\nBody.prototype.applyImpulse = function(impulseVector, relativePoint){\n    if(this.type !== Body.DYNAMIC){\n        return;\n    }\n\n    // Compute produced central impulse velocity\n    var velo = Body_applyImpulse_velo;\n    vec2.scale(velo, impulseVector, this.invMass);\n    vec2.multiply(velo, this.massMultiplier, velo);\n\n    // Add linear impulse\n    vec2.add(this.velocity, velo, this.velocity);\n\n    if(relativePoint){\n        // Compute produced rotational impulse velocity\n        var rotVelo = vec2.crossLength(relativePoint, impulseVector);\n        rotVelo *= this.invInertia;\n\n        // Add rotational Impulse\n        this.angularVelocity += rotVelo;\n    }\n};\n\n/**\n * Apply impulse to a point relative to the body. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.\n * @method applyImpulseLocal\n * @param  {Array} impulse The impulse vector to add, oriented in world space.\n * @param  {Array} [relativePoint] A point relative to the body in world space. If not given, it is set to zero and all of the impulse will be excerted on the center of mass.\n */\nvar Body_applyImpulse_impulseWorld = vec2.create();\nvar Body_applyImpulse_pointWorld = vec2.create();\nvar Body_applyImpulse_pointLocal = vec2.create();\nBody.prototype.applyImpulseLocal = function(localImpulse, localPoint){\n    localPoint = localPoint || Body_applyImpulse_pointLocal;\n    var worldImpulse = Body_applyImpulse_impulseWorld;\n    var worldPoint = Body_applyImpulse_pointWorld;\n    this.vectorToWorldFrame(worldImpulse, localImpulse);\n    this.vectorToWorldFrame(worldPoint, localPoint);\n    this.applyImpulse(worldImpulse, worldPoint);\n};\n\n/**\n * Transform a world point to local body frame.\n * @method toLocalFrame\n * @param  {Array} out          The vector to store the result in\n * @param  {Array} worldPoint   The input world point\n */\nBody.prototype.toLocalFrame = function(out, worldPoint){\n    vec2.toLocalFrame(out, worldPoint, this.position, this.angle);\n};\n\n/**\n * Transform a local point to world frame.\n * @method toWorldFrame\n * @param  {Array} out          The vector to store the result in\n * @param  {Array} localPoint   The input local point\n */\nBody.prototype.toWorldFrame = function(out, localPoint){\n    vec2.toGlobalFrame(out, localPoint, this.position, this.angle);\n};\n\n/**\n * Transform a world point to local body frame.\n * @method vectorToLocalFrame\n * @param  {Array} out          The vector to store the result in\n * @param  {Array} worldVector  The input world vector\n */\nBody.prototype.vectorToLocalFrame = function(out, worldVector){\n    vec2.vectorToLocalFrame(out, worldVector, this.angle);\n};\n\n/**\n * Transform a local point to world frame.\n * @method vectorToWorldFrame\n * @param  {Array} out          The vector to store the result in\n * @param  {Array} localVector  The input local vector\n */\nBody.prototype.vectorToWorldFrame = function(out, localVector){\n    vec2.vectorToGlobalFrame(out, localVector, this.angle);\n};\n\n/**\n * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.\n * @method fromPolygon\n * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.\n * @param {Object} [options]\n * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.\n * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.\n * @param {Boolean|Number} [options.removeCollinearPoints=false] Set to a number (angle threshold value) to remove collinear points, or false to keep all points.\n * @return {Boolean} True on success, else false.\n */\nBody.prototype.fromPolygon = function(path,options){\n    options = options || {};\n\n    // Remove all shapes\n    for(var i=this.shapes.length; i>=0; --i){\n        this.removeShape(this.shapes[i]);\n    }\n\n    var p = new decomp.Polygon();\n    p.vertices = path;\n\n    // Make it counter-clockwise\n    p.makeCCW();\n\n    if(typeof(options.removeCollinearPoints) === \"number\"){\n        p.removeCollinearPoints(options.removeCollinearPoints);\n    }\n\n    // Check if any line segment intersects the path itself\n    if(typeof(options.skipSimpleCheck) === \"undefined\"){\n        if(!p.isSimple()){\n            return false;\n        }\n    }\n\n    // Save this path for later\n    this.concavePath = p.vertices.slice(0);\n    for(var i=0; i<this.concavePath.length; i++){\n        var v = [0,0];\n        vec2.copy(v,this.concavePath[i]);\n        this.concavePath[i] = v;\n    }\n\n    // Slow or fast decomp?\n    var convexes;\n    if(options.optimalDecomp){\n        convexes = p.decomp();\n    } else {\n        convexes = p.quickDecomp();\n    }\n\n    var cm = vec2.create();\n\n    // Add convexes\n    for(var i=0; i!==convexes.length; i++){\n        // Create convex\n        var c = new Convex({ vertices: convexes[i].vertices });\n\n        // Move all vertices so its center of mass is in the local center of the convex\n        for(var j=0; j!==c.vertices.length; j++){\n            var v = c.vertices[j];\n            vec2.sub(v,v,c.centerOfMass);\n        }\n\n        vec2.scale(cm,c.centerOfMass,1);\n        c.updateTriangles();\n        c.updateCenterOfMass();\n        c.updateBoundingRadius();\n\n        // Add the shape\n        this.addShape(c,cm);\n    }\n\n    this.adjustCenterOfMass();\n\n    this.aabbNeedsUpdate = true;\n\n    return true;\n};\n\nvar adjustCenterOfMass_tmp1 = vec2.fromValues(0,0),\n    adjustCenterOfMass_tmp2 = vec2.fromValues(0,0),\n    adjustCenterOfMass_tmp3 = vec2.fromValues(0,0),\n    adjustCenterOfMass_tmp4 = vec2.fromValues(0,0);\n\n/**\n * Moves the shape offsets so their center of mass becomes the body center of mass.\n * @method adjustCenterOfMass\n */\nBody.prototype.adjustCenterOfMass = function(){\n    var offset_times_area = adjustCenterOfMass_tmp2,\n        sum =               adjustCenterOfMass_tmp3,\n        cm =                adjustCenterOfMass_tmp4,\n        totalArea =         0;\n    vec2.set(sum,0,0);\n\n    for(var i=0; i!==this.shapes.length; i++){\n        var s = this.shapes[i];\n        vec2.scale(offset_times_area, s.position, s.area);\n        vec2.add(sum, sum, offset_times_area);\n        totalArea += s.area;\n    }\n\n    vec2.scale(cm,sum,1/totalArea);\n\n    // Now move all shapes\n    for(var i=0; i!==this.shapes.length; i++){\n        var s = this.shapes[i];\n        vec2.sub(s.position, s.position, cm);\n    }\n\n    // Move the body position too\n    vec2.add(this.position,this.position,cm);\n\n    // And concave path\n    for(var i=0; this.concavePath && i<this.concavePath.length; i++){\n        vec2.sub(this.concavePath[i], this.concavePath[i], cm);\n    }\n\n    this.updateMassProperties();\n    this.updateBoundingRadius();\n};\n\n/**\n * Sets the force on the body to zero.\n * @method setZeroForce\n */\nBody.prototype.setZeroForce = function(){\n    vec2.set(this.force,0.0,0.0);\n    this.angularForce = 0.0;\n};\n\nBody.prototype.resetConstraintVelocity = function(){\n    var b = this,\n        vlambda = b.vlambda;\n    vec2.set(vlambda,0,0);\n    b.wlambda = 0;\n};\n\nBody.prototype.addConstraintVelocity = function(){\n    var b = this,\n        v = b.velocity;\n    vec2.add( v, v, b.vlambda);\n    b.angularVelocity += b.wlambda;\n};\n\n/**\n * Apply damping, see <a href=\"http://code.google.com/p/bullet/issues/detail?id=74\">this</a> for details.\n * @method applyDamping\n * @param  {number} dt Current time step\n */\nBody.prototype.applyDamping = function(dt){\n    if(this.type === Body.DYNAMIC){ // Only for dynamic bodies\n        var v = this.velocity;\n        vec2.scale(v, v, Math.pow(1.0 - this.damping,dt));\n        this.angularVelocity *= Math.pow(1.0 - this.angularDamping,dt);\n    }\n};\n\n/**\n * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.\n * Sets the sleepState to {{#crossLink \"Body/AWAKE:property\"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.\n * @method wakeUp\n */\nBody.prototype.wakeUp = function(){\n    var s = this.sleepState;\n    this.sleepState = Body.AWAKE;\n    this.idleTime = 0;\n    if(s !== Body.AWAKE){\n        this.emit(Body.wakeUpEvent);\n    }\n};\n\n/**\n * Force body sleep\n * @method sleep\n */\nBody.prototype.sleep = function(){\n    this.sleepState = Body.SLEEPING;\n    this.angularVelocity = 0;\n    this.angularForce = 0;\n    vec2.set(this.velocity,0,0);\n    vec2.set(this.force,0,0);\n    this.emit(Body.sleepEvent);\n};\n\n/**\n * Called every timestep to update internal sleep timer and change sleep state if needed.\n * @method sleepTick\n * @param {number} time The world time in seconds\n * @param {boolean} dontSleep\n * @param {number} dt\n */\nBody.prototype.sleepTick = function(time, dontSleep, dt){\n    if(!this.allowSleep || this.type === Body.SLEEPING){\n        return;\n    }\n\n    this.wantsToSleep = false;\n\n    var sleepState = this.sleepState,\n        speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity,2),\n        speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);\n\n    // Add to idle time\n    if(speedSquared >= speedLimitSquared){\n        this.idleTime = 0;\n        this.sleepState = Body.AWAKE;\n    } else {\n        this.idleTime += dt;\n        this.sleepState = Body.SLEEPY;\n    }\n    if(this.idleTime > this.sleepTimeLimit){\n        if(!dontSleep){\n            this.sleep();\n        } else {\n            this.wantsToSleep = true;\n        }\n    }\n};\n\n/**\n * Check if the body is overlapping another body. Note that this method only works if the body was added to a World and if at least one step was taken.\n * @method overlaps\n * @param  {Body} body\n * @return {boolean}\n */\nBody.prototype.overlaps = function(body){\n    return this.world.overlapKeeper.bodiesAreOverlapping(this, body);\n};\n\nvar integrate_fhMinv = vec2.create();\nvar integrate_velodt = vec2.create();\n\n/**\n * Move the body forward in time given its current velocity.\n * @method integrate\n * @param  {Number} dt\n */\nBody.prototype.integrate = function(dt){\n    var minv = this.invMass,\n        f = this.force,\n        pos = this.position,\n        velo = this.velocity;\n\n    // Save old position\n    vec2.copy(this.previousPosition, this.position);\n    this.previousAngle = this.angle;\n\n    // Velocity update\n    if(!this.fixedRotation){\n        this.angularVelocity += this.angularForce * this.invInertia * dt;\n    }\n    vec2.scale(integrate_fhMinv, f, dt * minv);\n    vec2.multiply(integrate_fhMinv, this.massMultiplier, integrate_fhMinv);\n    vec2.add(velo, integrate_fhMinv, velo);\n\n    // CCD\n    if(!this.integrateToTimeOfImpact(dt)){\n\n        // Regular position update\n        vec2.scale(integrate_velodt, velo, dt);\n        vec2.add(pos, pos, integrate_velodt);\n        if(!this.fixedRotation){\n            this.angle += this.angularVelocity * dt;\n        }\n    }\n\n    this.aabbNeedsUpdate = true;\n};\n\nvar result = new RaycastResult();\nvar ray = new Ray({\n    mode: Ray.ALL\n});\nvar direction = vec2.create();\nvar end = vec2.create();\nvar startToEnd = vec2.create();\nvar rememberPosition = vec2.create();\nBody.prototype.integrateToTimeOfImpact = function(dt){\n\n    if(this.ccdSpeedThreshold < 0 || vec2.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)){\n        return false;\n    }\n\n    vec2.normalize(direction, this.velocity);\n\n    vec2.scale(end, this.velocity, dt);\n    vec2.add(end, end, this.position);\n\n    vec2.sub(startToEnd, end, this.position);\n    var startToEndAngle = this.angularVelocity * dt;\n    var len = vec2.length(startToEnd);\n\n    var timeOfImpact = 1;\n\n    var hit;\n    var that = this;\n    result.reset();\n    ray.callback = function (result) {\n        if(result.body === that){\n            return;\n        }\n        hit = result.body;\n        result.getHitPoint(end, ray);\n        vec2.sub(startToEnd, end, that.position);\n        timeOfImpact = vec2.length(startToEnd) / len;\n        result.stop();\n    };\n    vec2.copy(ray.from, this.position);\n    vec2.copy(ray.to, end);\n    ray.update();\n    this.world.raycast(result, ray);\n\n    if(!hit){\n        return false;\n    }\n\n    var rememberAngle = this.angle;\n    vec2.copy(rememberPosition, this.position);\n\n    // Got a start and end point. Approximate time of impact using binary search\n    var iter = 0;\n    var tmin = 0;\n    var tmid = 0;\n    var tmax = timeOfImpact;\n    while (tmax >= tmin && iter < this.ccdIterations) {\n        iter++;\n\n        // calculate the midpoint\n        tmid = (tmax - tmin) / 2;\n\n        // Move the body to that point\n        vec2.scale(integrate_velodt, startToEnd, timeOfImpact);\n        vec2.add(this.position, rememberPosition, integrate_velodt);\n        this.angle = rememberAngle + startToEndAngle * timeOfImpact;\n        this.updateAABB();\n\n        // check overlap\n        var overlaps = this.aabb.overlaps(hit.aabb) && this.world.narrowphase.bodiesOverlap(this, hit);\n\n        if (overlaps) {\n            // change min to search upper interval\n            tmin = tmid;\n        } else {\n            // change max to search lower interval\n            tmax = tmid;\n        }\n    }\n\n    timeOfImpact = tmid;\n\n    vec2.copy(this.position, rememberPosition);\n    this.angle = rememberAngle;\n\n    // move to TOI\n    vec2.scale(integrate_velodt, startToEnd, timeOfImpact);\n    vec2.add(this.position, this.position, integrate_velodt);\n    if(!this.fixedRotation){\n        this.angle += startToEndAngle * timeOfImpact;\n    }\n\n    return true;\n};\n\n/**\n * Get velocity of a point in the body.\n * @method getVelocityAtPoint\n * @param  {Array} result A vector to store the result in\n * @param  {Array} relativePoint A world oriented vector, indicating the position of the point to get the velocity from\n * @return {Array} The result vector\n */\nBody.prototype.getVelocityAtPoint = function(result, relativePoint){\n    vec2.crossVZ(result, relativePoint, this.angularVelocity);\n    vec2.subtract(result, this.velocity, result);\n    return result;\n};\n\n/**\n * @event sleepy\n */\nBody.sleepyEvent = {\n    type: \"sleepy\"\n};\n\n/**\n * @event sleep\n */\nBody.sleepEvent = {\n    type: \"sleep\"\n};\n\n/**\n * @event wakeup\n */\nBody.wakeUpEvent = {\n    type: \"wakeup\"\n};\n\n/**\n * Dynamic body.\n * @property DYNAMIC\n * @type {Number}\n * @static\n */\nBody.DYNAMIC = 1;\n\n/**\n * Static body.\n * @property STATIC\n * @type {Number}\n * @static\n */\nBody.STATIC = 2;\n\n/**\n * Kinematic body.\n * @property KINEMATIC\n * @type {Number}\n * @static\n */\nBody.KINEMATIC = 4;\n\n/**\n * @property AWAKE\n * @type {Number}\n * @static\n */\nBody.AWAKE = 0;\n\n/**\n * @property SLEEPY\n * @type {Number}\n * @static\n */\nBody.SLEEPY = 1;\n\n/**\n * @property SLEEPING\n * @type {Number}\n * @static\n */\nBody.SLEEPING = 2;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL29iamVjdHMvQm9keS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvb2JqZWN0cy9Cb2R5LmpzPzM4NDMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKVxuLCAgIGRlY29tcCA9IHJlcXVpcmUoJ3BvbHktZGVjb21wJylcbiwgICBDb252ZXggPSByZXF1aXJlKCcuLi9zaGFwZXMvQ29udmV4JylcbiwgICBSYXljYXN0UmVzdWx0ID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKVxuLCAgIFJheSA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9SYXknKVxuLCAgIEFBQkIgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQUFCQicpXG4sICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RW1pdHRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJvZHk7XG5cbi8qKlxuICogQSByaWdpZCBib2R5LiBIYXMgZ290IGEgY2VudGVyIG9mIG1hc3MsIHBvc2l0aW9uLCB2ZWxvY2l0eSBhbmQgYSBudW1iZXIgb2ZcbiAqIHNoYXBlcyB0aGF0IGFyZSB1c2VkIGZvciBjb2xsaXNpb25zLlxuICpcbiAqIEBjbGFzcyBCb2R5XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuZm9yY2VdXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5wb3NpdGlvbl1cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnZlbG9jaXR5XVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1NsZWVwXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZT0wXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ3VsYXJGb3JjZT0wXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ3VsYXJWZWxvY2l0eT0wXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNjZEl0ZXJhdGlvbnM9MTBdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2NkU3BlZWRUaHJlc2hvbGQ9LTFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZml4ZWRSb3RhdGlvbj1mYWxzZV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ncmF2aXR5U2NhbGVdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaWRdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWFzcz0wXSBBIG51bWJlciA+PSAwLiBJZiB6ZXJvLCB0aGUgLnR5cGUgd2lsbCBiZSBzZXQgdG8gQm9keS5TVEFUSUMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2xlZXBTcGVlZExpbWl0XVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNsZWVwVGltZUxpbWl0XVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIC8vIENyZWF0ZSBhIHR5cGljYWwgZHluYW1pYyBib2R5XG4gKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7XG4gKiAgICAgICAgIG1hc3M6IDEsXG4gKiAgICAgICAgIHBvc2l0aW9uOiBbMCwgMF0sXG4gKiAgICAgICAgIGFuZ2xlOiAwLFxuICogICAgICAgICB2ZWxvY2l0eTogWzAsIDBdLFxuICogICAgICAgICBhbmd1bGFyVmVsb2NpdHk6IDBcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gQWRkIGEgY2lyY3VsYXIgc2hhcGUgdG8gdGhlIGJvZHlcbiAqICAgICBib2R5LmFkZFNoYXBlKG5ldyBDaXJjbGUoeyByYWRpdXM6IDEgfSkpO1xuICpcbiAqICAgICAvLyBBZGQgdGhlIGJvZHkgdG8gdGhlIHdvcmxkXG4gKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcbiAqL1xuZnVuY3Rpb24gQm9keShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJvZHkgaWRlbnRpZnllclxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQgfHwgKytCb2R5Ll9pZENvdW50ZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd29ybGQgdGhhdCB0aGlzIGJvZHkgaXMgYWRkZWQgdG8uIFRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIE5VTEwgaWYgdGhlIGJvZHkgaXMgbm90IGFkZGVkIHRvIGFueSB3b3JsZC5cbiAgICAgKiBAcHJvcGVydHkgd29ybGRcbiAgICAgKiBAdHlwZSB7V29ybGR9XG4gICAgICovXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGVzIG9mIHRoZSBib2R5LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNoYXBlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hc3Mgb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IG1hc3NcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWFzcyA9IG9wdGlvbnMubWFzcyB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2UgbWFzcyBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgaW52TWFzc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbnZNYXNzID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmVydGlhIG9mIHRoZSBib2R5IGFyb3VuZCB0aGUgWiBheGlzLlxuICAgICAqIEBwcm9wZXJ0eSBpbmVydGlhXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmluZXJ0aWEgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2UgaW5lcnRpYSBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgaW52SW5lcnRpYVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbnZJbmVydGlhID0gMDtcblxuICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcbiAgICB0aGlzLmludkluZXJ0aWFTb2x2ZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBmaXggdGhlIHJvdGF0aW9uIG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBmaXhlZFJvdGF0aW9uXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5maXhlZFJvdGF0aW9uID0gISFvcHRpb25zLmZpeGVkUm90YXRpb247XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBmaXggdGhlIGJvZHkgbW92ZW1lbnQgYWxvbmcgdGhlIFggYXhpcy4gVGhlIGJvZHkgd2lsbCBzdGlsbCBiZSBhYmxlIHRvIG1vdmUgYWxvbmcgWS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGZpeGVkWFxuICAgICAqL1xuICAgIHRoaXMuZml4ZWRYID0gISFvcHRpb25zLmZpeGVkWDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGZpeCB0aGUgYm9keSBtb3ZlbWVudCBhbG9uZyB0aGUgWSBheGlzLiBUaGUgYm9keSB3aWxsIHN0aWxsIGJlIGFibGUgdG8gbW92ZSBhbG9uZyBYLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZml4ZWRZXG4gICAgICovXG4gICAgdGhpcy5maXhlZFkgPSAhIW9wdGlvbnMuZml4ZWRZO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBtYXNzTXVsdGlwbGllclxuICAgICAqL1xuICAgIHRoaXMubWFzc011bHRpcGxpZXIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5XG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcbiAgICBpZihvcHRpb25zLnBvc2l0aW9uKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMucG9zaXRpb24sIG9wdGlvbnMucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnBvbGF0ZWQgcG9zaXRpb24gb2YgdGhlIGJvZHkuIFVzZSB0aGlzIGZvciByZW5kZXJpbmcuXG4gICAgICogQHByb3BlcnR5IGludGVycG9sYXRlZFBvc2l0aW9uXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnBvbGF0ZWQgYW5nbGUgb2YgdGhlIGJvZHkuIFVzZSB0aGlzIGZvciByZW5kZXJpbmcuXG4gICAgICogQHByb3BlcnR5IGludGVycG9sYXRlZEFuZ2xlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmludGVycG9sYXRlZEFuZ2xlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyBwb3NpdGlvbiBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgcHJldmlvdXNQb3NpdGlvblxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyBhbmdsZSBvZiB0aGUgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgcHJldmlvdXNBbmdsZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wcmV2aW91c0FuZ2xlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHZlbG9jaXR5IG9mIHRoZSBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSB2ZWxvY2l0eVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlbG9jaXR5ID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG4gICAgaWYob3B0aW9ucy52ZWxvY2l0eSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLnZlbG9jaXR5LCBvcHRpb25zLnZlbG9jaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJhaW50IHZlbG9jaXR5IHRoYXQgd2FzIGFkZGVkIHRvIHRoZSBib2R5IGR1cmluZyB0aGUgbGFzdCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSB2bGFtYmRhXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmxhbWJkYSA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBjb25zdHJhaW50IHZlbG9jaXR5IHRoYXQgd2FzIGFkZGVkIHRvIHRoZSBib2R5IGR1cmluZyBsYXN0IHN0ZXAuXG4gICAgICogQHByb3BlcnR5IHdsYW1iZGFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy53bGFtYmRhID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmdsZSBvZiB0aGUgYm9keSwgaW4gcmFkaWFucy5cbiAgICAgKiBAcHJvcGVydHkgYW5nbGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIFRoZSBhbmdsZSBwcm9wZXJ0eSBpcyBub3Qgbm9ybWFsaXplZCB0byB0aGUgaW50ZXJ2YWwgMCB0byAyKnBpLCBpdCBjYW4gYmUgYW55IHZhbHVlLlxuICAgICAqICAgICAvLyBJZiB5b3UgbmVlZCBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMipwaSwgdXNlIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gdG8gbm9ybWFsaXplIGl0LlxuICAgICAqICAgICBmdW5jdGlvbiBub3JtYWxpemVBbmdsZShhbmdsZSl7XG4gICAgICogICAgICAgICBhbmdsZSA9IGFuZ2xlICUgKDIqTWF0aC5QSSk7XG4gICAgICogICAgICAgICBpZihhbmdsZSA8IDApe1xuICAgICAqICAgICAgICAgICAgIGFuZ2xlICs9ICgyKk1hdGguUEkpO1xuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGUgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSBib2R5LCBpbiByYWRpYW5zIHBlciBzZWNvbmQuXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJWZWxvY2l0eVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSBvcHRpb25zLmFuZ3VsYXJWZWxvY2l0eSB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcmNlIGFjdGluZyBvbiB0aGUgYm9keS4gU2luY2UgdGhlIGJvZHkgZm9yY2UgKGFuZCB7eyNjcm9zc0xpbmsgXCJCb2R5L2FuZ3VsYXJGb3JjZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSkgd2lsbCBiZSB6ZXJvZWQgYWZ0ZXIgZWFjaCBzdGVwLCBzbyB5b3UgbmVlZCB0byBzZXQgdGhlIGZvcmNlIGJlZm9yZSBlYWNoIHN0ZXAuXG4gICAgICogQHByb3BlcnR5IGZvcmNlXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gVGhpcyBwcm9kdWNlcyBhIGZvcmNlZmllbGQgb2YgMSBOZXd0b24gaW4gdGhlIHBvc2l0aXZlIHggZGlyZWN0aW9uLlxuICAgICAqICAgICBmb3IodmFyIGk9MDsgaTxudW1TdGVwczsgaSsrKXtcbiAgICAgKiAgICAgICAgIGJvZHkuZm9yY2VbMF0gPSAxO1xuICAgICAqICAgICAgICAgd29ybGQuc3RlcCgxLzYwKTtcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gVGhpcyB3aWxsIGFwcGx5IGEgcm90YXRpb25hbCBmb3JjZSBvbiB0aGUgYm9keVxuICAgICAqICAgICBmb3IodmFyIGk9MDsgaTxudW1TdGVwczsgaSsrKXtcbiAgICAgKiAgICAgICAgIGJvZHkuYW5ndWxhckZvcmNlID0gLTM7XG4gICAgICogICAgICAgICB3b3JsZC5zdGVwKDEvNjApO1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgdGhpcy5mb3JjZSA9IHZlYzIuY3JlYXRlKCk7XG4gICAgaWYob3B0aW9ucy5mb3JjZSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmZvcmNlLCBvcHRpb25zLmZvcmNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYW5ndWxhciBmb3JjZSBhY3Rpbmcgb24gdGhlIGJvZHkuIFNlZSB7eyNjcm9zc0xpbmsgXCJCb2R5L2ZvcmNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyRm9yY2VcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYW5ndWxhckZvcmNlID0gb3B0aW9ucy5hbmd1bGFyRm9yY2UgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsaW5lYXIgZGFtcGluZyBhY3Rpbmcgb24gdGhlIGJvZHkgaW4gdGhlIHZlbG9jaXR5IGRpcmVjdGlvbi4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwcm9wZXJ0eSBkYW1waW5nXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwLjFcbiAgICAgKi9cbiAgICB0aGlzLmRhbXBpbmcgPSB0eXBlb2Yob3B0aW9ucy5kYW1waW5nKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMuZGFtcGluZyA6IDAuMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbmd1bGFyIGZvcmNlIGFjdGluZyBvbiB0aGUgYm9keS4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwcm9wZXJ0eSBhbmd1bGFyRGFtcGluZ1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMC4xXG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmFuZ3VsYXJEYW1waW5nKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMuYW5ndWxhckRhbXBpbmcgOiAwLjE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBtb3Rpb24gdGhpcyBib2R5IGhhcy4gU2hvdWxkIGJlIG9uZSBvZjoge3sjY3Jvc3NMaW5rIFwiQm9keS9TVEFUSUM6cHJvcGVydHlcIn19Qm9keS5TVEFUSUN7ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiQm9keS9EWU5BTUlDOnByb3BlcnR5XCJ9fUJvZHkuRFlOQU1JQ3t7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJCb2R5L0tJTkVNQVRJQzpwcm9wZXJ0eVwifX1Cb2R5LktJTkVNQVRJQ3t7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogKiBTdGF0aWMgYm9kaWVzIGRvIG5vdCBtb3ZlLCBhbmQgdGhleSBkbyBub3QgcmVzcG9uZCB0byBmb3JjZXMgb3IgY29sbGlzaW9uLlxuICAgICAqICogRHluYW1pYyBib2RpZXMgYm9keSBjYW4gbW92ZSBhbmQgcmVzcG9uZCB0byBjb2xsaXNpb25zIGFuZCBmb3JjZXMuXG4gICAgICogKiBLaW5lbWF0aWMgYm9kaWVzIG9ubHkgbW92ZXMgYWNjb3JkaW5nIHRvIGl0cyAudmVsb2NpdHksIGFuZCBkb2VzIG5vdCByZXNwb25kIHRvIGNvbGxpc2lvbnMgb3IgZm9yY2UuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgdHlwZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBCb2RpZXMgYXJlIHN0YXRpYyBieSBkZWZhdWx0LiBTdGF0aWMgYm9kaWVzIHdpbGwgbmV2ZXIgbW92ZS5cbiAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSgpO1xuICAgICAqICAgICBjb25zb2xlLmxvZyhib2R5LnR5cGUgPT0gQm9keS5TVEFUSUMpOyAvLyB0cnVlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBCeSBzZXR0aW5nIHRoZSBtYXNzIG9mIGEgYm9keSB0byBhIG5vbnplcm8gbnVtYmVyLCB0aGUgYm9keVxuICAgICAqICAgICAvLyB3aWxsIGJlY29tZSBkeW5hbWljIGFuZCB3aWxsIG1vdmUgYW5kIGludGVyYWN0IHdpdGggb3RoZXIgYm9kaWVzLlxuICAgICAqICAgICB2YXIgZHluYW1pY0JvZHkgPSBuZXcgQm9keSh7XG4gICAgICogICAgICAgICBtYXNzIDogMVxuICAgICAqICAgICB9KTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZHluYW1pY0JvZHkudHlwZSA9PSBCb2R5LkRZTkFNSUMpOyAvLyB0cnVlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAvLyBLaW5lbWF0aWMgYm9kaWVzIHdpbGwgb25seSBtb3ZlIGlmIHlvdSBjaGFuZ2UgdGhlaXIgdmVsb2NpdHkuXG4gICAgICogICAgIHZhciBraW5lbWF0aWNCb2R5ID0gbmV3IEJvZHkoe1xuICAgICAqICAgICAgICAgdHlwZTogQm9keS5LSU5FTUFUSUMgLy8gVHlwZSBjYW4gYmUgc2V0IHZpYSB0aGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogICAgIH0pO1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IEJvZHkuU1RBVElDO1xuXG4gICAgaWYodHlwZW9mKG9wdGlvbnMudHlwZSkgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIH0gZWxzZSBpZighb3B0aW9ucy5tYXNzKXtcbiAgICAgICAgdGhpcy50eXBlID0gQm9keS5TVEFUSUM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50eXBlID0gQm9keS5EWU5BTUlDO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJvdW5kaW5nIGNpcmNsZSByYWRpdXMuXG4gICAgICogQHByb3BlcnR5IGJvdW5kaW5nUmFkaXVzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gMDtcblxuICAgIC8qKlxuICAgICAqIEJvdW5kaW5nIGJveCBvZiB0aGlzIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGFhYmJcbiAgICAgKiBAdHlwZSB7QUFCQn1cbiAgICAgKi9cbiAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBBQUJCIG5lZWRzIHVwZGF0ZS4gVXBkYXRlIGl0IHdpdGgge3sjY3Jvc3NMaW5rIFwiQm9keS91cGRhdGVBQUJCOm1ldGhvZFwifX0udXBkYXRlQUFCQigpe3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IGFhYmJOZWVkc1VwZGF0ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBzZWUgdXBkYXRlQUFCQlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gRm9yY2UgdXBkYXRlIHRoZSBBQUJCXG4gICAgICogICAgIGJvZHkuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgKiAgICAgYm9keS51cGRhdGVBQUJCKCk7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGJvZHkuYWFiYk5lZWRzVXBkYXRlKTsgLy8gZmFsc2VcbiAgICAgKi9cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYm9keSB3aWxsIGF1dG9tYXRpY2FsbHkgZmFsbCB0byBzbGVlcC4gTm90ZSB0aGF0IHlvdSBuZWVkIHRvIGVuYWJsZSBzbGVlcGluZyBpbiB0aGUge3sjY3Jvc3NMaW5rIFwiV29ybGRcIn19e3svY3Jvc3NMaW5rfX0gYmVmb3JlIGFueXRoaW5nIHdpbGwgaGFwcGVuLlxuICAgICAqIEBwcm9wZXJ0eSBhbGxvd1NsZWVwXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuYWxsb3dTbGVlcCA9IG9wdGlvbnMuYWxsb3dTbGVlcCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbGxvd1NsZWVwIDogdHJ1ZTtcblxuICAgIHRoaXMud2FudHNUb1NsZWVwID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBPbmUgb2Yge3sjY3Jvc3NMaW5rIFwiQm9keS9BV0FLRTpwcm9wZXJ0eVwifX1Cb2R5LkFXQUtFe3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkJvZHkvU0xFRVBZOnByb3BlcnR5XCJ9fUJvZHkuU0xFRVBZe3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkJvZHkvU0xFRVBJTkc6cHJvcGVydHlcIn19Qm9keS5TTEVFUElOR3t7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogVGhlIGJvZHkgaXMgaW5pdGlhbGx5IEJvZHkuQVdBS0UuIElmIGl0cyB2ZWxvY2l0eSBub3JtIGlzIGJlbG93IC5zbGVlcFNwZWVkTGltaXQsIHRoZSBzbGVlcFN0YXRlIHdpbGwgYmVjb21lIEJvZHkuU0xFRVBZLiBJZiB0aGUgYm9keSBjb250aW51ZXMgdG8gYmUgQm9keS5TTEVFUFkgZm9yIC5zbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCB3aWxsIGZhbGwgYXNsZWVwIChCb2R5LlNMRUVQWSkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgc2xlZXBTdGF0ZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgQm9keS5BV0FLRVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuQVdBS0U7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc3BlZWQgKHRoZSBub3JtIG9mIHRoZSB2ZWxvY2l0eSkgaXMgc21hbGxlciB0aGFuIHRoaXMgdmFsdWUsIHRoZSBib2R5IGlzIGNvbnNpZGVyZWQgc2xlZXB5LlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFNwZWVkTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMlxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBTcGVlZExpbWl0ID0gb3B0aW9ucy5zbGVlcFNwZWVkTGltaXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2xlZXBTcGVlZExpbWl0IDogMC4yO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGJvZHkgaGFzIGJlZW4gc2xlZXB5IGZvciB0aGlzIHNsZWVwVGltZUxpbWl0IHNlY29uZHMsIGl0IGlzIGNvbnNpZGVyZWQgc2xlZXBpbmcuXG4gICAgICogQHByb3BlcnR5IHNsZWVwVGltZUxpbWl0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5zbGVlcFRpbWVMaW1pdCA9IG9wdGlvbnMuc2xlZXBUaW1lTGltaXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2xlZXBUaW1lTGltaXQgOiAxO1xuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSBzY2FsaW5nIGZhY3Rvci4gSWYgeW91IHdhbnQgdGhlIGJvZHkgdG8gaWdub3JlIGdyYXZpdHksIHNldCB0aGlzIHRvIHplcm8uIElmIHlvdSB3YW50IHRvIHJldmVyc2UgZ3Jhdml0eSwgc2V0IGl0IHRvIC0xLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBncmF2aXR5U2NhbGVcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5ncmF2aXR5U2NhbGUgPSBvcHRpb25zLmdyYXZpdHlTY2FsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5ncmF2aXR5U2NhbGUgOiAxO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBwcm9kdWNlIGNvbnRhY3QgZm9yY2VzIHdoZW4gaW4gY29udGFjdCB3aXRoIG90aGVyIGJvZGllcy4gTm90ZSB0aGF0IGNvbnRhY3RzIHdpbGwgYmUgZ2VuZXJhdGVkLCBidXQgdGhleSB3aWxsIGJlIGRpc2FibGVkLiBUaGF0IG1lYW5zIHRoYXQgdGhpcyBib2R5IHdpbGwgbW92ZSB0aHJvdWdoIG90aGVyIGJvZGllcywgYnV0IGl0IHdpbGwgc3RpbGwgdHJpZ2dlciBjb250YWN0IGV2ZW50cywgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29sbGlzaW9uUmVzcG9uc2VcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvblJlc3BvbnNlID0gb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZSA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBIb3cgbG9uZyB0aGUgYm9keSBoYXMgYmVlbiBzbGVlcGluZy5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gaWRsZVRpbWVcbiAgICAgKi9cbiAgICB0aGlzLmlkbGVUaW1lID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IHRpbWUgd2hlbiB0aGUgYm9keSB3ZW50IHRvIFNMRUVQWSBzdGF0ZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gdGltZUxhc3RTbGVlcHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudGltZUxhc3RTbGVlcHkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGJvZHkgc3BlZWQgZXhjZWVkcyB0aGlzIHRocmVzaG9sZCwgQ0NEIChjb250aW51b3VzIGNvbGxpc2lvbiBkZXRlY3Rpb24pIHdpbGwgYmUgZW5hYmxlZC4gU2V0IGl0IHRvIGEgbmVnYXRpdmUgbnVtYmVyIHRvIGRpc2FibGUgQ0NEIGNvbXBsZXRlbHkgZm9yIHRoaXMgYm9keS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY2NkU3BlZWRUaHJlc2hvbGRcbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqL1xuICAgIHRoaXMuY2NkU3BlZWRUaHJlc2hvbGQgPSBvcHRpb25zLmNjZFNwZWVkVGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNjZFNwZWVkVGhyZXNob2xkIDogLTE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIHNlYXJjaGluZyBmb3IgdGhlIHRpbWUgb2YgaW1wYWN0IGR1cmluZyBDQ0QuIEEgbGFyZ2VyIG51bWJlciB3aWxsIGFzc3VyZSB0aGF0IHRoZXJlJ3MgYSBzbWFsbCBwZW5ldHJhdGlvbiBvbiBDQ0QgY29sbGlzaW9uLCBidXQgYSBzbWFsbCBudW1iZXIgd2lsbCBnaXZlIG1vcmUgcGVyZm9ybWFuY2UuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNjZEl0ZXJhdGlvbnNcbiAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAqL1xuICAgIHRoaXMuY2NkSXRlcmF0aW9ucyA9IG9wdGlvbnMuY2NkSXRlcmF0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jY2RJdGVyYXRpb25zIDogMTA7XG5cbiAgICB0aGlzLmNvbmNhdmVQYXRoID0gbnVsbDtcblxuICAgIHRoaXMuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcblxuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbn1cbkJvZHkucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuQm9keS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb2R5O1xuXG5Cb2R5Ll9pZENvdW50ZXIgPSAwO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIHVwZGF0ZVNvbHZlTWFzc1Byb3BlcnRpZXNcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlU29sdmVNYXNzUHJvcGVydGllcyA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpe1xuICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7XG4gICAgICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IHRoaXMuaW52TWFzcztcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSB0aGlzLmludkluZXJ0aWE7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIHRvdGFsIGRlbnNpdHkgb2YgdGhlIGJvZHlcbiAqIEBtZXRob2Qgc2V0RGVuc2l0eVxuICogQHBhcmFtIHtudW1iZXJ9IGRlbnNpdHlcbiAqL1xuQm9keS5wcm90b3R5cGUuc2V0RGVuc2l0eSA9IGZ1bmN0aW9uKGRlbnNpdHkpIHtcbiAgICB2YXIgdG90YWxBcmVhID0gdGhpcy5nZXRBcmVhKCk7XG4gICAgdGhpcy5tYXNzID0gdG90YWxBcmVhICogZGVuc2l0eTtcbiAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdG90YWwgYXJlYSBvZiBhbGwgc2hhcGVzIGluIHRoZSBib2R5XG4gKiBAbWV0aG9kIGdldEFyZWFcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b3RhbEFyZWEgPSAwO1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuc2hhcGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdG90YWxBcmVhICs9IHRoaXMuc2hhcGVzW2ldLmFyZWE7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbEFyZWE7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgQUFCQiBmcm9tIHRoZSBib2R5LiBUaGUgQUFCQiBpcyB1cGRhdGVkIGlmIG5lY2Vzc2FyeS5cbiAqIEBtZXRob2QgZ2V0QUFCQlxuICogQHJldHVybiB7QUFCQn0gVGhlIEFBQkIgaW5zdGFuY2UgKHRoaXMuYWFiYilcbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0QUFCQiA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWFiYjtcbn07XG5cbnZhciBzaGFwZUFBQkIgPSBuZXcgQUFCQigpLFxuICAgIHRtcCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgQUFCQiBvZiB0aGUgQm9keSwgYW5kIHNldCAuYWFiYk5lZWRzVXBkYXRlID0gZmFsc2UuXG4gKiBAbWV0aG9kIHVwZGF0ZUFBQkJcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlQUFCQiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcbiAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IHRtcCxcbiAgICAgICAgYm9keUFuZ2xlID0gdGhpcy5hbmdsZTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2ldLFxuICAgICAgICAgICAgYW5nbGUgPSBzaGFwZS5hbmdsZSArIGJvZHlBbmdsZTtcblxuICAgICAgICAvLyBHZXQgc2hhcGUgd29ybGQgb2Zmc2V0XG4gICAgICAgIHZlYzIucm90YXRlKG9mZnNldCwgc2hhcGUucG9zaXRpb24sIGJvZHlBbmdsZSk7XG4gICAgICAgIHZlYzIuYWRkKG9mZnNldCwgb2Zmc2V0LCB0aGlzLnBvc2l0aW9uKTtcblxuICAgICAgICAvLyBHZXQgc2hhcGUgQUFCQlxuICAgICAgICBzaGFwZS5jb21wdXRlQUFCQihzaGFwZUFBQkIsIG9mZnNldCwgYW5nbGUpO1xuXG4gICAgICAgIGlmKGk9PT0wKXtcbiAgICAgICAgICAgIHRoaXMuYWFiYi5jb3B5KHNoYXBlQUFCQik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFhYmIuZXh0ZW5kKHNoYXBlQUFCQik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgYm9keSAodGhpcy5ib3VuZGluZ1JhZGl1cykuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgc2hhcGUgZGltZW5zaW9ucyBvciBwb3NpdGlvbnMgYXJlIGNoYW5nZWQuXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKi9cbkJvZHkucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgc2hhcGVzID0gdGhpcy5zaGFwZXMsXG4gICAgICAgIE4gPSBzaGFwZXMubGVuZ3RoLFxuICAgICAgICByYWRpdXMgPSAwO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV0sXG4gICAgICAgICAgICBvZmZzZXQgPSB2ZWMyLmxlbmd0aChzaGFwZS5wb3NpdGlvbiksXG4gICAgICAgICAgICByID0gc2hhcGUuYm91bmRpbmdSYWRpdXM7XG4gICAgICAgIGlmKG9mZnNldCArIHIgPiByYWRpdXMpe1xuICAgICAgICAgICAgcmFkaXVzID0gb2Zmc2V0ICsgcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSByYWRpdXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIHNoYXBlIHRvIHRoZSBib2R5LiBZb3UgY2FuIHBhc3MgYSBsb2NhbCB0cmFuc2Zvcm0gd2hlbiBhZGRpbmcgYSBzaGFwZSxcbiAqIHNvIHRoYXQgdGhlIHNoYXBlIGdldHMgYW4gb2Zmc2V0IGFuZCBhbmdsZSByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcy5cbiAqIFdpbGwgYXV0b21hdGljYWxseSB1cGRhdGUgdGhlIG1hc3MgcHJvcGVydGllcyBhbmQgYm91bmRpbmcgcmFkaXVzLlxuICpcbiAqIEBtZXRob2QgYWRkU2hhcGVcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgICAgICAgICAgc2hhcGVcbiAqIEBwYXJhbSAge0FycmF5fSBbb2Zmc2V0XSBMb2NhbCBib2R5IG9mZnNldCBvZiB0aGUgc2hhcGUuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgICAgIFthbmdsZV0gIExvY2FsIGJvZHkgYW5nbGUuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KCksXG4gKiAgICAgICAgIHNoYXBlID0gbmV3IENpcmNsZSh7IHJhZGl1czogMSB9KTtcbiAqXG4gKiAgICAgLy8gQWRkIHRoZSBzaGFwZSB0byB0aGUgYm9keSwgcG9zaXRpb25lZCBpbiB0aGUgY2VudGVyXG4gKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSk7XG4gKlxuICogICAgIC8vIEFkZCBhbm90aGVyIHNoYXBlIHRvIHRoZSBib2R5LCBwb3NpdGlvbmVkIDEgdW5pdCBsZW5ndGggZnJvbSB0aGUgYm9keSBjZW50ZXIgb2YgbWFzcyBhbG9uZyB0aGUgbG9jYWwgeC1heGlzLlxuICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUsWzEsMF0pO1xuICpcbiAqICAgICAvLyBBZGQgYW5vdGhlciBzaGFwZSB0byB0aGUgYm9keSwgcG9zaXRpb25lZCAxIHVuaXQgbGVuZ3RoIGZyb20gdGhlIGJvZHkgY2VudGVyIG9mIG1hc3MgYWxvbmcgdGhlIGxvY2FsIHktYXhpcywgYW5kIHJvdGF0ZWQgOTAgZGVncmVlcyBDQ1cuXG4gKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSxbMCwxXSxNYXRoLlBJLzIpO1xuICovXG5Cb2R5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlLCBvZmZzZXQsIGFuZ2xlKXtcbiAgICBpZihzaGFwZS5ib2R5KXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHNoYXBlIGNhbiBvbmx5IGJlIGFkZGVkIHRvIG9uZSBib2R5LicpO1xuICAgIH1cbiAgICBzaGFwZS5ib2R5ID0gdGhpcztcblxuICAgIC8vIENvcHkgdGhlIG9mZnNldCB2ZWN0b3JcbiAgICBpZihvZmZzZXQpe1xuICAgICAgICB2ZWMyLmNvcHkoc2hhcGUucG9zaXRpb24sIG9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmVjMi5zZXQoc2hhcGUucG9zaXRpb24sIDAsIDApO1xuICAgIH1cblxuICAgIHNoYXBlLmFuZ2xlID0gYW5nbGUgfHwgMDtcblxuICAgIHRoaXMuc2hhcGVzLnB1c2goc2hhcGUpO1xuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHNoYXBlXG4gKiBAbWV0aG9kIHJlbW92ZVNoYXBlXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHNoYXBlIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZCwgZWxzZSBmYWxzZS5cbiAqL1xuQm9keS5wcm90b3R5cGUucmVtb3ZlU2hhcGUgPSBmdW5jdGlvbihzaGFwZSl7XG4gICAgdmFyIGlkeCA9IHRoaXMuc2hhcGVzLmluZGV4T2Yoc2hhcGUpO1xuXG4gICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgIHRoaXMuc2hhcGVzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgc2hhcGUuYm9keSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgLmluZXJ0aWEsIC5pbnZNYXNzLCAuaW52SW5lcnRpYSBmb3IgdGhpcyBCb2R5LiBTaG91bGQgYmUgY2FsbGVkIHdoZW5cbiAqIGNoYW5naW5nIHRoZSBzdHJ1Y3R1cmUgb3IgbWFzcyBvZiB0aGUgQm9keS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZU1hc3NQcm9wZXJ0aWVzXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICBib2R5Lm1hc3MgKz0gMTtcbiAqICAgICBib2R5LnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gKi9cbkJvZHkucHJvdG90eXBlLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLnR5cGUgPT09IEJvZHkuU1RBVElDIHx8IHRoaXMudHlwZSA9PT0gQm9keS5LSU5FTUFUSUMpe1xuXG4gICAgICAgIHRoaXMubWFzcyA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIHRoaXMuaW52TWFzcyA9IDA7XG4gICAgICAgIHRoaXMuaW5lcnRpYSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcbiAgICAgICAgICAgIE4gPSBzaGFwZXMubGVuZ3RoLFxuICAgICAgICAgICAgbSA9IHRoaXMubWFzcyAvIE4sXG4gICAgICAgICAgICBJID0gMDtcblxuICAgICAgICBpZighdGhpcy5maXhlZFJvdGF0aW9uKXtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPE47IGkrKyl7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2ldLFxuICAgICAgICAgICAgICAgICAgICByMiA9IHZlYzIuc3F1YXJlZExlbmd0aChzaGFwZS5wb3NpdGlvbiksXG4gICAgICAgICAgICAgICAgICAgIEljbSA9IHNoYXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEobSk7XG4gICAgICAgICAgICAgICAgSSArPSBJY20gKyBtKnIyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmVydGlhID0gSTtcbiAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IEk+MCA/IDEvSSA6IDA7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5lcnRpYSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB0aGlzLmludkluZXJ0aWEgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW52ZXJzZSBtYXNzIHByb3BlcnRpZXMgYXJlIGVhc3lcbiAgICAgICAgdGhpcy5pbnZNYXNzID0gMSAvIHRoaXMubWFzcztcblxuICAgICAgICB2ZWMyLnNldChcbiAgICAgICAgICAgIHRoaXMubWFzc011bHRpcGxpZXIsXG4gICAgICAgICAgICB0aGlzLmZpeGVkWCA/IDAgOiAxLFxuICAgICAgICAgICAgdGhpcy5maXhlZFkgPyAwIDogMVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbnZhciBCb2R5X2FwcGx5Rm9yY2VfciA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQXBwbHkgZm9yY2UgdG8gYSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgdGhlIGJvZHkuIFRoaXMgY291bGQgZm9yIGV4YW1wbGUgYmUgYSBwb2ludCBvbiB0aGUgUmlnaWRCb2R5IHN1cmZhY2UuIEFwcGx5aW5nIGZvcmNlIHRoaXMgd2F5IHdpbGwgYWRkIHRvIEJvZHkuZm9yY2UgYW5kIEJvZHkuYW5ndWxhckZvcmNlLiBJZiByZWxhdGl2ZVBvaW50IGlzIHplcm8sIHRoZSBmb3JjZSB3aWxsIGJlIGFwcGxpZWQgZGlyZWN0bHkgb24gdGhlIGNlbnRlciBvZiBtYXNzLCBhbmQgdGhlIHRvcnF1ZSBwcm9kdWNlZCB3aWxsIGJlIHplcm8uXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGZvcmNlIFRoZSBmb3JjZSB0byBhZGQuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVsYXRpdmVQb2ludF0gQSB3b3JsZCBwb2ludCB0byBhcHBseSB0aGUgZm9yY2Ugb24uXG4gKi9cbkJvZHkucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbihmb3JjZSwgcmVsYXRpdmVQb2ludCl7XG5cbiAgICAvLyBBZGQgbGluZWFyIGZvcmNlXG4gICAgdmVjMi5hZGQodGhpcy5mb3JjZSwgdGhpcy5mb3JjZSwgZm9yY2UpO1xuXG4gICAgaWYocmVsYXRpdmVQb2ludCl7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCByb3RhdGlvbmFsIGZvcmNlXG4gICAgICAgIHZhciByb3RGb3JjZSA9IHZlYzIuY3Jvc3NMZW5ndGgocmVsYXRpdmVQb2ludCxmb3JjZSk7XG5cbiAgICAgICAgLy8gQWRkIHJvdGF0aW9uYWwgZm9yY2VcbiAgICAgICAgdGhpcy5hbmd1bGFyRm9yY2UgKz0gcm90Rm9yY2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBcHBseSBmb3JjZSB0byBhIGJvZHktbG9jYWwgcG9pbnQuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VMb2NhbFxuICogQHBhcmFtICB7QXJyYXl9IGxvY2FsRm9yY2UgVGhlIGZvcmNlIHZlY3RvciB0byBhZGQsIG9yaWVudGVkIGluIGxvY2FsIGJvZHkgc3BhY2UuXG4gKiBAcGFyYW0gIHtBcnJheX0gW2xvY2FsUG9pbnRdIEEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGJvZHkgaW4gd29ybGQgc3BhY2UuIElmIG5vdCBnaXZlbiwgaXQgaXMgc2V0IHRvIHplcm8gYW5kIGFsbCBvZiB0aGUgaW1wdWxzZSB3aWxsIGJlIGV4Y2VydGVkIG9uIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAqL1xudmFyIEJvZHlfYXBwbHlGb3JjZV9mb3JjZVdvcmxkID0gdmVjMi5jcmVhdGUoKTtcbnZhciBCb2R5X2FwcGx5Rm9yY2VfcG9pbnRXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgQm9keV9hcHBseUZvcmNlX3BvaW50TG9jYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuQm9keS5wcm90b3R5cGUuYXBwbHlGb3JjZUxvY2FsID0gZnVuY3Rpb24obG9jYWxGb3JjZSwgbG9jYWxQb2ludCl7XG4gICAgbG9jYWxQb2ludCA9IGxvY2FsUG9pbnQgfHwgQm9keV9hcHBseUZvcmNlX3BvaW50TG9jYWw7XG4gICAgdmFyIHdvcmxkRm9yY2UgPSBCb2R5X2FwcGx5Rm9yY2VfZm9yY2VXb3JsZDtcbiAgICB2YXIgd29ybGRQb2ludCA9IEJvZHlfYXBwbHlGb3JjZV9wb2ludFdvcmxkO1xuICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKHdvcmxkRm9yY2UsIGxvY2FsRm9yY2UpO1xuICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKHdvcmxkUG9pbnQsIGxvY2FsUG9pbnQpO1xuICAgIHRoaXMuYXBwbHlGb3JjZSh3b3JsZEZvcmNlLCB3b3JsZFBvaW50KTtcbn07XG5cbi8qKlxuICogQXBwbHkgaW1wdWxzZSB0byBhIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBib2R5LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQW4gaW1wdWxzZSBpcyBhIGZvcmNlIGFkZGVkIHRvIGEgYm9keSBkdXJpbmcgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSAoaW1wdWxzZSA9IGZvcmNlICogdGltZSkuIEltcHVsc2VzIHdpbGwgYmUgYWRkZWQgdG8gQm9keS52ZWxvY2l0eSBhbmQgQm9keS5hbmd1bGFyVmVsb2NpdHkuXG4gKiBAbWV0aG9kIGFwcGx5SW1wdWxzZVxuICogQHBhcmFtICB7QXJyYXl9IGltcHVsc2UgVGhlIGltcHVsc2UgdmVjdG9yIHRvIGFkZCwgb3JpZW50ZWQgaW4gd29ybGQgc3BhY2UuXG4gKiBAcGFyYW0gIHtBcnJheX0gW3JlbGF0aXZlUG9pbnRdIEEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGJvZHkgaW4gd29ybGQgc3BhY2UuIElmIG5vdCBnaXZlbiwgaXQgaXMgc2V0IHRvIHplcm8gYW5kIGFsbCBvZiB0aGUgaW1wdWxzZSB3aWxsIGJlIGV4Y2VydGVkIG9uIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAqL1xudmFyIEJvZHlfYXBwbHlJbXB1bHNlX3ZlbG8gPSB2ZWMyLmNyZWF0ZSgpO1xuQm9keS5wcm90b3R5cGUuYXBwbHlJbXB1bHNlID0gZnVuY3Rpb24oaW1wdWxzZVZlY3RvciwgcmVsYXRpdmVQb2ludCl7XG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCBjZW50cmFsIGltcHVsc2UgdmVsb2NpdHlcbiAgICB2YXIgdmVsbyA9IEJvZHlfYXBwbHlJbXB1bHNlX3ZlbG87XG4gICAgdmVjMi5zY2FsZSh2ZWxvLCBpbXB1bHNlVmVjdG9yLCB0aGlzLmludk1hc3MpO1xuICAgIHZlYzIubXVsdGlwbHkodmVsbywgdGhpcy5tYXNzTXVsdGlwbGllciwgdmVsbyk7XG5cbiAgICAvLyBBZGQgbGluZWFyIGltcHVsc2VcbiAgICB2ZWMyLmFkZCh0aGlzLnZlbG9jaXR5LCB2ZWxvLCB0aGlzLnZlbG9jaXR5KTtcblxuICAgIGlmKHJlbGF0aXZlUG9pbnQpe1xuICAgICAgICAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgaW1wdWxzZSB2ZWxvY2l0eVxuICAgICAgICB2YXIgcm90VmVsbyA9IHZlYzIuY3Jvc3NMZW5ndGgocmVsYXRpdmVQb2ludCwgaW1wdWxzZVZlY3Rvcik7XG4gICAgICAgIHJvdFZlbG8gKj0gdGhpcy5pbnZJbmVydGlhO1xuXG4gICAgICAgIC8vIEFkZCByb3RhdGlvbmFsIEltcHVsc2VcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKz0gcm90VmVsbztcbiAgICB9XG59O1xuXG4vKipcbiAqIEFwcGx5IGltcHVsc2UgdG8gYSBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keS4gVGhpcyBjb3VsZCBmb3IgZXhhbXBsZSBiZSBhIHBvaW50IG9uIHRoZSBCb2R5IHN1cmZhY2UuIEFuIGltcHVsc2UgaXMgYSBmb3JjZSBhZGRlZCB0byBhIGJvZHkgZHVyaW5nIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgKGltcHVsc2UgPSBmb3JjZSAqIHRpbWUpLiBJbXB1bHNlcyB3aWxsIGJlIGFkZGVkIHRvIEJvZHkudmVsb2NpdHkgYW5kIEJvZHkuYW5ndWxhclZlbG9jaXR5LlxuICogQG1ldGhvZCBhcHBseUltcHVsc2VMb2NhbFxuICogQHBhcmFtICB7QXJyYXl9IGltcHVsc2UgVGhlIGltcHVsc2UgdmVjdG9yIHRvIGFkZCwgb3JpZW50ZWQgaW4gd29ybGQgc3BhY2UuXG4gKiBAcGFyYW0gIHtBcnJheX0gW3JlbGF0aXZlUG9pbnRdIEEgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGJvZHkgaW4gd29ybGQgc3BhY2UuIElmIG5vdCBnaXZlbiwgaXQgaXMgc2V0IHRvIHplcm8gYW5kIGFsbCBvZiB0aGUgaW1wdWxzZSB3aWxsIGJlIGV4Y2VydGVkIG9uIHRoZSBjZW50ZXIgb2YgbWFzcy5cbiAqL1xudmFyIEJvZHlfYXBwbHlJbXB1bHNlX2ltcHVsc2VXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgQm9keV9hcHBseUltcHVsc2VfcG9pbnRXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgQm9keV9hcHBseUltcHVsc2VfcG9pbnRMb2NhbCA9IHZlYzIuY3JlYXRlKCk7XG5Cb2R5LnByb3RvdHlwZS5hcHBseUltcHVsc2VMb2NhbCA9IGZ1bmN0aW9uKGxvY2FsSW1wdWxzZSwgbG9jYWxQb2ludCl7XG4gICAgbG9jYWxQb2ludCA9IGxvY2FsUG9pbnQgfHwgQm9keV9hcHBseUltcHVsc2VfcG9pbnRMb2NhbDtcbiAgICB2YXIgd29ybGRJbXB1bHNlID0gQm9keV9hcHBseUltcHVsc2VfaW1wdWxzZVdvcmxkO1xuICAgIHZhciB3b3JsZFBvaW50ID0gQm9keV9hcHBseUltcHVsc2VfcG9pbnRXb3JsZDtcbiAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZSh3b3JsZEltcHVsc2UsIGxvY2FsSW1wdWxzZSk7XG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUod29ybGRQb2ludCwgbG9jYWxQb2ludCk7XG4gICAgdGhpcy5hcHBseUltcHVsc2Uod29ybGRJbXB1bHNlLCB3b3JsZFBvaW50KTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgd29ybGQgcG9pbnQgdG8gbG9jYWwgYm9keSBmcmFtZS5cbiAqIEBtZXRob2QgdG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0ICAgICAgICAgIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpblxuICogQHBhcmFtICB7QXJyYXl9IHdvcmxkUG9pbnQgICBUaGUgaW5wdXQgd29ybGQgcG9pbnRcbiAqL1xuQm9keS5wcm90b3R5cGUudG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ob3V0LCB3b3JsZFBvaW50KXtcbiAgICB2ZWMyLnRvTG9jYWxGcmFtZShvdXQsIHdvcmxkUG9pbnQsIHRoaXMucG9zaXRpb24sIHRoaXMuYW5nbGUpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBsb2NhbCBwb2ludCB0byB3b3JsZCBmcmFtZS5cbiAqIEBtZXRob2QgdG9Xb3JsZEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0ICAgICAgICAgIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpblxuICogQHBhcmFtICB7QXJyYXl9IGxvY2FsUG9pbnQgICBUaGUgaW5wdXQgbG9jYWwgcG9pbnRcbiAqL1xuQm9keS5wcm90b3R5cGUudG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24ob3V0LCBsb2NhbFBvaW50KXtcbiAgICB2ZWMyLnRvR2xvYmFsRnJhbWUob3V0LCBsb2NhbFBvaW50LCB0aGlzLnBvc2l0aW9uLCB0aGlzLmFuZ2xlKTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgd29ybGQgcG9pbnQgdG8gbG9jYWwgYm9keSBmcmFtZS5cbiAqIEBtZXRob2QgdmVjdG9yVG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0ICAgICAgICAgIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpblxuICogQHBhcmFtICB7QXJyYXl9IHdvcmxkVmVjdG9yICBUaGUgaW5wdXQgd29ybGQgdmVjdG9yXG4gKi9cbkJvZHkucHJvdG90eXBlLnZlY3RvclRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uKG91dCwgd29ybGRWZWN0b3Ipe1xuICAgIHZlYzIudmVjdG9yVG9Mb2NhbEZyYW1lKG91dCwgd29ybGRWZWN0b3IsIHRoaXMuYW5nbGUpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBsb2NhbCBwb2ludCB0byB3b3JsZCBmcmFtZS5cbiAqIEBtZXRob2QgdmVjdG9yVG9Xb3JsZEZyYW1lXG4gKiBAcGFyYW0gIHtBcnJheX0gb3V0ICAgICAgICAgIFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpblxuICogQHBhcmFtICB7QXJyYXl9IGxvY2FsVmVjdG9yICBUaGUgaW5wdXQgbG9jYWwgdmVjdG9yXG4gKi9cbkJvZHkucHJvdG90eXBlLnZlY3RvclRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uKG91dCwgbG9jYWxWZWN0b3Ipe1xuICAgIHZlYzIudmVjdG9yVG9HbG9iYWxGcmFtZShvdXQsIGxvY2FsVmVjdG9yLCB0aGlzLmFuZ2xlKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBwb2x5Z29uIHNoYXBlIHBhdGgsIGFuZCBhc3NlbWJsZXMgY29udmV4IHNoYXBlcyBmcm9tIHRoYXQgYW5kIHB1dHMgdGhlbSBhdCBwcm9wZXIgb2Zmc2V0IHBvaW50cy5cbiAqIEBtZXRob2QgZnJvbVBvbHlnb25cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggQW4gYXJyYXkgb2YgMmQgdmVjdG9ycywgZS5nLiBbWzAsMF0sWzAsMV0sLi4uXSB0aGF0IHJlc2VtYmxlcyBhIGNvbmNhdmUgb3IgY29udmV4IHBvbHlnb24uIFRoZSBzaGFwZSBtdXN0IGJlIHNpbXBsZSBhbmQgd2l0aG91dCBob2xlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3B0aW1hbERlY29tcD1mYWxzZV0gICBTZXQgdG8gdHJ1ZSBpZiB5b3UgbmVlZCBvcHRpbWFsIGRlY29tcG9zaXRpb24uIFdhcm5pbmc6IHZlcnkgc2xvdyBmb3IgcG9seWdvbnMgd2l0aCBtb3JlIHRoYW4gMTAgdmVydGljZXMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBTaW1wbGVDaGVjaz1mYWxzZV0gU2V0IHRvIHRydWUgaWYgeW91IGFscmVhZHkga25vdyB0aGF0IHRoZSBwYXRoIGlzIG5vdCBpbnRlcnNlY3RpbmcgaXRzZWxmLlxuICogQHBhcmFtIHtCb29sZWFufE51bWJlcn0gW29wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzPWZhbHNlXSBTZXQgdG8gYSBudW1iZXIgKGFuZ2xlIHRocmVzaG9sZCB2YWx1ZSkgdG8gcmVtb3ZlIGNvbGxpbmVhciBwb2ludHMsIG9yIGZhbHNlIHRvIGtlZXAgYWxsIHBvaW50cy5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgb24gc3VjY2VzcywgZWxzZSBmYWxzZS5cbiAqL1xuQm9keS5wcm90b3R5cGUuZnJvbVBvbHlnb24gPSBmdW5jdGlvbihwYXRoLG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gUmVtb3ZlIGFsbCBzaGFwZXNcbiAgICBmb3IodmFyIGk9dGhpcy5zaGFwZXMubGVuZ3RoOyBpPj0wOyAtLWkpe1xuICAgICAgICB0aGlzLnJlbW92ZVNoYXBlKHRoaXMuc2hhcGVzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBkZWNvbXAuUG9seWdvbigpO1xuICAgIHAudmVydGljZXMgPSBwYXRoO1xuXG4gICAgLy8gTWFrZSBpdCBjb3VudGVyLWNsb2Nrd2lzZVxuICAgIHAubWFrZUNDVygpO1xuXG4gICAgaWYodHlwZW9mKG9wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICAgIHAucmVtb3ZlQ29sbGluZWFyUG9pbnRzKG9wdGlvbnMucmVtb3ZlQ29sbGluZWFyUG9pbnRzKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhbnkgbGluZSBzZWdtZW50IGludGVyc2VjdHMgdGhlIHBhdGggaXRzZWxmXG4gICAgaWYodHlwZW9mKG9wdGlvbnMuc2tpcFNpbXBsZUNoZWNrKSA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIGlmKCFwLmlzU2ltcGxlKCkpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2F2ZSB0aGlzIHBhdGggZm9yIGxhdGVyXG4gICAgdGhpcy5jb25jYXZlUGF0aCA9IHAudmVydGljZXMuc2xpY2UoMCk7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5jb25jYXZlUGF0aC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gWzAsMF07XG4gICAgICAgIHZlYzIuY29weSh2LHRoaXMuY29uY2F2ZVBhdGhbaV0pO1xuICAgICAgICB0aGlzLmNvbmNhdmVQYXRoW2ldID0gdjtcbiAgICB9XG5cbiAgICAvLyBTbG93IG9yIGZhc3QgZGVjb21wP1xuICAgIHZhciBjb252ZXhlcztcbiAgICBpZihvcHRpb25zLm9wdGltYWxEZWNvbXApe1xuICAgICAgICBjb252ZXhlcyA9IHAuZGVjb21wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29udmV4ZXMgPSBwLnF1aWNrRGVjb21wKCk7XG4gICAgfVxuXG4gICAgdmFyIGNtID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIC8vIEFkZCBjb252ZXhlc1xuICAgIGZvcih2YXIgaT0wOyBpIT09Y29udmV4ZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAvLyBDcmVhdGUgY29udmV4XG4gICAgICAgIHZhciBjID0gbmV3IENvbnZleCh7IHZlcnRpY2VzOiBjb252ZXhlc1tpXS52ZXJ0aWNlcyB9KTtcblxuICAgICAgICAvLyBNb3ZlIGFsbCB2ZXJ0aWNlcyBzbyBpdHMgY2VudGVyIG9mIG1hc3MgaXMgaW4gdGhlIGxvY2FsIGNlbnRlciBvZiB0aGUgY29udmV4XG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09Yy52ZXJ0aWNlcy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICB2YXIgdiA9IGMudmVydGljZXNbal07XG4gICAgICAgICAgICB2ZWMyLnN1Yih2LHYsYy5jZW50ZXJPZk1hc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVjMi5zY2FsZShjbSxjLmNlbnRlck9mTWFzcywxKTtcbiAgICAgICAgYy51cGRhdGVUcmlhbmdsZXMoKTtcbiAgICAgICAgYy51cGRhdGVDZW50ZXJPZk1hc3MoKTtcbiAgICAgICAgYy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgc2hhcGVcbiAgICAgICAgdGhpcy5hZGRTaGFwZShjLGNtKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkanVzdENlbnRlck9mTWFzcygpO1xuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDEgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMiA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIGFkanVzdENlbnRlck9mTWFzc190bXAzID0gdmVjMi5mcm9tVmFsdWVzKDAsMCksXG4gICAgYWRqdXN0Q2VudGVyT2ZNYXNzX3RtcDQgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBNb3ZlcyB0aGUgc2hhcGUgb2Zmc2V0cyBzbyB0aGVpciBjZW50ZXIgb2YgbWFzcyBiZWNvbWVzIHRoZSBib2R5IGNlbnRlciBvZiBtYXNzLlxuICogQG1ldGhvZCBhZGp1c3RDZW50ZXJPZk1hc3NcbiAqL1xuQm9keS5wcm90b3R5cGUuYWRqdXN0Q2VudGVyT2ZNYXNzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgb2Zmc2V0X3RpbWVzX2FyZWEgPSBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMixcbiAgICAgICAgc3VtID0gICAgICAgICAgICAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wMyxcbiAgICAgICAgY20gPSAgICAgICAgICAgICAgICBhZGp1c3RDZW50ZXJPZk1hc3NfdG1wNCxcbiAgICAgICAgdG90YWxBcmVhID0gICAgICAgICAwO1xuICAgIHZlYzIuc2V0KHN1bSwwLDApO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT10aGlzLnNoYXBlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIHZlYzIuc2NhbGUob2Zmc2V0X3RpbWVzX2FyZWEsIHMucG9zaXRpb24sIHMuYXJlYSk7XG4gICAgICAgIHZlYzIuYWRkKHN1bSwgc3VtLCBvZmZzZXRfdGltZXNfYXJlYSk7XG4gICAgICAgIHRvdGFsQXJlYSArPSBzLmFyZWE7XG4gICAgfVxuXG4gICAgdmVjMi5zY2FsZShjbSxzdW0sMS90b3RhbEFyZWEpO1xuXG4gICAgLy8gTm93IG1vdmUgYWxsIHNoYXBlc1xuICAgIGZvcih2YXIgaT0wOyBpIT09dGhpcy5zaGFwZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgcyA9IHRoaXMuc2hhcGVzW2ldO1xuICAgICAgICB2ZWMyLnN1YihzLnBvc2l0aW9uLCBzLnBvc2l0aW9uLCBjbSk7XG4gICAgfVxuXG4gICAgLy8gTW92ZSB0aGUgYm9keSBwb3NpdGlvbiB0b29cbiAgICB2ZWMyLmFkZCh0aGlzLnBvc2l0aW9uLHRoaXMucG9zaXRpb24sY20pO1xuXG4gICAgLy8gQW5kIGNvbmNhdmUgcGF0aFxuICAgIGZvcih2YXIgaT0wOyB0aGlzLmNvbmNhdmVQYXRoICYmIGk8dGhpcy5jb25jYXZlUGF0aC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZlYzIuc3ViKHRoaXMuY29uY2F2ZVBhdGhbaV0sIHRoaXMuY29uY2F2ZVBhdGhbaV0sIGNtKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBmb3JjZSBvbiB0aGUgYm9keSB0byB6ZXJvLlxuICogQG1ldGhvZCBzZXRaZXJvRm9yY2VcbiAqL1xuQm9keS5wcm90b3R5cGUuc2V0WmVyb0ZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICB2ZWMyLnNldCh0aGlzLmZvcmNlLDAuMCwwLjApO1xuICAgIHRoaXMuYW5ndWxhckZvcmNlID0gMC4wO1xufTtcblxuQm9keS5wcm90b3R5cGUucmVzZXRDb25zdHJhaW50VmVsb2NpdHkgPSBmdW5jdGlvbigpe1xuICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgdmxhbWJkYSA9IGIudmxhbWJkYTtcbiAgICB2ZWMyLnNldCh2bGFtYmRhLDAsMCk7XG4gICAgYi53bGFtYmRhID0gMDtcbn07XG5cbkJvZHkucHJvdG90eXBlLmFkZENvbnN0cmFpbnRWZWxvY2l0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICB2ID0gYi52ZWxvY2l0eTtcbiAgICB2ZWMyLmFkZCggdiwgdiwgYi52bGFtYmRhKTtcbiAgICBiLmFuZ3VsYXJWZWxvY2l0eSArPSBiLndsYW1iZGE7XG59O1xuXG4vKipcbiAqIEFwcGx5IGRhbXBpbmcsIHNlZSA8YSBocmVmPVwiaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2J1bGxldC9pc3N1ZXMvZGV0YWlsP2lkPTc0XCI+dGhpczwvYT4gZm9yIGRldGFpbHMuXG4gKiBAbWV0aG9kIGFwcGx5RGFtcGluZ1xuICogQHBhcmFtICB7bnVtYmVyfSBkdCBDdXJyZW50IHRpbWUgc3RlcFxuICovXG5Cb2R5LnByb3RvdHlwZS5hcHBseURhbXBpbmcgPSBmdW5jdGlvbihkdCl7XG4gICAgaWYodGhpcy50eXBlID09PSBCb2R5LkRZTkFNSUMpeyAvLyBPbmx5IGZvciBkeW5hbWljIGJvZGllc1xuICAgICAgICB2YXIgdiA9IHRoaXMudmVsb2NpdHk7XG4gICAgICAgIHZlYzIuc2NhbGUodiwgdiwgTWF0aC5wb3coMS4wIC0gdGhpcy5kYW1waW5nLGR0KSk7XG4gICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ICo9IE1hdGgucG93KDEuMCAtIHRoaXMuYW5ndWxhckRhbXBpbmcsZHQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogV2FrZSB0aGUgYm9keSB1cC4gTm9ybWFsbHkgeW91IHNob3VsZCBub3QgbmVlZCB0aGlzLCBhcyB0aGUgYm9keSBpcyBhdXRvbWF0aWNhbGx5IGF3b2tlbiBhdCBldmVudHMgc3VjaCBhcyBjb2xsaXNpb25zLlxuICogU2V0cyB0aGUgc2xlZXBTdGF0ZSB0byB7eyNjcm9zc0xpbmsgXCJCb2R5L0FXQUtFOnByb3BlcnR5XCJ9fUJvZHkuQVdBS0V7ey9jcm9zc0xpbmt9fSBhbmQgZW1pdHMgdGhlIHdha2VVcCBldmVudCBpZiB0aGUgYm9keSB3YXNuJ3QgYXdha2UgYmVmb3JlLlxuICogQG1ldGhvZCB3YWtlVXBcbiAqL1xuQm9keS5wcm90b3R5cGUud2FrZVVwID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcyA9IHRoaXMuc2xlZXBTdGF0ZTtcbiAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LkFXQUtFO1xuICAgIHRoaXMuaWRsZVRpbWUgPSAwO1xuICAgIGlmKHMgIT09IEJvZHkuQVdBS0Upe1xuICAgICAgICB0aGlzLmVtaXQoQm9keS53YWtlVXBFdmVudCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBGb3JjZSBib2R5IHNsZWVwXG4gKiBAbWV0aG9kIHNsZWVwXG4gKi9cbkJvZHkucHJvdG90eXBlLnNsZWVwID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQSU5HO1xuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0gMDtcbiAgICB0aGlzLmFuZ3VsYXJGb3JjZSA9IDA7XG4gICAgdmVjMi5zZXQodGhpcy52ZWxvY2l0eSwwLDApO1xuICAgIHZlYzIuc2V0KHRoaXMuZm9yY2UsMCwwKTtcbiAgICB0aGlzLmVtaXQoQm9keS5zbGVlcEV2ZW50KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGV2ZXJ5IHRpbWVzdGVwIHRvIHVwZGF0ZSBpbnRlcm5hbCBzbGVlcCB0aW1lciBhbmQgY2hhbmdlIHNsZWVwIHN0YXRlIGlmIG5lZWRlZC5cbiAqIEBtZXRob2Qgc2xlZXBUaWNrXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgd29ybGQgdGltZSBpbiBzZWNvbmRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRvbnRTbGVlcFxuICogQHBhcmFtIHtudW1iZXJ9IGR0XG4gKi9cbkJvZHkucHJvdG90eXBlLnNsZWVwVGljayA9IGZ1bmN0aW9uKHRpbWUsIGRvbnRTbGVlcCwgZHQpe1xuICAgIGlmKCF0aGlzLmFsbG93U2xlZXAgfHwgdGhpcy50eXBlID09PSBCb2R5LlNMRUVQSU5HKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud2FudHNUb1NsZWVwID0gZmFsc2U7XG5cbiAgICB2YXIgc2xlZXBTdGF0ZSA9IHRoaXMuc2xlZXBTdGF0ZSxcbiAgICAgICAgc3BlZWRTcXVhcmVkID0gdmVjMi5zcXVhcmVkTGVuZ3RoKHRoaXMudmVsb2NpdHkpICsgTWF0aC5wb3codGhpcy5hbmd1bGFyVmVsb2NpdHksMiksXG4gICAgICAgIHNwZWVkTGltaXRTcXVhcmVkID0gTWF0aC5wb3codGhpcy5zbGVlcFNwZWVkTGltaXQsMik7XG5cbiAgICAvLyBBZGQgdG8gaWRsZSB0aW1lXG4gICAgaWYoc3BlZWRTcXVhcmVkID49IHNwZWVkTGltaXRTcXVhcmVkKXtcbiAgICAgICAgdGhpcy5pZGxlVGltZSA9IDA7XG4gICAgICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuQVdBS0U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pZGxlVGltZSArPSBkdDtcbiAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUFk7XG4gICAgfVxuICAgIGlmKHRoaXMuaWRsZVRpbWUgPiB0aGlzLnNsZWVwVGltZUxpbWl0KXtcbiAgICAgICAgaWYoIWRvbnRTbGVlcCl7XG4gICAgICAgICAgICB0aGlzLnNsZWVwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndhbnRzVG9TbGVlcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBib2R5IGlzIG92ZXJsYXBwaW5nIGFub3RoZXIgYm9keS4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG9ubHkgd29ya3MgaWYgdGhlIGJvZHkgd2FzIGFkZGVkIHRvIGEgV29ybGQgYW5kIGlmIGF0IGxlYXN0IG9uZSBzdGVwIHdhcyB0YWtlbi5cbiAqIEBtZXRob2Qgb3ZlcmxhcHNcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkJvZHkucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24oYm9keSl7XG4gICAgcmV0dXJuIHRoaXMud29ybGQub3ZlcmxhcEtlZXBlci5ib2RpZXNBcmVPdmVybGFwcGluZyh0aGlzLCBib2R5KTtcbn07XG5cbnZhciBpbnRlZ3JhdGVfZmhNaW52ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlZ3JhdGVfdmVsb2R0ID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBNb3ZlIHRoZSBib2R5IGZvcndhcmQgaW4gdGltZSBnaXZlbiBpdHMgY3VycmVudCB2ZWxvY2l0eS5cbiAqIEBtZXRob2QgaW50ZWdyYXRlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGR0XG4gKi9cbkJvZHkucHJvdG90eXBlLmludGVncmF0ZSA9IGZ1bmN0aW9uKGR0KXtcbiAgICB2YXIgbWludiA9IHRoaXMuaW52TWFzcyxcbiAgICAgICAgZiA9IHRoaXMuZm9yY2UsXG4gICAgICAgIHBvcyA9IHRoaXMucG9zaXRpb24sXG4gICAgICAgIHZlbG8gPSB0aGlzLnZlbG9jaXR5O1xuXG4gICAgLy8gU2F2ZSBvbGQgcG9zaXRpb25cbiAgICB2ZWMyLmNvcHkodGhpcy5wcmV2aW91c1Bvc2l0aW9uLCB0aGlzLnBvc2l0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzQW5nbGUgPSB0aGlzLmFuZ2xlO1xuXG4gICAgLy8gVmVsb2NpdHkgdXBkYXRlXG4gICAgaWYoIXRoaXMuZml4ZWRSb3RhdGlvbil7XG4gICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ICs9IHRoaXMuYW5ndWxhckZvcmNlICogdGhpcy5pbnZJbmVydGlhICogZHQ7XG4gICAgfVxuICAgIHZlYzIuc2NhbGUoaW50ZWdyYXRlX2ZoTWludiwgZiwgZHQgKiBtaW52KTtcbiAgICB2ZWMyLm11bHRpcGx5KGludGVncmF0ZV9maE1pbnYsIHRoaXMubWFzc011bHRpcGxpZXIsIGludGVncmF0ZV9maE1pbnYpO1xuICAgIHZlYzIuYWRkKHZlbG8sIGludGVncmF0ZV9maE1pbnYsIHZlbG8pO1xuXG4gICAgLy8gQ0NEXG4gICAgaWYoIXRoaXMuaW50ZWdyYXRlVG9UaW1lT2ZJbXBhY3QoZHQpKXtcblxuICAgICAgICAvLyBSZWd1bGFyIHBvc2l0aW9uIHVwZGF0ZVxuICAgICAgICB2ZWMyLnNjYWxlKGludGVncmF0ZV92ZWxvZHQsIHZlbG8sIGR0KTtcbiAgICAgICAgdmVjMi5hZGQocG9zLCBwb3MsIGludGVncmF0ZV92ZWxvZHQpO1xuICAgICAgICBpZighdGhpcy5maXhlZFJvdGF0aW9uKXtcbiAgICAgICAgICAgIHRoaXMuYW5nbGUgKz0gdGhpcy5hbmd1bGFyVmVsb2NpdHkgKiBkdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcbn07XG5cbnZhciByZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xudmFyIHJheSA9IG5ldyBSYXkoe1xuICAgIG1vZGU6IFJheS5BTExcbn0pO1xudmFyIGRpcmVjdGlvbiA9IHZlYzIuY3JlYXRlKCk7XG52YXIgZW5kID0gdmVjMi5jcmVhdGUoKTtcbnZhciBzdGFydFRvRW5kID0gdmVjMi5jcmVhdGUoKTtcbnZhciByZW1lbWJlclBvc2l0aW9uID0gdmVjMi5jcmVhdGUoKTtcbkJvZHkucHJvdG90eXBlLmludGVncmF0ZVRvVGltZU9mSW1wYWN0ID0gZnVuY3Rpb24oZHQpe1xuXG4gICAgaWYodGhpcy5jY2RTcGVlZFRocmVzaG9sZCA8IDAgfHwgdmVjMi5zcXVhcmVkTGVuZ3RoKHRoaXMudmVsb2NpdHkpIDwgTWF0aC5wb3codGhpcy5jY2RTcGVlZFRocmVzaG9sZCwgMikpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmVjMi5ub3JtYWxpemUoZGlyZWN0aW9uLCB0aGlzLnZlbG9jaXR5KTtcblxuICAgIHZlYzIuc2NhbGUoZW5kLCB0aGlzLnZlbG9jaXR5LCBkdCk7XG4gICAgdmVjMi5hZGQoZW5kLCBlbmQsIHRoaXMucG9zaXRpb24pO1xuXG4gICAgdmVjMi5zdWIoc3RhcnRUb0VuZCwgZW5kLCB0aGlzLnBvc2l0aW9uKTtcbiAgICB2YXIgc3RhcnRUb0VuZEFuZ2xlID0gdGhpcy5hbmd1bGFyVmVsb2NpdHkgKiBkdDtcbiAgICB2YXIgbGVuID0gdmVjMi5sZW5ndGgoc3RhcnRUb0VuZCk7XG5cbiAgICB2YXIgdGltZU9mSW1wYWN0ID0gMTtcblxuICAgIHZhciBoaXQ7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJlc3VsdC5yZXNldCgpO1xuICAgIHJheS5jYWxsYmFjayA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYocmVzdWx0LmJvZHkgPT09IHRoYXQpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhpdCA9IHJlc3VsdC5ib2R5O1xuICAgICAgICByZXN1bHQuZ2V0SGl0UG9pbnQoZW5kLCByYXkpO1xuICAgICAgICB2ZWMyLnN1YihzdGFydFRvRW5kLCBlbmQsIHRoYXQucG9zaXRpb24pO1xuICAgICAgICB0aW1lT2ZJbXBhY3QgPSB2ZWMyLmxlbmd0aChzdGFydFRvRW5kKSAvIGxlbjtcbiAgICAgICAgcmVzdWx0LnN0b3AoKTtcbiAgICB9O1xuICAgIHZlYzIuY29weShyYXkuZnJvbSwgdGhpcy5wb3NpdGlvbik7XG4gICAgdmVjMi5jb3B5KHJheS50bywgZW5kKTtcbiAgICByYXkudXBkYXRlKCk7XG4gICAgdGhpcy53b3JsZC5yYXljYXN0KHJlc3VsdCwgcmF5KTtcblxuICAgIGlmKCFoaXQpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHJlbWVtYmVyQW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgIHZlYzIuY29weShyZW1lbWJlclBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uKTtcblxuICAgIC8vIEdvdCBhIHN0YXJ0IGFuZCBlbmQgcG9pbnQuIEFwcHJveGltYXRlIHRpbWUgb2YgaW1wYWN0IHVzaW5nIGJpbmFyeSBzZWFyY2hcbiAgICB2YXIgaXRlciA9IDA7XG4gICAgdmFyIHRtaW4gPSAwO1xuICAgIHZhciB0bWlkID0gMDtcbiAgICB2YXIgdG1heCA9IHRpbWVPZkltcGFjdDtcbiAgICB3aGlsZSAodG1heCA+PSB0bWluICYmIGl0ZXIgPCB0aGlzLmNjZEl0ZXJhdGlvbnMpIHtcbiAgICAgICAgaXRlcisrO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbWlkcG9pbnRcbiAgICAgICAgdG1pZCA9ICh0bWF4IC0gdG1pbikgLyAyO1xuXG4gICAgICAgIC8vIE1vdmUgdGhlIGJvZHkgdG8gdGhhdCBwb2ludFxuICAgICAgICB2ZWMyLnNjYWxlKGludGVncmF0ZV92ZWxvZHQsIHN0YXJ0VG9FbmQsIHRpbWVPZkltcGFjdCk7XG4gICAgICAgIHZlYzIuYWRkKHRoaXMucG9zaXRpb24sIHJlbWVtYmVyUG9zaXRpb24sIGludGVncmF0ZV92ZWxvZHQpO1xuICAgICAgICB0aGlzLmFuZ2xlID0gcmVtZW1iZXJBbmdsZSArIHN0YXJ0VG9FbmRBbmdsZSAqIHRpbWVPZkltcGFjdDtcbiAgICAgICAgdGhpcy51cGRhdGVBQUJCKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgb3ZlcmxhcFxuICAgICAgICB2YXIgb3ZlcmxhcHMgPSB0aGlzLmFhYmIub3ZlcmxhcHMoaGl0LmFhYmIpICYmIHRoaXMud29ybGQubmFycm93cGhhc2UuYm9kaWVzT3ZlcmxhcCh0aGlzLCBoaXQpO1xuXG4gICAgICAgIGlmIChvdmVybGFwcykge1xuICAgICAgICAgICAgLy8gY2hhbmdlIG1pbiB0byBzZWFyY2ggdXBwZXIgaW50ZXJ2YWxcbiAgICAgICAgICAgIHRtaW4gPSB0bWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2hhbmdlIG1heCB0byBzZWFyY2ggbG93ZXIgaW50ZXJ2YWxcbiAgICAgICAgICAgIHRtYXggPSB0bWlkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGltZU9mSW1wYWN0ID0gdG1pZDtcblxuICAgIHZlYzIuY29weSh0aGlzLnBvc2l0aW9uLCByZW1lbWJlclBvc2l0aW9uKTtcbiAgICB0aGlzLmFuZ2xlID0gcmVtZW1iZXJBbmdsZTtcblxuICAgIC8vIG1vdmUgdG8gVE9JXG4gICAgdmVjMi5zY2FsZShpbnRlZ3JhdGVfdmVsb2R0LCBzdGFydFRvRW5kLCB0aW1lT2ZJbXBhY3QpO1xuICAgIHZlYzIuYWRkKHRoaXMucG9zaXRpb24sIHRoaXMucG9zaXRpb24sIGludGVncmF0ZV92ZWxvZHQpO1xuICAgIGlmKCF0aGlzLmZpeGVkUm90YXRpb24pe1xuICAgICAgICB0aGlzLmFuZ2xlICs9IHN0YXJ0VG9FbmRBbmdsZSAqIHRpbWVPZkltcGFjdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogR2V0IHZlbG9jaXR5IG9mIGEgcG9pbnQgaW4gdGhlIGJvZHkuXG4gKiBAbWV0aG9kIGdldFZlbG9jaXR5QXRQb2ludFxuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdCBBIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluXG4gKiBAcGFyYW0gIHtBcnJheX0gcmVsYXRpdmVQb2ludCBBIHdvcmxkIG9yaWVudGVkIHZlY3RvciwgaW5kaWNhdGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvaW50IHRvIGdldCB0aGUgdmVsb2NpdHkgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IFRoZSByZXN1bHQgdmVjdG9yXG4gKi9cbkJvZHkucHJvdG90eXBlLmdldFZlbG9jaXR5QXRQb2ludCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmVsYXRpdmVQb2ludCl7XG4gICAgdmVjMi5jcm9zc1ZaKHJlc3VsdCwgcmVsYXRpdmVQb2ludCwgdGhpcy5hbmd1bGFyVmVsb2NpdHkpO1xuICAgIHZlYzIuc3VidHJhY3QocmVzdWx0LCB0aGlzLnZlbG9jaXR5LCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBldmVudCBzbGVlcHlcbiAqL1xuQm9keS5zbGVlcHlFdmVudCA9IHtcbiAgICB0eXBlOiBcInNsZWVweVwiXG59O1xuXG4vKipcbiAqIEBldmVudCBzbGVlcFxuICovXG5Cb2R5LnNsZWVwRXZlbnQgPSB7XG4gICAgdHlwZTogXCJzbGVlcFwiXG59O1xuXG4vKipcbiAqIEBldmVudCB3YWtldXBcbiAqL1xuQm9keS53YWtlVXBFdmVudCA9IHtcbiAgICB0eXBlOiBcIndha2V1cFwiXG59O1xuXG4vKipcbiAqIER5bmFtaWMgYm9keS5cbiAqIEBwcm9wZXJ0eSBEWU5BTUlDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5Cb2R5LkRZTkFNSUMgPSAxO1xuXG4vKipcbiAqIFN0YXRpYyBib2R5LlxuICogQHByb3BlcnR5IFNUQVRJQ1xuICogQHR5cGUge051bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuQm9keS5TVEFUSUMgPSAyO1xuXG4vKipcbiAqIEtpbmVtYXRpYyBib2R5LlxuICogQHByb3BlcnR5IEtJTkVNQVRJQ1xuICogQHR5cGUge051bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuQm9keS5LSU5FTUFUSUMgPSA0O1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBBV0FLRVxuICogQHR5cGUge051bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuQm9keS5BV0FLRSA9IDA7XG5cbi8qKlxuICogQHByb3BlcnR5IFNMRUVQWVxuICogQHR5cGUge051bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuQm9keS5TTEVFUFkgPSAxO1xuXG4vKipcbiAqIEBwcm9wZXJ0eSBTTEVFUElOR1xuICogQHR5cGUge051bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuQm9keS5TTEVFUElORyA9IDI7XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/objects/Body.js\n");

/***/ }),

/***/ "./node_modules/p2/src/objects/LinearSpring.js":
/*!*****************************************************!*\
  !*** ./node_modules/p2/src/objects/LinearSpring.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\nvar Spring = __webpack_require__(/*! ./Spring */ \"./node_modules/p2/src/objects/Spring.js\");\nvar Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\");\n\nmodule.exports = LinearSpring;\n\n/**\n * A spring, connecting two bodies.\n *\n * The Spring explicitly adds force and angularForce to the bodies.\n *\n * @class LinearSpring\n * @extends Spring\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {number} [options.restLength]   A number > 0. Default is the current distance between the world anchor points.\n * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.\n * @param {number} [options.damping=1]      A number >= 0. Default: 1\n * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option \"localAnchorA\" if given.\n * @param {Array}  [options.worldAnchorB]\n * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.\n * @param {Array}  [options.localAnchorB]\n */\nfunction LinearSpring(bodyA,bodyB,options){\n    options = options || {};\n\n    Spring.call(this, bodyA, bodyB, options);\n\n    /**\n     * Anchor for bodyA in local bodyA coordinates.\n     * @property localAnchorA\n     * @type {Array}\n     */\n    this.localAnchorA = vec2.fromValues(0,0);\n\n    /**\n     * Anchor for bodyB in local bodyB coordinates.\n     * @property localAnchorB\n     * @type {Array}\n     */\n    this.localAnchorB = vec2.fromValues(0,0);\n\n    if(options.localAnchorA){ vec2.copy(this.localAnchorA, options.localAnchorA); }\n    if(options.localAnchorB){ vec2.copy(this.localAnchorB, options.localAnchorB); }\n    if(options.worldAnchorA){ this.setWorldAnchorA(options.worldAnchorA); }\n    if(options.worldAnchorB){ this.setWorldAnchorB(options.worldAnchorB); }\n\n    var worldAnchorA = vec2.create();\n    var worldAnchorB = vec2.create();\n    this.getWorldAnchorA(worldAnchorA);\n    this.getWorldAnchorB(worldAnchorB);\n    var worldDistance = vec2.distance(worldAnchorA, worldAnchorB);\n\n    /**\n     * Rest length of the spring.\n     * @property restLength\n     * @type {number}\n     */\n    this.restLength = typeof(options.restLength) === \"number\" ? options.restLength : worldDistance;\n}\nLinearSpring.prototype = new Spring();\nLinearSpring.prototype.constructor = LinearSpring;\n\n/**\n * Set the anchor point on body A, using world coordinates.\n * @method setWorldAnchorA\n * @param {Array} worldAnchorA\n */\nLinearSpring.prototype.setWorldAnchorA = function(worldAnchorA){\n    this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);\n};\n\n/**\n * Set the anchor point on body B, using world coordinates.\n * @method setWorldAnchorB\n * @param {Array} worldAnchorB\n */\nLinearSpring.prototype.setWorldAnchorB = function(worldAnchorB){\n    this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);\n};\n\n/**\n * Get the anchor point on body A, in world coordinates.\n * @method getWorldAnchorA\n * @param {Array} result The vector to store the result in.\n */\nLinearSpring.prototype.getWorldAnchorA = function(result){\n    this.bodyA.toWorldFrame(result, this.localAnchorA);\n};\n\n/**\n * Get the anchor point on body B, in world coordinates.\n * @method getWorldAnchorB\n * @param {Array} result The vector to store the result in.\n */\nLinearSpring.prototype.getWorldAnchorB = function(result){\n    this.bodyB.toWorldFrame(result, this.localAnchorB);\n};\n\nvar applyForce_r =              vec2.create(),\n    applyForce_r_unit =         vec2.create(),\n    applyForce_u =              vec2.create(),\n    applyForce_f =              vec2.create(),\n    applyForce_worldAnchorA =   vec2.create(),\n    applyForce_worldAnchorB =   vec2.create(),\n    applyForce_ri =             vec2.create(),\n    applyForce_rj =             vec2.create(),\n    applyForce_tmp =            vec2.create();\n\n/**\n * Apply the spring force to the connected bodies.\n * @method applyForce\n */\nLinearSpring.prototype.applyForce = function(){\n    var k = this.stiffness,\n        d = this.damping,\n        l = this.restLength,\n        bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        r = applyForce_r,\n        r_unit = applyForce_r_unit,\n        u = applyForce_u,\n        f = applyForce_f,\n        tmp = applyForce_tmp;\n\n    var worldAnchorA = applyForce_worldAnchorA,\n        worldAnchorB = applyForce_worldAnchorB,\n        ri = applyForce_ri,\n        rj = applyForce_rj;\n\n    // Get world anchors\n    this.getWorldAnchorA(worldAnchorA);\n    this.getWorldAnchorB(worldAnchorB);\n\n    // Get offset points\n    vec2.sub(ri, worldAnchorA, bodyA.position);\n    vec2.sub(rj, worldAnchorB, bodyB.position);\n\n    // Compute distance vector between world anchor points\n    vec2.sub(r, worldAnchorB, worldAnchorA);\n    var rlen = vec2.len(r);\n    vec2.normalize(r_unit,r);\n\n    //console.log(rlen)\n    //console.log(\"A\",vec2.str(worldAnchorA),\"B\",vec2.str(worldAnchorB))\n\n    // Compute relative velocity of the anchor points, u\n    vec2.sub(u, bodyB.velocity, bodyA.velocity);\n    vec2.crossZV(tmp, bodyB.angularVelocity, rj);\n    vec2.add(u, u, tmp);\n    vec2.crossZV(tmp, bodyA.angularVelocity, ri);\n    vec2.sub(u, u, tmp);\n\n    // F = - k * ( x - L ) - D * ( u )\n    vec2.scale(f, r_unit, -k*(rlen-l) - d*vec2.dot(u,r_unit));\n\n    // Add forces to bodies\n    vec2.sub( bodyA.force, bodyA.force, f);\n    vec2.add( bodyB.force, bodyB.force, f);\n\n    // Angular force\n    var ri_x_f = vec2.crossLength(ri, f);\n    var rj_x_f = vec2.crossLength(rj, f);\n    bodyA.angularForce -= ri_x_f;\n    bodyB.angularForce += rj_x_f;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL29iamVjdHMvTGluZWFyU3ByaW5nLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9vYmplY3RzL0xpbmVhclNwcmluZy5qcz80YWFjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJyk7XG52YXIgU3ByaW5nID0gcmVxdWlyZSgnLi9TcHJpbmcnKTtcbnZhciBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZWFyU3ByaW5nO1xuXG4vKipcbiAqIEEgc3ByaW5nLCBjb25uZWN0aW5nIHR3byBib2RpZXMuXG4gKlxuICogVGhlIFNwcmluZyBleHBsaWNpdGx5IGFkZHMgZm9yY2UgYW5kIGFuZ3VsYXJGb3JjZSB0byB0aGUgYm9kaWVzLlxuICpcbiAqIEBjbGFzcyBMaW5lYXJTcHJpbmdcbiAqIEBleHRlbmRzIFNwcmluZ1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzdExlbmd0aF0gICBBIG51bWJlciA+IDAuIERlZmF1bHQgaXMgdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgd29ybGQgYW5jaG9yIHBvaW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGlmZm5lc3M9MTAwXSAgU3ByaW5nIGNvbnN0YW50IChzZWUgSG9va2VzIExhdykuIEEgbnVtYmVyID49IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZz0xXSAgICAgIEEgbnVtYmVyID49IDAuIERlZmF1bHQ6IDFcbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy53b3JsZEFuY2hvckFdICAgV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuIE92ZXJyaWRlcyB0aGUgb3B0aW9uIFwibG9jYWxBbmNob3JBXCIgaWYgZ2l2ZW4uXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JCXVxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLmxvY2FsQW5jaG9yQV0gICBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiBsb2NhbCBib2R5IGNvb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB0aGUgYm9keSBjZW50ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxuICovXG5mdW5jdGlvbiBMaW5lYXJTcHJpbmcoYm9keUEsYm9keUIsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBTcHJpbmcuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QSBpbiBsb2NhbCBib2R5QSBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubG9jYWxBbmNob3JBID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbiAgICAvKipcbiAgICAgKiBBbmNob3IgZm9yIGJvZHlCIGluIGxvY2FsIGJvZHlCIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbEFuY2hvckJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIGlmKG9wdGlvbnMubG9jYWxBbmNob3JBKXsgdmVjMi5jb3B5KHRoaXMubG9jYWxBbmNob3JBLCBvcHRpb25zLmxvY2FsQW5jaG9yQSk7IH1cbiAgICBpZihvcHRpb25zLmxvY2FsQW5jaG9yQil7IHZlYzIuY29weSh0aGlzLmxvY2FsQW5jaG9yQiwgb3B0aW9ucy5sb2NhbEFuY2hvckIpOyB9XG4gICAgaWYob3B0aW9ucy53b3JsZEFuY2hvckEpeyB0aGlzLnNldFdvcmxkQW5jaG9yQShvcHRpb25zLndvcmxkQW5jaG9yQSk7IH1cbiAgICBpZihvcHRpb25zLndvcmxkQW5jaG9yQil7IHRoaXMuc2V0V29ybGRBbmNob3JCKG9wdGlvbnMud29ybGRBbmNob3JCKTsgfVxuXG4gICAgdmFyIHdvcmxkQW5jaG9yQSA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdmFyIHdvcmxkQW5jaG9yQiA9IHZlYzIuY3JlYXRlKCk7XG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKTtcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xuICAgIHZhciB3b3JsZERpc3RhbmNlID0gdmVjMi5kaXN0YW5jZSh3b3JsZEFuY2hvckEsIHdvcmxkQW5jaG9yQik7XG5cbiAgICAvKipcbiAgICAgKiBSZXN0IGxlbmd0aCBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0TGVuZ3RoXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RMZW5ndGggPSB0eXBlb2Yob3B0aW9ucy5yZXN0TGVuZ3RoKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucmVzdExlbmd0aCA6IHdvcmxkRGlzdGFuY2U7XG59XG5MaW5lYXJTcHJpbmcucHJvdG90eXBlID0gbmV3IFNwcmluZygpO1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVhclNwcmluZztcblxuLyoqXG4gKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBzZXRXb3JsZEFuY2hvckFcbiAqIEBwYXJhbSB7QXJyYXl9IHdvcmxkQW5jaG9yQVxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLnNldFdvcmxkQW5jaG9yQSA9IGZ1bmN0aW9uKHdvcmxkQW5jaG9yQSl7XG4gICAgdGhpcy5ib2R5QS50b0xvY2FsRnJhbWUodGhpcy5sb2NhbEFuY2hvckEsIHdvcmxkQW5jaG9yQSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtBcnJheX0gd29ybGRBbmNob3JCXG4gKi9cbkxpbmVhclNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JCID0gZnVuY3Rpb24od29ybGRBbmNob3JCKXtcbiAgICB0aGlzLmJvZHlCLnRvTG9jYWxGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQiwgd29ybGRBbmNob3JCKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JBXG4gKiBAcGFyYW0ge0FycmF5fSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxuICovXG5MaW5lYXJTcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQSA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdGhpcy5ib2R5QS50b1dvcmxkRnJhbWUocmVzdWx0LCB0aGlzLmxvY2FsQW5jaG9yQSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIGdldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtBcnJheX0gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5nZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMuYm9keUIudG9Xb3JsZEZyYW1lKHJlc3VsdCwgdGhpcy5sb2NhbEFuY2hvckIpO1xufTtcblxudmFyIGFwcGx5Rm9yY2VfciA9ICAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2Vfcl91bml0ID0gICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfdSA9ICAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfZiA9ICAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBID0gICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCID0gICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfcmkgPSAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfcmogPSAgICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIGFwcGx5Rm9yY2VfdG1wID0gICAgICAgICAgICB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqL1xuTGluZWFyU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxuICAgICAgICBkID0gdGhpcy5kYW1waW5nLFxuICAgICAgICBsID0gdGhpcy5yZXN0TGVuZ3RoLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgciA9IGFwcGx5Rm9yY2VfcixcbiAgICAgICAgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQsXG4gICAgICAgIHUgPSBhcHBseUZvcmNlX3UsXG4gICAgICAgIGYgPSBhcHBseUZvcmNlX2YsXG4gICAgICAgIHRtcCA9IGFwcGx5Rm9yY2VfdG1wO1xuXG4gICAgdmFyIHdvcmxkQW5jaG9yQSA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBLFxuICAgICAgICB3b3JsZEFuY2hvckIgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQixcbiAgICAgICAgcmkgPSBhcHBseUZvcmNlX3JpLFxuICAgICAgICByaiA9IGFwcGx5Rm9yY2Vfcmo7XG5cbiAgICAvLyBHZXQgd29ybGQgYW5jaG9yc1xuICAgIHRoaXMuZ2V0V29ybGRBbmNob3JBKHdvcmxkQW5jaG9yQSk7XG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckIod29ybGRBbmNob3JCKTtcblxuICAgIC8vIEdldCBvZmZzZXQgcG9pbnRzXG4gICAgdmVjMi5zdWIocmksIHdvcmxkQW5jaG9yQSwgYm9keUEucG9zaXRpb24pO1xuICAgIHZlYzIuc3ViKHJqLCB3b3JsZEFuY2hvckIsIGJvZHlCLnBvc2l0aW9uKTtcblxuICAgIC8vIENvbXB1dGUgZGlzdGFuY2UgdmVjdG9yIGJldHdlZW4gd29ybGQgYW5jaG9yIHBvaW50c1xuICAgIHZlYzIuc3ViKHIsIHdvcmxkQW5jaG9yQiwgd29ybGRBbmNob3JBKTtcbiAgICB2YXIgcmxlbiA9IHZlYzIubGVuKHIpO1xuICAgIHZlYzIubm9ybWFsaXplKHJfdW5pdCxyKTtcblxuICAgIC8vY29uc29sZS5sb2cocmxlbilcbiAgICAvL2NvbnNvbGUubG9nKFwiQVwiLHZlYzIuc3RyKHdvcmxkQW5jaG9yQSksXCJCXCIsdmVjMi5zdHIod29ybGRBbmNob3JCKSlcblxuICAgIC8vIENvbXB1dGUgcmVsYXRpdmUgdmVsb2NpdHkgb2YgdGhlIGFuY2hvciBwb2ludHMsIHVcbiAgICB2ZWMyLnN1Yih1LCBib2R5Qi52ZWxvY2l0eSwgYm9keUEudmVsb2NpdHkpO1xuICAgIHZlYzIuY3Jvc3NaVih0bXAsIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSwgcmopO1xuICAgIHZlYzIuYWRkKHUsIHUsIHRtcCk7XG4gICAgdmVjMi5jcm9zc1pWKHRtcCwgYm9keUEuYW5ndWxhclZlbG9jaXR5LCByaSk7XG4gICAgdmVjMi5zdWIodSwgdSwgdG1wKTtcblxuICAgIC8vIEYgPSAtIGsgKiAoIHggLSBMICkgLSBEICogKCB1IClcbiAgICB2ZWMyLnNjYWxlKGYsIHJfdW5pdCwgLWsqKHJsZW4tbCkgLSBkKnZlYzIuZG90KHUscl91bml0KSk7XG5cbiAgICAvLyBBZGQgZm9yY2VzIHRvIGJvZGllc1xuICAgIHZlYzIuc3ViKCBib2R5QS5mb3JjZSwgYm9keUEuZm9yY2UsIGYpO1xuICAgIHZlYzIuYWRkKCBib2R5Qi5mb3JjZSwgYm9keUIuZm9yY2UsIGYpO1xuXG4gICAgLy8gQW5ndWxhciBmb3JjZVxuICAgIHZhciByaV94X2YgPSB2ZWMyLmNyb3NzTGVuZ3RoKHJpLCBmKTtcbiAgICB2YXIgcmpfeF9mID0gdmVjMi5jcm9zc0xlbmd0aChyaiwgZik7XG4gICAgYm9keUEuYW5ndWxhckZvcmNlIC09IHJpX3hfZjtcbiAgICBib2R5Qi5hbmd1bGFyRm9yY2UgKz0gcmpfeF9mO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/objects/LinearSpring.js\n");

/***/ }),

/***/ "./node_modules/p2/src/objects/RotationalSpring.js":
/*!*********************************************************!*\
  !*** ./node_modules/p2/src/objects/RotationalSpring.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\nvar Spring = __webpack_require__(/*! ./Spring */ \"./node_modules/p2/src/objects/Spring.js\");\n\nmodule.exports = RotationalSpring;\n\n/**\n * A rotational spring, connecting two bodies rotation. This spring explicitly adds angularForce (torque) to the bodies.\n *\n * The spring can be combined with a {{#crossLink \"RevoluteConstraint\"}}{{/crossLink}} to make, for example, a mouse trap.\n *\n * @class RotationalSpring\n * @extends Spring\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {number} [options.restAngle] The relative angle of bodies at which the spring is at rest. If not given, it's set to the current relative angle between the bodies.\n * @param {number} [options.stiffness=100] Spring constant (see Hookes Law). A number >= 0.\n * @param {number} [options.damping=1] A number >= 0.\n */\nfunction RotationalSpring(bodyA, bodyB, options){\n    options = options || {};\n\n    Spring.call(this, bodyA, bodyB, options);\n\n    /**\n     * Rest angle of the spring.\n     * @property restAngle\n     * @type {number}\n     */\n    this.restAngle = typeof(options.restAngle) === \"number\" ? options.restAngle : bodyB.angle - bodyA.angle;\n}\nRotationalSpring.prototype = new Spring();\nRotationalSpring.prototype.constructor = RotationalSpring;\n\n/**\n * Apply the spring force to the connected bodies.\n * @method applyForce\n */\nRotationalSpring.prototype.applyForce = function(){\n    var k = this.stiffness,\n        d = this.damping,\n        l = this.restAngle,\n        bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        x = bodyB.angle - bodyA.angle,\n        u = bodyB.angularVelocity - bodyA.angularVelocity;\n\n    var torque = - k * (x - l) - d * u * 0;\n\n    bodyA.angularForce -= torque;\n    bodyB.angularForce += torque;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL29iamVjdHMvUm90YXRpb25hbFNwcmluZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvb2JqZWN0cy9Sb3RhdGlvbmFsU3ByaW5nLmpzP2NhNTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcbnZhciBTcHJpbmcgPSByZXF1aXJlKCcuL1NwcmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxTcHJpbmc7XG5cbi8qKlxuICogQSByb3RhdGlvbmFsIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzIHJvdGF0aW9uLiBUaGlzIHNwcmluZyBleHBsaWNpdGx5IGFkZHMgYW5ndWxhckZvcmNlICh0b3JxdWUpIHRvIHRoZSBib2RpZXMuXG4gKlxuICogVGhlIHNwcmluZyBjYW4gYmUgY29tYmluZWQgd2l0aCBhIHt7I2Nyb3NzTGluayBcIlJldm9sdXRlQ29uc3RyYWludFwifX17ey9jcm9zc0xpbmt9fSB0byBtYWtlLCBmb3IgZXhhbXBsZSwgYSBtb3VzZSB0cmFwLlxuICpcbiAqIEBjbGFzcyBSb3RhdGlvbmFsU3ByaW5nXG4gKiBAZXh0ZW5kcyBTcHJpbmdcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc3RBbmdsZV0gVGhlIHJlbGF0aXZlIGFuZ2xlIG9mIGJvZGllcyBhdCB3aGljaCB0aGUgc3ByaW5nIGlzIGF0IHJlc3QuIElmIG5vdCBnaXZlbiwgaXQncyBzZXQgdG8gdGhlIGN1cnJlbnQgcmVsYXRpdmUgYW5nbGUgYmV0d2VlbiB0aGUgYm9kaWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzcz0xMDBdIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gQSBudW1iZXIgPj0gMC5cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbFNwcmluZyhib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgU3ByaW5nLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFJlc3QgYW5nbGUgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgcmVzdEFuZ2xlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RBbmdsZSA9IHR5cGVvZihvcHRpb25zLnJlc3RBbmdsZSkgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zLnJlc3RBbmdsZSA6IGJvZHlCLmFuZ2xlIC0gYm9keUEuYW5nbGU7XG59XG5Sb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZSA9IG5ldyBTcHJpbmcoKTtcblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbFNwcmluZztcblxuLyoqXG4gKiBBcHBseSB0aGUgc3ByaW5nIGZvcmNlIHRvIHRoZSBjb25uZWN0ZWQgYm9kaWVzLlxuICogQG1ldGhvZCBhcHBseUZvcmNlXG4gKi9cblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MsXG4gICAgICAgIGQgPSB0aGlzLmRhbXBpbmcsXG4gICAgICAgIGwgPSB0aGlzLnJlc3RBbmdsZSxcbiAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIHggPSBib2R5Qi5hbmdsZSAtIGJvZHlBLmFuZ2xlLFxuICAgICAgICB1ID0gYm9keUIuYW5ndWxhclZlbG9jaXR5IC0gYm9keUEuYW5ndWxhclZlbG9jaXR5O1xuXG4gICAgdmFyIHRvcnF1ZSA9IC0gayAqICh4IC0gbCkgLSBkICogdSAqIDA7XG5cbiAgICBib2R5QS5hbmd1bGFyRm9yY2UgLT0gdG9ycXVlO1xuICAgIGJvZHlCLmFuZ3VsYXJGb3JjZSArPSB0b3JxdWU7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/objects/RotationalSpring.js\n");

/***/ }),

/***/ "./node_modules/p2/src/objects/Spring.js":
/*!***********************************************!*\
  !*** ./node_modules/p2/src/objects/Spring.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\nvar Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\");\n\nmodule.exports = Spring;\n\n/**\n * A spring, connecting two bodies. The Spring explicitly adds force and angularForce to the bodies and does therefore not put load on the constraint solver.\n *\n * @class Spring\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.\n * @param {number} [options.damping=1]      A number >= 0. Default: 1\n * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.\n * @param {Array}  [options.localAnchorB]\n * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option \"localAnchorA\" if given.\n * @param {Array}  [options.worldAnchorB]\n */\nfunction Spring(bodyA, bodyB, options){\n    options = Utils.defaults(options,{\n        stiffness: 100,\n        damping: 1,\n    });\n\n    /**\n     * Stiffness of the spring.\n     * @property stiffness\n     * @type {number}\n     */\n    this.stiffness = options.stiffness;\n\n    /**\n     * Damping of the spring.\n     * @property damping\n     * @type {number}\n     */\n    this.damping = options.damping;\n\n    /**\n     * First connected body.\n     * @property bodyA\n     * @type {Body}\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * Second connected body.\n     * @property bodyB\n     * @type {Body}\n     */\n    this.bodyB = bodyB;\n}\n\n/**\n * Apply the spring force to the connected bodies.\n * @method applyForce\n */\nSpring.prototype.applyForce = function(){\n    // To be implemented by subclasses\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL29iamVjdHMvU3ByaW5nLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9vYmplY3RzL1NwcmluZy5qcz85MTVlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJyk7XG52YXIgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcmluZztcblxuLyoqXG4gKiBBIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzLiBUaGUgU3ByaW5nIGV4cGxpY2l0bHkgYWRkcyBmb3JjZSBhbmQgYW5ndWxhckZvcmNlIHRvIHRoZSBib2RpZXMgYW5kIGRvZXMgdGhlcmVmb3JlIG5vdCBwdXQgbG9hZCBvbiB0aGUgY29uc3RyYWludCBzb2x2ZXIuXG4gKlxuICogQGNsYXNzIFNwcmluZ1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzPTEwMF0gIFNwcmluZyBjb25zdGFudCAoc2VlIEhvb2tlcyBMYXcpLiBBIG51bWJlciA+PSAwLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmc9MV0gICAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuIERlZmF1bHRzIHRvIHRoZSBib2R5IGNlbnRlci5cbiAqIEBwYXJhbSB7QXJyYXl9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdXG4gKiBAcGFyYW0ge0FycmF5fSAgW29wdGlvbnMud29ybGRBbmNob3JBXSAgIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBPdmVycmlkZXMgdGhlIG9wdGlvbiBcImxvY2FsQW5jaG9yQVwiIGlmIGdpdmVuLlxuICogQHBhcmFtIHtBcnJheX0gIFtvcHRpb25zLndvcmxkQW5jaG9yQl1cbiAqL1xuZnVuY3Rpb24gU3ByaW5nKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMse1xuICAgICAgICBzdGlmZm5lc3M6IDEwMCxcbiAgICAgICAgZGFtcGluZzogMSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFN0aWZmbmVzcyBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSBzdGlmZm5lc3NcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RpZmZuZXNzID0gb3B0aW9ucy5zdGlmZm5lc3M7XG5cbiAgICAvKipcbiAgICAgKiBEYW1waW5nIG9mIHRoZSBzcHJpbmcuXG4gICAgICogQHByb3BlcnR5IGRhbXBpbmdcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGFtcGluZyA9IG9wdGlvbnMuZGFtcGluZztcblxuICAgIC8qKlxuICAgICAqIEZpcnN0IGNvbm5lY3RlZCBib2R5LlxuICAgICAqIEBwcm9wZXJ0eSBib2R5QVxuICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcblxuICAgIC8qKlxuICAgICAqIFNlY29uZCBjb25uZWN0ZWQgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYm9keUJcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XG59XG5cbi8qKlxuICogQXBwbHkgdGhlIHNwcmluZyBmb3JjZSB0byB0aGUgY29ubmVjdGVkIGJvZGllcy5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICovXG5TcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbigpe1xuICAgIC8vIFRvIGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXNcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/objects/Spring.js\n");

/***/ }),

/***/ "./node_modules/p2/src/objects/TopDownVehicle.js":
/*!*******************************************************!*\
  !*** ./node_modules/p2/src/objects/TopDownVehicle.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\nvar Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\");\nvar Constraint = __webpack_require__(/*! ../constraints/Constraint */ \"./node_modules/p2/src/constraints/Constraint.js\");\nvar FrictionEquation = __webpack_require__(/*! ../equations/FrictionEquation */ \"./node_modules/p2/src/equations/FrictionEquation.js\");\nvar Body = __webpack_require__(/*! ../objects/Body */ \"./node_modules/p2/src/objects/Body.js\");\n\nmodule.exports = TopDownVehicle;\n\n/**\n * @class TopDownVehicle\n * @constructor\n * @param {Body} chassisBody A dynamic body, already added to the world.\n * @param {Object} [options]\n *\n * @example\n *\n *     // Create a dynamic body for the chassis\n *     var chassisBody = new Body({\n *         mass: 1\n *     });\n *     var boxShape = new Box({ width: 0.5, height: 1 });\n *     chassisBody.addShape(boxShape);\n *     world.addBody(chassisBody);\n *\n *     // Create the vehicle\n *     var vehicle = new TopDownVehicle(chassisBody);\n *\n *     // Add one front wheel and one back wheel - we don't actually need four :)\n *     var frontWheel = vehicle.addWheel({\n *         localPosition: [0, 0.5] // front\n *     });\n *     frontWheel.setSideFriction(4);\n *\n *     // Back wheel\n *     var backWheel = vehicle.addWheel({\n *         localPosition: [0, -0.5] // back\n *     });\n *     backWheel.setSideFriction(3); // Less side friction on back wheel makes it easier to drift\n *     vehicle.addToWorld(world);\n *\n *     // Steer value zero means straight forward. Positive is left and negative right.\n *     frontWheel.steerValue = Math.PI / 16;\n *\n *     // Engine force forward\n *     backWheel.engineForce = 10;\n *     backWheel.setBrakeForce(0);\n */\nfunction TopDownVehicle(chassisBody, options){\n    options = options || {};\n\n    /**\n     * @property {Body} chassisBody\n     */\n    this.chassisBody = chassisBody;\n\n    /**\n     * @property {Array} wheels\n     */\n    this.wheels = [];\n\n    // A dummy body to constrain the chassis to\n    this.groundBody = new Body({ mass: 0 });\n\n    this.world = null;\n\n    var that = this;\n    this.preStepCallback = function(){\n        that.update();\n    };\n}\n\n/**\n * @method addToWorld\n * @param {World} world\n */\nTopDownVehicle.prototype.addToWorld = function(world){\n    this.world = world;\n    world.addBody(this.groundBody);\n    world.on('preStep', this.preStepCallback);\n    for (var i = 0; i < this.wheels.length; i++) {\n        var wheel = this.wheels[i];\n        world.addConstraint(wheel);\n    }\n};\n\n/**\n * @method removeFromWorld\n * @param {World} world\n */\nTopDownVehicle.prototype.removeFromWorld = function(){\n    var world = this.world;\n    world.removeBody(this.groundBody);\n    world.off('preStep', this.preStepCallback);\n    for (var i = 0; i < this.wheels.length; i++) {\n        var wheel = this.wheels[i];\n        world.removeConstraint(wheel);\n    }\n    this.world = null;\n};\n\n/**\n * @method addWheel\n * @param {object} [wheelOptions]\n * @return {WheelConstraint}\n */\nTopDownVehicle.prototype.addWheel = function(wheelOptions){\n    var wheel = new WheelConstraint(this,wheelOptions);\n    this.wheels.push(wheel);\n    return wheel;\n};\n\n/**\n * @method update\n */\nTopDownVehicle.prototype.update = function(){\n    for (var i = 0; i < this.wheels.length; i++) {\n        this.wheels[i].update();\n    }\n};\n\n/**\n * @class WheelConstraint\n * @constructor\n * @extends {Constraint}\n * @param {Vehicle} vehicle\n * @param {object} [options]\n * @param {Array} [options.localForwardVector]The local wheel forward vector in local body space. Default is zero.\n * @param {Array} [options.localPosition] The local position of the wheen in the chassis body. Default is zero - the center of the body.\n * @param {Array} [options.sideFriction=5] The max friction force in the sideways direction.\n */\nfunction WheelConstraint(vehicle, options){\n    options = options || {};\n\n    this.vehicle = vehicle;\n\n    this.forwardEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);\n\n    this.sideEquation = new FrictionEquation(vehicle.chassisBody, vehicle.groundBody);\n\n    /**\n     * @property {number} steerValue\n     */\n    this.steerValue = 0;\n\n    /**\n     * @property {number} engineForce\n     */\n    this.engineForce = 0;\n\n    this.setSideFriction(options.sideFriction !== undefined ? options.sideFriction : 5);\n\n    /**\n     * @property {Array} localForwardVector\n     */\n    this.localForwardVector = vec2.fromValues(0, 1);\n    if(options.localForwardVector){\n        vec2.copy(this.localForwardVector, options.localForwardVector);\n    }\n\n    /**\n     * @property {Array} localPosition\n     */\n    this.localPosition = vec2.fromValues(0, 0);\n    if(options.localPosition){\n        vec2.copy(this.localPosition, options.localPosition);\n    }\n\n    Constraint.apply(this, vehicle.chassisBody, vehicle.groundBody);\n\n    this.equations.push(\n        this.forwardEquation,\n        this.sideEquation\n    );\n\n    this.setBrakeForce(0);\n}\nWheelConstraint.prototype = new Constraint();\n\n/**\n * @method setForwardFriction\n */\nWheelConstraint.prototype.setBrakeForce = function(force){\n    this.forwardEquation.setSlipForce(force);\n};\n\n/**\n * @method setSideFriction\n */\nWheelConstraint.prototype.setSideFriction = function(force){\n    this.sideEquation.setSlipForce(force);\n};\n\nvar worldVelocity = vec2.create();\nvar relativePoint = vec2.create();\n\n/**\n * @method getSpeed\n */\nWheelConstraint.prototype.getSpeed = function(){\n    this.vehicle.chassisBody.vectorToWorldFrame(relativePoint, this.localForwardVector);\n    this.vehicle.chassisBody.getVelocityAtPoint(worldVelocity, relativePoint);\n    return vec2.dot(worldVelocity, relativePoint);\n};\n\nvar tmpVec = vec2.create();\n\n/**\n * @method update\n */\nWheelConstraint.prototype.update = function(){\n\n    // Directional\n    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector);\n    vec2.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2);\n    this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t);\n\n    vec2.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue);\n    vec2.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue);\n\n    // Attachment point\n    this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition);\n    vec2.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB);\n\n    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition);\n    vec2.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA);\n\n    // Add engine force\n    vec2.normalize(tmpVec, this.forwardEquation.t);\n    vec2.scale(tmpVec, tmpVec, this.engineForce);\n\n    this.vehicle.chassisBody.applyForce(tmpVec, this.forwardEquation.contactPointA);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL29iamVjdHMvVG9wRG93blZlaGljbGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL29iamVjdHMvVG9wRG93blZlaGljbGUuanM/NDdlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xudmFyIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKTtcbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi4vY29uc3RyYWludHMvQ29uc3RyYWludCcpO1xudmFyIEZyaWN0aW9uRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpO1xudmFyIEJvZHkgPSByZXF1aXJlKCcuLi9vYmplY3RzL0JvZHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb3BEb3duVmVoaWNsZTtcblxuLyoqXG4gKiBAY2xhc3MgVG9wRG93blZlaGljbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBjaGFzc2lzQm9keSBBIGR5bmFtaWMgYm9keSwgYWxyZWFkeSBhZGRlZCB0byB0aGUgd29ybGQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIGEgZHluYW1pYyBib2R5IGZvciB0aGUgY2hhc3Npc1xuICogICAgIHZhciBjaGFzc2lzQm9keSA9IG5ldyBCb2R5KHtcbiAqICAgICAgICAgbWFzczogMVxuICogICAgIH0pO1xuICogICAgIHZhciBib3hTaGFwZSA9IG5ldyBCb3goeyB3aWR0aDogMC41LCBoZWlnaHQ6IDEgfSk7XG4gKiAgICAgY2hhc3Npc0JvZHkuYWRkU2hhcGUoYm94U2hhcGUpO1xuICogICAgIHdvcmxkLmFkZEJvZHkoY2hhc3Npc0JvZHkpO1xuICpcbiAqICAgICAvLyBDcmVhdGUgdGhlIHZlaGljbGVcbiAqICAgICB2YXIgdmVoaWNsZSA9IG5ldyBUb3BEb3duVmVoaWNsZShjaGFzc2lzQm9keSk7XG4gKlxuICogICAgIC8vIEFkZCBvbmUgZnJvbnQgd2hlZWwgYW5kIG9uZSBiYWNrIHdoZWVsIC0gd2UgZG9uJ3QgYWN0dWFsbHkgbmVlZCBmb3VyIDopXG4gKiAgICAgdmFyIGZyb250V2hlZWwgPSB2ZWhpY2xlLmFkZFdoZWVsKHtcbiAqICAgICAgICAgbG9jYWxQb3NpdGlvbjogWzAsIDAuNV0gLy8gZnJvbnRcbiAqICAgICB9KTtcbiAqICAgICBmcm9udFdoZWVsLnNldFNpZGVGcmljdGlvbig0KTtcbiAqXG4gKiAgICAgLy8gQmFjayB3aGVlbFxuICogICAgIHZhciBiYWNrV2hlZWwgPSB2ZWhpY2xlLmFkZFdoZWVsKHtcbiAqICAgICAgICAgbG9jYWxQb3NpdGlvbjogWzAsIC0wLjVdIC8vIGJhY2tcbiAqICAgICB9KTtcbiAqICAgICBiYWNrV2hlZWwuc2V0U2lkZUZyaWN0aW9uKDMpOyAvLyBMZXNzIHNpZGUgZnJpY3Rpb24gb24gYmFjayB3aGVlbCBtYWtlcyBpdCBlYXNpZXIgdG8gZHJpZnRcbiAqICAgICB2ZWhpY2xlLmFkZFRvV29ybGQod29ybGQpO1xuICpcbiAqICAgICAvLyBTdGVlciB2YWx1ZSB6ZXJvIG1lYW5zIHN0cmFpZ2h0IGZvcndhcmQuIFBvc2l0aXZlIGlzIGxlZnQgYW5kIG5lZ2F0aXZlIHJpZ2h0LlxuICogICAgIGZyb250V2hlZWwuc3RlZXJWYWx1ZSA9IE1hdGguUEkgLyAxNjtcbiAqXG4gKiAgICAgLy8gRW5naW5lIGZvcmNlIGZvcndhcmRcbiAqICAgICBiYWNrV2hlZWwuZW5naW5lRm9yY2UgPSAxMDtcbiAqICAgICBiYWNrV2hlZWwuc2V0QnJha2VGb3JjZSgwKTtcbiAqL1xuZnVuY3Rpb24gVG9wRG93blZlaGljbGUoY2hhc3Npc0JvZHksIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBjaGFzc2lzQm9keVxuICAgICAqL1xuICAgIHRoaXMuY2hhc3Npc0JvZHkgPSBjaGFzc2lzQm9keTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdoZWVsc1xuICAgICAqL1xuICAgIHRoaXMud2hlZWxzID0gW107XG5cbiAgICAvLyBBIGR1bW15IGJvZHkgdG8gY29uc3RyYWluIHRoZSBjaGFzc2lzIHRvXG4gICAgdGhpcy5ncm91bmRCb2R5ID0gbmV3IEJvZHkoeyBtYXNzOiAwIH0pO1xuXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5wcmVTdGVwQ2FsbGJhY2sgPSBmdW5jdGlvbigpe1xuICAgICAgICB0aGF0LnVwZGF0ZSgpO1xuICAgIH07XG59XG5cbi8qKlxuICogQG1ldGhvZCBhZGRUb1dvcmxkXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICovXG5Ub3BEb3duVmVoaWNsZS5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgd29ybGQuYWRkQm9keSh0aGlzLmdyb3VuZEJvZHkpO1xuICAgIHdvcmxkLm9uKCdwcmVTdGVwJywgdGhpcy5wcmVTdGVwQ2FsbGJhY2spO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53aGVlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHdoZWVsID0gdGhpcy53aGVlbHNbaV07XG4gICAgICAgIHdvcmxkLmFkZENvbnN0cmFpbnQod2hlZWwpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQG1ldGhvZCByZW1vdmVGcm9tV29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblRvcERvd25WZWhpY2xlLnByb3RvdHlwZS5yZW1vdmVGcm9tV29ybGQgPSBmdW5jdGlvbigpe1xuICAgIHZhciB3b3JsZCA9IHRoaXMud29ybGQ7XG4gICAgd29ybGQucmVtb3ZlQm9keSh0aGlzLmdyb3VuZEJvZHkpO1xuICAgIHdvcmxkLm9mZigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2hlZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3aGVlbCA9IHRoaXMud2hlZWxzW2ldO1xuICAgICAgICB3b3JsZC5yZW1vdmVDb25zdHJhaW50KHdoZWVsKTtcbiAgICB9XG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgYWRkV2hlZWxcbiAqIEBwYXJhbSB7b2JqZWN0fSBbd2hlZWxPcHRpb25zXVxuICogQHJldHVybiB7V2hlZWxDb25zdHJhaW50fVxuICovXG5Ub3BEb3duVmVoaWNsZS5wcm90b3R5cGUuYWRkV2hlZWwgPSBmdW5jdGlvbih3aGVlbE9wdGlvbnMpe1xuICAgIHZhciB3aGVlbCA9IG5ldyBXaGVlbENvbnN0cmFpbnQodGhpcyx3aGVlbE9wdGlvbnMpO1xuICAgIHRoaXMud2hlZWxzLnB1c2god2hlZWwpO1xuICAgIHJldHVybiB3aGVlbDtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuVG9wRG93blZlaGljbGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndoZWVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndoZWVsc1tpXS51cGRhdGUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBjbGFzcyBXaGVlbENvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0NvbnN0cmFpbnR9XG4gKiBAcGFyYW0ge1ZlaGljbGV9IHZlaGljbGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmxvY2FsRm9yd2FyZFZlY3Rvcl1UaGUgbG9jYWwgd2hlZWwgZm9yd2FyZCB2ZWN0b3IgaW4gbG9jYWwgYm9keSBzcGFjZS4gRGVmYXVsdCBpcyB6ZXJvLlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubG9jYWxQb3NpdGlvbl0gVGhlIGxvY2FsIHBvc2l0aW9uIG9mIHRoZSB3aGVlbiBpbiB0aGUgY2hhc3NpcyBib2R5LiBEZWZhdWx0IGlzIHplcm8gLSB0aGUgY2VudGVyIG9mIHRoZSBib2R5LlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuc2lkZUZyaWN0aW9uPTVdIFRoZSBtYXggZnJpY3Rpb24gZm9yY2UgaW4gdGhlIHNpZGV3YXlzIGRpcmVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gV2hlZWxDb25zdHJhaW50KHZlaGljbGUsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy52ZWhpY2xlID0gdmVoaWNsZTtcblxuICAgIHRoaXMuZm9yd2FyZEVxdWF0aW9uID0gbmV3IEZyaWN0aW9uRXF1YXRpb24odmVoaWNsZS5jaGFzc2lzQm9keSwgdmVoaWNsZS5ncm91bmRCb2R5KTtcblxuICAgIHRoaXMuc2lkZUVxdWF0aW9uID0gbmV3IEZyaWN0aW9uRXF1YXRpb24odmVoaWNsZS5jaGFzc2lzQm9keSwgdmVoaWNsZS5ncm91bmRCb2R5KTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGVlclZhbHVlXG4gICAgICovXG4gICAgdGhpcy5zdGVlclZhbHVlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbmdpbmVGb3JjZVxuICAgICAqL1xuICAgIHRoaXMuZW5naW5lRm9yY2UgPSAwO1xuXG4gICAgdGhpcy5zZXRTaWRlRnJpY3Rpb24ob3B0aW9ucy5zaWRlRnJpY3Rpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2lkZUZyaWN0aW9uIDogNSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBsb2NhbEZvcndhcmRWZWN0b3JcbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsRm9yd2FyZFZlY3RvciA9IHZlYzIuZnJvbVZhbHVlcygwLCAxKTtcbiAgICBpZihvcHRpb25zLmxvY2FsRm9yd2FyZFZlY3Rvcil7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmxvY2FsRm9yd2FyZFZlY3Rvciwgb3B0aW9ucy5sb2NhbEZvcndhcmRWZWN0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGxvY2FsUG9zaXRpb25cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsUG9zaXRpb24gPSB2ZWMyLmZyb21WYWx1ZXMoMCwgMCk7XG4gICAgaWYob3B0aW9ucy5sb2NhbFBvc2l0aW9uKXtcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMubG9jYWxQb3NpdGlvbiwgb3B0aW9ucy5sb2NhbFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBDb25zdHJhaW50LmFwcGx5KHRoaXMsIHZlaGljbGUuY2hhc3Npc0JvZHksIHZlaGljbGUuZ3JvdW5kQm9keSk7XG5cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKFxuICAgICAgICB0aGlzLmZvcndhcmRFcXVhdGlvbixcbiAgICAgICAgdGhpcy5zaWRlRXF1YXRpb25cbiAgICApO1xuXG4gICAgdGhpcy5zZXRCcmFrZUZvcmNlKDApO1xufVxuV2hlZWxDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5cbi8qKlxuICogQG1ldGhvZCBzZXRGb3J3YXJkRnJpY3Rpb25cbiAqL1xuV2hlZWxDb25zdHJhaW50LnByb3RvdHlwZS5zZXRCcmFrZUZvcmNlID0gZnVuY3Rpb24oZm9yY2Upe1xuICAgIHRoaXMuZm9yd2FyZEVxdWF0aW9uLnNldFNsaXBGb3JjZShmb3JjZSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0U2lkZUZyaWN0aW9uXG4gKi9cbldoZWVsQ29uc3RyYWludC5wcm90b3R5cGUuc2V0U2lkZUZyaWN0aW9uID0gZnVuY3Rpb24oZm9yY2Upe1xuICAgIHRoaXMuc2lkZUVxdWF0aW9uLnNldFNsaXBGb3JjZShmb3JjZSk7XG59O1xuXG52YXIgd29ybGRWZWxvY2l0eSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgcmVsYXRpdmVQb2ludCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBnZXRTcGVlZFxuICovXG5XaGVlbENvbnN0cmFpbnQucHJvdG90eXBlLmdldFNwZWVkID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnZlaGljbGUuY2hhc3Npc0JvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKHJlbGF0aXZlUG9pbnQsIHRoaXMubG9jYWxGb3J3YXJkVmVjdG9yKTtcbiAgICB0aGlzLnZlaGljbGUuY2hhc3Npc0JvZHkuZ2V0VmVsb2NpdHlBdFBvaW50KHdvcmxkVmVsb2NpdHksIHJlbGF0aXZlUG9pbnQpO1xuICAgIHJldHVybiB2ZWMyLmRvdCh3b3JsZFZlbG9jaXR5LCByZWxhdGl2ZVBvaW50KTtcbn07XG5cbnZhciB0bXBWZWMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbldoZWVsQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcblxuICAgIC8vIERpcmVjdGlvbmFsXG4gICAgdGhpcy52ZWhpY2xlLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLmZvcndhcmRFcXVhdGlvbi50LCB0aGlzLmxvY2FsRm9yd2FyZFZlY3Rvcik7XG4gICAgdmVjMi5yb3RhdGUodGhpcy5zaWRlRXF1YXRpb24udCwgdGhpcy5sb2NhbEZvcndhcmRWZWN0b3IsIE1hdGguUEkgLyAyKTtcbiAgICB0aGlzLnZlaGljbGUuY2hhc3Npc0JvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuc2lkZUVxdWF0aW9uLnQsIHRoaXMuc2lkZUVxdWF0aW9uLnQpO1xuXG4gICAgdmVjMi5yb3RhdGUodGhpcy5mb3J3YXJkRXF1YXRpb24udCwgdGhpcy5mb3J3YXJkRXF1YXRpb24udCwgdGhpcy5zdGVlclZhbHVlKTtcbiAgICB2ZWMyLnJvdGF0ZSh0aGlzLnNpZGVFcXVhdGlvbi50LCB0aGlzLnNpZGVFcXVhdGlvbi50LCB0aGlzLnN0ZWVyVmFsdWUpO1xuXG4gICAgLy8gQXR0YWNobWVudCBwb2ludFxuICAgIHRoaXMudmVoaWNsZS5jaGFzc2lzQm9keS50b1dvcmxkRnJhbWUodGhpcy5mb3J3YXJkRXF1YXRpb24uY29udGFjdFBvaW50QiwgdGhpcy5sb2NhbFBvc2l0aW9uKTtcbiAgICB2ZWMyLmNvcHkodGhpcy5zaWRlRXF1YXRpb24uY29udGFjdFBvaW50QiwgdGhpcy5mb3J3YXJkRXF1YXRpb24uY29udGFjdFBvaW50Qik7XG5cbiAgICB0aGlzLnZlaGljbGUuY2hhc3Npc0JvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuZm9yd2FyZEVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHRoaXMubG9jYWxQb3NpdGlvbik7XG4gICAgdmVjMi5jb3B5KHRoaXMuc2lkZUVxdWF0aW9uLmNvbnRhY3RQb2ludEEsIHRoaXMuZm9yd2FyZEVxdWF0aW9uLmNvbnRhY3RQb2ludEEpO1xuXG4gICAgLy8gQWRkIGVuZ2luZSBmb3JjZVxuICAgIHZlYzIubm9ybWFsaXplKHRtcFZlYywgdGhpcy5mb3J3YXJkRXF1YXRpb24udCk7XG4gICAgdmVjMi5zY2FsZSh0bXBWZWMsIHRtcFZlYywgdGhpcy5lbmdpbmVGb3JjZSk7XG5cbiAgICB0aGlzLnZlaGljbGUuY2hhc3Npc0JvZHkuYXBwbHlGb3JjZSh0bXBWZWMsIHRoaXMuZm9yd2FyZEVxdWF0aW9uLmNvbnRhY3RQb2ludEEpO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/objects/TopDownVehicle.js\n");

/***/ }),

/***/ "./node_modules/p2/src/p2.js":
/*!***********************************!*\
  !*** ./node_modules/p2/src/p2.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("// Export p2 classes\nvar p2 = module.exports = {\n    AABB :                          __webpack_require__(/*! ./collision/AABB */ \"./node_modules/p2/src/collision/AABB.js\"),\n    AngleLockEquation :             __webpack_require__(/*! ./equations/AngleLockEquation */ \"./node_modules/p2/src/equations/AngleLockEquation.js\"),\n    Body :                          __webpack_require__(/*! ./objects/Body */ \"./node_modules/p2/src/objects/Body.js\"),\n    Broadphase :                    __webpack_require__(/*! ./collision/Broadphase */ \"./node_modules/p2/src/collision/Broadphase.js\"),\n    Capsule :                       __webpack_require__(/*! ./shapes/Capsule */ \"./node_modules/p2/src/shapes/Capsule.js\"),\n    Circle :                        __webpack_require__(/*! ./shapes/Circle */ \"./node_modules/p2/src/shapes/Circle.js\"),\n    Constraint :                    __webpack_require__(/*! ./constraints/Constraint */ \"./node_modules/p2/src/constraints/Constraint.js\"),\n    ContactEquation :               __webpack_require__(/*! ./equations/ContactEquation */ \"./node_modules/p2/src/equations/ContactEquation.js\"),\n    ContactEquationPool :           __webpack_require__(/*! ./utils/ContactEquationPool */ \"./node_modules/p2/src/utils/ContactEquationPool.js\"),\n    ContactMaterial :               __webpack_require__(/*! ./material/ContactMaterial */ \"./node_modules/p2/src/material/ContactMaterial.js\"),\n    Convex :                        __webpack_require__(/*! ./shapes/Convex */ \"./node_modules/p2/src/shapes/Convex.js\"),\n    DistanceConstraint :            __webpack_require__(/*! ./constraints/DistanceConstraint */ \"./node_modules/p2/src/constraints/DistanceConstraint.js\"),\n    Equation :                      __webpack_require__(/*! ./equations/Equation */ \"./node_modules/p2/src/equations/Equation.js\"),\n    EventEmitter :                  __webpack_require__(/*! ./events/EventEmitter */ \"./node_modules/p2/src/events/EventEmitter.js\"),\n    FrictionEquation :              __webpack_require__(/*! ./equations/FrictionEquation */ \"./node_modules/p2/src/equations/FrictionEquation.js\"),\n    FrictionEquationPool :          __webpack_require__(/*! ./utils/FrictionEquationPool */ \"./node_modules/p2/src/utils/FrictionEquationPool.js\"),\n    GearConstraint :                __webpack_require__(/*! ./constraints/GearConstraint */ \"./node_modules/p2/src/constraints/GearConstraint.js\"),\n    GSSolver :                      __webpack_require__(/*! ./solver/GSSolver */ \"./node_modules/p2/src/solver/GSSolver.js\"),\n    Heightfield :                   __webpack_require__(/*! ./shapes/Heightfield */ \"./node_modules/p2/src/shapes/Heightfield.js\"),\n    Line :                          __webpack_require__(/*! ./shapes/Line */ \"./node_modules/p2/src/shapes/Line.js\"),\n    LockConstraint :                __webpack_require__(/*! ./constraints/LockConstraint */ \"./node_modules/p2/src/constraints/LockConstraint.js\"),\n    Material :                      __webpack_require__(/*! ./material/Material */ \"./node_modules/p2/src/material/Material.js\"),\n    Narrowphase :                   __webpack_require__(/*! ./collision/Narrowphase */ \"./node_modules/p2/src/collision/Narrowphase.js\"),\n    NaiveBroadphase :               __webpack_require__(/*! ./collision/NaiveBroadphase */ \"./node_modules/p2/src/collision/NaiveBroadphase.js\"),\n    Particle :                      __webpack_require__(/*! ./shapes/Particle */ \"./node_modules/p2/src/shapes/Particle.js\"),\n    Plane :                         __webpack_require__(/*! ./shapes/Plane */ \"./node_modules/p2/src/shapes/Plane.js\"),\n    Pool :                          __webpack_require__(/*! ./utils/Pool */ \"./node_modules/p2/src/utils/Pool.js\"),\n    RevoluteConstraint :            __webpack_require__(/*! ./constraints/RevoluteConstraint */ \"./node_modules/p2/src/constraints/RevoluteConstraint.js\"),\n    PrismaticConstraint :           __webpack_require__(/*! ./constraints/PrismaticConstraint */ \"./node_modules/p2/src/constraints/PrismaticConstraint.js\"),\n    Ray :                           __webpack_require__(/*! ./collision/Ray */ \"./node_modules/p2/src/collision/Ray.js\"),\n    RaycastResult :                 __webpack_require__(/*! ./collision/RaycastResult */ \"./node_modules/p2/src/collision/RaycastResult.js\"),\n    Box :                           __webpack_require__(/*! ./shapes/Box */ \"./node_modules/p2/src/shapes/Box.js\"),\n    RotationalVelocityEquation :    __webpack_require__(/*! ./equations/RotationalVelocityEquation */ \"./node_modules/p2/src/equations/RotationalVelocityEquation.js\"),\n    SAPBroadphase :                 __webpack_require__(/*! ./collision/SAPBroadphase */ \"./node_modules/p2/src/collision/SAPBroadphase.js\"),\n    Shape :                         __webpack_require__(/*! ./shapes/Shape */ \"./node_modules/p2/src/shapes/Shape.js\"),\n    Solver :                        __webpack_require__(/*! ./solver/Solver */ \"./node_modules/p2/src/solver/Solver.js\"),\n    Spring :                        __webpack_require__(/*! ./objects/Spring */ \"./node_modules/p2/src/objects/Spring.js\"),\n    TopDownVehicle :                __webpack_require__(/*! ./objects/TopDownVehicle */ \"./node_modules/p2/src/objects/TopDownVehicle.js\"),\n    LinearSpring :                  __webpack_require__(/*! ./objects/LinearSpring */ \"./node_modules/p2/src/objects/LinearSpring.js\"),\n    RotationalSpring :              __webpack_require__(/*! ./objects/RotationalSpring */ \"./node_modules/p2/src/objects/RotationalSpring.js\"),\n    Utils :                         __webpack_require__(/*! ./utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\"),\n    World :                         __webpack_require__(/*! ./world/World */ \"./node_modules/p2/src/world/World.js\"),\n    vec2 :                          __webpack_require__(/*! ./math/vec2 */ \"./node_modules/p2/src/math/vec2.js\"),\n    version :                       __webpack_require__(/*! ../package.json */ \"./node_modules/p2/package.json\").version,\n};\n\nObject.defineProperty(p2, 'Rectangle', {\n    get: function() {\n        console.warn('The Rectangle class has been renamed to Box.');\n        return this.Box;\n    }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3AyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9wMi5qcz82MGMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEV4cG9ydCBwMiBjbGFzc2VzXG52YXIgcDIgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBQUJCIDogICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29sbGlzaW9uL0FBQkInKSxcbiAgICBBbmdsZUxvY2tFcXVhdGlvbiA6ICAgICAgICAgICAgIHJlcXVpcmUoJy4vZXF1YXRpb25zL0FuZ2xlTG9ja0VxdWF0aW9uJyksXG4gICAgQm9keSA6ICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL29iamVjdHMvQm9keScpLFxuICAgIEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxuICAgIENhcHN1bGUgOiAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFwZXMvQ2Fwc3VsZScpLFxuICAgIENpcmNsZSA6ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFwZXMvQ2lyY2xlJyksXG4gICAgQ29uc3RyYWludCA6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKSxcbiAgICBDb250YWN0RXF1YXRpb24gOiAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpLFxuICAgIENvbnRhY3RFcXVhdGlvblBvb2wgOiAgICAgICAgICAgcmVxdWlyZSgnLi91dGlscy9Db250YWN0RXF1YXRpb25Qb29sJyksXG4gICAgQ29udGFjdE1hdGVyaWFsIDogICAgICAgICAgICAgICByZXF1aXJlKCcuL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbCcpLFxuICAgIENvbnZleCA6ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFwZXMvQ29udmV4JyksXG4gICAgRGlzdGFuY2VDb25zdHJhaW50IDogICAgICAgICAgICByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludCcpLFxuICAgIEVxdWF0aW9uIDogICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9lcXVhdGlvbnMvRXF1YXRpb24nKSxcbiAgICBFdmVudEVtaXR0ZXIgOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vZXZlbnRzL0V2ZW50RW1pdHRlcicpLFxuICAgIEZyaWN0aW9uRXF1YXRpb24gOiAgICAgICAgICAgICAgcmVxdWlyZSgnLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpLFxuICAgIEZyaWN0aW9uRXF1YXRpb25Qb29sIDogICAgICAgICAgcmVxdWlyZSgnLi91dGlscy9GcmljdGlvbkVxdWF0aW9uUG9vbCcpLFxuICAgIEdlYXJDb25zdHJhaW50IDogICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb25zdHJhaW50cy9HZWFyQ29uc3RyYWludCcpLFxuICAgIEdTU29sdmVyIDogICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zb2x2ZXIvR1NTb2x2ZXInKSxcbiAgICBIZWlnaHRmaWVsZCA6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhcGVzL0hlaWdodGZpZWxkJyksXG4gICAgTGluZSA6ICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NoYXBlcy9MaW5lJyksXG4gICAgTG9ja0NvbnN0cmFpbnQgOiAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JyksXG4gICAgTWF0ZXJpYWwgOiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL21hdGVyaWFsL01hdGVyaWFsJyksXG4gICAgTmFycm93cGhhc2UgOiAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbGxpc2lvbi9OYXJyb3dwaGFzZScpLFxuICAgIE5haXZlQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyksXG4gICAgUGFydGljbGUgOiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NoYXBlcy9QYXJ0aWNsZScpLFxuICAgIFBsYW5lIDogICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFwZXMvUGxhbmUnKSxcbiAgICBQb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vdXRpbHMvUG9vbCcpLFxuICAgIFJldm9sdXRlQ29uc3RyYWludCA6ICAgICAgICAgICAgcmVxdWlyZSgnLi9jb25zdHJhaW50cy9SZXZvbHV0ZUNvbnN0cmFpbnQnKSxcbiAgICBQcmlzbWF0aWNDb25zdHJhaW50IDogICAgICAgICAgIHJlcXVpcmUoJy4vY29uc3RyYWludHMvUHJpc21hdGljQ29uc3RyYWludCcpLFxuICAgIFJheSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vUmF5JyksXG4gICAgUmF5Y2FzdFJlc3VsdCA6ICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0JyksXG4gICAgQm94IDogICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NoYXBlcy9Cb3gnKSxcbiAgICBSb3RhdGlvbmFsVmVsb2NpdHlFcXVhdGlvbiA6ICAgIHJlcXVpcmUoJy4vZXF1YXRpb25zL1JvdGF0aW9uYWxWZWxvY2l0eUVxdWF0aW9uJyksXG4gICAgU0FQQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlJyksXG4gICAgU2hhcGUgOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NoYXBlcy9TaGFwZScpLFxuICAgIFNvbHZlciA6ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zb2x2ZXIvU29sdmVyJyksXG4gICAgU3ByaW5nIDogICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL29iamVjdHMvU3ByaW5nJyksXG4gICAgVG9wRG93blZlaGljbGUgOiAgICAgICAgICAgICAgICByZXF1aXJlKCcuL29iamVjdHMvVG9wRG93blZlaGljbGUnKSxcbiAgICBMaW5lYXJTcHJpbmcgOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vb2JqZWN0cy9MaW5lYXJTcHJpbmcnKSxcbiAgICBSb3RhdGlvbmFsU3ByaW5nIDogICAgICAgICAgICAgIHJlcXVpcmUoJy4vb2JqZWN0cy9Sb3RhdGlvbmFsU3ByaW5nJyksXG4gICAgVXRpbHMgOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3V0aWxzL1V0aWxzJyksXG4gICAgV29ybGQgOiAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3dvcmxkL1dvcmxkJyksXG4gICAgdmVjMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL21hdGgvdmVjMicpLFxuICAgIHZlcnNpb24gOiAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbixcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwMiwgJ1JlY3RhbmdsZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBSZWN0YW5nbGUgY2xhc3MgaGFzIGJlZW4gcmVuYW1lZCB0byBCb3guJyk7XG4gICAgICAgIHJldHVybiB0aGlzLkJveDtcbiAgICB9XG59KTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/p2.js\n");

/***/ }),

/***/ "./node_modules/p2/src/shapes/Box.js":
/*!*******************************************!*\
  !*** ./node_modules/p2/src/shapes/Box.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,   Shape = __webpack_require__(/*! ./Shape */ \"./node_modules/p2/src/shapes/Shape.js\")\n,   Convex = __webpack_require__(/*! ./Convex */ \"./node_modules/p2/src/shapes/Convex.js\");\n\nmodule.exports = Box;\n\n/**\n * Box shape class.\n * @class Box\n * @constructor\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @param {Number} [options.width=1] Total width of the box\n * @param {Number} [options.height=1] Total height of the box\n * @extends Convex\n */\nfunction Box(options){\n    if(typeof(arguments[0]) === 'number' && typeof(arguments[1]) === 'number'){\n        options = {\n            width: arguments[0],\n            height: arguments[1]\n        };\n        console.warn('The Rectangle has been renamed to Box and its constructor signature has changed. Please use the following format: new Box({ width: 1, height: 1, ... })');\n    }\n    options = options || {};\n\n    /**\n     * Total width of the box\n     * @property width\n     * @type {Number}\n     */\n    var width = this.width = options.width || 1;\n\n    /**\n     * Total height of the box\n     * @property height\n     * @type {Number}\n     */\n    var height = this.height = options.height || 1;\n\n    var verts = [\n        vec2.fromValues(-width/2, -height/2),\n        vec2.fromValues( width/2, -height/2),\n        vec2.fromValues( width/2,  height/2),\n        vec2.fromValues(-width/2,  height/2)\n    ];\n    var axes = [\n        vec2.fromValues(1, 0),\n        vec2.fromValues(0, 1)\n    ];\n\n    options.vertices = verts;\n    options.axes = axes;\n    options.type = Shape.BOX;\n    Convex.call(this, options);\n}\nBox.prototype = new Convex();\nBox.prototype.constructor = Box;\n\n/**\n * Compute moment of inertia\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n */\nBox.prototype.computeMomentOfInertia = function(mass){\n    var w = this.width,\n        h = this.height;\n    return mass * (h*h + w*w) / 12;\n};\n\n/**\n * Update the bounding radius\n * @method updateBoundingRadius\n */\nBox.prototype.updateBoundingRadius = function(){\n    var w = this.width,\n        h = this.height;\n    this.boundingRadius = Math.sqrt(w*w + h*h) / 2;\n};\n\nvar corner1 = vec2.create(),\n    corner2 = vec2.create(),\n    corner3 = vec2.create(),\n    corner4 = vec2.create();\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nBox.prototype.computeAABB = function(out, position, angle){\n    out.setFromPoints(this.vertices,position,angle,0);\n};\n\nBox.prototype.updateArea = function(){\n    this.area = this.width * this.height;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9Cb3guanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9Cb3guanM/YTEwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpXG4sICAgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJylcbiwgICBDb252ZXggPSByZXF1aXJlKCcuL0NvbnZleCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJveDtcblxuLyoqXG4gKiBCb3ggc2hhcGUgY2xhc3MuXG4gKiBAY2xhc3MgQm94XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGg9MV0gVG90YWwgd2lkdGggb2YgdGhlIGJveFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD0xXSBUb3RhbCBoZWlnaHQgb2YgdGhlIGJveFxuICogQGV4dGVuZHMgQ29udmV4XG4gKi9cbmZ1bmN0aW9uIEJveChvcHRpb25zKXtcbiAgICBpZih0eXBlb2YoYXJndW1lbnRzWzBdKSA9PT0gJ251bWJlcicgJiYgdHlwZW9mKGFyZ3VtZW50c1sxXSkgPT09ICdudW1iZXInKXtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICBoZWlnaHQ6IGFyZ3VtZW50c1sxXVxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBSZWN0YW5nbGUgaGFzIGJlZW4gcmVuYW1lZCB0byBCb3ggYW5kIGl0cyBjb25zdHJ1Y3RvciBzaWduYXR1cmUgaGFzIGNoYW5nZWQuIFBsZWFzZSB1c2UgdGhlIGZvbGxvd2luZyBmb3JtYXQ6IG5ldyBCb3goeyB3aWR0aDogMSwgaGVpZ2h0OiAxLCAuLi4gfSknKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUb3RhbCB3aWR0aCBvZiB0aGUgYm94XG4gICAgICogQHByb3BlcnR5IHdpZHRoXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aCB8fCAxO1xuXG4gICAgLyoqXG4gICAgICogVG90YWwgaGVpZ2h0IG9mIHRoZSBib3hcbiAgICAgKiBAcHJvcGVydHkgaGVpZ2h0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCAxO1xuXG4gICAgdmFyIHZlcnRzID0gW1xuICAgICAgICB2ZWMyLmZyb21WYWx1ZXMoLXdpZHRoLzIsIC1oZWlnaHQvMiksXG4gICAgICAgIHZlYzIuZnJvbVZhbHVlcyggd2lkdGgvMiwgLWhlaWdodC8yKSxcbiAgICAgICAgdmVjMi5mcm9tVmFsdWVzKCB3aWR0aC8yLCAgaGVpZ2h0LzIpLFxuICAgICAgICB2ZWMyLmZyb21WYWx1ZXMoLXdpZHRoLzIsICBoZWlnaHQvMilcbiAgICBdO1xuICAgIHZhciBheGVzID0gW1xuICAgICAgICB2ZWMyLmZyb21WYWx1ZXMoMSwgMCksXG4gICAgICAgIHZlYzIuZnJvbVZhbHVlcygwLCAxKVxuICAgIF07XG5cbiAgICBvcHRpb25zLnZlcnRpY2VzID0gdmVydHM7XG4gICAgb3B0aW9ucy5heGVzID0gYXhlcztcbiAgICBvcHRpb25zLnR5cGUgPSBTaGFwZS5CT1g7XG4gICAgQ29udmV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5Cb3gucHJvdG90eXBlID0gbmV3IENvbnZleCgpO1xuQm94LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJveDtcblxuLyoqXG4gKiBDb21wdXRlIG1vbWVudCBvZiBpbmVydGlhXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Cb3gucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICB2YXIgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgIGggPSB0aGlzLmhlaWdodDtcbiAgICByZXR1cm4gbWFzcyAqIChoKmggKyB3KncpIC8gMTI7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgcmFkaXVzXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKi9cbkJveC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBNYXRoLnNxcnQodyp3ICsgaCpoKSAvIDI7XG59O1xuXG52YXIgY29ybmVyMSA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29ybmVyMiA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29ybmVyMyA9IHZlYzIuY3JlYXRlKCksXG4gICAgY29ybmVyNCA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXQgICAgICBUaGUgcmVzdWx0aW5nIEFBQkIuXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbkJveC5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgb3V0LnNldEZyb21Qb2ludHModGhpcy52ZXJ0aWNlcyxwb3NpdGlvbixhbmdsZSwwKTtcbn07XG5cbkJveC5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5hcmVhID0gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xufTtcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/shapes/Box.js\n");

/***/ }),

/***/ "./node_modules/p2/src/shapes/Capsule.js":
/*!***********************************************!*\
  !*** ./node_modules/p2/src/shapes/Capsule.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Shape = __webpack_require__(/*! ./Shape */ \"./node_modules/p2/src/shapes/Shape.js\")\n,   vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\n\nmodule.exports = Capsule;\n\n/**\n * Capsule shape class.\n * @class Capsule\n * @constructor\n * @extends Shape\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @param {Number} [options.length=1] The distance between the end points\n * @param {Number} [options.radius=1] Radius of the capsule\n * @example\n *     var capsuleShape = new Capsule({\n *         length: 1,\n *         radius: 2\n *     });\n *     body.addShape(capsuleShape);\n */\nfunction Capsule(options){\n    if(typeof(arguments[0]) === 'number' && typeof(arguments[1]) === 'number'){\n        options = {\n            length: arguments[0],\n            radius: arguments[1]\n        };\n        console.warn('The Capsule constructor signature has changed. Please use the following format: new Capsule({ radius: 1, length: 1 })');\n    }\n    options = options || {};\n\n    /**\n     * The distance between the end points.\n     * @property {Number} length\n     */\n    this.length = options.length || 1;\n\n    /**\n     * The radius of the capsule.\n     * @property {Number} radius\n     */\n    this.radius = options.radius || 1;\n\n    options.type = Shape.CAPSULE;\n    Shape.call(this, options);\n}\nCapsule.prototype = new Shape();\nCapsule.prototype.constructor = Capsule;\n\n/**\n * Compute the mass moment of inertia of the Capsule.\n * @method conputeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n * @todo\n */\nCapsule.prototype.computeMomentOfInertia = function(mass){\n    // Approximate with rectangle\n    var r = this.radius,\n        w = this.length + r, // 2*r is too much, 0 is too little\n        h = r*2;\n    return mass * (h*h + w*w) / 12;\n};\n\n/**\n * @method updateBoundingRadius\n */\nCapsule.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = this.radius + this.length/2;\n};\n\n/**\n * @method updateArea\n */\nCapsule.prototype.updateArea = function(){\n    this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;\n};\n\nvar r = vec2.create();\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nCapsule.prototype.computeAABB = function(out, position, angle){\n    var radius = this.radius;\n\n    // Compute center position of one of the the circles, world oriented, but with local offset\n    vec2.set(r,this.length / 2,0);\n    if(angle !== 0){\n        vec2.rotate(r,r,angle);\n    }\n\n    // Get bounds\n    vec2.set(out.upperBound,  Math.max(r[0]+radius, -r[0]+radius),\n                              Math.max(r[1]+radius, -r[1]+radius));\n    vec2.set(out.lowerBound,  Math.min(r[0]-radius, -r[0]-radius),\n                              Math.min(r[1]-radius, -r[1]-radius));\n\n    // Add offset\n    vec2.add(out.lowerBound, out.lowerBound, position);\n    vec2.add(out.upperBound, out.upperBound, position);\n};\n\nvar intersectCapsule_hitPointWorld = vec2.create();\nvar intersectCapsule_normal = vec2.create();\nvar intersectCapsule_l0 = vec2.create();\nvar intersectCapsule_l1 = vec2.create();\nvar intersectCapsule_unit_y = vec2.fromValues(0,1);\n\n/**\n * @method raycast\n * @param  {RaycastResult} result\n * @param  {Ray} ray\n * @param  {array} position\n * @param  {number} angle\n */\nCapsule.prototype.raycast = function(result, ray, position, angle){\n    var from = ray.from;\n    var to = ray.to;\n    var direction = ray.direction;\n\n    var hitPointWorld = intersectCapsule_hitPointWorld;\n    var normal = intersectCapsule_normal;\n    var l0 = intersectCapsule_l0;\n    var l1 = intersectCapsule_l1;\n\n    // The sides\n    var halfLen = this.length / 2;\n    for(var i=0; i<2; i++){\n\n        // get start and end of the line\n        var y = this.radius * (i*2-1);\n        vec2.set(l0, -halfLen, y);\n        vec2.set(l1, halfLen, y);\n        vec2.toGlobalFrame(l0, l0, position, angle);\n        vec2.toGlobalFrame(l1, l1, position, angle);\n\n        var delta = vec2.getLineSegmentsIntersectionFraction(from, to, l0, l1);\n        if(delta >= 0){\n            vec2.rotate(normal, intersectCapsule_unit_y, angle);\n            vec2.scale(normal, normal, (i*2-1));\n            ray.reportIntersection(result, delta, normal, -1);\n            if(result.shouldStop(ray)){\n                return;\n            }\n        }\n    }\n\n    // Circles\n    var diagonalLengthSquared = Math.pow(this.radius, 2) + Math.pow(halfLen, 2);\n    for(var i=0; i<2; i++){\n        vec2.set(l0, halfLen * (i*2-1), 0);\n        vec2.toGlobalFrame(l0, l0, position, angle);\n\n        var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);\n        var b = 2 * ((to[0] - from[0]) * (from[0] - l0[0]) + (to[1] - from[1]) * (from[1] - l0[1]));\n        var c = Math.pow(from[0] - l0[0], 2) + Math.pow(from[1] - l0[1], 2) - Math.pow(this.radius, 2);\n        var delta = Math.pow(b, 2) - 4 * a * c;\n\n        if(delta < 0){\n            // No intersection\n            continue;\n\n        } else if(delta === 0){\n            // single intersection point\n            vec2.lerp(hitPointWorld, from, to, delta);\n\n            if(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){\n                vec2.sub(normal, hitPointWorld, l0);\n                vec2.normalize(normal,normal);\n                ray.reportIntersection(result, delta, normal, -1);\n                if(result.shouldStop(ray)){\n                    return;\n                }\n            }\n\n        } else {\n            var sqrtDelta = Math.sqrt(delta);\n            var inv2a = 1 / (2 * a);\n            var d1 = (- b - sqrtDelta) * inv2a;\n            var d2 = (- b + sqrtDelta) * inv2a;\n\n            if(d1 >= 0 && d1 <= 1){\n                vec2.lerp(hitPointWorld, from, to, d1);\n                if(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){\n                    vec2.sub(normal, hitPointWorld, l0);\n                    vec2.normalize(normal,normal);\n                    ray.reportIntersection(result, d1, normal, -1);\n                    if(result.shouldStop(ray)){\n                        return;\n                    }\n                }\n            }\n\n            if(d2 >= 0 && d2 <= 1){\n                vec2.lerp(hitPointWorld, from, to, d2);\n                if(vec2.squaredDistance(hitPointWorld, position) > diagonalLengthSquared){\n                    vec2.sub(normal, hitPointWorld, l0);\n                    vec2.normalize(normal,normal);\n                    ray.reportIntersection(result, d2, normal, -1);\n                    if(result.shouldStop(ray)){\n                        return;\n                    }\n                }\n            }\n        }\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9DYXBzdWxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9zaGFwZXMvQ2Fwc3VsZS5qcz9kNmJhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBTaGFwZSA9IHJlcXVpcmUoJy4vU2hhcGUnKVxuLCAgIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYXBzdWxlO1xuXG4vKipcbiAqIENhcHN1bGUgc2hhcGUgY2xhc3MuXG4gKiBAY2xhc3MgQ2Fwc3VsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAoTm90ZSB0aGF0IHRoaXMgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IGNvbnN0cnVjdG9yLilcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MV0gVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGVuZCBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MV0gUmFkaXVzIG9mIHRoZSBjYXBzdWxlXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBjYXBzdWxlU2hhcGUgPSBuZXcgQ2Fwc3VsZSh7XG4gKiAgICAgICAgIGxlbmd0aDogMSxcbiAqICAgICAgICAgcmFkaXVzOiAyXG4gKiAgICAgfSk7XG4gKiAgICAgYm9keS5hZGRTaGFwZShjYXBzdWxlU2hhcGUpO1xuICovXG5mdW5jdGlvbiBDYXBzdWxlKG9wdGlvbnMpe1xuICAgIGlmKHR5cGVvZihhcmd1bWVudHNbMF0pID09PSAnbnVtYmVyJyAmJiB0eXBlb2YoYXJndW1lbnRzWzFdKSA9PT0gJ251bWJlcicpe1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgbGVuZ3RoOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICByYWRpdXM6IGFyZ3VtZW50c1sxXVxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBDYXBzdWxlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBoYXMgY2hhbmdlZC4gUGxlYXNlIHVzZSB0aGUgZm9sbG93aW5nIGZvcm1hdDogbmV3IENhcHN1bGUoeyByYWRpdXM6IDEsIGxlbmd0aDogMSB9KScpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBlbmQgcG9pbnRzLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLmxlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHx8IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmFkaXVzIG9mIHRoZSBjYXBzdWxlLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDE7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBTaGFwZS5DQVBTVUxFO1xuICAgIFNoYXBlLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5DYXBzdWxlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuQ2Fwc3VsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYXBzdWxlO1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIG1hc3MgbW9tZW50IG9mIGluZXJ0aWEgb2YgdGhlIENhcHN1bGUuXG4gKiBAbWV0aG9kIGNvbnB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICogQHRvZG9cbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIC8vIEFwcHJveGltYXRlIHdpdGggcmVjdGFuZ2xlXG4gICAgdmFyIHIgPSB0aGlzLnJhZGl1cyxcbiAgICAgICAgdyA9IHRoaXMubGVuZ3RoICsgciwgLy8gMipyIGlzIHRvbyBtdWNoLCAwIGlzIHRvbyBsaXR0bGVcbiAgICAgICAgaCA9IHIqMjtcbiAgICByZXR1cm4gbWFzcyAqIChoKmggKyB3KncpIC8gMTI7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuQ2Fwc3VsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSB0aGlzLnJhZGl1cyArIHRoaXMubGVuZ3RoLzI7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgdXBkYXRlQXJlYVxuICovXG5DYXBzdWxlLnByb3RvdHlwZS51cGRhdGVBcmVhID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmFyZWEgPSBNYXRoLlBJICogdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyArIHRoaXMucmFkaXVzICogMiAqIHRoaXMubGVuZ3RoO1xufTtcblxudmFyIHIgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5DYXBzdWxlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2YXIgcmFkaXVzID0gdGhpcy5yYWRpdXM7XG5cbiAgICAvLyBDb21wdXRlIGNlbnRlciBwb3NpdGlvbiBvZiBvbmUgb2YgdGhlIHRoZSBjaXJjbGVzLCB3b3JsZCBvcmllbnRlZCwgYnV0IHdpdGggbG9jYWwgb2Zmc2V0XG4gICAgdmVjMi5zZXQocix0aGlzLmxlbmd0aCAvIDIsMCk7XG4gICAgaWYoYW5nbGUgIT09IDApe1xuICAgICAgICB2ZWMyLnJvdGF0ZShyLHIsYW5nbGUpO1xuICAgIH1cblxuICAgIC8vIEdldCBib3VuZHNcbiAgICB2ZWMyLnNldChvdXQudXBwZXJCb3VuZCwgIE1hdGgubWF4KHJbMF0rcmFkaXVzLCAtclswXStyYWRpdXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoclsxXStyYWRpdXMsIC1yWzFdK3JhZGl1cykpO1xuICAgIHZlYzIuc2V0KG91dC5sb3dlckJvdW5kLCAgTWF0aC5taW4oclswXS1yYWRpdXMsIC1yWzBdLXJhZGl1cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihyWzFdLXJhZGl1cywgLXJbMV0tcmFkaXVzKSk7XG5cbiAgICAvLyBBZGQgb2Zmc2V0XG4gICAgdmVjMi5hZGQob3V0Lmxvd2VyQm91bmQsIG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgdmVjMi5hZGQob3V0LnVwcGVyQm91bmQsIG91dC51cHBlckJvdW5kLCBwb3NpdGlvbik7XG59O1xuXG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV9oaXRQb2ludFdvcmxkID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RDYXBzdWxlX25vcm1hbCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV9sMCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV9sMSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0Q2Fwc3VsZV91bml0X3kgPSB2ZWMyLmZyb21WYWx1ZXMoMCwxKTtcblxuLyoqXG4gKiBAbWV0aG9kIHJheWNhc3RcbiAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxuICogQHBhcmFtICB7UmF5fSByYXlcbiAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxuICovXG5DYXBzdWxlLnByb3RvdHlwZS5yYXljYXN0ID0gZnVuY3Rpb24ocmVzdWx0LCByYXksIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmFyIGZyb20gPSByYXkuZnJvbTtcbiAgICB2YXIgdG8gPSByYXkudG87XG4gICAgdmFyIGRpcmVjdGlvbiA9IHJheS5kaXJlY3Rpb247XG5cbiAgICB2YXIgaGl0UG9pbnRXb3JsZCA9IGludGVyc2VjdENhcHN1bGVfaGl0UG9pbnRXb3JsZDtcbiAgICB2YXIgbm9ybWFsID0gaW50ZXJzZWN0Q2Fwc3VsZV9ub3JtYWw7XG4gICAgdmFyIGwwID0gaW50ZXJzZWN0Q2Fwc3VsZV9sMDtcbiAgICB2YXIgbDEgPSBpbnRlcnNlY3RDYXBzdWxlX2wxO1xuXG4gICAgLy8gVGhlIHNpZGVzXG4gICAgdmFyIGhhbGZMZW4gPSB0aGlzLmxlbmd0aCAvIDI7XG4gICAgZm9yKHZhciBpPTA7IGk8MjsgaSsrKXtcblxuICAgICAgICAvLyBnZXQgc3RhcnQgYW5kIGVuZCBvZiB0aGUgbGluZVxuICAgICAgICB2YXIgeSA9IHRoaXMucmFkaXVzICogKGkqMi0xKTtcbiAgICAgICAgdmVjMi5zZXQobDAsIC1oYWxmTGVuLCB5KTtcbiAgICAgICAgdmVjMi5zZXQobDEsIGhhbGZMZW4sIHkpO1xuICAgICAgICB2ZWMyLnRvR2xvYmFsRnJhbWUobDAsIGwwLCBwb3NpdGlvbiwgYW5nbGUpO1xuICAgICAgICB2ZWMyLnRvR2xvYmFsRnJhbWUobDEsIGwxLCBwb3NpdGlvbiwgYW5nbGUpO1xuXG4gICAgICAgIHZhciBkZWx0YSA9IHZlYzIuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb24oZnJvbSwgdG8sIGwwLCBsMSk7XG4gICAgICAgIGlmKGRlbHRhID49IDApe1xuICAgICAgICAgICAgdmVjMi5yb3RhdGUobm9ybWFsLCBpbnRlcnNlY3RDYXBzdWxlX3VuaXRfeSwgYW5nbGUpO1xuICAgICAgICAgICAgdmVjMi5zY2FsZShub3JtYWwsIG5vcm1hbCwgKGkqMi0xKSk7XG4gICAgICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZGVsdGEsIG5vcm1hbCwgLTEpO1xuICAgICAgICAgICAgaWYocmVzdWx0LnNob3VsZFN0b3AocmF5KSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2lyY2xlc1xuICAgIHZhciBkaWFnb25hbExlbmd0aFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMikgKyBNYXRoLnBvdyhoYWxmTGVuLCAyKTtcbiAgICBmb3IodmFyIGk9MDsgaTwyOyBpKyspe1xuICAgICAgICB2ZWMyLnNldChsMCwgaGFsZkxlbiAqIChpKjItMSksIDApO1xuICAgICAgICB2ZWMyLnRvR2xvYmFsRnJhbWUobDAsIGwwLCBwb3NpdGlvbiwgYW5nbGUpO1xuXG4gICAgICAgIHZhciBhID0gTWF0aC5wb3codG9bMF0gLSBmcm9tWzBdLCAyKSArIE1hdGgucG93KHRvWzFdIC0gZnJvbVsxXSwgMik7XG4gICAgICAgIHZhciBiID0gMiAqICgodG9bMF0gLSBmcm9tWzBdKSAqIChmcm9tWzBdIC0gbDBbMF0pICsgKHRvWzFdIC0gZnJvbVsxXSkgKiAoZnJvbVsxXSAtIGwwWzFdKSk7XG4gICAgICAgIHZhciBjID0gTWF0aC5wb3coZnJvbVswXSAtIGwwWzBdLCAyKSArIE1hdGgucG93KGZyb21bMV0gLSBsMFsxXSwgMikgLSBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMik7XG4gICAgICAgIHZhciBkZWx0YSA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGEgKiBjO1xuXG4gICAgICAgIGlmKGRlbHRhIDwgMCl7XG4gICAgICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIH0gZWxzZSBpZihkZWx0YSA9PT0gMCl7XG4gICAgICAgICAgICAvLyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgICAgICB2ZWMyLmxlcnAoaGl0UG9pbnRXb3JsZCwgZnJvbSwgdG8sIGRlbHRhKTtcblxuICAgICAgICAgICAgaWYodmVjMi5zcXVhcmVkRGlzdGFuY2UoaGl0UG9pbnRXb3JsZCwgcG9zaXRpb24pID4gZGlhZ29uYWxMZW5ndGhTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICB2ZWMyLnN1Yihub3JtYWwsIGhpdFBvaW50V29ybGQsIGwwKTtcbiAgICAgICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTtcbiAgICAgICAgICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZGVsdGEsIG5vcm1hbCwgLTEpO1xuICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5zaG91bGRTdG9wKHJheSkpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3FydERlbHRhID0gTWF0aC5zcXJ0KGRlbHRhKTtcbiAgICAgICAgICAgIHZhciBpbnYyYSA9IDEgLyAoMiAqIGEpO1xuICAgICAgICAgICAgdmFyIGQxID0gKC0gYiAtIHNxcnREZWx0YSkgKiBpbnYyYTtcbiAgICAgICAgICAgIHZhciBkMiA9ICgtIGIgKyBzcXJ0RGVsdGEpICogaW52MmE7XG5cbiAgICAgICAgICAgIGlmKGQxID49IDAgJiYgZDEgPD0gMSl7XG4gICAgICAgICAgICAgICAgdmVjMi5sZXJwKGhpdFBvaW50V29ybGQsIGZyb20sIHRvLCBkMSk7XG4gICAgICAgICAgICAgICAgaWYodmVjMi5zcXVhcmVkRGlzdGFuY2UoaGl0UG9pbnRXb3JsZCwgcG9zaXRpb24pID4gZGlhZ29uYWxMZW5ndGhTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBoaXRQb2ludFdvcmxkLCBsMCk7XG4gICAgICAgICAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCxub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICByYXkucmVwb3J0SW50ZXJzZWN0aW9uKHJlc3VsdCwgZDEsIG5vcm1hbCwgLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQuc2hvdWxkU3RvcChyYXkpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZDIgPj0gMCAmJiBkMiA8PSAxKXtcbiAgICAgICAgICAgICAgICB2ZWMyLmxlcnAoaGl0UG9pbnRXb3JsZCwgZnJvbSwgdG8sIGQyKTtcbiAgICAgICAgICAgICAgICBpZih2ZWMyLnNxdWFyZWREaXN0YW5jZShoaXRQb2ludFdvcmxkLCBwb3NpdGlvbikgPiBkaWFnb25hbExlbmd0aFNxdWFyZWQpe1xuICAgICAgICAgICAgICAgICAgICB2ZWMyLnN1Yihub3JtYWwsIGhpdFBvaW50V29ybGQsIGwwKTtcbiAgICAgICAgICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkMiwgbm9ybWFsLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5zaG91bGRTdG9wKHJheSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/shapes/Capsule.js\n");

/***/ }),

/***/ "./node_modules/p2/src/shapes/Circle.js":
/*!**********************************************!*\
  !*** ./node_modules/p2/src/shapes/Circle.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Shape = __webpack_require__(/*! ./Shape */ \"./node_modules/p2/src/shapes/Shape.js\")\n,    vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\n\nmodule.exports = Circle;\n\n/**\n * Circle shape class.\n * @class Circle\n * @extends Shape\n * @constructor\n * @param {options} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @param {number} [options.radius=1] The radius of this circle\n *\n * @example\n *     var circleShape = new Circle({ radius: 1 });\n *     body.addShape(circleShape);\n */\nfunction Circle(options){\n    if(typeof(arguments[0]) === 'number'){\n        options = {\n            radius: arguments[0]\n        };\n        console.warn('The Circle constructor signature has changed. Please use the following format: new Circle({ radius: 1 })');\n    }\n    options = options || {};\n\n    /**\n     * The radius of the circle.\n     * @property radius\n     * @type {number}\n     */\n    this.radius = options.radius || 1;\n\n    options.type = Shape.CIRCLE;\n    Shape.call(this, options);\n}\nCircle.prototype = new Shape();\nCircle.prototype.constructor = Circle;\n\n/**\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n */\nCircle.prototype.computeMomentOfInertia = function(mass){\n    var r = this.radius;\n    return mass * r * r / 2;\n};\n\n/**\n * @method updateBoundingRadius\n * @return {Number}\n */\nCircle.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = this.radius;\n};\n\n/**\n * @method updateArea\n * @return {Number}\n */\nCircle.prototype.updateArea = function(){\n    this.area = Math.PI * this.radius * this.radius;\n};\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nCircle.prototype.computeAABB = function(out, position, angle){\n    var r = this.radius;\n    vec2.set(out.upperBound,  r,  r);\n    vec2.set(out.lowerBound, -r, -r);\n    if(position){\n        vec2.add(out.lowerBound, out.lowerBound, position);\n        vec2.add(out.upperBound, out.upperBound, position);\n    }\n};\n\nvar Ray_intersectSphere_intersectionPoint = vec2.create();\nvar Ray_intersectSphere_normal = vec2.create();\n\n/**\n * @method raycast\n * @param  {RaycastResult} result\n * @param  {Ray} ray\n * @param  {array} position\n * @param  {number} angle\n */\nCircle.prototype.raycast = function(result, ray, position, angle){\n    var from = ray.from,\n        to = ray.to,\n        r = this.radius;\n\n    var a = Math.pow(to[0] - from[0], 2) + Math.pow(to[1] - from[1], 2);\n    var b = 2 * ((to[0] - from[0]) * (from[0] - position[0]) + (to[1] - from[1]) * (from[1] - position[1]));\n    var c = Math.pow(from[0] - position[0], 2) + Math.pow(from[1] - position[1], 2) - Math.pow(r, 2);\n    var delta = Math.pow(b, 2) - 4 * a * c;\n\n    var intersectionPoint = Ray_intersectSphere_intersectionPoint;\n    var normal = Ray_intersectSphere_normal;\n\n    if(delta < 0){\n        // No intersection\n        return;\n\n    } else if(delta === 0){\n        // single intersection point\n        vec2.lerp(intersectionPoint, from, to, delta);\n\n        vec2.sub(normal, intersectionPoint, position);\n        vec2.normalize(normal,normal);\n\n        ray.reportIntersection(result, delta, normal, -1);\n\n    } else {\n        var sqrtDelta = Math.sqrt(delta);\n        var inv2a = 1 / (2 * a);\n        var d1 = (- b - sqrtDelta) * inv2a;\n        var d2 = (- b + sqrtDelta) * inv2a;\n\n        if(d1 >= 0 && d1 <= 1){\n            vec2.lerp(intersectionPoint, from, to, d1);\n\n            vec2.sub(normal, intersectionPoint, position);\n            vec2.normalize(normal,normal);\n\n            ray.reportIntersection(result, d1, normal, -1);\n\n            if(result.shouldStop(ray)){\n                return;\n            }\n        }\n\n        if(d2 >= 0 && d2 <= 1){\n            vec2.lerp(intersectionPoint, from, to, d2);\n\n            vec2.sub(normal, intersectionPoint, position);\n            vec2.normalize(normal,normal);\n\n            ray.reportIntersection(result, d2, normal, -1);\n        }\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9DaXJjbGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9DaXJjbGUuanM/YTM4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJylcbiwgICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZTtcblxuLyoqXG4gKiBDaXJjbGUgc2hhcGUgY2xhc3MuXG4gKiBAY2xhc3MgQ2lyY2xlXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29wdGlvbnN9IFtvcHRpb25zXSAoTm90ZSB0aGF0IHRoaXMgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IGNvbnN0cnVjdG9yLilcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yYWRpdXM9MV0gVGhlIHJhZGl1cyBvZiB0aGlzIGNpcmNsZVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGNpcmNsZVNoYXBlID0gbmV3IENpcmNsZSh7IHJhZGl1czogMSB9KTtcbiAqICAgICBib2R5LmFkZFNoYXBlKGNpcmNsZVNoYXBlKTtcbiAqL1xuZnVuY3Rpb24gQ2lyY2xlKG9wdGlvbnMpe1xuICAgIGlmKHR5cGVvZihhcmd1bWVudHNbMF0pID09PSAnbnVtYmVyJyl7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByYWRpdXM6IGFyZ3VtZW50c1swXVxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBDaXJjbGUgY29uc3RydWN0b3Igc2lnbmF0dXJlIGhhcyBjaGFuZ2VkLiBQbGVhc2UgdXNlIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBuZXcgQ2lyY2xlKHsgcmFkaXVzOiAxIH0pJyk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxuICAgICAqIEBwcm9wZXJ0eSByYWRpdXNcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMTtcblxuICAgIG9wdGlvbnMudHlwZSA9IFNoYXBlLkNJUkNMRTtcbiAgICBTaGFwZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuQ2lyY2xlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuQ2lyY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENpcmNsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5DaXJjbGUucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xuICAgIHJldHVybiBtYXNzICogciAqIHIgLyAyO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkNpcmNsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSB0aGlzLnJhZGl1cztcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVBcmVhXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkNpcmNsZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5hcmVhID0gTWF0aC5QSSAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0ICAgICAgVGhlIHJlc3VsdGluZyBBQUJCLlxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5DaXJjbGUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciByID0gdGhpcy5yYWRpdXM7XG4gICAgdmVjMi5zZXQob3V0LnVwcGVyQm91bmQsICByLCAgcik7XG4gICAgdmVjMi5zZXQob3V0Lmxvd2VyQm91bmQsIC1yLCAtcik7XG4gICAgaWYocG9zaXRpb24pe1xuICAgICAgICB2ZWMyLmFkZChvdXQubG93ZXJCb3VuZCwgb3V0Lmxvd2VyQm91bmQsIHBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5hZGQob3V0LnVwcGVyQm91bmQsIG91dC51cHBlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgfVxufTtcblxudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsID0gdmVjMi5jcmVhdGUoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHJheWNhc3RcbiAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxuICogQHBhcmFtICB7UmF5fSByYXlcbiAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxuICovXG5DaXJjbGUucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbihyZXN1bHQsIHJheSwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2YXIgZnJvbSA9IHJheS5mcm9tLFxuICAgICAgICB0byA9IHJheS50byxcbiAgICAgICAgciA9IHRoaXMucmFkaXVzO1xuXG4gICAgdmFyIGEgPSBNYXRoLnBvdyh0b1swXSAtIGZyb21bMF0sIDIpICsgTWF0aC5wb3codG9bMV0gLSBmcm9tWzFdLCAyKTtcbiAgICB2YXIgYiA9IDIgKiAoKHRvWzBdIC0gZnJvbVswXSkgKiAoZnJvbVswXSAtIHBvc2l0aW9uWzBdKSArICh0b1sxXSAtIGZyb21bMV0pICogKGZyb21bMV0gLSBwb3NpdGlvblsxXSkpO1xuICAgIHZhciBjID0gTWF0aC5wb3coZnJvbVswXSAtIHBvc2l0aW9uWzBdLCAyKSArIE1hdGgucG93KGZyb21bMV0gLSBwb3NpdGlvblsxXSwgMikgLSBNYXRoLnBvdyhyLCAyKTtcbiAgICB2YXIgZGVsdGEgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBhICogYztcblxuICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQ7XG4gICAgdmFyIG5vcm1hbCA9IFJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsO1xuXG4gICAgaWYoZGVsdGEgPCAwKXtcbiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXG4gICAgICAgIHJldHVybjtcblxuICAgIH0gZWxzZSBpZihkZWx0YSA9PT0gMCl7XG4gICAgICAgIC8vIHNpbmdsZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgdmVjMi5sZXJwKGludGVyc2VjdGlvblBvaW50LCBmcm9tLCB0bywgZGVsdGEpO1xuXG4gICAgICAgIHZlYzIuc3ViKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHBvc2l0aW9uKTtcbiAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7XG5cbiAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGRlbHRhLCBub3JtYWwsIC0xKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcXJ0RGVsdGEgPSBNYXRoLnNxcnQoZGVsdGEpO1xuICAgICAgICB2YXIgaW52MmEgPSAxIC8gKDIgKiBhKTtcbiAgICAgICAgdmFyIGQxID0gKC0gYiAtIHNxcnREZWx0YSkgKiBpbnYyYTtcbiAgICAgICAgdmFyIGQyID0gKC0gYiArIHNxcnREZWx0YSkgKiBpbnYyYTtcblxuICAgICAgICBpZihkMSA+PSAwICYmIGQxIDw9IDEpe1xuICAgICAgICAgICAgdmVjMi5sZXJwKGludGVyc2VjdGlvblBvaW50LCBmcm9tLCB0bywgZDEpO1xuXG4gICAgICAgICAgICB2ZWMyLnN1Yihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBwb3NpdGlvbik7XG4gICAgICAgICAgICB2ZWMyLm5vcm1hbGl6ZShub3JtYWwsbm9ybWFsKTtcblxuICAgICAgICAgICAgcmF5LnJlcG9ydEludGVyc2VjdGlvbihyZXN1bHQsIGQxLCBub3JtYWwsIC0xKTtcblxuICAgICAgICAgICAgaWYocmVzdWx0LnNob3VsZFN0b3AocmF5KSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoZDIgPj0gMCAmJiBkMiA8PSAxKXtcbiAgICAgICAgICAgIHZlYzIubGVycChpbnRlcnNlY3Rpb25Qb2ludCwgZnJvbSwgdG8sIGQyKTtcblxuICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLG5vcm1hbCk7XG5cbiAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkMiwgbm9ybWFsLCAtMSk7XG4gICAgICAgIH1cbiAgICB9XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/shapes/Circle.js\n");

/***/ }),

/***/ "./node_modules/p2/src/shapes/Convex.js":
/*!**********************************************!*\
  !*** ./node_modules/p2/src/shapes/Convex.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Shape = __webpack_require__(/*! ./Shape */ \"./node_modules/p2/src/shapes/Shape.js\")\n,   vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,   polyk = __webpack_require__(/*! ../math/polyk */ \"./node_modules/p2/src/math/polyk.js\")\n,   decomp = __webpack_require__(/*! poly-decomp */ \"./node_modules/poly-decomp/src/index.js\");\n\nmodule.exports = Convex;\n\n/**\n * Convex shape class.\n * @class Convex\n * @constructor\n * @extends Shape\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @param {Array} [options.vertices] An array of vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.\n * @param {Array} [options.axes] An array of unit length vectors, representing the symmetry axes in the convex.\n * @example\n *     // Create a box\n *     var vertices = [[-1,-1], [1,-1], [1,1], [-1,1]];\n *     var convexShape = new Convex({ vertices: vertices });\n *     body.addShape(convexShape);\n */\nfunction Convex(options){\n    if(Array.isArray(arguments[0])){\n        options = {\n            vertices: arguments[0],\n            axes: arguments[1]\n        };\n        console.warn('The Convex constructor signature has changed. Please use the following format: new Convex({ vertices: [...], ... })');\n    }\n    options = options || {};\n\n    /**\n     * Vertices defined in the local frame.\n     * @property vertices\n     * @type {Array}\n     */\n    this.vertices = [];\n\n    // Copy the verts\n    var vertices = options.vertices !== undefined ? options.vertices : [];\n    for(var i=0; i < vertices.length; i++){\n        var v = vec2.create();\n        vec2.copy(v, vertices[i]);\n        this.vertices.push(v);\n    }\n\n    /**\n     * Axes defined in the local frame.\n     * @property axes\n     * @type {Array}\n     */\n    this.axes = [];\n\n    if(options.axes){\n\n        // Copy the axes\n        for(var i=0; i < options.axes.length; i++){\n            var axis = vec2.create();\n            vec2.copy(axis, options.axes[i]);\n            this.axes.push(axis);\n        }\n\n    } else {\n\n        // Construct axes from the vertex data\n        for(var i = 0; i < this.vertices.length; i++){\n            // Get the world edge\n            var worldPoint0 = this.vertices[i];\n            var worldPoint1 = this.vertices[(i+1) % this.vertices.length];\n\n            var normal = vec2.create();\n            vec2.sub(normal, worldPoint1, worldPoint0);\n\n            // Get normal - just rotate 90 degrees since vertices are given in CCW\n            vec2.rotate90cw(normal, normal);\n            vec2.normalize(normal, normal);\n\n            this.axes.push(normal);\n        }\n\n    }\n\n    /**\n     * The center of mass of the Convex\n     * @property centerOfMass\n     * @type {Array}\n     */\n    this.centerOfMass = vec2.fromValues(0,0);\n\n    /**\n     * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.\n     * @property triangles\n     * @type {Array}\n     */\n    this.triangles = [];\n\n    if(this.vertices.length){\n        this.updateTriangles();\n        this.updateCenterOfMass();\n    }\n\n    /**\n     * The bounding radius of the convex\n     * @property boundingRadius\n     * @type {Number}\n     */\n    this.boundingRadius = 0;\n\n    options.type = Shape.CONVEX;\n    Shape.call(this, options);\n\n    this.updateBoundingRadius();\n    this.updateArea();\n    if(this.area < 0){\n        throw new Error(\"Convex vertices must be given in conter-clockwise winding.\");\n    }\n}\nConvex.prototype = new Shape();\nConvex.prototype.constructor = Convex;\n\nvar tmpVec1 = vec2.create();\nvar tmpVec2 = vec2.create();\n\n/**\n * Project a Convex onto a world-oriented axis\n * @method projectOntoAxis\n * @static\n * @param  {Array} offset\n * @param  {Array} localAxis\n * @param  {Array} result\n */\nConvex.prototype.projectOntoLocalAxis = function(localAxis, result){\n    var max=null,\n        min=null,\n        v,\n        value,\n        localAxis = tmpVec1;\n\n    // Get projected position of all vertices\n    for(var i=0; i<this.vertices.length; i++){\n        v = this.vertices[i];\n        value = vec2.dot(v, localAxis);\n        if(max === null || value > max){\n            max = value;\n        }\n        if(min === null || value < min){\n            min = value;\n        }\n    }\n\n    if(min > max){\n        var t = min;\n        min = max;\n        max = t;\n    }\n\n    vec2.set(result, min, max);\n};\n\nConvex.prototype.projectOntoWorldAxis = function(localAxis, shapeOffset, shapeAngle, result){\n    var worldAxis = tmpVec2;\n\n    this.projectOntoLocalAxis(localAxis, result);\n\n    // Project the position of the body onto the axis - need to add this to the result\n    if(shapeAngle !== 0){\n        vec2.rotate(worldAxis, localAxis, shapeAngle);\n    } else {\n        worldAxis = localAxis;\n    }\n    var offset = vec2.dot(shapeOffset, worldAxis);\n\n    vec2.set(result, result[0] + offset, result[1] + offset);\n};\n\n\n/**\n * Update the .triangles property\n * @method updateTriangles\n */\nConvex.prototype.updateTriangles = function(){\n\n    this.triangles.length = 0;\n\n    // Rewrite on polyk notation, array of numbers\n    var polykVerts = [];\n    for(var i=0; i<this.vertices.length; i++){\n        var v = this.vertices[i];\n        polykVerts.push(v[0],v[1]);\n    }\n\n    // Triangulate\n    var triangles = polyk.Triangulate(polykVerts);\n\n    // Loop over all triangles, add their inertia contributions to I\n    for(var i=0; i<triangles.length; i+=3){\n        var id1 = triangles[i],\n            id2 = triangles[i+1],\n            id3 = triangles[i+2];\n\n        // Add to triangles\n        this.triangles.push([id1,id2,id3]);\n    }\n};\n\nvar updateCenterOfMass_centroid = vec2.create(),\n    updateCenterOfMass_centroid_times_mass = vec2.create(),\n    updateCenterOfMass_a = vec2.create(),\n    updateCenterOfMass_b = vec2.create(),\n    updateCenterOfMass_c = vec2.create(),\n    updateCenterOfMass_ac = vec2.create(),\n    updateCenterOfMass_ca = vec2.create(),\n    updateCenterOfMass_cb = vec2.create(),\n    updateCenterOfMass_n = vec2.create();\n\n/**\n * Update the .centerOfMass property.\n * @method updateCenterOfMass\n */\nConvex.prototype.updateCenterOfMass = function(){\n    var triangles = this.triangles,\n        verts = this.vertices,\n        cm = this.centerOfMass,\n        centroid = updateCenterOfMass_centroid,\n        n = updateCenterOfMass_n,\n        a = updateCenterOfMass_a,\n        b = updateCenterOfMass_b,\n        c = updateCenterOfMass_c,\n        ac = updateCenterOfMass_ac,\n        ca = updateCenterOfMass_ca,\n        cb = updateCenterOfMass_cb,\n        centroid_times_mass = updateCenterOfMass_centroid_times_mass;\n\n    vec2.set(cm,0,0);\n    var totalArea = 0;\n\n    for(var i=0; i!==triangles.length; i++){\n        var t = triangles[i],\n            a = verts[t[0]],\n            b = verts[t[1]],\n            c = verts[t[2]];\n\n        vec2.centroid(centroid,a,b,c);\n\n        // Get mass for the triangle (density=1 in this case)\n        // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors\n        var m = Convex.triangleArea(a,b,c);\n        totalArea += m;\n\n        // Add to center of mass\n        vec2.scale(centroid_times_mass, centroid, m);\n        vec2.add(cm, cm, centroid_times_mass);\n    }\n\n    vec2.scale(cm,cm,1/totalArea);\n};\n\n/**\n * Compute the mass moment of inertia of the Convex.\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/\n */\nConvex.prototype.computeMomentOfInertia = function(mass){\n    var denom = 0.0,\n        numer = 0.0,\n        N = this.vertices.length;\n    for(var j = N-1, i = 0; i < N; j = i, i ++){\n        var p0 = this.vertices[j];\n        var p1 = this.vertices[i];\n        var a = Math.abs(vec2.crossLength(p0,p1));\n        var b = vec2.dot(p1,p1) + vec2.dot(p1,p0) + vec2.dot(p0,p0);\n        denom += a * b;\n        numer += a;\n    }\n    return (mass / 6.0) * (denom / numer);\n};\n\n/**\n * Updates the .boundingRadius property\n * @method updateBoundingRadius\n */\nConvex.prototype.updateBoundingRadius = function(){\n    var verts = this.vertices,\n        r2 = 0;\n\n    for(var i=0; i!==verts.length; i++){\n        var l2 = vec2.squaredLength(verts[i]);\n        if(l2 > r2){\n            r2 = l2;\n        }\n    }\n\n    this.boundingRadius = Math.sqrt(r2);\n};\n\n/**\n * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.\n * @static\n * @method triangleArea\n * @param {Array} a\n * @param {Array} b\n * @param {Array} c\n * @return {Number}\n */\nConvex.triangleArea = function(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1]))) * 0.5;\n};\n\n/**\n * Update the .area\n * @method updateArea\n */\nConvex.prototype.updateArea = function(){\n    this.updateTriangles();\n    this.area = 0;\n\n    var triangles = this.triangles,\n        verts = this.vertices;\n    for(var i=0; i!==triangles.length; i++){\n        var t = triangles[i],\n            a = verts[t[0]],\n            b = verts[t[1]],\n            c = verts[t[2]];\n\n        // Get mass for the triangle (density=1 in this case)\n        var m = Convex.triangleArea(a,b,c);\n        this.area += m;\n    }\n};\n\n/**\n * @method computeAABB\n * @param  {AABB}   out\n * @param  {Array}  position\n * @param  {Number} angle\n */\nConvex.prototype.computeAABB = function(out, position, angle){\n    out.setFromPoints(this.vertices, position, angle, 0);\n};\n\nvar intersectConvex_rayStart = vec2.create();\nvar intersectConvex_rayEnd = vec2.create();\nvar intersectConvex_normal = vec2.create();\n\n/**\n * @method raycast\n * @param  {RaycastResult} result\n * @param  {Ray} ray\n * @param  {array} position\n * @param  {number} angle\n */\nConvex.prototype.raycast = function(result, ray, position, angle){\n    var rayStart = intersectConvex_rayStart;\n    var rayEnd = intersectConvex_rayEnd;\n    var normal = intersectConvex_normal;\n    var vertices = this.vertices;\n\n    // Transform to local shape space\n    vec2.toLocalFrame(rayStart, ray.from, position, angle);\n    vec2.toLocalFrame(rayEnd, ray.to, position, angle);\n\n    var n = vertices.length;\n\n    for (var i = 0; i < n && !result.shouldStop(ray); i++) {\n        var q1 = vertices[i];\n        var q2 = vertices[(i+1) % n];\n        var delta = vec2.getLineSegmentsIntersectionFraction(rayStart, rayEnd, q1, q2);\n\n        if(delta >= 0){\n            vec2.sub(normal, q2, q1);\n            vec2.rotate(normal, normal, -Math.PI / 2 + angle);\n            vec2.normalize(normal, normal);\n            ray.reportIntersection(result, delta, normal, i);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9Db252ZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9Db252ZXguanM/NDMwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJylcbiwgICB2ZWMyID0gcmVxdWlyZSgnLi4vbWF0aC92ZWMyJylcbiwgICBwb2x5ayA9IHJlcXVpcmUoJy4uL21hdGgvcG9seWsnKVxuLCAgIGRlY29tcCA9IHJlcXVpcmUoJ3BvbHktZGVjb21wJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udmV4O1xuXG4vKipcbiAqIENvbnZleCBzaGFwZSBjbGFzcy5cbiAqIEBjbGFzcyBDb252ZXhcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy52ZXJ0aWNlc10gQW4gYXJyYXkgb2YgdmVydGljZXMgdGhhdCBzcGFuIHRoaXMgc2hhcGUuIFZlcnRpY2VzIGFyZSBnaXZlbiBpbiBjb3VudGVyLWNsb2Nrd2lzZSAoQ0NXKSBkaXJlY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5heGVzXSBBbiBhcnJheSBvZiB1bml0IGxlbmd0aCB2ZWN0b3JzLCByZXByZXNlbnRpbmcgdGhlIHN5bW1ldHJ5IGF4ZXMgaW4gdGhlIGNvbnZleC5cbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gQ3JlYXRlIGEgYm94XG4gKiAgICAgdmFyIHZlcnRpY2VzID0gW1stMSwtMV0sIFsxLC0xXSwgWzEsMV0sIFstMSwxXV07XG4gKiAgICAgdmFyIGNvbnZleFNoYXBlID0gbmV3IENvbnZleCh7IHZlcnRpY2VzOiB2ZXJ0aWNlcyB9KTtcbiAqICAgICBib2R5LmFkZFNoYXBlKGNvbnZleFNoYXBlKTtcbiAqL1xuZnVuY3Rpb24gQ29udmV4KG9wdGlvbnMpe1xuICAgIGlmKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSl7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB2ZXJ0aWNlczogYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgYXhlczogYXJndW1lbnRzWzFdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUud2FybignVGhlIENvbnZleCBjb25zdHJ1Y3RvciBzaWduYXR1cmUgaGFzIGNoYW5nZWQuIFBsZWFzZSB1c2UgdGhlIGZvbGxvd2luZyBmb3JtYXQ6IG5ldyBDb252ZXgoeyB2ZXJ0aWNlczogWy4uLl0sIC4uLiB9KScpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2VzIGRlZmluZWQgaW4gdGhlIGxvY2FsIGZyYW1lLlxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG5cbiAgICAvLyBDb3B5IHRoZSB2ZXJ0c1xuICAgIHZhciB2ZXJ0aWNlcyA9IG9wdGlvbnMudmVydGljZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudmVydGljZXMgOiBbXTtcbiAgICBmb3IodmFyIGk9MDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgICAgICB2ZWMyLmNvcHkodiwgdmVydGljZXNbaV0pO1xuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2godik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXhlcyBkZWZpbmVkIGluIHRoZSBsb2NhbCBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkgYXhlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmF4ZXMgPSBbXTtcblxuICAgIGlmKG9wdGlvbnMuYXhlcyl7XG5cbiAgICAgICAgLy8gQ29weSB0aGUgYXhlc1xuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IG9wdGlvbnMuYXhlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYXhpcyA9IHZlYzIuY3JlYXRlKCk7XG4gICAgICAgICAgICB2ZWMyLmNvcHkoYXhpcywgb3B0aW9ucy5heGVzW2ldKTtcbiAgICAgICAgICAgIHRoaXMuYXhlcy5wdXNoKGF4aXMpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBheGVzIGZyb20gdGhlIHZlcnRleCBkYXRhXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgd29ybGQgZWRnZVxuICAgICAgICAgICAgdmFyIHdvcmxkUG9pbnQwID0gdGhpcy52ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIHZhciB3b3JsZFBvaW50MSA9IHRoaXMudmVydGljZXNbKGkrMSkgJSB0aGlzLnZlcnRpY2VzLmxlbmd0aF07XG5cbiAgICAgICAgICAgIHZhciBub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCB3b3JsZFBvaW50MSwgd29ybGRQb2ludDApO1xuXG4gICAgICAgICAgICAvLyBHZXQgbm9ybWFsIC0ganVzdCByb3RhdGUgOTAgZGVncmVlcyBzaW5jZSB2ZXJ0aWNlcyBhcmUgZ2l2ZW4gaW4gQ0NXXG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZTkwY3cobm9ybWFsLCBub3JtYWwpO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUobm9ybWFsLCBub3JtYWwpO1xuXG4gICAgICAgICAgICB0aGlzLmF4ZXMucHVzaChub3JtYWwpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2VudGVyIG9mIG1hc3Mgb2YgdGhlIENvbnZleFxuICAgICAqIEBwcm9wZXJ0eSBjZW50ZXJPZk1hc3NcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jZW50ZXJPZk1hc3MgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuICAgIC8qKlxuICAgICAqIFRyaWFuZ3VsYXRlZCB2ZXJzaW9uIG9mIHRoaXMgY29udmV4LiBUaGUgc3RydWN0dXJlIGlzIEFycmF5IG9mIDMtQXJyYXlzLCBhbmQgZWFjaCBzdWJhcnJheSBjb250YWlucyAzIGludGVnZXJzLCByZWZlcmVuY2luZyB0aGUgdmVydGljZXMuXG4gICAgICogQHByb3BlcnR5IHRyaWFuZ2xlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYodGhpcy52ZXJ0aWNlcy5sZW5ndGgpe1xuICAgICAgICB0aGlzLnVwZGF0ZVRyaWFuZ2xlcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNlbnRlck9mTWFzcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBib3VuZGluZyByYWRpdXMgb2YgdGhlIGNvbnZleFxuICAgICAqIEBwcm9wZXJ0eSBib3VuZGluZ1JhZGl1c1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XG5cbiAgICBvcHRpb25zLnR5cGUgPSBTaGFwZS5DT05WRVg7XG4gICAgU2hhcGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZUFyZWEoKTtcbiAgICBpZih0aGlzLmFyZWEgPCAwKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udmV4IHZlcnRpY2VzIG11c3QgYmUgZ2l2ZW4gaW4gY29udGVyLWNsb2Nrd2lzZSB3aW5kaW5nLlwiKTtcbiAgICB9XG59XG5Db252ZXgucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5Db252ZXgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udmV4O1xuXG52YXIgdG1wVmVjMSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgdG1wVmVjMiA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogUHJvamVjdCBhIENvbnZleCBvbnRvIGEgd29ybGQtb3JpZW50ZWQgYXhpc1xuICogQG1ldGhvZCBwcm9qZWN0T250b0F4aXNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBvZmZzZXRcbiAqIEBwYXJhbSAge0FycmF5fSBsb2NhbEF4aXNcbiAqIEBwYXJhbSAge0FycmF5fSByZXN1bHRcbiAqL1xuQ29udmV4LnByb3RvdHlwZS5wcm9qZWN0T250b0xvY2FsQXhpcyA9IGZ1bmN0aW9uKGxvY2FsQXhpcywgcmVzdWx0KXtcbiAgICB2YXIgbWF4PW51bGwsXG4gICAgICAgIG1pbj1udWxsLFxuICAgICAgICB2LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbG9jYWxBeGlzID0gdG1wVmVjMTtcblxuICAgIC8vIEdldCBwcm9qZWN0ZWQgcG9zaXRpb24gb2YgYWxsIHZlcnRpY2VzXG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzW2ldO1xuICAgICAgICB2YWx1ZSA9IHZlYzIuZG90KHYsIGxvY2FsQXhpcyk7XG4gICAgICAgIGlmKG1heCA9PT0gbnVsbCB8fCB2YWx1ZSA+IG1heCl7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZihtaW4gPT09IG51bGwgfHwgdmFsdWUgPCBtaW4pe1xuICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZihtaW4gPiBtYXgpe1xuICAgICAgICB2YXIgdCA9IG1pbjtcbiAgICAgICAgbWluID0gbWF4O1xuICAgICAgICBtYXggPSB0O1xuICAgIH1cblxuICAgIHZlYzIuc2V0KHJlc3VsdCwgbWluLCBtYXgpO1xufTtcblxuQ29udmV4LnByb3RvdHlwZS5wcm9qZWN0T250b1dvcmxkQXhpcyA9IGZ1bmN0aW9uKGxvY2FsQXhpcywgc2hhcGVPZmZzZXQsIHNoYXBlQW5nbGUsIHJlc3VsdCl7XG4gICAgdmFyIHdvcmxkQXhpcyA9IHRtcFZlYzI7XG5cbiAgICB0aGlzLnByb2plY3RPbnRvTG9jYWxBeGlzKGxvY2FsQXhpcywgcmVzdWx0KTtcblxuICAgIC8vIFByb2plY3QgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5IG9udG8gdGhlIGF4aXMgLSBuZWVkIHRvIGFkZCB0aGlzIHRvIHRoZSByZXN1bHRcbiAgICBpZihzaGFwZUFuZ2xlICE9PSAwKXtcbiAgICAgICAgdmVjMi5yb3RhdGUod29ybGRBeGlzLCBsb2NhbEF4aXMsIHNoYXBlQW5nbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmxkQXhpcyA9IGxvY2FsQXhpcztcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IHZlYzIuZG90KHNoYXBlT2Zmc2V0LCB3b3JsZEF4aXMpO1xuXG4gICAgdmVjMi5zZXQocmVzdWx0LCByZXN1bHRbMF0gKyBvZmZzZXQsIHJlc3VsdFsxXSArIG9mZnNldCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIHRoZSAudHJpYW5nbGVzIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZVRyaWFuZ2xlc1xuICovXG5Db252ZXgucHJvdG90eXBlLnVwZGF0ZVRyaWFuZ2xlcyA9IGZ1bmN0aW9uKCl7XG5cbiAgICB0aGlzLnRyaWFuZ2xlcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmV3cml0ZSBvbiBwb2x5ayBub3RhdGlvbiwgYXJyYXkgb2YgbnVtYmVyc1xuICAgIHZhciBwb2x5a1ZlcnRzID0gW107XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlc1tpXTtcbiAgICAgICAgcG9seWtWZXJ0cy5wdXNoKHZbMF0sdlsxXSk7XG4gICAgfVxuXG4gICAgLy8gVHJpYW5ndWxhdGVcbiAgICB2YXIgdHJpYW5nbGVzID0gcG9seWsuVHJpYW5ndWxhdGUocG9seWtWZXJ0cyk7XG5cbiAgICAvLyBMb29wIG92ZXIgYWxsIHRyaWFuZ2xlcywgYWRkIHRoZWlyIGluZXJ0aWEgY29udHJpYnV0aW9ucyB0byBJXG4gICAgZm9yKHZhciBpPTA7IGk8dHJpYW5nbGVzLmxlbmd0aDsgaSs9Myl7XG4gICAgICAgIHZhciBpZDEgPSB0cmlhbmdsZXNbaV0sXG4gICAgICAgICAgICBpZDIgPSB0cmlhbmdsZXNbaSsxXSxcbiAgICAgICAgICAgIGlkMyA9IHRyaWFuZ2xlc1tpKzJdO1xuXG4gICAgICAgIC8vIEFkZCB0byB0cmlhbmdsZXNcbiAgICAgICAgdGhpcy50cmlhbmdsZXMucHVzaChbaWQxLGlkMixpZDNdKTtcbiAgICB9XG59O1xuXG52YXIgdXBkYXRlQ2VudGVyT2ZNYXNzX2NlbnRyb2lkID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWRfdGltZXNfbWFzcyA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2EgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19iID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfYyA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX2FjID0gdmVjMi5jcmVhdGUoKSxcbiAgICB1cGRhdGVDZW50ZXJPZk1hc3NfY2EgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHVwZGF0ZUNlbnRlck9mTWFzc19jYiA9IHZlYzIuY3JlYXRlKCksXG4gICAgdXBkYXRlQ2VudGVyT2ZNYXNzX24gPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLmNlbnRlck9mTWFzcyBwcm9wZXJ0eS5cbiAqIEBtZXRob2QgdXBkYXRlQ2VudGVyT2ZNYXNzXG4gKi9cbkNvbnZleC5wcm90b3R5cGUudXBkYXRlQ2VudGVyT2ZNYXNzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdHJpYW5nbGVzID0gdGhpcy50cmlhbmdsZXMsXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgY20gPSB0aGlzLmNlbnRlck9mTWFzcyxcbiAgICAgICAgY2VudHJvaWQgPSB1cGRhdGVDZW50ZXJPZk1hc3NfY2VudHJvaWQsXG4gICAgICAgIG4gPSB1cGRhdGVDZW50ZXJPZk1hc3NfbixcbiAgICAgICAgYSA9IHVwZGF0ZUNlbnRlck9mTWFzc19hLFxuICAgICAgICBiID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2IsXG4gICAgICAgIGMgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYyxcbiAgICAgICAgYWMgPSB1cGRhdGVDZW50ZXJPZk1hc3NfYWMsXG4gICAgICAgIGNhID0gdXBkYXRlQ2VudGVyT2ZNYXNzX2NhLFxuICAgICAgICBjYiA9IHVwZGF0ZUNlbnRlck9mTWFzc19jYixcbiAgICAgICAgY2VudHJvaWRfdGltZXNfbWFzcyA9IHVwZGF0ZUNlbnRlck9mTWFzc19jZW50cm9pZF90aW1lc19tYXNzO1xuXG4gICAgdmVjMi5zZXQoY20sMCwwKTtcbiAgICB2YXIgdG90YWxBcmVhID0gMDtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09dHJpYW5nbGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHQgPSB0cmlhbmdsZXNbaV0sXG4gICAgICAgICAgICBhID0gdmVydHNbdFswXV0sXG4gICAgICAgICAgICBiID0gdmVydHNbdFsxXV0sXG4gICAgICAgICAgICBjID0gdmVydHNbdFsyXV07XG5cbiAgICAgICAgdmVjMi5jZW50cm9pZChjZW50cm9pZCxhLGIsYyk7XG5cbiAgICAgICAgLy8gR2V0IG1hc3MgZm9yIHRoZSB0cmlhbmdsZSAoZGVuc2l0eT0xIGluIHRoaXMgY2FzZSlcbiAgICAgICAgLy8gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzgwMTk4L2FyZWEtb2YtdHJpYW5nbGUtdmlhLXZlY3RvcnNcbiAgICAgICAgdmFyIG0gPSBDb252ZXgudHJpYW5nbGVBcmVhKGEsYixjKTtcbiAgICAgICAgdG90YWxBcmVhICs9IG07XG5cbiAgICAgICAgLy8gQWRkIHRvIGNlbnRlciBvZiBtYXNzXG4gICAgICAgIHZlYzIuc2NhbGUoY2VudHJvaWRfdGltZXNfbWFzcywgY2VudHJvaWQsIG0pO1xuICAgICAgICB2ZWMyLmFkZChjbSwgY20sIGNlbnRyb2lkX3RpbWVzX21hc3MpO1xuICAgIH1cblxuICAgIHZlYzIuc2NhbGUoY20sY20sMS90b3RhbEFyZWEpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBtYXNzIG1vbWVudCBvZiBpbmVydGlhIG9mIHRoZSBDb252ZXguXG4gKiBAbWV0aG9kIGNvbXB1dGVNb21lbnRPZkluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHJldHVybiB7TnVtYmVyfVxuICogQHNlZSBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3RvcGljLzM0MjgyMi1tb21lbnQtb2YtaW5lcnRpYS1vZi1hLXBvbHlnb24tMmQvXG4gKi9cbkNvbnZleC5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHZhciBkZW5vbSA9IDAuMCxcbiAgICAgICAgbnVtZXIgPSAwLjAsXG4gICAgICAgIE4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICBmb3IodmFyIGogPSBOLTEsIGkgPSAwOyBpIDwgTjsgaiA9IGksIGkgKyspe1xuICAgICAgICB2YXIgcDAgPSB0aGlzLnZlcnRpY2VzW2pdO1xuICAgICAgICB2YXIgcDEgPSB0aGlzLnZlcnRpY2VzW2ldO1xuICAgICAgICB2YXIgYSA9IE1hdGguYWJzKHZlYzIuY3Jvc3NMZW5ndGgocDAscDEpKTtcbiAgICAgICAgdmFyIGIgPSB2ZWMyLmRvdChwMSxwMSkgKyB2ZWMyLmRvdChwMSxwMCkgKyB2ZWMyLmRvdChwMCxwMCk7XG4gICAgICAgIGRlbm9tICs9IGEgKiBiO1xuICAgICAgICBudW1lciArPSBhO1xuICAgIH1cbiAgICByZXR1cm4gKG1hc3MgLyA2LjApICogKGRlbm9tIC8gbnVtZXIpO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSAuYm91bmRpbmdSYWRpdXMgcHJvcGVydHlcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuQ29udmV4LnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgcjIgPSAwO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT12ZXJ0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBsMiA9IHZlYzIuc3F1YXJlZExlbmd0aCh2ZXJ0c1tpXSk7XG4gICAgICAgIGlmKGwyID4gcjIpe1xuICAgICAgICAgICAgcjIgPSBsMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSBNYXRoLnNxcnQocjIpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFyZWEgb2YgdGhlIHRyaWFuZ2xlIHNwYW5uZWQgYnkgdGhlIHRocmVlIHBvaW50cyBhLCBiLCBjLiBUaGUgYXJlYSBpcyBwb3NpdGl2ZSBpZiB0aGUgcG9pbnRzIGFyZSBnaXZlbiBpbiBjb3VudGVyLWNsb2Nrd2lzZSBvcmRlciwgb3RoZXJ3aXNlIG5lZ2F0aXZlLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCB0cmlhbmdsZUFyZWFcbiAqIEBwYXJhbSB7QXJyYXl9IGFcbiAqIEBwYXJhbSB7QXJyYXl9IGJcbiAqIEBwYXJhbSB7QXJyYXl9IGNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQ29udmV4LnRyaWFuZ2xlQXJlYSA9IGZ1bmN0aW9uKGEsYixjKXtcbiAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pKihjWzFdIC0gYVsxXSkpLSgoY1swXSAtIGFbMF0pKihiWzFdIC0gYVsxXSkpKSAqIDAuNTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSAuYXJlYVxuICogQG1ldGhvZCB1cGRhdGVBcmVhXG4gKi9cbkNvbnZleC5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy51cGRhdGVUcmlhbmdsZXMoKTtcbiAgICB0aGlzLmFyZWEgPSAwO1xuXG4gICAgdmFyIHRyaWFuZ2xlcyA9IHRoaXMudHJpYW5nbGVzLFxuICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG4gICAgZm9yKHZhciBpPTA7IGkhPT10cmlhbmdsZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdCA9IHRyaWFuZ2xlc1tpXSxcbiAgICAgICAgICAgIGEgPSB2ZXJ0c1t0WzBdXSxcbiAgICAgICAgICAgIGIgPSB2ZXJ0c1t0WzFdXSxcbiAgICAgICAgICAgIGMgPSB2ZXJ0c1t0WzJdXTtcblxuICAgICAgICAvLyBHZXQgbWFzcyBmb3IgdGhlIHRyaWFuZ2xlIChkZW5zaXR5PTEgaW4gdGhpcyBjYXNlKVxuICAgICAgICB2YXIgbSA9IENvbnZleC50cmlhbmdsZUFyZWEoYSxiLGMpO1xuICAgICAgICB0aGlzLmFyZWEgKz0gbTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9ICAgb3V0XG4gKiBAcGFyYW0gIHtBcnJheX0gIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbkNvbnZleC5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgb3V0LnNldEZyb21Qb2ludHModGhpcy52ZXJ0aWNlcywgcG9zaXRpb24sIGFuZ2xlLCAwKTtcbn07XG5cbnZhciBpbnRlcnNlY3RDb252ZXhfcmF5U3RhcnQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdENvbnZleF9yYXlFbmQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdENvbnZleF9ub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4vKipcbiAqIEBtZXRob2QgcmF5Y2FzdFxuICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAcGFyYW0gIHtSYXl9IHJheVxuICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXG4gKi9cbkNvbnZleC5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciByYXlTdGFydCA9IGludGVyc2VjdENvbnZleF9yYXlTdGFydDtcbiAgICB2YXIgcmF5RW5kID0gaW50ZXJzZWN0Q29udmV4X3JheUVuZDtcbiAgICB2YXIgbm9ybWFsID0gaW50ZXJzZWN0Q29udmV4X25vcm1hbDtcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRvIGxvY2FsIHNoYXBlIHNwYWNlXG4gICAgdmVjMi50b0xvY2FsRnJhbWUocmF5U3RhcnQsIHJheS5mcm9tLCBwb3NpdGlvbiwgYW5nbGUpO1xuICAgIHZlYzIudG9Mb2NhbEZyYW1lKHJheUVuZCwgcmF5LnRvLCBwb3NpdGlvbiwgYW5nbGUpO1xuXG4gICAgdmFyIG4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4gJiYgIXJlc3VsdC5zaG91bGRTdG9wKHJheSk7IGkrKykge1xuICAgICAgICB2YXIgcTEgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgdmFyIHEyID0gdmVydGljZXNbKGkrMSkgJSBuXTtcbiAgICAgICAgdmFyIGRlbHRhID0gdmVjMi5nZXRMaW5lU2VnbWVudHNJbnRlcnNlY3Rpb25GcmFjdGlvbihyYXlTdGFydCwgcmF5RW5kLCBxMSwgcTIpO1xuXG4gICAgICAgIGlmKGRlbHRhID49IDApe1xuICAgICAgICAgICAgdmVjMi5zdWIobm9ybWFsLCBxMiwgcTEpO1xuICAgICAgICAgICAgdmVjMi5yb3RhdGUobm9ybWFsLCBub3JtYWwsIC1NYXRoLlBJIC8gMiArIGFuZ2xlKTtcbiAgICAgICAgICAgIHZlYzIubm9ybWFsaXplKG5vcm1hbCwgbm9ybWFsKTtcbiAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBkZWx0YSwgbm9ybWFsLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/shapes/Convex.js\n");

/***/ }),

/***/ "./node_modules/p2/src/shapes/Heightfield.js":
/*!***************************************************!*\
  !*** ./node_modules/p2/src/shapes/Heightfield.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Shape = __webpack_require__(/*! ./Shape */ \"./node_modules/p2/src/shapes/Shape.js\")\n,    vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,    Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\");\n\nmodule.exports = Heightfield;\n\n/**\n * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance \"elementWidth\".\n * @class Heightfield\n * @extends Shape\n * @constructor\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @param {array} [options.heights] An array of Y values that will be used to construct the terrain.\n * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.\n * @param {Number} [options.maxValue] Maximum value.\n * @param {Number} [options.elementWidth=0.1] World spacing between the data points in X direction.\n *\n * @example\n *     // Generate some height data (y-values).\n *     var heights = [];\n *     for(var i = 0; i < 1000; i++){\n *         var y = 0.5 * Math.cos(0.2 * i);\n *         heights.push(y);\n *     }\n *\n *     // Create the heightfield shape\n *     var heightfieldShape = new Heightfield({\n *         heights: heights,\n *         elementWidth: 1 // Distance between the data points in X direction\n *     });\n *     var heightfieldBody = new Body();\n *     heightfieldBody.addShape(heightfieldShape);\n *     world.addBody(heightfieldBody);\n *\n * @todo Should use a scale property with X and Y direction instead of just elementWidth\n */\nfunction Heightfield(options){\n    if(Array.isArray(arguments[0])){\n        options = {\n            heights: arguments[0]\n        };\n\n        if(typeof(arguments[1]) === 'object'){\n            for(var key in arguments[1]){\n                options[key] = arguments[1][key];\n            }\n        }\n\n        console.warn('The Heightfield constructor signature has changed. Please use the following format: new Heightfield({ heights: [...], ... })');\n    }\n    options = options || {};\n\n    /**\n     * An array of numbers, or height values, that are spread out along the x axis.\n     * @property {array} heights\n     */\n    this.heights = options.heights ? options.heights.slice(0) : [];\n\n    /**\n     * Max value of the heights\n     * @property {number} maxValue\n     */\n    this.maxValue = options.maxValue || null;\n\n    /**\n     * Max value of the heights\n     * @property {number} minValue\n     */\n    this.minValue = options.minValue || null;\n\n    /**\n     * The width of each element\n     * @property {number} elementWidth\n     */\n    this.elementWidth = options.elementWidth || 0.1;\n\n    if(options.maxValue === undefined || options.minValue === undefined){\n        this.updateMaxMinValues();\n    }\n\n    options.type = Shape.HEIGHTFIELD;\n    Shape.call(this, options);\n}\nHeightfield.prototype = new Shape();\nHeightfield.prototype.constructor = Heightfield;\n\n/**\n * Update the .minValue and the .maxValue\n * @method updateMaxMinValues\n */\nHeightfield.prototype.updateMaxMinValues = function(){\n    var data = this.heights;\n    var maxValue = data[0];\n    var minValue = data[0];\n    for(var i=0; i !== data.length; i++){\n        var v = data[i];\n        if(v > maxValue){\n            maxValue = v;\n        }\n        if(v < minValue){\n            minValue = v;\n        }\n    }\n    this.maxValue = maxValue;\n    this.minValue = minValue;\n};\n\n/**\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n */\nHeightfield.prototype.computeMomentOfInertia = function(mass){\n    return Number.MAX_VALUE;\n};\n\nHeightfield.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = Number.MAX_VALUE;\n};\n\nHeightfield.prototype.updateArea = function(){\n    var data = this.heights,\n        area = 0;\n    for(var i=0; i<data.length-1; i++){\n        area += (data[i]+data[i+1]) / 2 * this.elementWidth;\n    }\n    this.area = area;\n};\n\nvar points = [\n    vec2.create(),\n    vec2.create(),\n    vec2.create(),\n    vec2.create()\n];\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nHeightfield.prototype.computeAABB = function(out, position, angle){\n    vec2.set(points[0], 0, this.maxValue);\n    vec2.set(points[1], this.elementWidth * this.heights.length, this.maxValue);\n    vec2.set(points[2], this.elementWidth * this.heights.length, this.minValue);\n    vec2.set(points[3], 0, this.minValue);\n    out.setFromPoints(points, position, angle);\n};\n\n/**\n * Get a line segment in the heightfield\n * @method getLineSegment\n * @param  {array} start Where to store the resulting start point\n * @param  {array} end Where to store the resulting end point\n * @param  {number} i\n */\nHeightfield.prototype.getLineSegment = function(start, end, i){\n    var data = this.heights;\n    var width = this.elementWidth;\n    vec2.set(start, i * width, data[i]);\n    vec2.set(end, (i + 1) * width, data[i + 1]);\n};\n\nHeightfield.prototype.getSegmentIndex = function(position){\n    return Math.floor(position[0] / this.elementWidth);\n};\n\nHeightfield.prototype.getClampedSegmentIndex = function(position){\n    var i = this.getSegmentIndex(position);\n    i = Math.min(this.heights.length, Math.max(i, 0)); // clamp\n    return i;\n};\n\nvar intersectHeightfield_hitPointWorld = vec2.create();\nvar intersectHeightfield_worldNormal = vec2.create();\nvar intersectHeightfield_l0 = vec2.create();\nvar intersectHeightfield_l1 = vec2.create();\nvar intersectHeightfield_localFrom = vec2.create();\nvar intersectHeightfield_localTo = vec2.create();\nvar intersectHeightfield_unit_y = vec2.fromValues(0,1);\n\n// Returns 1 if the lines intersect, otherwise 0.\nfunction getLineSegmentsIntersection (out, p0, p1, p2, p3) {\n\n    var s1_x, s1_y, s2_x, s2_y;\n    s1_x = p1[0] - p0[0];\n    s1_y = p1[1] - p0[1];\n    s2_x = p3[0] - p2[0];\n    s2_y = p3[1] - p2[1];\n\n    var s, t;\n    s = (-s1_y * (p0[0] - p2[0]) + s1_x * (p0[1] - p2[1])) / (-s2_x * s1_y + s1_x * s2_y);\n    t = ( s2_x * (p0[1] - p2[1]) - s2_y * (p0[0] - p2[0])) / (-s2_x * s1_y + s1_x * s2_y);\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) { // Collision detected\n        var intX = p0[0] + (t * s1_x);\n        var intY = p0[1] + (t * s1_y);\n        out[0] = intX;\n        out[1] = intY;\n        return t;\n    }\n    return -1; // No collision\n}\n\n/**\n * @method raycast\n * @param  {RayResult} result\n * @param  {Ray} ray\n * @param  {array} position\n * @param  {number} angle\n */\nHeightfield.prototype.raycast = function(result, ray, position, angle){\n    var from = ray.from;\n    var to = ray.to;\n    var direction = ray.direction;\n\n    var hitPointWorld = intersectHeightfield_hitPointWorld;\n    var worldNormal = intersectHeightfield_worldNormal;\n    var l0 = intersectHeightfield_l0;\n    var l1 = intersectHeightfield_l1;\n    var localFrom = intersectHeightfield_localFrom;\n    var localTo = intersectHeightfield_localTo;\n\n    // get local ray start and end\n    vec2.toLocalFrame(localFrom, from, position, angle);\n    vec2.toLocalFrame(localTo, to, position, angle);\n\n    // Get the segment range\n    var i0 = this.getClampedSegmentIndex(localFrom);\n    var i1 = this.getClampedSegmentIndex(localTo);\n    if(i0 > i1){\n        var tmp = i0;\n        i0 = i1;\n        i1 = tmp;\n    }\n\n    // The segments\n    for(var i=0; i<this.heights.length - 1; i++){\n        this.getLineSegment(l0, l1, i);\n        var t = vec2.getLineSegmentsIntersectionFraction(localFrom, localTo, l0, l1);\n        if(t >= 0){\n            vec2.sub(worldNormal, l1, l0);\n            vec2.rotate(worldNormal, worldNormal, angle + Math.PI / 2);\n            vec2.normalize(worldNormal, worldNormal);\n            ray.reportIntersection(result, t, worldNormal, -1);\n            if(result.shouldStop(ray)){\n                return;\n            }\n        }\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9IZWlnaHRmaWVsZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvc2hhcGVzL0hlaWdodGZpZWxkLmpzP2EyZDIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpXG4sICAgIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKVxuLCAgICBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSGVpZ2h0ZmllbGQ7XG5cbi8qKlxuICogSGVpZ2h0ZmllbGQgc2hhcGUgY2xhc3MuIEhlaWdodCBkYXRhIGlzIGdpdmVuIGFzIGFuIGFycmF5LiBUaGVzZSBkYXRhIHBvaW50cyBhcmUgc3ByZWFkIG91dCBldmVubHkgd2l0aCBhIGRpc3RhbmNlIFwiZWxlbWVudFdpZHRoXCIuXG4gKiBAY2xhc3MgSGVpZ2h0ZmllbGRcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKiBAcGFyYW0ge2FycmF5fSBbb3B0aW9ucy5oZWlnaHRzXSBBbiBhcnJheSBvZiBZIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHRlcnJhaW4uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluVmFsdWVdIE1pbmltdW0gdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnRzIGluIHRoZSBkYXRhIGFycmF5LiBXaWxsIGJlIGNvbXB1dGVkIGF1dG9tYXRpY2FsbHkgaWYgbm90IGdpdmVuLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFZhbHVlXSBNYXhpbXVtIHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmVsZW1lbnRXaWR0aD0wLjFdIFdvcmxkIHNwYWNpbmcgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBHZW5lcmF0ZSBzb21lIGhlaWdodCBkYXRhICh5LXZhbHVlcykuXG4gKiAgICAgdmFyIGhlaWdodHMgPSBbXTtcbiAqICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKXtcbiAqICAgICAgICAgdmFyIHkgPSAwLjUgKiBNYXRoLmNvcygwLjIgKiBpKTtcbiAqICAgICAgICAgaGVpZ2h0cy5wdXNoKHkpO1xuICogICAgIH1cbiAqXG4gKiAgICAgLy8gQ3JlYXRlIHRoZSBoZWlnaHRmaWVsZCBzaGFwZVxuICogICAgIHZhciBoZWlnaHRmaWVsZFNoYXBlID0gbmV3IEhlaWdodGZpZWxkKHtcbiAqICAgICAgICAgaGVpZ2h0czogaGVpZ2h0cyxcbiAqICAgICAgICAgZWxlbWVudFdpZHRoOiAxIC8vIERpc3RhbmNlIGJldHdlZW4gdGhlIGRhdGEgcG9pbnRzIGluIFggZGlyZWN0aW9uXG4gKiAgICAgfSk7XG4gKiAgICAgdmFyIGhlaWdodGZpZWxkQm9keSA9IG5ldyBCb2R5KCk7XG4gKiAgICAgaGVpZ2h0ZmllbGRCb2R5LmFkZFNoYXBlKGhlaWdodGZpZWxkU2hhcGUpO1xuICogICAgIHdvcmxkLmFkZEJvZHkoaGVpZ2h0ZmllbGRCb2R5KTtcbiAqXG4gKiBAdG9kbyBTaG91bGQgdXNlIGEgc2NhbGUgcHJvcGVydHkgd2l0aCBYIGFuZCBZIGRpcmVjdGlvbiBpbnN0ZWFkIG9mIGp1c3QgZWxlbWVudFdpZHRoXG4gKi9cbmZ1bmN0aW9uIEhlaWdodGZpZWxkKG9wdGlvbnMpe1xuICAgIGlmKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSl7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBoZWlnaHRzOiBhcmd1bWVudHNbMF1cbiAgICAgICAgfTtcblxuICAgICAgICBpZih0eXBlb2YoYXJndW1lbnRzWzFdKSA9PT0gJ29iamVjdCcpe1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gYXJndW1lbnRzWzFdKXtcbiAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSBhcmd1bWVudHNbMV1ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUud2FybignVGhlIEhlaWdodGZpZWxkIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBoYXMgY2hhbmdlZC4gUGxlYXNlIHVzZSB0aGUgZm9sbG93aW5nIGZvcm1hdDogbmV3IEhlaWdodGZpZWxkKHsgaGVpZ2h0czogWy4uLl0sIC4uLiB9KScpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIG51bWJlcnMsIG9yIGhlaWdodCB2YWx1ZXMsIHRoYXQgYXJlIHNwcmVhZCBvdXQgYWxvbmcgdGhlIHggYXhpcy5cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBoZWlnaHRzXG4gICAgICovXG4gICAgdGhpcy5oZWlnaHRzID0gb3B0aW9ucy5oZWlnaHRzID8gb3B0aW9ucy5oZWlnaHRzLnNsaWNlKDApIDogW107XG5cbiAgICAvKipcbiAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGhlaWdodHNcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4VmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLm1heFZhbHVlID0gb3B0aW9ucy5tYXhWYWx1ZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogTWF4IHZhbHVlIG9mIHRoZSBoZWlnaHRzXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblZhbHVlXG4gICAgICovXG4gICAgdGhpcy5taW5WYWx1ZSA9IG9wdGlvbnMubWluVmFsdWUgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZWxlbWVudFdpZHRoXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50V2lkdGggPSBvcHRpb25zLmVsZW1lbnRXaWR0aCB8fCAwLjE7XG5cbiAgICBpZihvcHRpb25zLm1heFZhbHVlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5taW5WYWx1ZSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgdGhpcy51cGRhdGVNYXhNaW5WYWx1ZXMoKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLnR5cGUgPSBTaGFwZS5IRUlHSFRGSUVMRDtcbiAgICBTaGFwZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuSGVpZ2h0ZmllbGQucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIZWlnaHRmaWVsZDtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIC5taW5WYWx1ZSBhbmQgdGhlIC5tYXhWYWx1ZVxuICogQG1ldGhvZCB1cGRhdGVNYXhNaW5WYWx1ZXNcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZU1heE1pblZhbHVlcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmhlaWdodHM7XG4gICAgdmFyIG1heFZhbHVlID0gZGF0YVswXTtcbiAgICB2YXIgbWluVmFsdWUgPSBkYXRhWzBdO1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSBkYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSBkYXRhW2ldO1xuICAgICAgICBpZih2ID4gbWF4VmFsdWUpe1xuICAgICAgICAgICAgbWF4VmFsdWUgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGlmKHYgPCBtaW5WYWx1ZSl7XG4gICAgICAgICAgICBtaW5WYWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXhWYWx1ZSA9IG1heFZhbHVlO1xuICAgIHRoaXMubWluVmFsdWUgPSBtaW5WYWx1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlTW9tZW50T2ZJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNvbXB1dGVNb21lbnRPZkluZXJ0aWEgPSBmdW5jdGlvbihtYXNzKXtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmhlaWdodHMsXG4gICAgICAgIGFyZWEgPSAwO1xuICAgIGZvcih2YXIgaT0wOyBpPGRhdGEubGVuZ3RoLTE7IGkrKyl7XG4gICAgICAgIGFyZWEgKz0gKGRhdGFbaV0rZGF0YVtpKzFdKSAvIDIgKiB0aGlzLmVsZW1lbnRXaWR0aDtcbiAgICB9XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbn07XG5cbnZhciBwb2ludHMgPSBbXG4gICAgdmVjMi5jcmVhdGUoKSxcbiAgICB2ZWMyLmNyZWF0ZSgpLFxuICAgIHZlYzIuY3JlYXRlKCksXG4gICAgdmVjMi5jcmVhdGUoKVxuXTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZlYzIuc2V0KHBvaW50c1swXSwgMCwgdGhpcy5tYXhWYWx1ZSk7XG4gICAgdmVjMi5zZXQocG9pbnRzWzFdLCB0aGlzLmVsZW1lbnRXaWR0aCAqIHRoaXMuaGVpZ2h0cy5sZW5ndGgsIHRoaXMubWF4VmFsdWUpO1xuICAgIHZlYzIuc2V0KHBvaW50c1syXSwgdGhpcy5lbGVtZW50V2lkdGggKiB0aGlzLmhlaWdodHMubGVuZ3RoLCB0aGlzLm1pblZhbHVlKTtcbiAgICB2ZWMyLnNldChwb2ludHNbM10sIDAsIHRoaXMubWluVmFsdWUpO1xuICAgIG91dC5zZXRGcm9tUG9pbnRzKHBvaW50cywgcG9zaXRpb24sIGFuZ2xlKTtcbn07XG5cbi8qKlxuICogR2V0IGEgbGluZSBzZWdtZW50IGluIHRoZSBoZWlnaHRmaWVsZFxuICogQG1ldGhvZCBnZXRMaW5lU2VnbWVudFxuICogQHBhcmFtICB7YXJyYXl9IHN0YXJ0IFdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRpbmcgc3RhcnQgcG9pbnRcbiAqIEBwYXJhbSAge2FycmF5fSBlbmQgV2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBlbmQgcG9pbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0TGluZVNlZ21lbnQgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBpKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuaGVpZ2h0cztcbiAgICB2YXIgd2lkdGggPSB0aGlzLmVsZW1lbnRXaWR0aDtcbiAgICB2ZWMyLnNldChzdGFydCwgaSAqIHdpZHRoLCBkYXRhW2ldKTtcbiAgICB2ZWMyLnNldChlbmQsIChpICsgMSkgKiB3aWR0aCwgZGF0YVtpICsgMV0pO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldFNlZ21lbnRJbmRleCA9IGZ1bmN0aW9uKHBvc2l0aW9uKXtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihwb3NpdGlvblswXSAvIHRoaXMuZWxlbWVudFdpZHRoKTtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRDbGFtcGVkU2VnbWVudEluZGV4ID0gZnVuY3Rpb24ocG9zaXRpb24pe1xuICAgIHZhciBpID0gdGhpcy5nZXRTZWdtZW50SW5kZXgocG9zaXRpb24pO1xuICAgIGkgPSBNYXRoLm1pbih0aGlzLmhlaWdodHMubGVuZ3RoLCBNYXRoLm1heChpLCAwKSk7IC8vIGNsYW1wXG4gICAgcmV0dXJuIGk7XG59O1xuXG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfaGl0UG9pbnRXb3JsZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfd29ybGROb3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdEhlaWdodGZpZWxkX2wwID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sMSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxGcm9tID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sb2NhbFRvID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF91bml0X3kgPSB2ZWMyLmZyb21WYWx1ZXMoMCwxKTtcblxuLy8gUmV0dXJucyAxIGlmIHRoZSBsaW5lcyBpbnRlcnNlY3QsIG90aGVyd2lzZSAwLlxuZnVuY3Rpb24gZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uIChvdXQsIHAwLCBwMSwgcDIsIHAzKSB7XG5cbiAgICB2YXIgczFfeCwgczFfeSwgczJfeCwgczJfeTtcbiAgICBzMV94ID0gcDFbMF0gLSBwMFswXTtcbiAgICBzMV95ID0gcDFbMV0gLSBwMFsxXTtcbiAgICBzMl94ID0gcDNbMF0gLSBwMlswXTtcbiAgICBzMl95ID0gcDNbMV0gLSBwMlsxXTtcblxuICAgIHZhciBzLCB0O1xuICAgIHMgPSAoLXMxX3kgKiAocDBbMF0gLSBwMlswXSkgKyBzMV94ICogKHAwWzFdIC0gcDJbMV0pKSAvICgtczJfeCAqIHMxX3kgKyBzMV94ICogczJfeSk7XG4gICAgdCA9ICggczJfeCAqIChwMFsxXSAtIHAyWzFdKSAtIHMyX3kgKiAocDBbMF0gLSBwMlswXSkpIC8gKC1zMl94ICogczFfeSArIHMxX3ggKiBzMl95KTtcbiAgICBpZiAocyA+PSAwICYmIHMgPD0gMSAmJiB0ID49IDAgJiYgdCA8PSAxKSB7IC8vIENvbGxpc2lvbiBkZXRlY3RlZFxuICAgICAgICB2YXIgaW50WCA9IHAwWzBdICsgKHQgKiBzMV94KTtcbiAgICAgICAgdmFyIGludFkgPSBwMFsxXSArICh0ICogczFfeSk7XG4gICAgICAgIG91dFswXSA9IGludFg7XG4gICAgICAgIG91dFsxXSA9IGludFk7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICByZXR1cm4gLTE7IC8vIE5vIGNvbGxpc2lvblxufVxuXG4vKipcbiAqIEBtZXRob2QgcmF5Y2FzdFxuICogQHBhcmFtICB7UmF5UmVzdWx0fSByZXN1bHRcbiAqIEBwYXJhbSAge1JheX0gcmF5XG4gKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGVcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbihyZXN1bHQsIHJheSwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICB2YXIgZnJvbSA9IHJheS5mcm9tO1xuICAgIHZhciB0byA9IHJheS50bztcbiAgICB2YXIgZGlyZWN0aW9uID0gcmF5LmRpcmVjdGlvbjtcblxuICAgIHZhciBoaXRQb2ludFdvcmxkID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfaGl0UG9pbnRXb3JsZDtcbiAgICB2YXIgd29ybGROb3JtYWwgPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF93b3JsZE5vcm1hbDtcbiAgICB2YXIgbDAgPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sMDtcbiAgICB2YXIgbDEgPSBpbnRlcnNlY3RIZWlnaHRmaWVsZF9sMTtcbiAgICB2YXIgbG9jYWxGcm9tID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxGcm9tO1xuICAgIHZhciBsb2NhbFRvID0gaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxUbztcblxuICAgIC8vIGdldCBsb2NhbCByYXkgc3RhcnQgYW5kIGVuZFxuICAgIHZlYzIudG9Mb2NhbEZyYW1lKGxvY2FsRnJvbSwgZnJvbSwgcG9zaXRpb24sIGFuZ2xlKTtcbiAgICB2ZWMyLnRvTG9jYWxGcmFtZShsb2NhbFRvLCB0bywgcG9zaXRpb24sIGFuZ2xlKTtcblxuICAgIC8vIEdldCB0aGUgc2VnbWVudCByYW5nZVxuICAgIHZhciBpMCA9IHRoaXMuZ2V0Q2xhbXBlZFNlZ21lbnRJbmRleChsb2NhbEZyb20pO1xuICAgIHZhciBpMSA9IHRoaXMuZ2V0Q2xhbXBlZFNlZ21lbnRJbmRleChsb2NhbFRvKTtcbiAgICBpZihpMCA+IGkxKXtcbiAgICAgICAgdmFyIHRtcCA9IGkwO1xuICAgICAgICBpMCA9IGkxO1xuICAgICAgICBpMSA9IHRtcDtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2VnbWVudHNcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmhlaWdodHMubGVuZ3RoIC0gMTsgaSsrKXtcbiAgICAgICAgdGhpcy5nZXRMaW5lU2VnbWVudChsMCwgbDEsIGkpO1xuICAgICAgICB2YXIgdCA9IHZlYzIuZ2V0TGluZVNlZ21lbnRzSW50ZXJzZWN0aW9uRnJhY3Rpb24obG9jYWxGcm9tLCBsb2NhbFRvLCBsMCwgbDEpO1xuICAgICAgICBpZih0ID49IDApe1xuICAgICAgICAgICAgdmVjMi5zdWIod29ybGROb3JtYWwsIGwxLCBsMCk7XG4gICAgICAgICAgICB2ZWMyLnJvdGF0ZSh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwsIGFuZ2xlICsgTWF0aC5QSSAvIDIpO1xuICAgICAgICAgICAgdmVjMi5ub3JtYWxpemUod29ybGROb3JtYWwsIHdvcmxkTm9ybWFsKTtcbiAgICAgICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCB0LCB3b3JsZE5vcm1hbCwgLTEpO1xuICAgICAgICAgICAgaWYocmVzdWx0LnNob3VsZFN0b3AocmF5KSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/shapes/Heightfield.js\n");

/***/ }),

/***/ "./node_modules/p2/src/shapes/Line.js":
/*!********************************************!*\
  !*** ./node_modules/p2/src/shapes/Line.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Shape = __webpack_require__(/*! ./Shape */ \"./node_modules/p2/src/shapes/Shape.js\")\n,   vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\n\nmodule.exports = Line;\n\n/**\n * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].\n * @class Line\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @param {Number} [options.length=1] The total length of the line\n * @extends Shape\n * @constructor\n */\nfunction Line(options){\n    if(typeof(arguments[0]) === 'number'){\n        options = {\n            length: arguments[0]\n        };\n        console.warn('The Line constructor signature has changed. Please use the following format: new Line({ length: 1, ... })');\n    }\n    options = options || {};\n\n    /**\n     * Length of this line\n     * @property {Number} length\n     * @default 1\n     */\n    this.length = options.length || 1;\n\n    options.type = Shape.LINE;\n    Shape.call(this, options);\n}\nLine.prototype = new Shape();\nLine.prototype.constructor = Line;\n\nLine.prototype.computeMomentOfInertia = function(mass){\n    return mass * Math.pow(this.length,2) / 12;\n};\n\nLine.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = this.length/2;\n};\n\nvar points = [vec2.create(),vec2.create()];\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nLine.prototype.computeAABB = function(out, position, angle){\n    var l2 = this.length / 2;\n    vec2.set(points[0], -l2,  0);\n    vec2.set(points[1],  l2,  0);\n    out.setFromPoints(points,position,angle,0);\n};\n\nvar raycast_hitPoint = vec2.create();\nvar raycast_normal = vec2.create();\nvar raycast_l0 = vec2.create();\nvar raycast_l1 = vec2.create();\nvar raycast_unit_y = vec2.fromValues(0,1);\n\n/**\n * @method raycast\n * @param  {RaycastResult} result\n * @param  {Ray} ray\n * @param  {number} angle\n * @param  {array} position\n */\nLine.prototype.raycast = function(result, ray, position, angle){\n    var from = ray.from;\n    var to = ray.to;\n\n    var l0 = raycast_l0;\n    var l1 = raycast_l1;\n\n    // get start and end of the line\n    var halfLen = this.length / 2;\n    vec2.set(l0, -halfLen, 0);\n    vec2.set(l1, halfLen, 0);\n    vec2.toGlobalFrame(l0, l0, position, angle);\n    vec2.toGlobalFrame(l1, l1, position, angle);\n\n    var fraction = vec2.getLineSegmentsIntersectionFraction(l0, l1, from, to);\n    if(fraction >= 0){\n        var normal = raycast_normal;\n        vec2.rotate(normal, raycast_unit_y, angle); // todo: this should depend on which side the ray comes from\n        ray.reportIntersection(result, fraction, normal, -1);\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9MaW5lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy9zaGFwZXMvTGluZS5qcz8yZDI5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBTaGFwZSA9IHJlcXVpcmUoJy4vU2hhcGUnKVxuLCAgIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG4vKipcbiAqIExpbmUgc2hhcGUgY2xhc3MuIFRoZSBsaW5lIHNoYXBlIGlzIGFsb25nIHRoZSB4IGRpcmVjdGlvbiwgYW5kIHN0cmV0Y2hlcyBmcm9tIFstbGVuZ3RoLzIsIDBdIHRvIFtsZW5ndGgvMiwwXS5cbiAqIEBjbGFzcyBMaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIChOb3RlIHRoYXQgdGhpcyBvcHRpb25zIG9iamVjdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0gY29uc3RydWN0b3IuKVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0xXSBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBsaW5lXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExpbmUob3B0aW9ucyl7XG4gICAgaWYodHlwZW9mKGFyZ3VtZW50c1swXSkgPT09ICdudW1iZXInKXtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGxlbmd0aDogYXJndW1lbnRzWzBdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUud2FybignVGhlIExpbmUgY29uc3RydWN0b3Igc2lnbmF0dXJlIGhhcyBjaGFuZ2VkLiBQbGVhc2UgdXNlIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBuZXcgTGluZSh7IGxlbmd0aDogMSwgLi4uIH0pJyk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogTGVuZ3RoIG9mIHRoaXMgbGluZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsZW5ndGhcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5sZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8fCAxO1xuXG4gICAgb3B0aW9ucy50eXBlID0gU2hhcGUuTElORTtcbiAgICBTaGFwZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuTGluZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkxpbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZTtcblxuTGluZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiBtYXNzICogTWF0aC5wb3codGhpcy5sZW5ndGgsMikgLyAxMjtcbn07XG5cbkxpbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gdGhpcy5sZW5ndGgvMjtcbn07XG5cbnZhciBwb2ludHMgPSBbdmVjMi5jcmVhdGUoKSx2ZWMyLmNyZWF0ZSgpXTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dCAgICAgIFRoZSByZXN1bHRpbmcgQUFCQi5cbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuTGluZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmFyIGwyID0gdGhpcy5sZW5ndGggLyAyO1xuICAgIHZlYzIuc2V0KHBvaW50c1swXSwgLWwyLCAgMCk7XG4gICAgdmVjMi5zZXQocG9pbnRzWzFdLCAgbDIsICAwKTtcbiAgICBvdXQuc2V0RnJvbVBvaW50cyhwb2ludHMscG9zaXRpb24sYW5nbGUsMCk7XG59O1xuXG52YXIgcmF5Y2FzdF9oaXRQb2ludCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgcmF5Y2FzdF9ub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJheWNhc3RfbDAgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJheWNhc3RfbDEgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIHJheWNhc3RfdW5pdF95ID0gdmVjMi5mcm9tVmFsdWVzKDAsMSk7XG5cbi8qKlxuICogQG1ldGhvZCByYXljYXN0XG4gKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAqIEBwYXJhbSAge1JheX0gcmF5XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXG4gKiBAcGFyYW0gIHthcnJheX0gcG9zaXRpb25cbiAqL1xuTGluZS5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBmcm9tID0gcmF5LmZyb207XG4gICAgdmFyIHRvID0gcmF5LnRvO1xuXG4gICAgdmFyIGwwID0gcmF5Y2FzdF9sMDtcbiAgICB2YXIgbDEgPSByYXljYXN0X2wxO1xuXG4gICAgLy8gZ2V0IHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGxpbmVcbiAgICB2YXIgaGFsZkxlbiA9IHRoaXMubGVuZ3RoIC8gMjtcbiAgICB2ZWMyLnNldChsMCwgLWhhbGZMZW4sIDApO1xuICAgIHZlYzIuc2V0KGwxLCBoYWxmTGVuLCAwKTtcbiAgICB2ZWMyLnRvR2xvYmFsRnJhbWUobDAsIGwwLCBwb3NpdGlvbiwgYW5nbGUpO1xuICAgIHZlYzIudG9HbG9iYWxGcmFtZShsMSwgbDEsIHBvc2l0aW9uLCBhbmdsZSk7XG5cbiAgICB2YXIgZnJhY3Rpb24gPSB2ZWMyLmdldExpbmVTZWdtZW50c0ludGVyc2VjdGlvbkZyYWN0aW9uKGwwLCBsMSwgZnJvbSwgdG8pO1xuICAgIGlmKGZyYWN0aW9uID49IDApe1xuICAgICAgICB2YXIgbm9ybWFsID0gcmF5Y2FzdF9ub3JtYWw7XG4gICAgICAgIHZlYzIucm90YXRlKG5vcm1hbCwgcmF5Y2FzdF91bml0X3ksIGFuZ2xlKTsgLy8gdG9kbzogdGhpcyBzaG91bGQgZGVwZW5kIG9uIHdoaWNoIHNpZGUgdGhlIHJheSBjb21lcyBmcm9tXG4gICAgICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCBmcmFjdGlvbiwgbm9ybWFsLCAtMSk7XG4gICAgfVxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/shapes/Line.js\n");

/***/ }),

/***/ "./node_modules/p2/src/shapes/Particle.js":
/*!************************************************!*\
  !*** ./node_modules/p2/src/shapes/Particle.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Shape = __webpack_require__(/*! ./Shape */ \"./node_modules/p2/src/shapes/Shape.js\")\n,   vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\n\nmodule.exports = Particle;\n\n/**\n * Particle shape class.\n * @class Particle\n * @constructor\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n * @extends Shape\n */\nfunction Particle(options){\n    options = options || {};\n\toptions.type = Shape.PARTICLE;\n    Shape.call(this, options);\n}\nParticle.prototype = new Shape();\nParticle.prototype.constructor = Particle;\n\nParticle.prototype.computeMomentOfInertia = function(mass){\n    return 0; // Can't rotate a particle\n};\n\nParticle.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = 0;\n};\n\n/**\n * @method computeAABB\n * @param  {AABB}   out\n * @param  {Array}  position\n * @param  {Number} angle\n */\nParticle.prototype.computeAABB = function(out, position, angle){\n    vec2.copy(out.lowerBound, position);\n    vec2.copy(out.upperBound, position);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9QYXJ0aWNsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvc2hhcGVzL1BhcnRpY2xlLmpzPzdiZmMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpXG4sICAgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlO1xuXG4vKipcbiAqIFBhcnRpY2xlIHNoYXBlIGNsYXNzLlxuICogQGNsYXNzIFBhcnRpY2xlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICovXG5mdW5jdGlvbiBQYXJ0aWNsZShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy50eXBlID0gU2hhcGUuUEFSVElDTEU7XG4gICAgU2hhcGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblBhcnRpY2xlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuUGFydGljbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFydGljbGU7XG5cblBhcnRpY2xlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7XG4gICAgcmV0dXJuIDA7IC8vIENhbid0IHJvdGF0ZSBhIHBhcnRpY2xlXG59O1xuXG5QYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSAwO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSAgIG91dFxuICogQHBhcmFtICB7QXJyYXl9ICBwb3NpdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbihvdXQsIHBvc2l0aW9uLCBhbmdsZSl7XG4gICAgdmVjMi5jb3B5KG91dC5sb3dlckJvdW5kLCBwb3NpdGlvbik7XG4gICAgdmVjMi5jb3B5KG91dC51cHBlckJvdW5kLCBwb3NpdGlvbik7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/shapes/Particle.js\n");

/***/ }),

/***/ "./node_modules/p2/src/shapes/Plane.js":
/*!*********************************************!*\
  !*** ./node_modules/p2/src/shapes/Plane.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Shape =  __webpack_require__(/*! ./Shape */ \"./node_modules/p2/src/shapes/Shape.js\")\n,    vec2 =  __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,    Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\");\n\nmodule.exports = Plane;\n\n/**\n * Plane shape class. The plane is facing in the Y direction.\n * @class Plane\n * @extends Shape\n * @constructor\n * @param {object} [options] (Note that this options object will be passed on to the {{#crossLink \"Shape\"}}{{/crossLink}} constructor.)\n */\nfunction Plane(options){\n    options = options || {};\n    options.type = Shape.PLANE;\n    Shape.call(this, options);\n}\nPlane.prototype = new Shape();\nPlane.prototype.constructor = Plane;\n\n/**\n * Compute moment of inertia\n * @method computeMomentOfInertia\n */\nPlane.prototype.computeMomentOfInertia = function(mass){\n    return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here\n};\n\n/**\n * Update the bounding radius\n * @method updateBoundingRadius\n */\nPlane.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = Number.MAX_VALUE;\n};\n\n/**\n * @method computeAABB\n * @param  {AABB}   out\n * @param  {Array}  position\n * @param  {Number} angle\n */\nPlane.prototype.computeAABB = function(out, position, angle){\n    var a = angle % (2 * Math.PI);\n    var set = vec2.set;\n    var max = 1e7;\n    var lowerBound = out.lowerBound;\n    var upperBound = out.upperBound;\n\n    // Set max bounds\n    set(lowerBound, -max, -max);\n    set(upperBound,  max,  max);\n\n    if(a === 0){\n        // y goes from -inf to 0\n        upperBound[1] = 0;\n        // set(lowerBound, -max, -max);\n        // set(upperBound,  max,  0);\n\n    } else if(a === Math.PI / 2){\n\n        // x goes from 0 to inf\n        lowerBound[0] = 0;\n        // set(lowerBound, 0, -max);\n        // set(upperBound,      max,  max);\n\n    } else if(a === Math.PI){\n\n        // y goes from 0 to inf\n        lowerBound[1] = 0;\n        // set(lowerBound, -max, 0);\n        // set(upperBound,  max, max);\n\n    } else if(a === 3*Math.PI/2){\n\n        // x goes from -inf to 0\n        upperBound[0] = 0;\n        // set(lowerBound, -max,     -max);\n        // set(upperBound,  0,  max);\n\n    }\n};\n\nPlane.prototype.updateArea = function(){\n    this.area = Number.MAX_VALUE;\n};\n\nvar intersectPlane_planePointToFrom = vec2.create();\nvar intersectPlane_dir_scaled_with_t = vec2.create();\nvar intersectPlane_hitPoint = vec2.create();\nvar intersectPlane_normal = vec2.create();\nvar intersectPlane_len = vec2.create();\n\n/**\n * @method raycast\n * @param  {RayResult} result\n * @param  {Ray} ray\n * @param  {array} position\n * @param  {number} angle\n */\nPlane.prototype.raycast = function(result, ray, position, angle){\n    var from = ray.from;\n    var to = ray.to;\n    var direction = ray.direction;\n    var planePointToFrom = intersectPlane_planePointToFrom;\n    var dir_scaled_with_t = intersectPlane_dir_scaled_with_t;\n    var hitPoint = intersectPlane_hitPoint;\n    var normal = intersectPlane_normal;\n    var len = intersectPlane_len;\n\n    // Get plane normal\n    vec2.set(normal, 0, 1);\n    vec2.rotate(normal, normal, angle);\n\n    vec2.sub(len, from, position);\n    var planeToFrom = vec2.dot(len, normal);\n    vec2.sub(len, to, position);\n    var planeToTo = vec2.dot(len, normal);\n\n    if(planeToFrom * planeToTo > 0){\n        // \"from\" and \"to\" are on the same side of the plane... bail out\n        return;\n    }\n\n    if(vec2.squaredDistance(from, to) < planeToFrom * planeToFrom){\n        return;\n    }\n\n    var n_dot_dir = vec2.dot(normal, direction);\n\n    vec2.sub(planePointToFrom, from, position);\n    var t = -vec2.dot(normal, planePointToFrom) / n_dot_dir / ray.length;\n\n    ray.reportIntersection(result, t, normal, -1);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9QbGFuZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvc2hhcGVzL1BsYW5lLmpzP2E1OGIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFNoYXBlID0gIHJlcXVpcmUoJy4vU2hhcGUnKVxuLCAgICB2ZWMyID0gIHJlcXVpcmUoJy4uL21hdGgvdmVjMicpXG4sICAgIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbGFuZTtcblxuLyoqXG4gKiBQbGFuZSBzaGFwZSBjbGFzcy4gVGhlIHBsYW5lIGlzIGZhY2luZyBpbiB0aGUgWSBkaXJlY3Rpb24uXG4gKiBAY2xhc3MgUGxhbmVcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gKE5vdGUgdGhhdCB0aGlzIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBjb25zdHJ1Y3Rvci4pXG4gKi9cbmZ1bmN0aW9uIFBsYW5lKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudHlwZSA9IFNoYXBlLlBMQU5FO1xuICAgIFNoYXBlLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5QbGFuZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblBsYW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lO1xuXG4vKipcbiAqIENvbXB1dGUgbW9tZW50IG9mIGluZXJ0aWFcbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICovXG5QbGFuZS5wcm90b3R5cGUuY29tcHV0ZU1vbWVudE9mSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3Mpe1xuICAgIHJldHVybiAwOyAvLyBQbGFuZSBpcyBpbmZpbml0ZS4gVGhlIGluZXJ0aWEgc2hvdWxkIHRoZXJlZm9yZSBiZSBpbmZpbnR5IGJ1dCBieSBjb252ZW50aW9uIHdlIHNldCAwIGhlcmVcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXNcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuUGxhbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHBhcmFtICB7QUFCQn0gICBvdXRcbiAqIEBwYXJhbSAge0FycmF5fSAgcG9zaXRpb25cbiAqIEBwYXJhbSAge051bWJlcn0gYW5nbGVcbiAqL1xuUGxhbmUucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24ob3V0LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBhID0gYW5nbGUgJSAoMiAqIE1hdGguUEkpO1xuICAgIHZhciBzZXQgPSB2ZWMyLnNldDtcbiAgICB2YXIgbWF4ID0gMWU3O1xuICAgIHZhciBsb3dlckJvdW5kID0gb3V0Lmxvd2VyQm91bmQ7XG4gICAgdmFyIHVwcGVyQm91bmQgPSBvdXQudXBwZXJCb3VuZDtcblxuICAgIC8vIFNldCBtYXggYm91bmRzXG4gICAgc2V0KGxvd2VyQm91bmQsIC1tYXgsIC1tYXgpO1xuICAgIHNldCh1cHBlckJvdW5kLCAgbWF4LCAgbWF4KTtcblxuICAgIGlmKGEgPT09IDApe1xuICAgICAgICAvLyB5IGdvZXMgZnJvbSAtaW5mIHRvIDBcbiAgICAgICAgdXBwZXJCb3VuZFsxXSA9IDA7XG4gICAgICAgIC8vIHNldChsb3dlckJvdW5kLCAtbWF4LCAtbWF4KTtcbiAgICAgICAgLy8gc2V0KHVwcGVyQm91bmQsICBtYXgsICAwKTtcblxuICAgIH0gZWxzZSBpZihhID09PSBNYXRoLlBJIC8gMil7XG5cbiAgICAgICAgLy8geCBnb2VzIGZyb20gMCB0byBpbmZcbiAgICAgICAgbG93ZXJCb3VuZFswXSA9IDA7XG4gICAgICAgIC8vIHNldChsb3dlckJvdW5kLCAwLCAtbWF4KTtcbiAgICAgICAgLy8gc2V0KHVwcGVyQm91bmQsICAgICAgbWF4LCAgbWF4KTtcblxuICAgIH0gZWxzZSBpZihhID09PSBNYXRoLlBJKXtcblxuICAgICAgICAvLyB5IGdvZXMgZnJvbSAwIHRvIGluZlxuICAgICAgICBsb3dlckJvdW5kWzFdID0gMDtcbiAgICAgICAgLy8gc2V0KGxvd2VyQm91bmQsIC1tYXgsIDApO1xuICAgICAgICAvLyBzZXQodXBwZXJCb3VuZCwgIG1heCwgbWF4KTtcblxuICAgIH0gZWxzZSBpZihhID09PSAzKk1hdGguUEkvMil7XG5cbiAgICAgICAgLy8geCBnb2VzIGZyb20gLWluZiB0byAwXG4gICAgICAgIHVwcGVyQm91bmRbMF0gPSAwO1xuICAgICAgICAvLyBzZXQobG93ZXJCb3VuZCwgLW1heCwgICAgIC1tYXgpO1xuICAgICAgICAvLyBzZXQodXBwZXJCb3VuZCwgIDAsICBtYXgpO1xuXG4gICAgfVxufTtcblxuUGxhbmUucHJvdG90eXBlLnVwZGF0ZUFyZWEgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYXJlYSA9IE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG52YXIgaW50ZXJzZWN0UGxhbmVfcGxhbmVQb2ludFRvRnJvbSA9IHZlYzIuY3JlYXRlKCk7XG52YXIgaW50ZXJzZWN0UGxhbmVfZGlyX3NjYWxlZF93aXRoX3QgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBsYW5lX2hpdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcbnZhciBpbnRlcnNlY3RQbGFuZV9ub3JtYWwgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGludGVyc2VjdFBsYW5lX2xlbiA9IHZlYzIuY3JlYXRlKCk7XG5cbi8qKlxuICogQG1ldGhvZCByYXljYXN0XG4gKiBAcGFyYW0gIHtSYXlSZXN1bHR9IHJlc3VsdFxuICogQHBhcmFtICB7UmF5fSByYXlcbiAqIEBwYXJhbSAge2FycmF5fSBwb3NpdGlvblxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZVxuICovXG5QbGFuZS5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5LCBwb3NpdGlvbiwgYW5nbGUpe1xuICAgIHZhciBmcm9tID0gcmF5LmZyb207XG4gICAgdmFyIHRvID0gcmF5LnRvO1xuICAgIHZhciBkaXJlY3Rpb24gPSByYXkuZGlyZWN0aW9uO1xuICAgIHZhciBwbGFuZVBvaW50VG9Gcm9tID0gaW50ZXJzZWN0UGxhbmVfcGxhbmVQb2ludFRvRnJvbTtcbiAgICB2YXIgZGlyX3NjYWxlZF93aXRoX3QgPSBpbnRlcnNlY3RQbGFuZV9kaXJfc2NhbGVkX3dpdGhfdDtcbiAgICB2YXIgaGl0UG9pbnQgPSBpbnRlcnNlY3RQbGFuZV9oaXRQb2ludDtcbiAgICB2YXIgbm9ybWFsID0gaW50ZXJzZWN0UGxhbmVfbm9ybWFsO1xuICAgIHZhciBsZW4gPSBpbnRlcnNlY3RQbGFuZV9sZW47XG5cbiAgICAvLyBHZXQgcGxhbmUgbm9ybWFsXG4gICAgdmVjMi5zZXQobm9ybWFsLCAwLCAxKTtcbiAgICB2ZWMyLnJvdGF0ZShub3JtYWwsIG5vcm1hbCwgYW5nbGUpO1xuXG4gICAgdmVjMi5zdWIobGVuLCBmcm9tLCBwb3NpdGlvbik7XG4gICAgdmFyIHBsYW5lVG9Gcm9tID0gdmVjMi5kb3QobGVuLCBub3JtYWwpO1xuICAgIHZlYzIuc3ViKGxlbiwgdG8sIHBvc2l0aW9uKTtcbiAgICB2YXIgcGxhbmVUb1RvID0gdmVjMi5kb3QobGVuLCBub3JtYWwpO1xuXG4gICAgaWYocGxhbmVUb0Zyb20gKiBwbGFuZVRvVG8gPiAwKXtcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBhcmUgb24gdGhlIHNhbWUgc2lkZSBvZiB0aGUgcGxhbmUuLi4gYmFpbCBvdXRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKHZlYzIuc3F1YXJlZERpc3RhbmNlKGZyb20sIHRvKSA8IHBsYW5lVG9Gcm9tICogcGxhbmVUb0Zyb20pe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5fZG90X2RpciA9IHZlYzIuZG90KG5vcm1hbCwgZGlyZWN0aW9uKTtcblxuICAgIHZlYzIuc3ViKHBsYW5lUG9pbnRUb0Zyb20sIGZyb20sIHBvc2l0aW9uKTtcbiAgICB2YXIgdCA9IC12ZWMyLmRvdChub3JtYWwsIHBsYW5lUG9pbnRUb0Zyb20pIC8gbl9kb3RfZGlyIC8gcmF5Lmxlbmd0aDtcblxuICAgIHJheS5yZXBvcnRJbnRlcnNlY3Rpb24ocmVzdWx0LCB0LCBub3JtYWwsIC0xKTtcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/shapes/Plane.js\n");

/***/ }),

/***/ "./node_modules/p2/src/shapes/Shape.js":
/*!*********************************************!*\
  !*** ./node_modules/p2/src/shapes/Shape.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = Shape;\n\nvar vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\");\n\n/**\n * Base class for shapes.\n * @class Shape\n * @constructor\n * @param {object} [options]\n * @param {array} [options.position]\n * @param {number} [options.angle=0]\n * @param {number} [options.collisionGroup=1]\n * @param {number} [options.collisionMask=1]\n * @param {boolean} [options.sensor=false]\n * @param {boolean} [options.collisionResponse=true]\n * @param {object} [options.type=0]\n */\nfunction Shape(options){\n    options = options || {};\n\n    /**\n     * The body this shape is attached to. A shape can only be attached to a single body.\n     * @property {Body} body\n     */\n    this.body = null;\n\n    /**\n     * Body-local position of the shape.\n     * @property {Array} position\n     */\n    this.position = vec2.fromValues(0,0);\n    if(options.position){\n        vec2.copy(this.position, options.position);\n    }\n\n    /**\n     * Body-local angle of the shape.\n     * @property {number} angle\n     */\n    this.angle = options.angle || 0;\n\n    /**\n     * The type of the shape. One of:\n     *\n     * * {{#crossLink \"Shape/CIRCLE:property\"}}Shape.CIRCLE{{/crossLink}}\n     * * {{#crossLink \"Shape/PARTICLE:property\"}}Shape.PARTICLE{{/crossLink}}\n     * * {{#crossLink \"Shape/PLANE:property\"}}Shape.PLANE{{/crossLink}}\n     * * {{#crossLink \"Shape/CONVEX:property\"}}Shape.CONVEX{{/crossLink}}\n     * * {{#crossLink \"Shape/LINE:property\"}}Shape.LINE{{/crossLink}}\n     * * {{#crossLink \"Shape/BOX:property\"}}Shape.BOX{{/crossLink}}\n     * * {{#crossLink \"Shape/CAPSULE:property\"}}Shape.CAPSULE{{/crossLink}}\n     * * {{#crossLink \"Shape/HEIGHTFIELD:property\"}}Shape.HEIGHTFIELD{{/crossLink}}\n     *\n     * @property {number} type\n     */\n    this.type = options.type || 0;\n\n    /**\n     * Shape object identifier.\n     * @type {Number}\n     * @property id\n     */\n    this.id = Shape.idCounter++;\n\n    /**\n     * Bounding circle radius of this shape\n     * @property boundingRadius\n     * @type {Number}\n     */\n    this.boundingRadius = 0;\n\n    /**\n     * Collision group that this shape belongs to (bit mask). See <a href=\"http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/\">this tutorial</a>.\n     * @property collisionGroup\n     * @type {Number}\n     * @example\n     *     // Setup bits for each available group\n     *     var PLAYER = Math.pow(2,0),\n     *         ENEMY =  Math.pow(2,1),\n     *         GROUND = Math.pow(2,2)\n     *\n     *     // Put shapes into their groups\n     *     player1Shape.collisionGroup = PLAYER;\n     *     player2Shape.collisionGroup = PLAYER;\n     *     enemyShape  .collisionGroup = ENEMY;\n     *     groundShape .collisionGroup = GROUND;\n     *\n     *     // Assign groups that each shape collide with.\n     *     // Note that the players can collide with ground and enemies, but not with other players.\n     *     player1Shape.collisionMask = ENEMY | GROUND;\n     *     player2Shape.collisionMask = ENEMY | GROUND;\n     *     enemyShape  .collisionMask = PLAYER | GROUND;\n     *     groundShape .collisionMask = PLAYER | ENEMY;\n     *\n     * @example\n     *     // How collision check is done\n     *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){\n     *         // The shapes will collide\n     *     }\n     */\n    this.collisionGroup = options.collisionGroup !== undefined ? options.collisionGroup : 1;\n\n    /**\n     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled. That means that this shape will move through other body shapes, but it will still trigger contact events, etc.\n     * @property {Boolean} collisionResponse\n     */\n    this.collisionResponse = options.collisionResponse !== undefined ? options.collisionResponse : true;\n\n    /**\n     * Collision mask of this shape. See .collisionGroup.\n     * @property collisionMask\n     * @type {Number}\n     */\n    this.collisionMask = options.collisionMask !== undefined ? options.collisionMask : 1;\n\n    /**\n     * Material to use in collisions for this Shape. If this is set to null, the world will use default material properties instead.\n     * @property material\n     * @type {Material}\n     */\n    this.material = options.material || null;\n\n    /**\n     * Area of this shape.\n     * @property area\n     * @type {Number}\n     */\n    this.area = 0;\n\n    /**\n     * Set to true if you want this shape to be a sensor. A sensor does not generate contacts, but it still reports contact events. This is good if you want to know if a shape is overlapping another shape, without them generating contacts.\n     * @property {Boolean} sensor\n     */\n    this.sensor = options.sensor !== undefined ? options.sensor : false;\n\n    if(this.type){\n        this.updateBoundingRadius();\n    }\n\n    this.updateArea();\n}\n\nShape.idCounter = 0;\n\n/**\n * @static\n * @property {Number} CIRCLE\n */\nShape.CIRCLE =      1;\n\n/**\n * @static\n * @property {Number} PARTICLE\n */\nShape.PARTICLE =    2;\n\n/**\n * @static\n * @property {Number} PLANE\n */\nShape.PLANE =       4;\n\n/**\n * @static\n * @property {Number} CONVEX\n */\nShape.CONVEX =      8;\n\n/**\n * @static\n * @property {Number} LINE\n */\nShape.LINE =        16;\n\n/**\n * @static\n * @property {Number} BOX\n */\nShape.BOX =   32;\n\nObject.defineProperty(Shape, 'RECTANGLE', {\n    get: function() {\n        console.warn('Shape.RECTANGLE is deprecated, use Shape.BOX instead.');\n        return Shape.BOX;\n    }\n});\n\n/**\n * @static\n * @property {Number} CAPSULE\n */\nShape.CAPSULE =     64;\n\n/**\n * @static\n * @property {Number} HEIGHTFIELD\n */\nShape.HEIGHTFIELD = 128;\n\n/**\n * Should return the moment of inertia around the Z axis of the body given the total mass. See <a href=\"http://en.wikipedia.org/wiki/List_of_moments_of_inertia\">Wikipedia's list of moments of inertia</a>.\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number} If the inertia is infinity or if the object simply isn't possible to rotate, return 0.\n */\nShape.prototype.computeMomentOfInertia = function(mass){};\n\n/**\n * Returns the bounding circle radius of this shape.\n * @method updateBoundingRadius\n * @return {Number}\n */\nShape.prototype.updateBoundingRadius = function(){};\n\n/**\n * Update the .area property of the shape.\n * @method updateArea\n */\nShape.prototype.updateArea = function(){\n    // To be implemented in all subclasses\n};\n\n/**\n * Compute the world axis-aligned bounding box (AABB) of this shape.\n * @method computeAABB\n * @param  {AABB} out The resulting AABB.\n * @param  {Array} position World position of the shape.\n * @param  {Number} angle World angle of the shape.\n */\nShape.prototype.computeAABB = function(out, position, angle){\n    // To be implemented in each subclass\n};\n\n/**\n * Perform raycasting on this shape.\n * @method raycast\n * @param  {RayResult} result Where to store the resulting data.\n * @param  {Ray} ray The Ray that you want to use for raycasting.\n * @param  {array} position World position of the shape (the .position property will be ignored).\n * @param  {number} angle World angle of the shape (the .angle property will be ignored).\n */\nShape.prototype.raycast = function(result, ray, position, angle){\n    // To be implemented in each subclass\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NoYXBlcy9TaGFwZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvc2hhcGVzL1NoYXBlLmpzPzUwMWYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBTaGFwZTtcblxudmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBzaGFwZXMuXG4gKiBAY2xhc3MgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMucG9zaXRpb25dXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYW5nbGU9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25Hcm91cD0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbk1hc2s9MV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2Vuc29yPWZhbHNlXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZT10cnVlXVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnR5cGU9MF1cbiAqL1xuZnVuY3Rpb24gU2hhcGUob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYm9keSB0aGlzIHNoYXBlIGlzIGF0dGFjaGVkIHRvLiBBIHNoYXBlIGNhbiBvbmx5IGJlIGF0dGFjaGVkIHRvIGEgc2luZ2xlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5XG4gICAgICovXG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEJvZHktbG9jYWwgcG9zaXRpb24gb2YgdGhlIHNoYXBlLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHBvc2l0aW9uXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IHZlYzIuZnJvbVZhbHVlcygwLDApO1xuICAgIGlmKG9wdGlvbnMucG9zaXRpb24pe1xuICAgICAgICB2ZWMyLmNvcHkodGhpcy5wb3NpdGlvbiwgb3B0aW9ucy5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQm9keS1sb2NhbCBhbmdsZSBvZiB0aGUgc2hhcGUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGUgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBzaGFwZS4gT25lIG9mOlxuICAgICAqXG4gICAgICogKiB7eyNjcm9zc0xpbmsgXCJTaGFwZS9DSVJDTEU6cHJvcGVydHlcIn19U2hhcGUuQ0lSQ0xFe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL1BBUlRJQ0xFOnByb3BlcnR5XCJ9fVNoYXBlLlBBUlRJQ0xFe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL1BMQU5FOnByb3BlcnR5XCJ9fVNoYXBlLlBMQU5Fe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0NPTlZFWDpwcm9wZXJ0eVwifX1TaGFwZS5DT05WRVh7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvTElORTpwcm9wZXJ0eVwifX1TaGFwZS5MSU5Fe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0JPWDpwcm9wZXJ0eVwifX1TaGFwZS5CT1h7ey9jcm9zc0xpbmt9fVxuICAgICAqICoge3sjY3Jvc3NMaW5rIFwiU2hhcGUvQ0FQU1VMRTpwcm9wZXJ0eVwifX1TaGFwZS5DQVBTVUxFe3svY3Jvc3NMaW5rfX1cbiAgICAgKiAqIHt7I2Nyb3NzTGluayBcIlNoYXBlL0hFSUdIVEZJRUxEOnByb3BlcnR5XCJ9fVNoYXBlLkhFSUdIVEZJRUxEe3svY3Jvc3NMaW5rfX1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0eXBlXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlIHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBTaGFwZSBvYmplY3QgaWRlbnRpZmllci5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBTaGFwZS5pZENvdW50ZXIrKztcblxuICAgIC8qKlxuICAgICAqIEJvdW5kaW5nIGNpcmNsZSByYWRpdXMgb2YgdGhpcyBzaGFwZVxuICAgICAqIEBwcm9wZXJ0eSBib3VuZGluZ1JhZGl1c1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBDb2xsaXNpb24gZ3JvdXAgdGhhdCB0aGlzIHNoYXBlIGJlbG9uZ3MgdG8gKGJpdCBtYXNrKS4gU2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3LmF1cmVsaWVucmlib24uY29tL2Jsb2cvMjAxMS8wNy9ib3gyZC10dXRvcmlhbC1jb2xsaXNpb24tZmlsdGVyaW5nL1wiPnRoaXMgdHV0b3JpYWw8L2E+LlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25Hcm91cFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgLy8gU2V0dXAgYml0cyBmb3IgZWFjaCBhdmFpbGFibGUgZ3JvdXBcbiAgICAgKiAgICAgdmFyIFBMQVlFUiA9IE1hdGgucG93KDIsMCksXG4gICAgICogICAgICAgICBFTkVNWSA9ICBNYXRoLnBvdygyLDEpLFxuICAgICAqICAgICAgICAgR1JPVU5EID0gTWF0aC5wb3coMiwyKVxuICAgICAqXG4gICAgICogICAgIC8vIFB1dCBzaGFwZXMgaW50byB0aGVpciBncm91cHNcbiAgICAgKiAgICAgcGxheWVyMVNoYXBlLmNvbGxpc2lvbkdyb3VwID0gUExBWUVSO1xuICAgICAqICAgICBwbGF5ZXIyU2hhcGUuY29sbGlzaW9uR3JvdXAgPSBQTEFZRVI7XG4gICAgICogICAgIGVuZW15U2hhcGUgIC5jb2xsaXNpb25Hcm91cCA9IEVORU1ZO1xuICAgICAqICAgICBncm91bmRTaGFwZSAuY29sbGlzaW9uR3JvdXAgPSBHUk9VTkQ7XG4gICAgICpcbiAgICAgKiAgICAgLy8gQXNzaWduIGdyb3VwcyB0aGF0IGVhY2ggc2hhcGUgY29sbGlkZSB3aXRoLlxuICAgICAqICAgICAvLyBOb3RlIHRoYXQgdGhlIHBsYXllcnMgY2FuIGNvbGxpZGUgd2l0aCBncm91bmQgYW5kIGVuZW1pZXMsIGJ1dCBub3Qgd2l0aCBvdGhlciBwbGF5ZXJzLlxuICAgICAqICAgICBwbGF5ZXIxU2hhcGUuY29sbGlzaW9uTWFzayA9IEVORU1ZIHwgR1JPVU5EO1xuICAgICAqICAgICBwbGF5ZXIyU2hhcGUuY29sbGlzaW9uTWFzayA9IEVORU1ZIHwgR1JPVU5EO1xuICAgICAqICAgICBlbmVteVNoYXBlICAuY29sbGlzaW9uTWFzayA9IFBMQVlFUiB8IEdST1VORDtcbiAgICAgKiAgICAgZ3JvdW5kU2hhcGUgLmNvbGxpc2lvbk1hc2sgPSBQTEFZRVIgfCBFTkVNWTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIC8vIEhvdyBjb2xsaXNpb24gY2hlY2sgaXMgZG9uZVxuICAgICAqICAgICBpZihzaGFwZUEuY29sbGlzaW9uR3JvdXAgJiBzaGFwZUIuY29sbGlzaW9uTWFzaykhPTAgJiYgKHNoYXBlQi5jb2xsaXNpb25Hcm91cCAmIHNoYXBlQS5jb2xsaXNpb25NYXNrKSE9MCl7XG4gICAgICogICAgICAgICAvLyBUaGUgc2hhcGVzIHdpbGwgY29sbGlkZVxuICAgICAqICAgICB9XG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IG9wdGlvbnMuY29sbGlzaW9uR3JvdXAgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGlzaW9uR3JvdXAgOiAxO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBwcm9kdWNlIGNvbnRhY3QgZm9yY2VzIHdoZW4gaW4gY29udGFjdCB3aXRoIG90aGVyIGJvZGllcy4gTm90ZSB0aGF0IGNvbnRhY3RzIHdpbGwgYmUgZ2VuZXJhdGVkLCBidXQgdGhleSB3aWxsIGJlIGRpc2FibGVkLiBUaGF0IG1lYW5zIHRoYXQgdGhpcyBzaGFwZSB3aWxsIG1vdmUgdGhyb3VnaCBvdGhlciBib2R5IHNoYXBlcywgYnV0IGl0IHdpbGwgc3RpbGwgdHJpZ2dlciBjb250YWN0IGV2ZW50cywgZXRjLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29sbGlzaW9uUmVzcG9uc2VcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvblJlc3BvbnNlID0gb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsaXNpb25SZXNwb25zZSA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBDb2xsaXNpb24gbWFzayBvZiB0aGlzIHNoYXBlLiBTZWUgLmNvbGxpc2lvbkdyb3VwLlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaXNpb25NYXNrXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvbk1hc2sgPSBvcHRpb25zLmNvbGxpc2lvbk1hc2sgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGlzaW9uTWFzayA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBNYXRlcmlhbCB0byB1c2UgaW4gY29sbGlzaW9ucyBmb3IgdGhpcyBTaGFwZS4gSWYgdGhpcyBpcyBzZXQgdG8gbnVsbCwgdGhlIHdvcmxkIHdpbGwgdXNlIGRlZmF1bHQgbWF0ZXJpYWwgcHJvcGVydGllcyBpbnN0ZWFkLlxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbFxuICAgICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXJlYSBvZiB0aGlzIHNoYXBlLlxuICAgICAqIEBwcm9wZXJ0eSBhcmVhXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFyZWEgPSAwO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdGhpcyBzaGFwZSB0byBiZSBhIHNlbnNvci4gQSBzZW5zb3IgZG9lcyBub3QgZ2VuZXJhdGUgY29udGFjdHMsIGJ1dCBpdCBzdGlsbCByZXBvcnRzIGNvbnRhY3QgZXZlbnRzLiBUaGlzIGlzIGdvb2QgaWYgeW91IHdhbnQgdG8ga25vdyBpZiBhIHNoYXBlIGlzIG92ZXJsYXBwaW5nIGFub3RoZXIgc2hhcGUsIHdpdGhvdXQgdGhlbSBnZW5lcmF0aW5nIGNvbnRhY3RzLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2Vuc29yXG4gICAgICovXG4gICAgdGhpcy5zZW5zb3IgPSBvcHRpb25zLnNlbnNvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zZW5zb3IgOiBmYWxzZTtcblxuICAgIGlmKHRoaXMudHlwZSl7XG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdSYWRpdXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUFyZWEoKTtcbn1cblxuU2hhcGUuaWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQ0lSQ0xFXG4gKi9cblNoYXBlLkNJUkNMRSA9ICAgICAgMTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gUEFSVElDTEVcbiAqL1xuU2hhcGUuUEFSVElDTEUgPSAgICAyO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBQTEFORVxuICovXG5TaGFwZS5QTEFORSA9ICAgICAgIDQ7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IENPTlZFWFxuICovXG5TaGFwZS5DT05WRVggPSAgICAgIDg7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IExJTkVcbiAqL1xuU2hhcGUuTElORSA9ICAgICAgICAxNjtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gQk9YXG4gKi9cblNoYXBlLkJPWCA9ICAgMzI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaGFwZSwgJ1JFQ1RBTkdMRScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1NoYXBlLlJFQ1RBTkdMRSBpcyBkZXByZWNhdGVkLCB1c2UgU2hhcGUuQk9YIGluc3RlYWQuJyk7XG4gICAgICAgIHJldHVybiBTaGFwZS5CT1g7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IENBUFNVTEVcbiAqL1xuU2hhcGUuQ0FQU1VMRSA9ICAgICA2NDtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge051bWJlcn0gSEVJR0hURklFTERcbiAqL1xuU2hhcGUuSEVJR0hURklFTEQgPSAxMjg7XG5cbi8qKlxuICogU2hvdWxkIHJldHVybiB0aGUgbW9tZW50IG9mIGluZXJ0aWEgYXJvdW5kIHRoZSBaIGF4aXMgb2YgdGhlIGJvZHkgZ2l2ZW4gdGhlIHRvdGFsIG1hc3MuIFNlZSA8YSBocmVmPVwiaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVwiPldpa2lwZWRpYSdzIGxpc3Qgb2YgbW9tZW50cyBvZiBpbmVydGlhPC9hPi5cbiAqIEBtZXRob2QgY29tcHV0ZU1vbWVudE9mSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IElmIHRoZSBpbmVydGlhIGlzIGluZmluaXR5IG9yIGlmIHRoZSBvYmplY3Qgc2ltcGx5IGlzbid0IHBvc3NpYmxlIHRvIHJvdGF0ZSwgcmV0dXJuIDAuXG4gKi9cblNoYXBlLnByb3RvdHlwZS5jb21wdXRlTW9tZW50T2ZJbmVydGlhID0gZnVuY3Rpb24obWFzcyl7fTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBib3VuZGluZyBjaXJjbGUgcmFkaXVzIG9mIHRoaXMgc2hhcGUuXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nUmFkaXVzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblNoYXBlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7fTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIC5hcmVhIHByb3BlcnR5IG9mIHRoZSBzaGFwZS5cbiAqIEBtZXRob2QgdXBkYXRlQXJlYVxuICovXG5TaGFwZS5wcm90b3R5cGUudXBkYXRlQXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gVG8gYmUgaW1wbGVtZW50ZWQgaW4gYWxsIHN1YmNsYXNzZXNcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgd29ybGQgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCAoQUFCQikgb2YgdGhpcyBzaGFwZS5cbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9IG91dCBUaGUgcmVzdWx0aW5nIEFBQkIuXG4gKiBAcGFyYW0gIHtBcnJheX0gcG9zaXRpb24gV29ybGQgcG9zaXRpb24gb2YgdGhlIHNoYXBlLlxuICogQHBhcmFtICB7TnVtYmVyfSBhbmdsZSBXb3JsZCBhbmdsZSBvZiB0aGUgc2hhcGUuXG4gKi9cblNoYXBlLnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKG91dCwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICAvLyBUbyBiZSBpbXBsZW1lbnRlZCBpbiBlYWNoIHN1YmNsYXNzXG59O1xuXG4vKipcbiAqIFBlcmZvcm0gcmF5Y2FzdGluZyBvbiB0aGlzIHNoYXBlLlxuICogQG1ldGhvZCByYXljYXN0XG4gKiBAcGFyYW0gIHtSYXlSZXN1bHR9IHJlc3VsdCBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0aW5nIGRhdGEuXG4gKiBAcGFyYW0gIHtSYXl9IHJheSBUaGUgUmF5IHRoYXQgeW91IHdhbnQgdG8gdXNlIGZvciByYXljYXN0aW5nLlxuICogQHBhcmFtICB7YXJyYXl9IHBvc2l0aW9uIFdvcmxkIHBvc2l0aW9uIG9mIHRoZSBzaGFwZSAodGhlIC5wb3NpdGlvbiBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQpLlxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZSBXb3JsZCBhbmdsZSBvZiB0aGUgc2hhcGUgKHRoZSAuYW5nbGUgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkKS5cbiAqL1xuU2hhcGUucHJvdG90eXBlLnJheWNhc3QgPSBmdW5jdGlvbihyZXN1bHQsIHJheSwgcG9zaXRpb24sIGFuZ2xlKXtcbiAgICAvLyBUbyBiZSBpbXBsZW1lbnRlZCBpbiBlYWNoIHN1YmNsYXNzXG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/shapes/Shape.js\n");

/***/ }),

/***/ "./node_modules/p2/src/solver/GSSolver.js":
/*!************************************************!*\
  !*** ./node_modules/p2/src/solver/GSSolver.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,   Solver = __webpack_require__(/*! ./Solver */ \"./node_modules/p2/src/solver/Solver.js\")\n,   Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\")\n,   FrictionEquation = __webpack_require__(/*! ../equations/FrictionEquation */ \"./node_modules/p2/src/equations/FrictionEquation.js\");\n\nmodule.exports = GSSolver;\n\n/**\n * Iterative Gauss-Seidel constraint equation solver.\n *\n * @class GSSolver\n * @constructor\n * @extends Solver\n * @param {Object} [options]\n * @param {Number} [options.iterations=10]\n * @param {Number} [options.tolerance=0]\n */\nfunction GSSolver(options){\n    Solver.call(this,options,Solver.GS);\n    options = options || {};\n\n    /**\n     * The max number of iterations to do when solving. More gives better results, but is more expensive.\n     * @property iterations\n     * @type {Number}\n     */\n    this.iterations = options.iterations || 10;\n\n    /**\n     * The error tolerance, per constraint. If the total error is below this limit, the solver will stop iterating. Set to zero for as good solution as possible, but to something larger than zero to make computations faster.\n     * @property tolerance\n     * @type {Number}\n     * @default 1e-7\n     */\n    this.tolerance = options.tolerance || 1e-7;\n\n    this.arrayStep = 30;\n    this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);\n    this.Bs =     new Utils.ARRAY_TYPE(this.arrayStep);\n    this.invCs =  new Utils.ARRAY_TYPE(this.arrayStep);\n\n    /**\n     * Set to true to set all right hand side terms to zero when solving. Can be handy for a few applications.\n     * @property useZeroRHS\n     * @type {Boolean}\n     * @todo Remove, not used\n     */\n    this.useZeroRHS = false;\n\n    /**\n     * Number of solver iterations that are used to approximate normal forces used for friction (F_friction = mu * F_normal). These friction forces will override any other friction forces that are set. If you set frictionIterations = 0, then this feature will be disabled.\n     *\n     * Use only frictionIterations > 0 if the approximated normal force (F_normal = mass * gravity) is not good enough. Examples of where it can happen is in space games where gravity is zero, or in tall stacks where the normal force is large at bottom but small at top.\n     *\n     * @property frictionIterations\n     * @type {Number}\n     * @default 0\n     */\n    this.frictionIterations = options.frictionIterations !== undefined ? 0 : options.frictionIterations;\n\n    /**\n     * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.\n     * @property {Number} usedIterations\n     */\n    this.usedIterations = 0;\n}\nGSSolver.prototype = new Solver();\nGSSolver.prototype.constructor = GSSolver;\n\nfunction setArrayZero(array){\n    var l = array.length;\n    while(l--){\n        array[l] = +0.0;\n    }\n}\n\n/**\n * Solve the system of equations\n * @method solve\n * @param  {Number}  h       Time step\n * @param  {World}   world    World to solve\n */\nGSSolver.prototype.solve = function(h, world){\n\n    this.sortEquations();\n\n    var iter = 0,\n        maxIter = this.iterations,\n        maxFrictionIter = this.frictionIterations,\n        equations = this.equations,\n        Neq = equations.length,\n        tolSquared = Math.pow(this.tolerance*Neq, 2),\n        bodies = world.bodies,\n        Nbodies = world.bodies.length,\n        add = vec2.add,\n        set = vec2.set,\n        useZeroRHS = this.useZeroRHS,\n        lambda = this.lambda;\n\n    this.usedIterations = 0;\n\n    if(Neq){\n        for(var i=0; i!==Nbodies; i++){\n            var b = bodies[i];\n\n            // Update solve mass\n            b.updateSolveMassProperties();\n        }\n    }\n\n    // Things that does not change during iteration can be computed once\n    if(lambda.length < Neq){\n        lambda = this.lambda =  new Utils.ARRAY_TYPE(Neq + this.arrayStep);\n        this.Bs =               new Utils.ARRAY_TYPE(Neq + this.arrayStep);\n        this.invCs =            new Utils.ARRAY_TYPE(Neq + this.arrayStep);\n    }\n    setArrayZero(lambda);\n    var invCs = this.invCs,\n        Bs = this.Bs,\n        lambda = this.lambda;\n\n    for(var i=0; i!==equations.length; i++){\n        var c = equations[i];\n        if(c.timeStep !== h || c.needsUpdate){\n            c.timeStep = h;\n            c.update();\n        }\n        Bs[i] =     c.computeB(c.a,c.b,h);\n        invCs[i] =  c.computeInvC(c.epsilon);\n    }\n\n    var q, B, c, deltalambdaTot,i,j;\n\n    if(Neq !== 0){\n\n        for(i=0; i!==Nbodies; i++){\n            var b = bodies[i];\n\n            // Reset vlambda\n            b.resetConstraintVelocity();\n        }\n\n        if(maxFrictionIter){\n            // Iterate over contact equations to get normal forces\n            for(iter=0; iter!==maxFrictionIter; iter++){\n\n                // Accumulate the total error for each iteration.\n                deltalambdaTot = 0.0;\n\n                for(j=0; j!==Neq; j++){\n                    c = equations[j];\n\n                    var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);\n                    deltalambdaTot += Math.abs(deltalambda);\n                }\n\n                this.usedIterations++;\n\n                // If the total error is small enough - stop iterate\n                if(deltalambdaTot*deltalambdaTot <= tolSquared){\n                    break;\n                }\n            }\n\n            GSSolver.updateMultipliers(equations, lambda, 1/h);\n\n            // Set computed friction force\n            for(j=0; j!==Neq; j++){\n                var eq = equations[j];\n                if(eq instanceof FrictionEquation){\n                    var f = 0.0;\n                    for(var k=0; k!==eq.contactEquations.length; k++){\n                        f += eq.contactEquations[k].multiplier;\n                    }\n                    f *= eq.frictionCoefficient / eq.contactEquations.length;\n                    eq.maxForce =  f;\n                    eq.minForce = -f;\n                }\n            }\n        }\n\n        // Iterate over all equations\n        for(iter=0; iter!==maxIter; iter++){\n\n            // Accumulate the total error for each iteration.\n            deltalambdaTot = 0.0;\n\n            for(j=0; j!==Neq; j++){\n                c = equations[j];\n\n                var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);\n                deltalambdaTot += Math.abs(deltalambda);\n            }\n\n            this.usedIterations++;\n\n            // If the total error is small enough - stop iterate\n            if(deltalambdaTot*deltalambdaTot <= tolSquared){\n                break;\n            }\n        }\n\n        // Add result to velocity\n        for(i=0; i!==Nbodies; i++){\n            bodies[i].addConstraintVelocity();\n        }\n\n        GSSolver.updateMultipliers(equations, lambda, 1/h);\n    }\n};\n\n// Sets the .multiplier property of each equation\nGSSolver.updateMultipliers = function(equations, lambda, invDt){\n    // Set the .multiplier property of each equation\n    var l = equations.length;\n    while(l--){\n        equations[l].multiplier = lambda[l] * invDt;\n    }\n};\n\nGSSolver.iterateEquation = function(j,eq,eps,Bs,invCs,lambda,useZeroRHS,dt,iter){\n    // Compute iteration\n    var B = Bs[j],\n        invC = invCs[j],\n        lambdaj = lambda[j],\n        GWlambda = eq.computeGWlambda();\n\n    var maxForce = eq.maxForce,\n        minForce = eq.minForce;\n\n    if(useZeroRHS){\n        B = 0;\n    }\n\n    var deltalambda = invC * ( B - GWlambda - eps * lambdaj );\n\n    // Clamp if we are not within the min/max interval\n    var lambdaj_plus_deltalambda = lambdaj + deltalambda;\n    if(lambdaj_plus_deltalambda < minForce*dt){\n        deltalambda = minForce*dt - lambdaj;\n    } else if(lambdaj_plus_deltalambda > maxForce*dt){\n        deltalambda = maxForce*dt - lambdaj;\n    }\n    lambda[j] += deltalambda;\n    eq.addToWlambda(deltalambda);\n\n    return deltalambda;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NvbHZlci9HU1NvbHZlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvc29sdmVyL0dTU29sdmVyLmpzP2ViYWQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKVxuLCAgIFNvbHZlciA9IHJlcXVpcmUoJy4vU29sdmVyJylcbiwgICBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJylcbiwgICBGcmljdGlvbkVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHU1NvbHZlcjtcblxuLyoqXG4gKiBJdGVyYXRpdmUgR2F1c3MtU2VpZGVsIGNvbnN0cmFpbnQgZXF1YXRpb24gc29sdmVyLlxuICpcbiAqIEBjbGFzcyBHU1NvbHZlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTb2x2ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pdGVyYXRpb25zPTEwXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvbGVyYW5jZT0wXVxuICovXG5mdW5jdGlvbiBHU1NvbHZlcihvcHRpb25zKXtcbiAgICBTb2x2ZXIuY2FsbCh0aGlzLG9wdGlvbnMsU29sdmVyLkdTKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXggbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gZG8gd2hlbiBzb2x2aW5nLiBNb3JlIGdpdmVzIGJldHRlciByZXN1bHRzLCBidXQgaXMgbW9yZSBleHBlbnNpdmUuXG4gICAgICogQHByb3BlcnR5IGl0ZXJhdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaXRlcmF0aW9ucyA9IG9wdGlvbnMuaXRlcmF0aW9ucyB8fCAxMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlcnJvciB0b2xlcmFuY2UsIHBlciBjb25zdHJhaW50LiBJZiB0aGUgdG90YWwgZXJyb3IgaXMgYmVsb3cgdGhpcyBsaW1pdCwgdGhlIHNvbHZlciB3aWxsIHN0b3AgaXRlcmF0aW5nLiBTZXQgdG8gemVybyBmb3IgYXMgZ29vZCBzb2x1dGlvbiBhcyBwb3NzaWJsZSwgYnV0IHRvIHNvbWV0aGluZyBsYXJnZXIgdGhhbiB6ZXJvIHRvIG1ha2UgY29tcHV0YXRpb25zIGZhc3Rlci5cbiAgICAgKiBAcHJvcGVydHkgdG9sZXJhbmNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxZS03XG4gICAgICovXG4gICAgdGhpcy50b2xlcmFuY2UgPSBvcHRpb25zLnRvbGVyYW5jZSB8fCAxZS03O1xuXG4gICAgdGhpcy5hcnJheVN0ZXAgPSAzMDtcbiAgICB0aGlzLmxhbWJkYSA9IG5ldyBVdGlscy5BUlJBWV9UWVBFKHRoaXMuYXJyYXlTdGVwKTtcbiAgICB0aGlzLkJzID0gICAgIG5ldyBVdGlscy5BUlJBWV9UWVBFKHRoaXMuYXJyYXlTdGVwKTtcbiAgICB0aGlzLmludkNzID0gIG5ldyBVdGlscy5BUlJBWV9UWVBFKHRoaXMuYXJyYXlTdGVwKTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIHNldCBhbGwgcmlnaHQgaGFuZCBzaWRlIHRlcm1zIHRvIHplcm8gd2hlbiBzb2x2aW5nLiBDYW4gYmUgaGFuZHkgZm9yIGEgZmV3IGFwcGxpY2F0aW9ucy5cbiAgICAgKiBAcHJvcGVydHkgdXNlWmVyb1JIU1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEB0b2RvIFJlbW92ZSwgbm90IHVzZWRcbiAgICAgKi9cbiAgICB0aGlzLnVzZVplcm9SSFMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBzb2x2ZXIgaXRlcmF0aW9ucyB0aGF0IGFyZSB1c2VkIHRvIGFwcHJveGltYXRlIG5vcm1hbCBmb3JjZXMgdXNlZCBmb3IgZnJpY3Rpb24gKEZfZnJpY3Rpb24gPSBtdSAqIEZfbm9ybWFsKS4gVGhlc2UgZnJpY3Rpb24gZm9yY2VzIHdpbGwgb3ZlcnJpZGUgYW55IG90aGVyIGZyaWN0aW9uIGZvcmNlcyB0aGF0IGFyZSBzZXQuIElmIHlvdSBzZXQgZnJpY3Rpb25JdGVyYXRpb25zID0gMCwgdGhlbiB0aGlzIGZlYXR1cmUgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvbmx5IGZyaWN0aW9uSXRlcmF0aW9ucyA+IDAgaWYgdGhlIGFwcHJveGltYXRlZCBub3JtYWwgZm9yY2UgKEZfbm9ybWFsID0gbWFzcyAqIGdyYXZpdHkpIGlzIG5vdCBnb29kIGVub3VnaC4gRXhhbXBsZXMgb2Ygd2hlcmUgaXQgY2FuIGhhcHBlbiBpcyBpbiBzcGFjZSBnYW1lcyB3aGVyZSBncmF2aXR5IGlzIHplcm8sIG9yIGluIHRhbGwgc3RhY2tzIHdoZXJlIHRoZSBub3JtYWwgZm9yY2UgaXMgbGFyZ2UgYXQgYm90dG9tIGJ1dCBzbWFsbCBhdCB0b3AuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZnJpY3Rpb25JdGVyYXRpb25zXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkl0ZXJhdGlvbnMgPSBvcHRpb25zLmZyaWN0aW9uSXRlcmF0aW9ucyAhPT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMuZnJpY3Rpb25JdGVyYXRpb25zO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRoYXQgd2VyZSBtYWRlIGR1cmluZyB0aGUgbGFzdCBzb2x2ZS4gSWYgLnRvbGVyYW5jZSBpcyB6ZXJvLCB0aGlzIHZhbHVlIHdpbGwgYWx3YXlzIGJlIGVxdWFsIHRvIC5pdGVyYXRpb25zLCBidXQgaWYgLnRvbGVyYW5jZSBpcyBsYXJnZXIgdGhhbiB6ZXJvLCBhbmQgdGhlIHNvbHZlciBjYW4gcXVpdCBlYXJseSwgdGhlbiB0aGlzIG51bWJlciB3aWxsIGJlIHNvbWV3aGVyZSBiZXR3ZWVuIDEgYW5kIC5pdGVyYXRpb25zLlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB1c2VkSXRlcmF0aW9uc1xuICAgICAqL1xuICAgIHRoaXMudXNlZEl0ZXJhdGlvbnMgPSAwO1xufVxuR1NTb2x2ZXIucHJvdG90eXBlID0gbmV3IFNvbHZlcigpO1xuR1NTb2x2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR1NTb2x2ZXI7XG5cbmZ1bmN0aW9uIHNldEFycmF5WmVybyhhcnJheSl7XG4gICAgdmFyIGwgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgYXJyYXlbbF0gPSArMC4wO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTb2x2ZSB0aGUgc3lzdGVtIG9mIGVxdWF0aW9uc1xuICogQG1ldGhvZCBzb2x2ZVxuICogQHBhcmFtICB7TnVtYmVyfSAgaCAgICAgICBUaW1lIHN0ZXBcbiAqIEBwYXJhbSAge1dvcmxkfSAgIHdvcmxkICAgIFdvcmxkIHRvIHNvbHZlXG4gKi9cbkdTU29sdmVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKGgsIHdvcmxkKXtcblxuICAgIHRoaXMuc29ydEVxdWF0aW9ucygpO1xuXG4gICAgdmFyIGl0ZXIgPSAwLFxuICAgICAgICBtYXhJdGVyID0gdGhpcy5pdGVyYXRpb25zLFxuICAgICAgICBtYXhGcmljdGlvbkl0ZXIgPSB0aGlzLmZyaWN0aW9uSXRlcmF0aW9ucyxcbiAgICAgICAgZXF1YXRpb25zID0gdGhpcy5lcXVhdGlvbnMsXG4gICAgICAgIE5lcSA9IGVxdWF0aW9ucy5sZW5ndGgsXG4gICAgICAgIHRvbFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnRvbGVyYW5jZSpOZXEsIDIpLFxuICAgICAgICBib2RpZXMgPSB3b3JsZC5ib2RpZXMsXG4gICAgICAgIE5ib2RpZXMgPSB3b3JsZC5ib2RpZXMubGVuZ3RoLFxuICAgICAgICBhZGQgPSB2ZWMyLmFkZCxcbiAgICAgICAgc2V0ID0gdmVjMi5zZXQsXG4gICAgICAgIHVzZVplcm9SSFMgPSB0aGlzLnVzZVplcm9SSFMsXG4gICAgICAgIGxhbWJkYSA9IHRoaXMubGFtYmRhO1xuXG4gICAgdGhpcy51c2VkSXRlcmF0aW9ucyA9IDA7XG5cbiAgICBpZihOZXEpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHNvbHZlIG1hc3NcbiAgICAgICAgICAgIGIudXBkYXRlU29sdmVNYXNzUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpbmdzIHRoYXQgZG9lcyBub3QgY2hhbmdlIGR1cmluZyBpdGVyYXRpb24gY2FuIGJlIGNvbXB1dGVkIG9uY2VcbiAgICBpZihsYW1iZGEubGVuZ3RoIDwgTmVxKXtcbiAgICAgICAgbGFtYmRhID0gdGhpcy5sYW1iZGEgPSAgbmV3IFV0aWxzLkFSUkFZX1RZUEUoTmVxICsgdGhpcy5hcnJheVN0ZXApO1xuICAgICAgICB0aGlzLkJzID0gICAgICAgICAgICAgICBuZXcgVXRpbHMuQVJSQVlfVFlQRShOZXEgKyB0aGlzLmFycmF5U3RlcCk7XG4gICAgICAgIHRoaXMuaW52Q3MgPSAgICAgICAgICAgIG5ldyBVdGlscy5BUlJBWV9UWVBFKE5lcSArIHRoaXMuYXJyYXlTdGVwKTtcbiAgICB9XG4gICAgc2V0QXJyYXlaZXJvKGxhbWJkYSk7XG4gICAgdmFyIGludkNzID0gdGhpcy5pbnZDcyxcbiAgICAgICAgQnMgPSB0aGlzLkJzLFxuICAgICAgICBsYW1iZGEgPSB0aGlzLmxhbWJkYTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09ZXF1YXRpb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSBlcXVhdGlvbnNbaV07XG4gICAgICAgIGlmKGMudGltZVN0ZXAgIT09IGggfHwgYy5uZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBjLnRpbWVTdGVwID0gaDtcbiAgICAgICAgICAgIGMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgQnNbaV0gPSAgICAgYy5jb21wdXRlQihjLmEsYy5iLGgpO1xuICAgICAgICBpbnZDc1tpXSA9ICBjLmNvbXB1dGVJbnZDKGMuZXBzaWxvbik7XG4gICAgfVxuXG4gICAgdmFyIHEsIEIsIGMsIGRlbHRhbGFtYmRhVG90LGksajtcblxuICAgIGlmKE5lcSAhPT0gMCl7XG5cbiAgICAgICAgZm9yKGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcblxuICAgICAgICAgICAgLy8gUmVzZXQgdmxhbWJkYVxuICAgICAgICAgICAgYi5yZXNldENvbnN0cmFpbnRWZWxvY2l0eSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobWF4RnJpY3Rpb25JdGVyKXtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBjb250YWN0IGVxdWF0aW9ucyB0byBnZXQgbm9ybWFsIGZvcmNlc1xuICAgICAgICAgICAgZm9yKGl0ZXI9MDsgaXRlciE9PW1heEZyaWN0aW9uSXRlcjsgaXRlcisrKXtcblxuICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHRvdGFsIGVycm9yIGZvciBlYWNoIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDtcblxuICAgICAgICAgICAgICAgIGZvcihqPTA7IGohPT1OZXE7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBlcXVhdGlvbnNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhbGFtYmRhID0gR1NTb2x2ZXIuaXRlcmF0ZUVxdWF0aW9uKGosYyxjLmVwc2lsb24sQnMsaW52Q3MsbGFtYmRhLHVzZVplcm9SSFMsaCxpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgKz0gTWF0aC5hYnMoZGVsdGFsYW1iZGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudXNlZEl0ZXJhdGlvbnMrKztcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0b3RhbCBlcnJvciBpcyBzbWFsbCBlbm91Z2ggLSBzdG9wIGl0ZXJhdGVcbiAgICAgICAgICAgICAgICBpZihkZWx0YWxhbWJkYVRvdCpkZWx0YWxhbWJkYVRvdCA8PSB0b2xTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBHU1NvbHZlci51cGRhdGVNdWx0aXBsaWVycyhlcXVhdGlvbnMsIGxhbWJkYSwgMS9oKTtcblxuICAgICAgICAgICAgLy8gU2V0IGNvbXB1dGVkIGZyaWN0aW9uIGZvcmNlXG4gICAgICAgICAgICBmb3Ioaj0wOyBqIT09TmVxOyBqKyspe1xuICAgICAgICAgICAgICAgIHZhciBlcSA9IGVxdWF0aW9uc1tqXTtcbiAgICAgICAgICAgICAgICBpZihlcSBpbnN0YW5jZW9mIEZyaWN0aW9uRXF1YXRpb24pe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBrPTA7IGshPT1lcS5jb250YWN0RXF1YXRpb25zLmxlbmd0aDsgaysrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgKz0gZXEuY29udGFjdEVxdWF0aW9uc1trXS5tdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGYgKj0gZXEuZnJpY3Rpb25Db2VmZmljaWVudCAvIGVxLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBlcS5tYXhGb3JjZSA9ICBmO1xuICAgICAgICAgICAgICAgICAgICBlcS5taW5Gb3JjZSA9IC1mO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZXF1YXRpb25zXG4gICAgICAgIGZvcihpdGVyPTA7IGl0ZXIhPT1tYXhJdGVyOyBpdGVyKyspe1xuXG4gICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uXG4gICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDtcblxuICAgICAgICAgICAgZm9yKGo9MDsgaiE9PU5lcTsgaisrKXtcbiAgICAgICAgICAgICAgICBjID0gZXF1YXRpb25zW2pdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhbGFtYmRhID0gR1NTb2x2ZXIuaXRlcmF0ZUVxdWF0aW9uKGosYyxjLmVwc2lsb24sQnMsaW52Q3MsbGFtYmRhLHVzZVplcm9SSFMsaCxpdGVyKTtcbiAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCArPSBNYXRoLmFicyhkZWx0YWxhbWJkYSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXNlZEl0ZXJhdGlvbnMrKztcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZVxuICAgICAgICAgICAgaWYoZGVsdGFsYW1iZGFUb3QqZGVsdGFsYW1iZGFUb3QgPD0gdG9sU3F1YXJlZCl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgcmVzdWx0IHRvIHZlbG9jaXR5XG4gICAgICAgIGZvcihpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgYm9kaWVzW2ldLmFkZENvbnN0cmFpbnRWZWxvY2l0eSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgR1NTb2x2ZXIudXBkYXRlTXVsdGlwbGllcnMoZXF1YXRpb25zLCBsYW1iZGEsIDEvaCk7XG4gICAgfVxufTtcblxuLy8gU2V0cyB0aGUgLm11bHRpcGxpZXIgcHJvcGVydHkgb2YgZWFjaCBlcXVhdGlvblxuR1NTb2x2ZXIudXBkYXRlTXVsdGlwbGllcnMgPSBmdW5jdGlvbihlcXVhdGlvbnMsIGxhbWJkYSwgaW52RHQpe1xuICAgIC8vIFNldCB0aGUgLm11bHRpcGxpZXIgcHJvcGVydHkgb2YgZWFjaCBlcXVhdGlvblxuICAgIHZhciBsID0gZXF1YXRpb25zLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICBlcXVhdGlvbnNbbF0ubXVsdGlwbGllciA9IGxhbWJkYVtsXSAqIGludkR0O1xuICAgIH1cbn07XG5cbkdTU29sdmVyLml0ZXJhdGVFcXVhdGlvbiA9IGZ1bmN0aW9uKGosZXEsZXBzLEJzLGludkNzLGxhbWJkYSx1c2VaZXJvUkhTLGR0LGl0ZXIpe1xuICAgIC8vIENvbXB1dGUgaXRlcmF0aW9uXG4gICAgdmFyIEIgPSBCc1tqXSxcbiAgICAgICAgaW52QyA9IGludkNzW2pdLFxuICAgICAgICBsYW1iZGFqID0gbGFtYmRhW2pdLFxuICAgICAgICBHV2xhbWJkYSA9IGVxLmNvbXB1dGVHV2xhbWJkYSgpO1xuXG4gICAgdmFyIG1heEZvcmNlID0gZXEubWF4Rm9yY2UsXG4gICAgICAgIG1pbkZvcmNlID0gZXEubWluRm9yY2U7XG5cbiAgICBpZih1c2VaZXJvUkhTKXtcbiAgICAgICAgQiA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhbGFtYmRhID0gaW52QyAqICggQiAtIEdXbGFtYmRhIC0gZXBzICogbGFtYmRhaiApO1xuXG4gICAgLy8gQ2xhbXAgaWYgd2UgYXJlIG5vdCB3aXRoaW4gdGhlIG1pbi9tYXggaW50ZXJ2YWxcbiAgICB2YXIgbGFtYmRhal9wbHVzX2RlbHRhbGFtYmRhID0gbGFtYmRhaiArIGRlbHRhbGFtYmRhO1xuICAgIGlmKGxhbWJkYWpfcGx1c19kZWx0YWxhbWJkYSA8IG1pbkZvcmNlKmR0KXtcbiAgICAgICAgZGVsdGFsYW1iZGEgPSBtaW5Gb3JjZSpkdCAtIGxhbWJkYWo7XG4gICAgfSBlbHNlIGlmKGxhbWJkYWpfcGx1c19kZWx0YWxhbWJkYSA+IG1heEZvcmNlKmR0KXtcbiAgICAgICAgZGVsdGFsYW1iZGEgPSBtYXhGb3JjZSpkdCAtIGxhbWJkYWo7XG4gICAgfVxuICAgIGxhbWJkYVtqXSArPSBkZWx0YWxhbWJkYTtcbiAgICBlcS5hZGRUb1dsYW1iZGEoZGVsdGFsYW1iZGEpO1xuXG4gICAgcmV0dXJuIGRlbHRhbGFtYmRhO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/solver/GSSolver.js\n");

/***/ }),

/***/ "./node_modules/p2/src/solver/Solver.js":
/*!**********************************************!*\
  !*** ./node_modules/p2/src/solver/Solver.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\")\n,   EventEmitter = __webpack_require__(/*! ../events/EventEmitter */ \"./node_modules/p2/src/events/EventEmitter.js\");\n\nmodule.exports = Solver;\n\n/**\n * Base class for constraint solvers.\n * @class Solver\n * @constructor\n * @extends EventEmitter\n */\nfunction Solver(options,type){\n    options = options || {};\n\n    EventEmitter.call(this);\n\n    this.type = type;\n\n    /**\n     * Current equations in the solver.\n     *\n     * @property equations\n     * @type {Array}\n     */\n    this.equations = [];\n\n    /**\n     * Function that is used to sort all equations before each solve.\n     * @property equationSortFunction\n     * @type {function|boolean}\n     */\n    this.equationSortFunction = options.equationSortFunction || false;\n}\nSolver.prototype = new EventEmitter();\nSolver.prototype.constructor = Solver;\n\n/**\n * Method to be implemented in each subclass\n * @method solve\n * @param  {Number} dt\n * @param  {World} world\n */\nSolver.prototype.solve = function(dt,world){\n    throw new Error(\"Solver.solve should be implemented by subclasses!\");\n};\n\nvar mockWorld = {bodies:[]};\n\n/**\n * Solves all constraints in an island.\n * @method solveIsland\n * @param  {Number} dt\n * @param  {Island} island\n */\nSolver.prototype.solveIsland = function(dt,island){\n\n    this.removeAllEquations();\n\n    if(island.equations.length){\n        // Add equations to solver\n        this.addEquations(island.equations);\n        mockWorld.bodies.length = 0;\n        island.getBodies(mockWorld.bodies);\n\n        // Solve\n        if(mockWorld.bodies.length){\n            this.solve(dt,mockWorld);\n        }\n    }\n};\n\n/**\n * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.\n * @method sortEquations\n */\nSolver.prototype.sortEquations = function(){\n    if(this.equationSortFunction){\n        this.equations.sort(this.equationSortFunction);\n    }\n};\n\n/**\n * Add an equation to be solved.\n *\n * @method addEquation\n * @param {Equation} eq\n */\nSolver.prototype.addEquation = function(eq){\n    if(eq.enabled){\n        this.equations.push(eq);\n    }\n};\n\n/**\n * Add equations. Same as .addEquation, but this time the argument is an array of Equations\n *\n * @method addEquations\n * @param {Array} eqs\n */\nSolver.prototype.addEquations = function(eqs){\n    //Utils.appendArray(this.equations,eqs);\n    for(var i=0, N=eqs.length; i!==N; i++){\n        var eq = eqs[i];\n        if(eq.enabled){\n            this.equations.push(eq);\n        }\n    }\n};\n\n/**\n * Remove an equation.\n *\n * @method removeEquation\n * @param {Equation} eq\n */\nSolver.prototype.removeEquation = function(eq){\n    var i = this.equations.indexOf(eq);\n    if(i !== -1){\n        this.equations.splice(i,1);\n    }\n};\n\n/**\n * Remove all currently added equations.\n *\n * @method removeAllEquations\n */\nSolver.prototype.removeAllEquations = function(){\n    this.equations.length=0;\n};\n\nSolver.GS = 1;\nSolver.ISLAND = 2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NvbHZlci9Tb2x2ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL3NvbHZlci9Tb2x2ZXIuanM/MjA3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpXG4sICAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi4vZXZlbnRzL0V2ZW50RW1pdHRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbHZlcjtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBjb25zdHJhaW50IHNvbHZlcnMuXG4gKiBAY2xhc3MgU29sdmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5mdW5jdGlvbiBTb2x2ZXIob3B0aW9ucyx0eXBlKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZXF1YXRpb25zIGluIHRoZSBzb2x2ZXIuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gc29ydCBhbGwgZXF1YXRpb25zIGJlZm9yZSBlYWNoIHNvbHZlLlxuICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvblNvcnRGdW5jdGlvblxuICAgICAqIEB0eXBlIHtmdW5jdGlvbnxib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25Tb3J0RnVuY3Rpb24gPSBvcHRpb25zLmVxdWF0aW9uU29ydEZ1bmN0aW9uIHx8IGZhbHNlO1xufVxuU29sdmVyLnByb3RvdHlwZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblNvbHZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2x2ZXI7XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGltcGxlbWVudGVkIGluIGVhY2ggc3ViY2xhc3NcbiAqIEBtZXRob2Qgc29sdmVcbiAqIEBwYXJhbSAge051bWJlcn0gZHRcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICovXG5Tb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oZHQsd29ybGQpe1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNvbHZlci5zb2x2ZSBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcyFcIik7XG59O1xuXG52YXIgbW9ja1dvcmxkID0ge2JvZGllczpbXX07XG5cbi8qKlxuICogU29sdmVzIGFsbCBjb25zdHJhaW50cyBpbiBhbiBpc2xhbmQuXG4gKiBAbWV0aG9kIHNvbHZlSXNsYW5kXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGR0XG4gKiBAcGFyYW0gIHtJc2xhbmR9IGlzbGFuZFxuICovXG5Tb2x2ZXIucHJvdG90eXBlLnNvbHZlSXNsYW5kID0gZnVuY3Rpb24oZHQsaXNsYW5kKXtcblxuICAgIHRoaXMucmVtb3ZlQWxsRXF1YXRpb25zKCk7XG5cbiAgICBpZihpc2xhbmQuZXF1YXRpb25zLmxlbmd0aCl7XG4gICAgICAgIC8vIEFkZCBlcXVhdGlvbnMgdG8gc29sdmVyXG4gICAgICAgIHRoaXMuYWRkRXF1YXRpb25zKGlzbGFuZC5lcXVhdGlvbnMpO1xuICAgICAgICBtb2NrV29ybGQuYm9kaWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlzbGFuZC5nZXRCb2RpZXMobW9ja1dvcmxkLmJvZGllcyk7XG5cbiAgICAgICAgLy8gU29sdmVcbiAgICAgICAgaWYobW9ja1dvcmxkLmJvZGllcy5sZW5ndGgpe1xuICAgICAgICAgICAgdGhpcy5zb2x2ZShkdCxtb2NrV29ybGQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBTb3J0IGFsbCBlcXVhdGlvbnMgdXNpbmcgdGhlIC5lcXVhdGlvblNvcnRGdW5jdGlvbi4gU2hvdWxkIGJlIGNhbGxlZCBieSBzdWJjbGFzc2VzIGJlZm9yZSBzb2x2aW5nLlxuICogQG1ldGhvZCBzb3J0RXF1YXRpb25zXG4gKi9cblNvbHZlci5wcm90b3R5cGUuc29ydEVxdWF0aW9ucyA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5lcXVhdGlvblNvcnRGdW5jdGlvbil7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnNvcnQodGhpcy5lcXVhdGlvblNvcnRGdW5jdGlvbik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGQgYW4gZXF1YXRpb24gdG8gYmUgc29sdmVkLlxuICpcbiAqIEBtZXRob2QgYWRkRXF1YXRpb25cbiAqIEBwYXJhbSB7RXF1YXRpb259IGVxXG4gKi9cblNvbHZlci5wcm90b3R5cGUuYWRkRXF1YXRpb24gPSBmdW5jdGlvbihlcSl7XG4gICAgaWYoZXEuZW5hYmxlZCl7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGVxdWF0aW9ucy4gU2FtZSBhcyAuYWRkRXF1YXRpb24sIGJ1dCB0aGlzIHRpbWUgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IG9mIEVxdWF0aW9uc1xuICpcbiAqIEBtZXRob2QgYWRkRXF1YXRpb25zXG4gKiBAcGFyYW0ge0FycmF5fSBlcXNcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5hZGRFcXVhdGlvbnMgPSBmdW5jdGlvbihlcXMpe1xuICAgIC8vVXRpbHMuYXBwZW5kQXJyYXkodGhpcy5lcXVhdGlvbnMsZXFzKTtcbiAgICBmb3IodmFyIGk9MCwgTj1lcXMubGVuZ3RoOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGVxID0gZXFzW2ldO1xuICAgICAgICBpZihlcS5lbmFibGVkKXtcbiAgICAgICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gZXF1YXRpb24uXG4gKlxuICogQG1ldGhvZCByZW1vdmVFcXVhdGlvblxuICogQHBhcmFtIHtFcXVhdGlvbn0gZXFcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5yZW1vdmVFcXVhdGlvbiA9IGZ1bmN0aW9uKGVxKXtcbiAgICB2YXIgaSA9IHRoaXMuZXF1YXRpb25zLmluZGV4T2YoZXEpO1xuICAgIGlmKGkgIT09IC0xKXtcbiAgICAgICAgdGhpcy5lcXVhdGlvbnMuc3BsaWNlKGksMSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGN1cnJlbnRseSBhZGRlZCBlcXVhdGlvbnMuXG4gKlxuICogQG1ldGhvZCByZW1vdmVBbGxFcXVhdGlvbnNcbiAqL1xuU29sdmVyLnByb3RvdHlwZS5yZW1vdmVBbGxFcXVhdGlvbnMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aD0wO1xufTtcblxuU29sdmVyLkdTID0gMTtcblNvbHZlci5JU0xBTkQgPSAyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/solver/Solver.js\n");

/***/ }),

/***/ "./node_modules/p2/src/utils/ContactEquationPool.js":
/*!**********************************************************!*\
  !*** ./node_modules/p2/src/utils/ContactEquationPool.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var ContactEquation = __webpack_require__(/*! ../equations/ContactEquation */ \"./node_modules/p2/src/equations/ContactEquation.js\");\nvar Pool = __webpack_require__(/*! ./Pool */ \"./node_modules/p2/src/utils/Pool.js\");\n\nmodule.exports = ContactEquationPool;\n\n/**\n * @class\n */\nfunction ContactEquationPool() {\n\tPool.apply(this, arguments);\n}\nContactEquationPool.prototype = new Pool();\nContactEquationPool.prototype.constructor = ContactEquationPool;\n\n/**\n * @method create\n * @return {ContactEquation}\n */\nContactEquationPool.prototype.create = function () {\n\treturn new ContactEquation();\n};\n\n/**\n * @method destroy\n * @param {ContactEquation} equation\n * @return {ContactEquationPool}\n */\nContactEquationPool.prototype.destroy = function (equation) {\n\tequation.bodyA = equation.bodyB = null;\n\treturn this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL0NvbnRhY3RFcXVhdGlvblBvb2wuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL0NvbnRhY3RFcXVhdGlvblBvb2wuanM/YjJjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29udGFjdEVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xudmFyIFBvb2wgPSByZXF1aXJlKCcuL1Bvb2wnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWN0RXF1YXRpb25Qb29sO1xuXG4vKipcbiAqIEBjbGFzc1xuICovXG5mdW5jdGlvbiBDb250YWN0RXF1YXRpb25Qb29sKCkge1xuXHRQb29sLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5Db250YWN0RXF1YXRpb25Qb29sLnByb3RvdHlwZSA9IG5ldyBQb29sKCk7XG5Db250YWN0RXF1YXRpb25Qb29sLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRhY3RFcXVhdGlvblBvb2w7XG5cbi8qKlxuICogQG1ldGhvZCBjcmVhdGVcbiAqIEByZXR1cm4ge0NvbnRhY3RFcXVhdGlvbn1cbiAqL1xuQ29udGFjdEVxdWF0aW9uUG9vbC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gbmV3IENvbnRhY3RFcXVhdGlvbigpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRlc3Ryb3lcbiAqIEBwYXJhbSB7Q29udGFjdEVxdWF0aW9ufSBlcXVhdGlvblxuICogQHJldHVybiB7Q29udGFjdEVxdWF0aW9uUG9vbH1cbiAqL1xuQ29udGFjdEVxdWF0aW9uUG9vbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcXVhdGlvbikge1xuXHRlcXVhdGlvbi5ib2R5QSA9IGVxdWF0aW9uLmJvZHlCID0gbnVsbDtcblx0cmV0dXJuIHRoaXM7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/utils/ContactEquationPool.js\n");

/***/ }),

/***/ "./node_modules/p2/src/utils/FrictionEquationPool.js":
/*!***********************************************************!*\
  !*** ./node_modules/p2/src/utils/FrictionEquationPool.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var FrictionEquation = __webpack_require__(/*! ../equations/FrictionEquation */ \"./node_modules/p2/src/equations/FrictionEquation.js\");\nvar Pool = __webpack_require__(/*! ./Pool */ \"./node_modules/p2/src/utils/Pool.js\");\n\nmodule.exports = FrictionEquationPool;\n\n/**\n * @class\n */\nfunction FrictionEquationPool() {\n\tPool.apply(this, arguments);\n}\nFrictionEquationPool.prototype = new Pool();\nFrictionEquationPool.prototype.constructor = FrictionEquationPool;\n\n/**\n * @method create\n * @return {FrictionEquation}\n */\nFrictionEquationPool.prototype.create = function () {\n\treturn new FrictionEquation();\n};\n\n/**\n * @method destroy\n * @param {FrictionEquation} equation\n * @return {FrictionEquationPool}\n */\nFrictionEquationPool.prototype.destroy = function (equation) {\n\tequation.bodyA = equation.bodyB = null;\n\treturn this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL0ZyaWN0aW9uRXF1YXRpb25Qb29sLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy91dGlscy9GcmljdGlvbkVxdWF0aW9uUG9vbC5qcz9mNGJiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBGcmljdGlvbkVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcbnZhciBQb29sID0gcmVxdWlyZSgnLi9Qb29sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnJpY3Rpb25FcXVhdGlvblBvb2w7XG5cbi8qKlxuICogQGNsYXNzXG4gKi9cbmZ1bmN0aW9uIEZyaWN0aW9uRXF1YXRpb25Qb29sKCkge1xuXHRQb29sLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5GcmljdGlvbkVxdWF0aW9uUG9vbC5wcm90b3R5cGUgPSBuZXcgUG9vbCgpO1xuRnJpY3Rpb25FcXVhdGlvblBvb2wucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJpY3Rpb25FcXVhdGlvblBvb2w7XG5cbi8qKlxuICogQG1ldGhvZCBjcmVhdGVcbiAqIEByZXR1cm4ge0ZyaWN0aW9uRXF1YXRpb259XG4gKi9cbkZyaWN0aW9uRXF1YXRpb25Qb29sLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgRnJpY3Rpb25FcXVhdGlvbigpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRlc3Ryb3lcbiAqIEBwYXJhbSB7RnJpY3Rpb25FcXVhdGlvbn0gZXF1YXRpb25cbiAqIEByZXR1cm4ge0ZyaWN0aW9uRXF1YXRpb25Qb29sfVxuICovXG5GcmljdGlvbkVxdWF0aW9uUG9vbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcXVhdGlvbikge1xuXHRlcXVhdGlvbi5ib2R5QSA9IGVxdWF0aW9uLmJvZHlCID0gbnVsbDtcblx0cmV0dXJuIHRoaXM7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/utils/FrictionEquationPool.js\n");

/***/ }),

/***/ "./node_modules/p2/src/utils/IslandNodePool.js":
/*!*****************************************************!*\
  !*** ./node_modules/p2/src/utils/IslandNodePool.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var IslandNode = __webpack_require__(/*! ../world/IslandNode */ \"./node_modules/p2/src/world/IslandNode.js\");\nvar Pool = __webpack_require__(/*! ./Pool */ \"./node_modules/p2/src/utils/Pool.js\");\n\nmodule.exports = IslandNodePool;\n\n/**\n * @class\n */\nfunction IslandNodePool() {\n\tPool.apply(this, arguments);\n}\nIslandNodePool.prototype = new Pool();\nIslandNodePool.prototype.constructor = IslandNodePool;\n\n/**\n * @method create\n * @return {IslandNode}\n */\nIslandNodePool.prototype.create = function () {\n\treturn new IslandNode();\n};\n\n/**\n * @method destroy\n * @param {IslandNode} node\n * @return {IslandNodePool}\n */\nIslandNodePool.prototype.destroy = function (node) {\n\tnode.reset();\n\treturn this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL0lzbGFuZE5vZGVQb29sLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy91dGlscy9Jc2xhbmROb2RlUG9vbC5qcz9jZDBmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBJc2xhbmROb2RlID0gcmVxdWlyZSgnLi4vd29ybGQvSXNsYW5kTm9kZScpO1xudmFyIFBvb2wgPSByZXF1aXJlKCcuL1Bvb2wnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJc2xhbmROb2RlUG9vbDtcblxuLyoqXG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gSXNsYW5kTm9kZVBvb2woKSB7XG5cdFBvb2wuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbklzbGFuZE5vZGVQb29sLnByb3RvdHlwZSA9IG5ldyBQb29sKCk7XG5Jc2xhbmROb2RlUG9vbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJc2xhbmROb2RlUG9vbDtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZVxuICogQHJldHVybiB7SXNsYW5kTm9kZX1cbiAqL1xuSXNsYW5kTm9kZVBvb2wucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBJc2xhbmROb2RlKCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGVzdHJveVxuICogQHBhcmFtIHtJc2xhbmROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtJc2xhbmROb2RlUG9vbH1cbiAqL1xuSXNsYW5kTm9kZVBvb2wucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAobm9kZSkge1xuXHRub2RlLnJlc2V0KCk7XG5cdHJldHVybiB0aGlzO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/utils/IslandNodePool.js\n");

/***/ }),

/***/ "./node_modules/p2/src/utils/IslandPool.js":
/*!*************************************************!*\
  !*** ./node_modules/p2/src/utils/IslandPool.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Island = __webpack_require__(/*! ../world/Island */ \"./node_modules/p2/src/world/Island.js\");\nvar Pool = __webpack_require__(/*! ./Pool */ \"./node_modules/p2/src/utils/Pool.js\");\n\nmodule.exports = IslandPool;\n\n/**\n * @class\n */\nfunction IslandPool() {\n\tPool.apply(this, arguments);\n}\nIslandPool.prototype = new Pool();\nIslandPool.prototype.constructor = IslandPool;\n\n/**\n * @method create\n * @return {Island}\n */\nIslandPool.prototype.create = function () {\n\treturn new Island();\n};\n\n/**\n * @method destroy\n * @param {Island} island\n * @return {IslandPool}\n */\nIslandPool.prototype.destroy = function (island) {\n\tisland.reset();\n\treturn this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL0lzbGFuZFBvb2wuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL0lzbGFuZFBvb2wuanM/YTUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSXNsYW5kID0gcmVxdWlyZSgnLi4vd29ybGQvSXNsYW5kJyk7XG52YXIgUG9vbCA9IHJlcXVpcmUoJy4vUG9vbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElzbGFuZFBvb2w7XG5cbi8qKlxuICogQGNsYXNzXG4gKi9cbmZ1bmN0aW9uIElzbGFuZFBvb2woKSB7XG5cdFBvb2wuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbklzbGFuZFBvb2wucHJvdG90eXBlID0gbmV3IFBvb2woKTtcbklzbGFuZFBvb2wucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSXNsYW5kUG9vbDtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZVxuICogQHJldHVybiB7SXNsYW5kfVxuICovXG5Jc2xhbmRQb29sLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgSXNsYW5kKCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGVzdHJveVxuICogQHBhcmFtIHtJc2xhbmR9IGlzbGFuZFxuICogQHJldHVybiB7SXNsYW5kUG9vbH1cbiAqL1xuSXNsYW5kUG9vbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChpc2xhbmQpIHtcblx0aXNsYW5kLnJlc2V0KCk7XG5cdHJldHVybiB0aGlzO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/utils/IslandPool.js\n");

/***/ }),

/***/ "./node_modules/p2/src/utils/OverlapKeeper.js":
/*!****************************************************!*\
  !*** ./node_modules/p2/src/utils/OverlapKeeper.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var TupleDictionary = __webpack_require__(/*! ./TupleDictionary */ \"./node_modules/p2/src/utils/TupleDictionary.js\");\nvar OverlapKeeperRecord = __webpack_require__(/*! ./OverlapKeeperRecord */ \"./node_modules/p2/src/utils/OverlapKeeperRecord.js\");\nvar OverlapKeeperRecordPool = __webpack_require__(/*! ./OverlapKeeperRecordPool */ \"./node_modules/p2/src/utils/OverlapKeeperRecordPool.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/p2/src/utils/Utils.js\");\n\nmodule.exports = OverlapKeeper;\n\n/**\n * Keeps track of overlaps in the current state and the last step state.\n * @class OverlapKeeper\n * @constructor\n */\nfunction OverlapKeeper() {\n    this.overlappingShapesLastState = new TupleDictionary();\n    this.overlappingShapesCurrentState = new TupleDictionary();\n    this.recordPool = new OverlapKeeperRecordPool({ size: 16 });\n    this.tmpDict = new TupleDictionary();\n    this.tmpArray1 = [];\n}\n\n/**\n * Ticks one step forward in time. This will move the current overlap state to the \"old\" overlap state, and create a new one as current.\n * @method tick\n */\nOverlapKeeper.prototype.tick = function() {\n    var last = this.overlappingShapesLastState;\n    var current = this.overlappingShapesCurrentState;\n\n    // Save old objects into pool\n    var l = last.keys.length;\n    while(l--){\n        var key = last.keys[l];\n        var lastObject = last.getByKey(key);\n        var currentObject = current.getByKey(key);\n        if(lastObject){\n            // The record is only used in the \"last\" dict, and will be removed. We might as well pool it.\n            this.recordPool.release(lastObject);\n        }\n    }\n\n    // Clear last object\n    last.reset();\n\n    // Transfer from new object to old\n    last.copy(current);\n\n    // Clear current object\n    current.reset();\n};\n\n/**\n * @method setOverlapping\n * @param {Body} bodyA\n * @param {Body} shapeA\n * @param {Body} bodyB\n * @param {Body} shapeB\n */\nOverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {\n    var last = this.overlappingShapesLastState;\n    var current = this.overlappingShapesCurrentState;\n\n    // Store current contact state\n    if(!current.get(shapeA.id, shapeB.id)){\n        var data = this.recordPool.get();\n        data.set(bodyA, shapeA, bodyB, shapeB);\n        current.set(shapeA.id, shapeB.id, data);\n    }\n};\n\nOverlapKeeper.prototype.getNewOverlaps = function(result){\n    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, result);\n};\n\nOverlapKeeper.prototype.getEndOverlaps = function(result){\n    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, result);\n};\n\n/**\n * Checks if two bodies are currently overlapping.\n * @method bodiesAreOverlapping\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {boolean}\n */\nOverlapKeeper.prototype.bodiesAreOverlapping = function(bodyA, bodyB){\n    var current = this.overlappingShapesCurrentState;\n    var l = current.keys.length;\n    while(l--){\n        var key = current.keys[l];\n        var data = current.data[key];\n        if((data.bodyA === bodyA && data.bodyB === bodyB) || data.bodyA === bodyB && data.bodyB === bodyA){\n            return true;\n        }\n    }\n    return false;\n};\n\nOverlapKeeper.prototype.getDiff = function(dictA, dictB, result){\n    var result = result || [];\n    var last = dictA;\n    var current = dictB;\n\n    result.length = 0;\n\n    var l = current.keys.length;\n    while(l--){\n        var key = current.keys[l];\n        var data = current.data[key];\n\n        if(!data){\n            throw new Error('Key '+key+' had no data!');\n        }\n\n        var lastData = last.data[key];\n        if(!lastData){\n            // Not overlapping in last state, but in current.\n            result.push(data);\n        }\n    }\n\n    return result;\n};\n\nOverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB){\n    var idA = shapeA.id|0,\n        idB = shapeB.id|0;\n    var last = this.overlappingShapesLastState;\n    var current = this.overlappingShapesCurrentState;\n    // Not in last but in new\n    return !!!last.get(idA, idB) && !!current.get(idA, idB);\n};\n\nOverlapKeeper.prototype.getNewBodyOverlaps = function(result){\n    this.tmpArray1.length = 0;\n    var overlaps = this.getNewOverlaps(this.tmpArray1);\n    return this.getBodyDiff(overlaps, result);\n};\n\nOverlapKeeper.prototype.getEndBodyOverlaps = function(result){\n    this.tmpArray1.length = 0;\n    var overlaps = this.getEndOverlaps(this.tmpArray1);\n    return this.getBodyDiff(overlaps, result);\n};\n\nOverlapKeeper.prototype.getBodyDiff = function(overlaps, result){\n    result = result || [];\n    var accumulator = this.tmpDict;\n\n    var l = overlaps.length;\n\n    while(l--){\n        var data = overlaps[l];\n\n        // Since we use body id's for the accumulator, these will be a subset of the original one\n        accumulator.set(data.bodyA.id|0, data.bodyB.id|0, data);\n    }\n\n    l = accumulator.keys.length;\n    while(l--){\n        var data = accumulator.getByKey(accumulator.keys[l]);\n        if(data){\n            result.push(data.bodyA, data.bodyB);\n        }\n    }\n\n    accumulator.reset();\n\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL092ZXJsYXBLZWVwZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL092ZXJsYXBLZWVwZXIuanM/MzU3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVHVwbGVEaWN0aW9uYXJ5ID0gcmVxdWlyZSgnLi9UdXBsZURpY3Rpb25hcnknKTtcbnZhciBPdmVybGFwS2VlcGVyUmVjb3JkID0gcmVxdWlyZSgnLi9PdmVybGFwS2VlcGVyUmVjb3JkJyk7XG52YXIgT3ZlcmxhcEtlZXBlclJlY29yZFBvb2wgPSByZXF1aXJlKCcuL092ZXJsYXBLZWVwZXJSZWNvcmRQb29sJyk7XG52YXIgVXRpbHMgPSByZXF1aXJlKCcuL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT3ZlcmxhcEtlZXBlcjtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiBvdmVybGFwcyBpbiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgdGhlIGxhc3Qgc3RlcCBzdGF0ZS5cbiAqIEBjbGFzcyBPdmVybGFwS2VlcGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gT3ZlcmxhcEtlZXBlcigpIHtcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuICAgIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUgPSBuZXcgVHVwbGVEaWN0aW9uYXJ5KCk7XG4gICAgdGhpcy5yZWNvcmRQb29sID0gbmV3IE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sKHsgc2l6ZTogMTYgfSk7XG4gICAgdGhpcy50bXBEaWN0ID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuICAgIHRoaXMudG1wQXJyYXkxID0gW107XG59XG5cbi8qKlxuICogVGlja3Mgb25lIHN0ZXAgZm9yd2FyZCBpbiB0aW1lLiBUaGlzIHdpbGwgbW92ZSB0aGUgY3VycmVudCBvdmVybGFwIHN0YXRlIHRvIHRoZSBcIm9sZFwiIG92ZXJsYXAgc3RhdGUsIGFuZCBjcmVhdGUgYSBuZXcgb25lIGFzIGN1cnJlbnQuXG4gKiBAbWV0aG9kIHRpY2tcbiAqL1xuT3ZlcmxhcEtlZXBlci5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsYXN0ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZTtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGU7XG5cbiAgICAvLyBTYXZlIG9sZCBvYmplY3RzIGludG8gcG9vbFxuICAgIHZhciBsID0gbGFzdC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gbGFzdC5rZXlzW2xdO1xuICAgICAgICB2YXIgbGFzdE9iamVjdCA9IGxhc3QuZ2V0QnlLZXkoa2V5KTtcbiAgICAgICAgdmFyIGN1cnJlbnRPYmplY3QgPSBjdXJyZW50LmdldEJ5S2V5KGtleSk7XG4gICAgICAgIGlmKGxhc3RPYmplY3Qpe1xuICAgICAgICAgICAgLy8gVGhlIHJlY29yZCBpcyBvbmx5IHVzZWQgaW4gdGhlIFwibGFzdFwiIGRpY3QsIGFuZCB3aWxsIGJlIHJlbW92ZWQuIFdlIG1pZ2h0IGFzIHdlbGwgcG9vbCBpdC5cbiAgICAgICAgICAgIHRoaXMucmVjb3JkUG9vbC5yZWxlYXNlKGxhc3RPYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgbGFzdCBvYmplY3RcbiAgICBsYXN0LnJlc2V0KCk7XG5cbiAgICAvLyBUcmFuc2ZlciBmcm9tIG5ldyBvYmplY3QgdG8gb2xkXG4gICAgbGFzdC5jb3B5KGN1cnJlbnQpO1xuXG4gICAgLy8gQ2xlYXIgY3VycmVudCBvYmplY3RcbiAgICBjdXJyZW50LnJlc2V0KCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0T3ZlcmxhcHBpbmdcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gc2hhcGVBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge0JvZHl9IHNoYXBlQlxuICovXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5zZXRPdmVybGFwcGluZyA9IGZ1bmN0aW9uKGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpIHtcbiAgICB2YXIgbGFzdCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuXG4gICAgLy8gU3RvcmUgY3VycmVudCBjb250YWN0IHN0YXRlXG4gICAgaWYoIWN1cnJlbnQuZ2V0KHNoYXBlQS5pZCwgc2hhcGVCLmlkKSl7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5yZWNvcmRQb29sLmdldCgpO1xuICAgICAgICBkYXRhLnNldChib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbiAgICAgICAgY3VycmVudC5zZXQoc2hhcGVBLmlkLCBzaGFwZUIuaWQsIGRhdGEpO1xuICAgIH1cbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldE5ld092ZXJsYXBzID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICByZXR1cm4gdGhpcy5nZXREaWZmKHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNMYXN0U3RhdGUsIHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGUsIHJlc3VsdCk7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXRFbmRPdmVybGFwcyA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGlmZih0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlLCB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGJvZGllcyBhcmUgY3VycmVudGx5IG92ZXJsYXBwaW5nLlxuICogQG1ldGhvZCBib2RpZXNBcmVPdmVybGFwcGluZ1xuICogQHBhcmFtICB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5ib2RpZXNBcmVPdmVybGFwcGluZyA9IGZ1bmN0aW9uKGJvZHlBLCBib2R5Qil7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzQ3VycmVudFN0YXRlO1xuICAgIHZhciBsID0gY3VycmVudC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gY3VycmVudC5rZXlzW2xdO1xuICAgICAgICB2YXIgZGF0YSA9IGN1cnJlbnQuZGF0YVtrZXldO1xuICAgICAgICBpZigoZGF0YS5ib2R5QSA9PT0gYm9keUEgJiYgZGF0YS5ib2R5QiA9PT0gYm9keUIpIHx8IGRhdGEuYm9keUEgPT09IGJvZHlCICYmIGRhdGEuYm9keUIgPT09IGJvZHlBKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmdldERpZmYgPSBmdW5jdGlvbihkaWN0QSwgZGljdEIsIHJlc3VsdCl7XG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgICB2YXIgbGFzdCA9IGRpY3RBO1xuICAgIHZhciBjdXJyZW50ID0gZGljdEI7XG5cbiAgICByZXN1bHQubGVuZ3RoID0gMDtcblxuICAgIHZhciBsID0gY3VycmVudC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gY3VycmVudC5rZXlzW2xdO1xuICAgICAgICB2YXIgZGF0YSA9IGN1cnJlbnQuZGF0YVtrZXldO1xuXG4gICAgICAgIGlmKCFkYXRhKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5ICcra2V5KycgaGFkIG5vIGRhdGEhJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdERhdGEgPSBsYXN0LmRhdGFba2V5XTtcbiAgICAgICAgaWYoIWxhc3REYXRhKXtcbiAgICAgICAgICAgIC8vIE5vdCBvdmVybGFwcGluZyBpbiBsYXN0IHN0YXRlLCBidXQgaW4gY3VycmVudC5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk92ZXJsYXBLZWVwZXIucHJvdG90eXBlLmlzTmV3T3ZlcmxhcCA9IGZ1bmN0aW9uKHNoYXBlQSwgc2hhcGVCKXtcbiAgICB2YXIgaWRBID0gc2hhcGVBLmlkfDAsXG4gICAgICAgIGlkQiA9IHNoYXBlQi5pZHwwO1xuICAgIHZhciBsYXN0ID0gdGhpcy5vdmVybGFwcGluZ1NoYXBlc0xhc3RTdGF0ZTtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMub3ZlcmxhcHBpbmdTaGFwZXNDdXJyZW50U3RhdGU7XG4gICAgLy8gTm90IGluIGxhc3QgYnV0IGluIG5ld1xuICAgIHJldHVybiAhISFsYXN0LmdldChpZEEsIGlkQikgJiYgISFjdXJyZW50LmdldChpZEEsIGlkQik7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXROZXdCb2R5T3ZlcmxhcHMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMudG1wQXJyYXkxLmxlbmd0aCA9IDA7XG4gICAgdmFyIG92ZXJsYXBzID0gdGhpcy5nZXROZXdPdmVybGFwcyh0aGlzLnRtcEFycmF5MSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm9keURpZmYob3ZlcmxhcHMsIHJlc3VsdCk7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXRFbmRCb2R5T3ZlcmxhcHMgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMudG1wQXJyYXkxLmxlbmd0aCA9IDA7XG4gICAgdmFyIG92ZXJsYXBzID0gdGhpcy5nZXRFbmRPdmVybGFwcyh0aGlzLnRtcEFycmF5MSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm9keURpZmYob3ZlcmxhcHMsIHJlc3VsdCk7XG59O1xuXG5PdmVybGFwS2VlcGVyLnByb3RvdHlwZS5nZXRCb2R5RGlmZiA9IGZ1bmN0aW9uKG92ZXJsYXBzLCByZXN1bHQpe1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcbiAgICB2YXIgYWNjdW11bGF0b3IgPSB0aGlzLnRtcERpY3Q7XG5cbiAgICB2YXIgbCA9IG92ZXJsYXBzLmxlbmd0aDtcblxuICAgIHdoaWxlKGwtLSl7XG4gICAgICAgIHZhciBkYXRhID0gb3ZlcmxhcHNbbF07XG5cbiAgICAgICAgLy8gU2luY2Ugd2UgdXNlIGJvZHkgaWQncyBmb3IgdGhlIGFjY3VtdWxhdG9yLCB0aGVzZSB3aWxsIGJlIGEgc3Vic2V0IG9mIHRoZSBvcmlnaW5hbCBvbmVcbiAgICAgICAgYWNjdW11bGF0b3Iuc2V0KGRhdGEuYm9keUEuaWR8MCwgZGF0YS5ib2R5Qi5pZHwwLCBkYXRhKTtcbiAgICB9XG5cbiAgICBsID0gYWNjdW11bGF0b3Iua2V5cy5sZW5ndGg7XG4gICAgd2hpbGUobC0tKXtcbiAgICAgICAgdmFyIGRhdGEgPSBhY2N1bXVsYXRvci5nZXRCeUtleShhY2N1bXVsYXRvci5rZXlzW2xdKTtcbiAgICAgICAgaWYoZGF0YSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXRhLmJvZHlBLCBkYXRhLmJvZHlCKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFjY3VtdWxhdG9yLnJlc2V0KCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/utils/OverlapKeeper.js\n");

/***/ }),

/***/ "./node_modules/p2/src/utils/OverlapKeeperRecord.js":
/*!**********************************************************!*\
  !*** ./node_modules/p2/src/utils/OverlapKeeperRecord.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = OverlapKeeperRecord;\n\n/**\n * Overlap data container for the OverlapKeeper\n * @class OverlapKeeperRecord\n * @constructor\n * @param {Body} bodyA\n * @param {Shape} shapeA\n * @param {Body} bodyB\n * @param {Shape} shapeB\n */\nfunction OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB){\n    /**\n     * @property {Shape} shapeA\n     */\n    this.shapeA = shapeA;\n    /**\n     * @property {Shape} shapeB\n     */\n    this.shapeB = shapeB;\n    /**\n     * @property {Body} bodyA\n     */\n    this.bodyA = bodyA;\n    /**\n     * @property {Body} bodyB\n     */\n    this.bodyB = bodyB;\n}\n\n/**\n * Set the data for the record\n * @method set\n * @param {Body} bodyA\n * @param {Shape} shapeA\n * @param {Body} bodyB\n * @param {Shape} shapeB\n */\nOverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB){\n    OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL092ZXJsYXBLZWVwZXJSZWNvcmQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL092ZXJsYXBLZWVwZXJSZWNvcmQuanM/MGFlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXBLZWVwZXJSZWNvcmQ7XG5cbi8qKlxuICogT3ZlcmxhcCBkYXRhIGNvbnRhaW5lciBmb3IgdGhlIE92ZXJsYXBLZWVwZXJcbiAqIEBjbGFzcyBPdmVybGFwS2VlcGVyUmVjb3JkXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gKi9cbmZ1bmN0aW9uIE92ZXJsYXBLZWVwZXJSZWNvcmQoYm9keUEsIHNoYXBlQSwgYm9keUIsIHNoYXBlQil7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtTaGFwZX0gc2hhcGVBXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUEgPSBzaGFwZUE7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtTaGFwZX0gc2hhcGVCXG4gICAgICovXG4gICAgdGhpcy5zaGFwZUIgPSBzaGFwZUI7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5QVxuICAgICAqL1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlCXG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xufVxuXG4vKipcbiAqIFNldCB0aGUgZGF0YSBmb3IgdGhlIHJlY29yZFxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gKi9cbk92ZXJsYXBLZWVwZXJSZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGJvZHlBLCBzaGFwZUEsIGJvZHlCLCBzaGFwZUIpe1xuICAgIE92ZXJsYXBLZWVwZXJSZWNvcmQuY2FsbCh0aGlzLCBib2R5QSwgc2hhcGVBLCBib2R5Qiwgc2hhcGVCKTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/utils/OverlapKeeperRecord.js\n");

/***/ }),

/***/ "./node_modules/p2/src/utils/OverlapKeeperRecordPool.js":
/*!**************************************************************!*\
  !*** ./node_modules/p2/src/utils/OverlapKeeperRecordPool.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var OverlapKeeperRecord = __webpack_require__(/*! ./OverlapKeeperRecord */ \"./node_modules/p2/src/utils/OverlapKeeperRecord.js\");\nvar Pool = __webpack_require__(/*! ./Pool */ \"./node_modules/p2/src/utils/Pool.js\");\n\nmodule.exports = OverlapKeeperRecordPool;\n\n/**\n * @class\n */\nfunction OverlapKeeperRecordPool() {\n\tPool.apply(this, arguments);\n}\nOverlapKeeperRecordPool.prototype = new Pool();\nOverlapKeeperRecordPool.prototype.constructor = OverlapKeeperRecordPool;\n\n/**\n * @method create\n * @return {OverlapKeeperRecord}\n */\nOverlapKeeperRecordPool.prototype.create = function () {\n\treturn new OverlapKeeperRecord();\n};\n\n/**\n * @method destroy\n * @param {OverlapKeeperRecord} record\n * @return {OverlapKeeperRecordPool}\n */\nOverlapKeeperRecordPool.prototype.destroy = function (record) {\n\trecord.bodyA = record.bodyB = record.shapeA = record.shapeB = null;\n\treturn this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL092ZXJsYXBLZWVwZXJSZWNvcmRQb29sLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy91dGlscy9PdmVybGFwS2VlcGVyUmVjb3JkUG9vbC5qcz8wMzhlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBPdmVybGFwS2VlcGVyUmVjb3JkID0gcmVxdWlyZSgnLi9PdmVybGFwS2VlcGVyUmVjb3JkJyk7XG52YXIgUG9vbCA9IHJlcXVpcmUoJy4vUG9vbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sO1xuXG4vKipcbiAqIEBjbGFzc1xuICovXG5mdW5jdGlvbiBPdmVybGFwS2VlcGVyUmVjb3JkUG9vbCgpIHtcblx0UG9vbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuT3ZlcmxhcEtlZXBlclJlY29yZFBvb2wucHJvdG90eXBlID0gbmV3IFBvb2woKTtcbk92ZXJsYXBLZWVwZXJSZWNvcmRQb29sLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE92ZXJsYXBLZWVwZXJSZWNvcmRQb29sO1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlXG4gKiBAcmV0dXJuIHtPdmVybGFwS2VlcGVyUmVjb3JkfVxuICovXG5PdmVybGFwS2VlcGVyUmVjb3JkUG9vbC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gbmV3IE92ZXJsYXBLZWVwZXJSZWNvcmQoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkZXN0cm95XG4gKiBAcGFyYW0ge092ZXJsYXBLZWVwZXJSZWNvcmR9IHJlY29yZFxuICogQHJldHVybiB7T3ZlcmxhcEtlZXBlclJlY29yZFBvb2x9XG4gKi9cbk92ZXJsYXBLZWVwZXJSZWNvcmRQb29sLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHJlY29yZCkge1xuXHRyZWNvcmQuYm9keUEgPSByZWNvcmQuYm9keUIgPSByZWNvcmQuc2hhcGVBID0gcmVjb3JkLnNoYXBlQiA9IG51bGw7XG5cdHJldHVybiB0aGlzO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/utils/OverlapKeeperRecordPool.js\n");

/***/ }),

/***/ "./node_modules/p2/src/utils/Pool.js":
/*!*******************************************!*\
  !*** ./node_modules/p2/src/utils/Pool.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = Pool;\n\n/**\n * @class Object pooling utility.\n */\nfunction Pool(options) {\n\toptions = options || {};\n\n\t/**\n\t * @property {Array} objects\n\t * @type {Array}\n\t */\n\tthis.objects = [];\n\n\tif(options.size !== undefined){\n\t\tthis.resize(options.size);\n\t}\n}\n\n/**\n * @method resize\n * @param {number} size\n * @return {Pool} Self, for chaining\n */\nPool.prototype.resize = function (size) {\n\tvar objects = this.objects;\n\n\twhile (objects.length > size) {\n\t\tobjects.pop();\n\t}\n\n\twhile (objects.length < size) {\n\t\tobjects.push(this.create());\n\t}\n\n\treturn this;\n};\n\n/**\n * Get an object from the pool or create a new instance.\n * @method get\n * @return {Object}\n */\nPool.prototype.get = function () {\n\tvar objects = this.objects;\n\treturn objects.length ? objects.pop() : this.create();\n};\n\n/**\n * Clean up and put the object back into the pool for later use.\n * @method release\n * @param {Object} object\n * @return {Pool} Self for chaining\n */\nPool.prototype.release = function (object) {\n\tthis.destroy(object);\n\tthis.objects.push(object);\n\treturn this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL1Bvb2wuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL1Bvb2wuanM/MjYwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFBvb2w7XG5cbi8qKlxuICogQGNsYXNzIE9iamVjdCBwb29saW5nIHV0aWxpdHkuXG4gKi9cbmZ1bmN0aW9uIFBvb2wob3B0aW9ucykge1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHtBcnJheX0gb2JqZWN0c1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqL1xuXHR0aGlzLm9iamVjdHMgPSBbXTtcblxuXHRpZihvcHRpb25zLnNpemUgIT09IHVuZGVmaW5lZCl7XG5cdFx0dGhpcy5yZXNpemUob3B0aW9ucy5zaXplKTtcblx0fVxufVxuXG4vKipcbiAqIEBtZXRob2QgcmVzaXplXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxuICogQHJldHVybiB7UG9vbH0gU2VsZiwgZm9yIGNoYWluaW5nXG4gKi9cblBvb2wucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XG5cdHZhciBvYmplY3RzID0gdGhpcy5vYmplY3RzO1xuXG5cdHdoaWxlIChvYmplY3RzLmxlbmd0aCA+IHNpemUpIHtcblx0XHRvYmplY3RzLnBvcCgpO1xuXHR9XG5cblx0d2hpbGUgKG9iamVjdHMubGVuZ3RoIDwgc2l6ZSkge1xuXHRcdG9iamVjdHMucHVzaCh0aGlzLmNyZWF0ZSgpKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IGZyb20gdGhlIHBvb2wgb3IgY3JlYXRlIGEgbmV3IGluc3RhbmNlLlxuICogQG1ldGhvZCBnZXRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuUG9vbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgb2JqZWN0cyA9IHRoaXMub2JqZWN0cztcblx0cmV0dXJuIG9iamVjdHMubGVuZ3RoID8gb2JqZWN0cy5wb3AoKSA6IHRoaXMuY3JlYXRlKCk7XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGFuZCBwdXQgdGhlIG9iamVjdCBiYWNrIGludG8gdGhlIHBvb2wgZm9yIGxhdGVyIHVzZS5cbiAqIEBtZXRob2QgcmVsZWFzZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7UG9vbH0gU2VsZiBmb3IgY2hhaW5pbmdcbiAqL1xuUG9vbC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcblx0dGhpcy5kZXN0cm95KG9iamVjdCk7XG5cdHRoaXMub2JqZWN0cy5wdXNoKG9iamVjdCk7XG5cdHJldHVybiB0aGlzO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/utils/Pool.js\n");

/***/ }),

/***/ "./node_modules/p2/src/utils/TupleDictionary.js":
/*!******************************************************!*\
  !*** ./node_modules/p2/src/utils/TupleDictionary.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Utils = __webpack_require__(/*! ./Utils */ \"./node_modules/p2/src/utils/Utils.js\");\n\nmodule.exports = TupleDictionary;\n\n/**\n * @class TupleDictionary\n * @constructor\n */\nfunction TupleDictionary() {\n\n    /**\n     * The data storage\n     * @property data\n     * @type {Object}\n     */\n    this.data = {};\n\n    /**\n     * Keys that are currently used.\n     * @property {Array} keys\n     */\n    this.keys = [];\n}\n\n/**\n * Generate a key given two integers\n * @method getKey\n * @param  {number} i\n * @param  {number} j\n * @return {string}\n */\nTupleDictionary.prototype.getKey = function(id1, id2) {\n    id1 = id1|0;\n    id2 = id2|0;\n\n    if ( (id1|0) === (id2|0) ){\n        return -1;\n    }\n\n    // valid for values < 2^16\n    return ((id1|0) > (id2|0) ?\n        (id1 << 16) | (id2 & 0xFFFF) :\n        (id2 << 16) | (id1 & 0xFFFF))|0\n        ;\n};\n\n/**\n * @method getByKey\n * @param  {Number} key\n * @return {Object}\n */\nTupleDictionary.prototype.getByKey = function(key) {\n    key = key|0;\n    return this.data[key];\n};\n\n/**\n * @method get\n * @param  {Number} i\n * @param  {Number} j\n * @return {Number}\n */\nTupleDictionary.prototype.get = function(i, j) {\n    return this.data[this.getKey(i, j)];\n};\n\n/**\n * Set a value.\n * @method set\n * @param  {Number} i\n * @param  {Number} j\n * @param {Number} value\n */\nTupleDictionary.prototype.set = function(i, j, value) {\n    if(!value){\n        throw new Error(\"No data!\");\n    }\n\n    var key = this.getKey(i, j);\n\n    // Check if key already exists\n    if(!this.data[key]){\n        this.keys.push(key);\n    }\n\n    this.data[key] = value;\n\n    return key;\n};\n\n/**\n * Remove all data.\n * @method reset\n */\nTupleDictionary.prototype.reset = function() {\n    var data = this.data,\n        keys = this.keys;\n\n    var l = keys.length;\n    while(l--) {\n        delete data[keys[l]];\n    }\n\n    keys.length = 0;\n};\n\n/**\n * Copy another TupleDictionary. Note that all data in this dictionary will be removed.\n * @method copy\n * @param {TupleDictionary} dict The TupleDictionary to copy into this one.\n */\nTupleDictionary.prototype.copy = function(dict) {\n    this.reset();\n    Utils.appendArray(this.keys, dict.keys);\n    var l = dict.keys.length;\n    while(l--){\n        var key = dict.keys[l];\n        this.data[key] = dict.data[key];\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL1R1cGxlRGljdGlvbmFyeS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvdXRpbHMvVHVwbGVEaWN0aW9uYXJ5LmpzPzg0ZDkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFV0aWxzID0gcmVxdWlyZSgnLi9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFR1cGxlRGljdGlvbmFyeTtcblxuLyoqXG4gKiBAY2xhc3MgVHVwbGVEaWN0aW9uYXJ5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVHVwbGVEaWN0aW9uYXJ5KCkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgc3RvcmFnZVxuICAgICAqIEBwcm9wZXJ0eSBkYXRhXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEtleXMgdGhhdCBhcmUgY3VycmVudGx5IHVzZWQuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0ga2V5c1xuICAgICAqL1xuICAgIHRoaXMua2V5cyA9IFtdO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IGdpdmVuIHR3byBpbnRlZ2Vyc1xuICogQG1ldGhvZCBnZXRLZXlcbiAqIEBwYXJhbSAge251bWJlcn0gaVxuICogQHBhcmFtICB7bnVtYmVyfSBqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24oaWQxLCBpZDIpIHtcbiAgICBpZDEgPSBpZDF8MDtcbiAgICBpZDIgPSBpZDJ8MDtcblxuICAgIGlmICggKGlkMXwwKSA9PT0gKGlkMnwwKSApe1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLy8gdmFsaWQgZm9yIHZhbHVlcyA8IDJeMTZcbiAgICByZXR1cm4gKChpZDF8MCkgPiAoaWQyfDApID9cbiAgICAgICAgKGlkMSA8PCAxNikgfCAoaWQyICYgMHhGRkZGKSA6XG4gICAgICAgIChpZDIgPDwgMTYpIHwgKGlkMSAmIDB4RkZGRikpfDBcbiAgICAgICAgO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGdldEJ5S2V5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGtleVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldEJ5S2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAga2V5ID0ga2V5fDA7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtrZXldO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGdldFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpLCBqKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLmdldEtleShpLCBqKV07XG59O1xuXG4vKipcbiAqIFNldCBhIHZhbHVlLlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSBqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihpLCBqLCB2YWx1ZSkge1xuICAgIGlmKCF2YWx1ZSl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGRhdGEhXCIpO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShpLCBqKTtcblxuICAgIC8vIENoZWNrIGlmIGtleSBhbHJlYWR5IGV4aXN0c1xuICAgIGlmKCF0aGlzLmRhdGFba2V5XSl7XG4gICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcblxuICAgIHJldHVybiBrZXk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgZGF0YS5cbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICBrZXlzID0gdGhpcy5rZXlzO1xuXG4gICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pIHtcbiAgICAgICAgZGVsZXRlIGRhdGFba2V5c1tsXV07XG4gICAgfVxuXG4gICAga2V5cy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBDb3B5IGFub3RoZXIgVHVwbGVEaWN0aW9uYXJ5LiBOb3RlIHRoYXQgYWxsIGRhdGEgaW4gdGhpcyBkaWN0aW9uYXJ5IHdpbGwgYmUgcmVtb3ZlZC5cbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtIHtUdXBsZURpY3Rpb25hcnl9IGRpY3QgVGhlIFR1cGxlRGljdGlvbmFyeSB0byBjb3B5IGludG8gdGhpcyBvbmUuXG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGRpY3QpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgVXRpbHMuYXBwZW5kQXJyYXkodGhpcy5rZXlzLCBkaWN0LmtleXMpO1xuICAgIHZhciBsID0gZGljdC5rZXlzLmxlbmd0aDtcbiAgICB3aGlsZShsLS0pe1xuICAgICAgICB2YXIga2V5ID0gZGljdC5rZXlzW2xdO1xuICAgICAgICB0aGlzLmRhdGFba2V5XSA9IGRpY3QuZGF0YVtrZXldO1xuICAgIH1cbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/utils/TupleDictionary.js\n");

/***/ }),

/***/ "./node_modules/p2/src/utils/Utils.js":
/*!********************************************!*\
  !*** ./node_modules/p2/src/utils/Utils.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("/* global P2_ARRAY_TYPE */\n\nmodule.exports = Utils;\n\n/**\n * Misc utility functions\n * @class Utils\n * @constructor\n */\nfunction Utils(){}\n\n/**\n * Append the values in array b to the array a. See <a href=\"http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131\">this</a> for an explanation.\n * @method appendArray\n * @static\n * @param  {Array} a\n * @param  {Array} b\n */\nUtils.appendArray = function(a,b){\n    if (b.length < 150000) {\n        a.push.apply(a, b);\n    } else {\n        for (var i = 0, len = b.length; i !== len; ++i) {\n            a.push(b[i]);\n        }\n    }\n};\n\n/**\n * Garbage free Array.splice(). Does not allocate a new array.\n * @method splice\n * @static\n * @param  {Array} array\n * @param  {Number} index\n * @param  {Number} howmany\n */\nUtils.splice = function(array,index,howmany){\n    howmany = howmany || 1;\n    for (var i=index, len=array.length-howmany; i < len; i++){\n        array[i] = array[i + howmany];\n    }\n    array.length = len;\n};\n\n/**\n * The array type to use for internal numeric computations throughout the library. Float32Array is used if it is available, but falls back on Array. If you want to set array type manually, inject it via the global variable P2_ARRAY_TYPE. See example below.\n * @static\n * @property {function} ARRAY_TYPE\n * @example\n *     <script>\n *         <!-- Inject your preferred array type before loading p2.js -->\n *         P2_ARRAY_TYPE = Array;\n *     </script>\n *     <script src=\"p2.js\"></script>\n */\nif(typeof P2_ARRAY_TYPE !== 'undefined') {\n    Utils.ARRAY_TYPE = P2_ARRAY_TYPE;\n} else if (typeof Float32Array !== 'undefined'){\n    Utils.ARRAY_TYPE = Float32Array;\n} else {\n    Utils.ARRAY_TYPE = Array;\n}\n\n/**\n * Extend an object with the properties of another\n * @static\n * @method extend\n * @param  {object} a\n * @param  {object} b\n */\nUtils.extend = function(a,b){\n    for(var key in b){\n        a[key] = b[key];\n    }\n};\n\n/**\n * Extend an options object with default values.\n * @static\n * @method defaults\n * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.\n * @param  {object} defaults An object containing default values.\n * @return {object} The modified options object.\n */\nUtils.defaults = function(options, defaults){\n    options = options || {};\n    for(var key in defaults){\n        if(!(key in options)){\n            options[key] = defaults[key];\n        }\n    }\n    return options;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3V0aWxzL1V0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy91dGlscy9VdGlscy5qcz83Y2I3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBQMl9BUlJBWV9UWVBFICovXG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG5cbi8qKlxuICogTWlzYyB1dGlsaXR5IGZ1bmN0aW9uc1xuICogQGNsYXNzIFV0aWxzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVXRpbHMoKXt9XG5cbi8qKlxuICogQXBwZW5kIHRoZSB2YWx1ZXMgaW4gYXJyYXkgYiB0byB0aGUgYXJyYXkgYS4gU2VlIDxhIGhyZWY9XCJodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzNzQxMjYvaG93LXRvLWFwcGVuZC1hbi1hcnJheS10by1hbi1leGlzdGluZy1qYXZhc2NyaXB0LWFycmF5LzEzNzQxMzEjMTM3NDEzMVwiPnRoaXM8L2E+IGZvciBhbiBleHBsYW5hdGlvbi5cbiAqIEBtZXRob2QgYXBwZW5kQXJyYXlcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICovXG5VdGlscy5hcHBlbmRBcnJheSA9IGZ1bmN0aW9uKGEsYil7XG4gICAgaWYgKGIubGVuZ3RoIDwgMTUwMDAwKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYi5sZW5ndGg7IGkgIT09IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBhLnB1c2goYltpXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEdhcmJhZ2UgZnJlZSBBcnJheS5zcGxpY2UoKS4gRG9lcyBub3QgYWxsb2NhdGUgYSBuZXcgYXJyYXkuXG4gKiBAbWV0aG9kIHNwbGljZVxuICogQHN0YXRpY1xuICogQHBhcmFtICB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGhvd21hbnlcbiAqL1xuVXRpbHMuc3BsaWNlID0gZnVuY3Rpb24oYXJyYXksaW5kZXgsaG93bWFueSl7XG4gICAgaG93bWFueSA9IGhvd21hbnkgfHwgMTtcbiAgICBmb3IgKHZhciBpPWluZGV4LCBsZW49YXJyYXkubGVuZ3RoLWhvd21hbnk7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIGhvd21hbnldO1xuICAgIH1cbiAgICBhcnJheS5sZW5ndGggPSBsZW47XG59O1xuXG4vKipcbiAqIFRoZSBhcnJheSB0eXBlIHRvIHVzZSBmb3IgaW50ZXJuYWwgbnVtZXJpYyBjb21wdXRhdGlvbnMgdGhyb3VnaG91dCB0aGUgbGlicmFyeS4gRmxvYXQzMkFycmF5IGlzIHVzZWQgaWYgaXQgaXMgYXZhaWxhYmxlLCBidXQgZmFsbHMgYmFjayBvbiBBcnJheS4gSWYgeW91IHdhbnQgdG8gc2V0IGFycmF5IHR5cGUgbWFudWFsbHksIGluamVjdCBpdCB2aWEgdGhlIGdsb2JhbCB2YXJpYWJsZSBQMl9BUlJBWV9UWVBFLiBTZWUgZXhhbXBsZSBiZWxvdy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IEFSUkFZX1RZUEVcbiAqIEBleGFtcGxlXG4gKiAgICAgPHNjcmlwdD5cbiAqICAgICAgICAgPCEtLSBJbmplY3QgeW91ciBwcmVmZXJyZWQgYXJyYXkgdHlwZSBiZWZvcmUgbG9hZGluZyBwMi5qcyAtLT5cbiAqICAgICAgICAgUDJfQVJSQVlfVFlQRSA9IEFycmF5O1xuICogICAgIDwvc2NyaXB0PlxuICogICAgIDxzY3JpcHQgc3JjPVwicDIuanNcIj48L3NjcmlwdD5cbiAqL1xuaWYodHlwZW9mIFAyX0FSUkFZX1RZUEUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgVXRpbHMuQVJSQVlfVFlQRSA9IFAyX0FSUkFZX1RZUEU7XG59IGVsc2UgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKXtcbiAgICBVdGlscy5BUlJBWV9UWVBFID0gRmxvYXQzMkFycmF5O1xufSBlbHNlIHtcbiAgICBVdGlscy5BUlJBWV9UWVBFID0gQXJyYXk7XG59XG5cbi8qKlxuICogRXh0ZW5kIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIGFub3RoZXJcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0gIHtvYmplY3R9IGFcbiAqIEBwYXJhbSAge29iamVjdH0gYlxuICovXG5VdGlscy5leHRlbmQgPSBmdW5jdGlvbihhLGIpe1xuICAgIGZvcih2YXIga2V5IGluIGIpe1xuICAgICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxufTtcblxuLyoqXG4gKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZGVmYXVsdHNcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuIE1heSBiZSBmYWxzeTogaW4gdGhpcyBjYXNlLCBhIG5ldyBvYmplY3QgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRlZmF1bHRzIEFuIG9iamVjdCBjb250YWluaW5nIGRlZmF1bHQgdmFsdWVzLlxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgbW9kaWZpZWQgb3B0aW9ucyBvYmplY3QuXG4gKi9cblV0aWxzLmRlZmF1bHRzID0gZnVuY3Rpb24ob3B0aW9ucywgZGVmYXVsdHMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGZvcih2YXIga2V5IGluIGRlZmF1bHRzKXtcbiAgICAgICAgaWYoIShrZXkgaW4gb3B0aW9ucykpe1xuICAgICAgICAgICAgb3B0aW9uc1trZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/utils/Utils.js\n");

/***/ }),

/***/ "./node_modules/p2/src/world/Island.js":
/*!*********************************************!*\
  !*** ./node_modules/p2/src/world/Island.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Body = __webpack_require__(/*! ../objects/Body */ \"./node_modules/p2/src/objects/Body.js\");\n\nmodule.exports = Island;\n\n/**\n * An island of bodies connected with equations.\n * @class Island\n * @constructor\n */\nfunction Island(){\n\n    /**\n     * Current equations in this island.\n     * @property equations\n     * @type {Array}\n     */\n    this.equations = [];\n\n    /**\n     * Current bodies in this island.\n     * @property bodies\n     * @type {Array}\n     */\n    this.bodies = [];\n}\n\n/**\n * Clean this island from bodies and equations.\n * @method reset\n */\nIsland.prototype.reset = function(){\n    this.equations.length = this.bodies.length = 0;\n};\n\nvar bodyIds = [];\n\n/**\n * Get all unique bodies in this island.\n * @method getBodies\n * @return {Array} An array of Body\n */\nIsland.prototype.getBodies = function(result){\n    var bodies = result || [],\n        eqs = this.equations;\n    bodyIds.length = 0;\n    for(var i=0; i!==eqs.length; i++){\n        var eq = eqs[i];\n        if(bodyIds.indexOf(eq.bodyA.id)===-1){\n            bodies.push(eq.bodyA);\n            bodyIds.push(eq.bodyA.id);\n        }\n        if(bodyIds.indexOf(eq.bodyB.id)===-1){\n            bodies.push(eq.bodyB);\n            bodyIds.push(eq.bodyB.id);\n        }\n    }\n    return bodies;\n};\n\n/**\n * Check if the entire island wants to sleep.\n * @method wantsToSleep\n * @return {Boolean}\n */\nIsland.prototype.wantsToSleep = function(){\n    for(var i=0; i<this.bodies.length; i++){\n        var b = this.bodies[i];\n        if(b.type === Body.DYNAMIC && !b.wantsToSleep){\n            return false;\n        }\n    }\n    return true;\n};\n\n/**\n * Make all bodies in the island sleep.\n * @method sleep\n */\nIsland.prototype.sleep = function(){\n    for(var i=0; i<this.bodies.length; i++){\n        var b = this.bodies[i];\n        b.sleep();\n    }\n    return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3dvcmxkL0lzbGFuZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wMi9zcmMvd29ybGQvSXNsYW5kLmpzP2Q2NTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEJvZHkgPSByZXF1aXJlKCcuLi9vYmplY3RzL0JvZHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJc2xhbmQ7XG5cbi8qKlxuICogQW4gaXNsYW5kIG9mIGJvZGllcyBjb25uZWN0ZWQgd2l0aCBlcXVhdGlvbnMuXG4gKiBAY2xhc3MgSXNsYW5kXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSXNsYW5kKCl7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGVxdWF0aW9ucyBpbiB0aGlzIGlzbGFuZC5cbiAgICAgKiBAcHJvcGVydHkgZXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGJvZGllcyBpbiB0aGlzIGlzbGFuZC5cbiAgICAgKiBAcHJvcGVydHkgYm9kaWVzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYm9kaWVzID0gW107XG59XG5cbi8qKlxuICogQ2xlYW4gdGhpcyBpc2xhbmQgZnJvbSBib2RpZXMgYW5kIGVxdWF0aW9ucy5cbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuSXNsYW5kLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5lcXVhdGlvbnMubGVuZ3RoID0gdGhpcy5ib2RpZXMubGVuZ3RoID0gMDtcbn07XG5cbnZhciBib2R5SWRzID0gW107XG5cbi8qKlxuICogR2V0IGFsbCB1bmlxdWUgYm9kaWVzIGluIHRoaXMgaXNsYW5kLlxuICogQG1ldGhvZCBnZXRCb2RpZXNcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBCb2R5XG4gKi9cbklzbGFuZC5wcm90b3R5cGUuZ2V0Qm9kaWVzID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB2YXIgYm9kaWVzID0gcmVzdWx0IHx8IFtdLFxuICAgICAgICBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBib2R5SWRzLmxlbmd0aCA9IDA7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1lcXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZXEgPSBlcXNbaV07XG4gICAgICAgIGlmKGJvZHlJZHMuaW5kZXhPZihlcS5ib2R5QS5pZCk9PT0tMSl7XG4gICAgICAgICAgICBib2RpZXMucHVzaChlcS5ib2R5QSk7XG4gICAgICAgICAgICBib2R5SWRzLnB1c2goZXEuYm9keUEuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGJvZHlJZHMuaW5kZXhPZihlcS5ib2R5Qi5pZCk9PT0tMSl7XG4gICAgICAgICAgICBib2RpZXMucHVzaChlcS5ib2R5Qik7XG4gICAgICAgICAgICBib2R5SWRzLnB1c2goZXEuYm9keUIuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib2RpZXM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBlbnRpcmUgaXNsYW5kIHdhbnRzIHRvIHNsZWVwLlxuICogQG1ldGhvZCB3YW50c1RvU2xlZXBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbklzbGFuZC5wcm90b3R5cGUud2FudHNUb1NsZWVwID0gZnVuY3Rpb24oKXtcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gdGhpcy5ib2RpZXNbaV07XG4gICAgICAgIGlmKGIudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmICFiLndhbnRzVG9TbGVlcCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIE1ha2UgYWxsIGJvZGllcyBpbiB0aGUgaXNsYW5kIHNsZWVwLlxuICogQG1ldGhvZCBzbGVlcFxuICovXG5Jc2xhbmQucHJvdG90eXBlLnNsZWVwID0gZnVuY3Rpb24oKXtcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gdGhpcy5ib2RpZXNbaV07XG4gICAgICAgIGIuc2xlZXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/p2/src/world/Island.js\n");

/***/ }),

/***/ "./node_modules/p2/src/world/IslandManager.js":
/*!****************************************************!*\
  !*** ./node_modules/p2/src/world/IslandManager.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,   Island = __webpack_require__(/*! ./Island */ \"./node_modules/p2/src/world/Island.js\")\n,   IslandNode = __webpack_require__(/*! ./IslandNode */ \"./node_modules/p2/src/world/IslandNode.js\")\n,   IslandNodePool = __webpack_require__(/*! ./../utils/IslandNodePool */ \"./node_modules/p2/src/utils/IslandNodePool.js\")\n,   IslandPool = __webpack_require__(/*! ./../utils/IslandPool */ \"./node_modules/p2/src/utils/IslandPool.js\")\n,   Body = __webpack_require__(/*! ../objects/Body */ \"./node_modules/p2/src/objects/Body.js\");\n\nmodule.exports = IslandManager;\n\n/**\n * Splits the system of bodies and equations into independent islands\n *\n * @class IslandManager\n * @constructor\n * @param {Object} [options]\n * @extends Solver\n */\nfunction IslandManager(options){\n\n    /**\n     * @property nodePool\n     * @type {IslandNodePool}\n     */\n    this.nodePool = new IslandNodePool({ size: 16 });\n\n    /**\n     * @property islandPool\n     * @type {IslandPool}\n     */\n    this.islandPool = new IslandPool({ size: 8 });\n\n    /**\n     * The equations to split. Manually fill this array before running .split().\n     * @property {Array} equations\n     */\n    this.equations = [];\n\n    /**\n     * The resulting {{#crossLink \"Island\"}}{{/crossLink}}s.\n     * @property {Array} islands\n     */\n    this.islands = [];\n\n    /**\n     * The resulting graph nodes.\n     * @property {Array} nodes\n     */\n    this.nodes = [];\n\n    /**\n     * The node queue, used when traversing the graph of nodes.\n     * @private\n     * @property {Array} queue\n     */\n    this.queue = [];\n}\n\n/**\n * Get an unvisited node from a list of nodes.\n * @static\n * @method getUnvisitedNode\n * @param  {Array} nodes\n * @return {IslandNode|boolean} The node if found, else false.\n */\nIslandManager.getUnvisitedNode = function(nodes){\n    var Nnodes = nodes.length;\n    for(var i=0; i!==Nnodes; i++){\n        var node = nodes[i];\n        if(!node.visited && node.body.type === Body.DYNAMIC){\n            return node;\n        }\n    }\n    return false;\n};\n\n/**\n * Visit a node.\n * @method visit\n * @param  {IslandNode} node\n * @param  {Array} bds\n * @param  {Array} eqs\n */\nIslandManager.prototype.visit = function (node,bds,eqs){\n    bds.push(node.body);\n    var Neqs = node.equations.length;\n    for(var i=0; i!==Neqs; i++){\n        var eq = node.equations[i];\n        if(eqs.indexOf(eq) === -1){ // Already added?\n            eqs.push(eq);\n        }\n    }\n};\n\n/**\n * Runs the search algorithm, starting at a root node. The resulting bodies and equations will be stored in the provided arrays.\n * @method bfs\n * @param  {IslandNode} root The node to start from\n * @param  {Array} bds  An array to append resulting Bodies to.\n * @param  {Array} eqs  An array to append resulting Equations to.\n */\nIslandManager.prototype.bfs = function(root,bds,eqs){\n\n    // Reset the visit queue\n    var queue = this.queue;\n    queue.length = 0;\n\n    // Add root node to queue\n    queue.push(root);\n    root.visited = true;\n    this.visit(root,bds,eqs);\n\n    // Process all queued nodes\n    while(queue.length) {\n\n        // Get next node in the queue\n        var node = queue.pop();\n\n        // Visit unvisited neighboring nodes\n        var child;\n        while((child = IslandManager.getUnvisitedNode(node.neighbors))) {\n            child.visited = true;\n            this.visit(child,bds,eqs);\n\n            // Only visit the children of this node if it's dynamic\n            if(child.body.type === Body.DYNAMIC){\n                queue.push(child);\n            }\n        }\n    }\n};\n\n/**\n * Split the world into independent islands. The result is stored in .islands.\n * @method split\n * @param  {World} world\n * @return {Array} The generated islands\n */\nIslandManager.prototype.split = function(world){\n    var bodies = world.bodies,\n        nodes = this.nodes,\n        equations = this.equations;\n\n    // Move old nodes to the node pool\n    while(nodes.length){\n        this.nodePool.release(nodes.pop());\n    }\n\n    // Create needed nodes, reuse if possible\n    for(var i=0; i!==bodies.length; i++){\n        var node = this.nodePool.get();\n        node.body = bodies[i];\n        nodes.push(node);\n        // if(this.nodePool.length){\n        //     var node = this.nodePool.pop();\n        //     node.reset();\n        //     node.body = bodies[i];\n        //     nodes.push(node);\n        // } else {\n        //     nodes.push(new IslandNode(bodies[i]));\n        // }\n    }\n\n    // Add connectivity data. Each equation connects 2 bodies.\n    for(var k=0; k!==equations.length; k++){\n        var eq=equations[k],\n            i=bodies.indexOf(eq.bodyA),\n            j=bodies.indexOf(eq.bodyB),\n            ni=nodes[i],\n            nj=nodes[j];\n        ni.neighbors.push(nj);\n        nj.neighbors.push(ni);\n        ni.equations.push(eq);\n        nj.equations.push(eq);\n    }\n\n    // Move old islands to the island pool\n    var islands = this.islands;\n    for(var i=0; i<islands.length; i++){\n        this.islandPool.release(islands[i]);\n    }\n    islands.length = 0;\n\n    // Get islands\n    var child;\n    while((child = IslandManager.getUnvisitedNode(nodes))){\n\n        // Create new island\n        var island = this.islandPool.get();\n\n        // Get all equations and bodies in this island\n        this.bfs(child, island.bodies, island.equations);\n\n        islands.push(island);\n    }\n\n    return islands;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3dvcmxkL0lzbGFuZE1hbmFnZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL3dvcmxkL0lzbGFuZE1hbmFnZXIuanM/N2M0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdmVjMiA9IHJlcXVpcmUoJy4uL21hdGgvdmVjMicpXG4sICAgSXNsYW5kID0gcmVxdWlyZSgnLi9Jc2xhbmQnKVxuLCAgIElzbGFuZE5vZGUgPSByZXF1aXJlKCcuL0lzbGFuZE5vZGUnKVxuLCAgIElzbGFuZE5vZGVQb29sID0gcmVxdWlyZSgnLi8uLi91dGlscy9Jc2xhbmROb2RlUG9vbCcpXG4sICAgSXNsYW5kUG9vbCA9IHJlcXVpcmUoJy4vLi4vdXRpbHMvSXNsYW5kUG9vbCcpXG4sICAgQm9keSA9IHJlcXVpcmUoJy4uL29iamVjdHMvQm9keScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElzbGFuZE1hbmFnZXI7XG5cbi8qKlxuICogU3BsaXRzIHRoZSBzeXN0ZW0gb2YgYm9kaWVzIGFuZCBlcXVhdGlvbnMgaW50byBpbmRlcGVuZGVudCBpc2xhbmRzXG4gKlxuICogQGNsYXNzIElzbGFuZE1hbmFnZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGV4dGVuZHMgU29sdmVyXG4gKi9cbmZ1bmN0aW9uIElzbGFuZE1hbmFnZXIob3B0aW9ucyl7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbm9kZVBvb2xcbiAgICAgKiBAdHlwZSB7SXNsYW5kTm9kZVBvb2x9XG4gICAgICovXG4gICAgdGhpcy5ub2RlUG9vbCA9IG5ldyBJc2xhbmROb2RlUG9vbCh7IHNpemU6IDE2IH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGlzbGFuZFBvb2xcbiAgICAgKiBAdHlwZSB7SXNsYW5kUG9vbH1cbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZFBvb2wgPSBuZXcgSXNsYW5kUG9vbCh7IHNpemU6IDggfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXF1YXRpb25zIHRvIHNwbGl0LiBNYW51YWxseSBmaWxsIHRoaXMgYXJyYXkgYmVmb3JlIHJ1bm5pbmcgLnNwbGl0KCkuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZXF1YXRpb25zXG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcge3sjY3Jvc3NMaW5rIFwiSXNsYW5kXCJ9fXt7L2Nyb3NzTGlua319cy5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBpc2xhbmRzXG4gICAgICovXG4gICAgdGhpcy5pc2xhbmRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdWx0aW5nIGdyYXBoIG5vZGVzLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG5vZGVzXG4gICAgICovXG4gICAgdGhpcy5ub2RlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5vZGUgcXVldWUsIHVzZWQgd2hlbiB0cmF2ZXJzaW5nIHRoZSBncmFwaCBvZiBub2Rlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHF1ZXVlXG4gICAgICovXG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xufVxuXG4vKipcbiAqIEdldCBhbiB1bnZpc2l0ZWQgbm9kZSBmcm9tIGEgbGlzdCBvZiBub2Rlcy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2V0VW52aXNpdGVkTm9kZVxuICogQHBhcmFtICB7QXJyYXl9IG5vZGVzXG4gKiBAcmV0dXJuIHtJc2xhbmROb2RlfGJvb2xlYW59IFRoZSBub2RlIGlmIGZvdW5kLCBlbHNlIGZhbHNlLlxuICovXG5Jc2xhbmRNYW5hZ2VyLmdldFVudmlzaXRlZE5vZGUgPSBmdW5jdGlvbihub2Rlcyl7XG4gICAgdmFyIE5ub2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5ub2RlczsgaSsrKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYoIW5vZGUudmlzaXRlZCAmJiBub2RlLmJvZHkudHlwZSA9PT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogVmlzaXQgYSBub2RlLlxuICogQG1ldGhvZCB2aXNpdFxuICogQHBhcmFtICB7SXNsYW5kTm9kZX0gbm9kZVxuICogQHBhcmFtICB7QXJyYXl9IGJkc1xuICogQHBhcmFtICB7QXJyYXl9IGVxc1xuICovXG5Jc2xhbmRNYW5hZ2VyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIChub2RlLGJkcyxlcXMpe1xuICAgIGJkcy5wdXNoKG5vZGUuYm9keSk7XG4gICAgdmFyIE5lcXMgPSBub2RlLmVxdWF0aW9ucy5sZW5ndGg7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1OZXFzOyBpKyspe1xuICAgICAgICB2YXIgZXEgPSBub2RlLmVxdWF0aW9uc1tpXTtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YoZXEpID09PSAtMSl7IC8vIEFscmVhZHkgYWRkZWQ/XG4gICAgICAgICAgICBlcXMucHVzaChlcSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJ1bnMgdGhlIHNlYXJjaCBhbGdvcml0aG0sIHN0YXJ0aW5nIGF0IGEgcm9vdCBub2RlLiBUaGUgcmVzdWx0aW5nIGJvZGllcyBhbmQgZXF1YXRpb25zIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBwcm92aWRlZCBhcnJheXMuXG4gKiBAbWV0aG9kIGJmc1xuICogQHBhcmFtICB7SXNsYW5kTm9kZX0gcm9vdCBUaGUgbm9kZSB0byBzdGFydCBmcm9tXG4gKiBAcGFyYW0gIHtBcnJheX0gYmRzICBBbiBhcnJheSB0byBhcHBlbmQgcmVzdWx0aW5nIEJvZGllcyB0by5cbiAqIEBwYXJhbSAge0FycmF5fSBlcXMgIEFuIGFycmF5IHRvIGFwcGVuZCByZXN1bHRpbmcgRXF1YXRpb25zIHRvLlxuICovXG5Jc2xhbmRNYW5hZ2VyLnByb3RvdHlwZS5iZnMgPSBmdW5jdGlvbihyb290LGJkcyxlcXMpe1xuXG4gICAgLy8gUmVzZXQgdGhlIHZpc2l0IHF1ZXVlXG4gICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTtcbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgLy8gQWRkIHJvb3Qgbm9kZSB0byBxdWV1ZVxuICAgIHF1ZXVlLnB1c2gocm9vdCk7XG4gICAgcm9vdC52aXNpdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnZpc2l0KHJvb3QsYmRzLGVxcyk7XG5cbiAgICAvLyBQcm9jZXNzIGFsbCBxdWV1ZWQgbm9kZXNcbiAgICB3aGlsZShxdWV1ZS5sZW5ndGgpIHtcblxuICAgICAgICAvLyBHZXQgbmV4dCBub2RlIGluIHRoZSBxdWV1ZVxuICAgICAgICB2YXIgbm9kZSA9IHF1ZXVlLnBvcCgpO1xuXG4gICAgICAgIC8vIFZpc2l0IHVudmlzaXRlZCBuZWlnaGJvcmluZyBub2Rlc1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIHdoaWxlKChjaGlsZCA9IElzbGFuZE1hbmFnZXIuZ2V0VW52aXNpdGVkTm9kZShub2RlLm5laWdoYm9ycykpKSB7XG4gICAgICAgICAgICBjaGlsZC52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmlzaXQoY2hpbGQsYmRzLGVxcyk7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSBpZiBpdCdzIGR5bmFtaWNcbiAgICAgICAgICAgIGlmKGNoaWxkLmJvZHkudHlwZSA9PT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogU3BsaXQgdGhlIHdvcmxkIGludG8gaW5kZXBlbmRlbnQgaXNsYW5kcy4gVGhlIHJlc3VsdCBpcyBzdG9yZWQgaW4gLmlzbGFuZHMuXG4gKiBAbWV0aG9kIHNwbGl0XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZ2VuZXJhdGVkIGlzbGFuZHNcbiAqL1xuSXNsYW5kTWFuYWdlci5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgbm9kZXMgPSB0aGlzLm5vZGVzLFxuICAgICAgICBlcXVhdGlvbnMgPSB0aGlzLmVxdWF0aW9ucztcblxuICAgIC8vIE1vdmUgb2xkIG5vZGVzIHRvIHRoZSBub2RlIHBvb2xcbiAgICB3aGlsZShub2Rlcy5sZW5ndGgpe1xuICAgICAgICB0aGlzLm5vZGVQb29sLnJlbGVhc2Uobm9kZXMucG9wKCkpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZWVkZWQgbm9kZXMsIHJldXNlIGlmIHBvc3NpYmxlXG4gICAgZm9yKHZhciBpPTA7IGkhPT1ib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZVBvb2wuZ2V0KCk7XG4gICAgICAgIG5vZGUuYm9keSA9IGJvZGllc1tpXTtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgLy8gaWYodGhpcy5ub2RlUG9vbC5sZW5ndGgpe1xuICAgICAgICAvLyAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVQb29sLnBvcCgpO1xuICAgICAgICAvLyAgICAgbm9kZS5yZXNldCgpO1xuICAgICAgICAvLyAgICAgbm9kZS5ib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAvLyAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICAgIG5vZGVzLnB1c2gobmV3IElzbGFuZE5vZGUoYm9kaWVzW2ldKSk7XG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgY29ubmVjdGl2aXR5IGRhdGEuIEVhY2ggZXF1YXRpb24gY29ubmVjdHMgMiBib2RpZXMuXG4gICAgZm9yKHZhciBrPTA7IGshPT1lcXVhdGlvbnMubGVuZ3RoOyBrKyspe1xuICAgICAgICB2YXIgZXE9ZXF1YXRpb25zW2tdLFxuICAgICAgICAgICAgaT1ib2RpZXMuaW5kZXhPZihlcS5ib2R5QSksXG4gICAgICAgICAgICBqPWJvZGllcy5pbmRleE9mKGVxLmJvZHlCKSxcbiAgICAgICAgICAgIG5pPW5vZGVzW2ldLFxuICAgICAgICAgICAgbmo9bm9kZXNbal07XG4gICAgICAgIG5pLm5laWdoYm9ycy5wdXNoKG5qKTtcbiAgICAgICAgbmoubmVpZ2hib3JzLnB1c2gobmkpO1xuICAgICAgICBuaS5lcXVhdGlvbnMucHVzaChlcSk7XG4gICAgICAgIG5qLmVxdWF0aW9ucy5wdXNoKGVxKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIG9sZCBpc2xhbmRzIHRvIHRoZSBpc2xhbmQgcG9vbFxuICAgIHZhciBpc2xhbmRzID0gdGhpcy5pc2xhbmRzO1xuICAgIGZvcih2YXIgaT0wOyBpPGlzbGFuZHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmlzbGFuZFBvb2wucmVsZWFzZShpc2xhbmRzW2ldKTtcbiAgICB9XG4gICAgaXNsYW5kcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gR2V0IGlzbGFuZHNcbiAgICB2YXIgY2hpbGQ7XG4gICAgd2hpbGUoKGNoaWxkID0gSXNsYW5kTWFuYWdlci5nZXRVbnZpc2l0ZWROb2RlKG5vZGVzKSkpe1xuXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaXNsYW5kXG4gICAgICAgIHZhciBpc2xhbmQgPSB0aGlzLmlzbGFuZFBvb2wuZ2V0KCk7XG5cbiAgICAgICAgLy8gR2V0IGFsbCBlcXVhdGlvbnMgYW5kIGJvZGllcyBpbiB0aGlzIGlzbGFuZFxuICAgICAgICB0aGlzLmJmcyhjaGlsZCwgaXNsYW5kLmJvZGllcywgaXNsYW5kLmVxdWF0aW9ucyk7XG5cbiAgICAgICAgaXNsYW5kcy5wdXNoKGlzbGFuZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzbGFuZHM7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/world/IslandManager.js\n");

/***/ }),

/***/ "./node_modules/p2/src/world/IslandNode.js":
/*!*************************************************!*\
  !*** ./node_modules/p2/src/world/IslandNode.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = IslandNode;\n\n/**\n * Holds a body and keeps track of some additional properties needed for graph traversal.\n * @class IslandNode\n * @constructor\n * @param {Body} body\n */\nfunction IslandNode(body){\n\n\t/**\n\t * The body that is contained in this node.\n\t * @property {Body} body\n\t */\n    this.body = body;\n\n    /**\n     * Neighboring IslandNodes\n     * @property {Array} neighbors\n     */\n    this.neighbors = [];\n\n    /**\n     * Equations connected to this node.\n     * @property {Array} equations\n     */\n    this.equations = [];\n\n    /**\n     * If this node was visiting during the graph traversal.\n     * @property visited\n     * @type {Boolean}\n     */\n    this.visited = false;\n}\n\n/**\n * Clean this node from bodies and equations.\n * @method reset\n */\nIslandNode.prototype.reset = function(){\n    this.equations.length = 0;\n    this.neighbors.length = 0;\n    this.visited = false;\n    this.body = null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3dvcmxkL0lzbGFuZE5vZGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcDIvc3JjL3dvcmxkL0lzbGFuZE5vZGUuanM/Y2UxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IElzbGFuZE5vZGU7XG5cbi8qKlxuICogSG9sZHMgYSBib2R5IGFuZCBrZWVwcyB0cmFjayBvZiBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyBuZWVkZWQgZm9yIGdyYXBoIHRyYXZlcnNhbC5cbiAqIEBjbGFzcyBJc2xhbmROb2RlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5mdW5jdGlvbiBJc2xhbmROb2RlKGJvZHkpe1xuXG5cdC8qKlxuXHQgKiBUaGUgYm9keSB0aGF0IGlzIGNvbnRhaW5lZCBpbiB0aGlzIG5vZGUuXG5cdCAqIEBwcm9wZXJ0eSB7Qm9keX0gYm9keVxuXHQgKi9cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgLyoqXG4gICAgICogTmVpZ2hib3JpbmcgSXNsYW5kTm9kZXNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBuZWlnaGJvcnNcbiAgICAgKi9cbiAgICB0aGlzLm5laWdoYm9ycyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRXF1YXRpb25zIGNvbm5lY3RlZCB0byB0aGlzIG5vZGUuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZXF1YXRpb25zXG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgbm9kZSB3YXMgdmlzaXRpbmcgZHVyaW5nIHRoZSBncmFwaCB0cmF2ZXJzYWwuXG4gICAgICogQHByb3BlcnR5IHZpc2l0ZWRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBDbGVhbiB0aGlzIG5vZGUgZnJvbSBib2RpZXMgYW5kIGVxdWF0aW9ucy5cbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuSXNsYW5kTm9kZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5uZWlnaGJvcnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnZpc2l0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/p2/src/world/IslandNode.js\n");

/***/ }),

/***/ "./node_modules/p2/src/world/World.js":
/*!********************************************!*\
  !*** ./node_modules/p2/src/world/World.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var  GSSolver = __webpack_require__(/*! ../solver/GSSolver */ \"./node_modules/p2/src/solver/GSSolver.js\")\n,    Solver = __webpack_require__(/*! ../solver/Solver */ \"./node_modules/p2/src/solver/Solver.js\")\n,    Ray = __webpack_require__(/*! ../collision/Ray */ \"./node_modules/p2/src/collision/Ray.js\")\n,    vec2 = __webpack_require__(/*! ../math/vec2 */ \"./node_modules/p2/src/math/vec2.js\")\n,    Circle = __webpack_require__(/*! ../shapes/Circle */ \"./node_modules/p2/src/shapes/Circle.js\")\n,    Convex = __webpack_require__(/*! ../shapes/Convex */ \"./node_modules/p2/src/shapes/Convex.js\")\n,    Line = __webpack_require__(/*! ../shapes/Line */ \"./node_modules/p2/src/shapes/Line.js\")\n,    Plane = __webpack_require__(/*! ../shapes/Plane */ \"./node_modules/p2/src/shapes/Plane.js\")\n,    Capsule = __webpack_require__(/*! ../shapes/Capsule */ \"./node_modules/p2/src/shapes/Capsule.js\")\n,    Particle = __webpack_require__(/*! ../shapes/Particle */ \"./node_modules/p2/src/shapes/Particle.js\")\n,    EventEmitter = __webpack_require__(/*! ../events/EventEmitter */ \"./node_modules/p2/src/events/EventEmitter.js\")\n,    Body = __webpack_require__(/*! ../objects/Body */ \"./node_modules/p2/src/objects/Body.js\")\n,    Shape = __webpack_require__(/*! ../shapes/Shape */ \"./node_modules/p2/src/shapes/Shape.js\")\n,    LinearSpring = __webpack_require__(/*! ../objects/LinearSpring */ \"./node_modules/p2/src/objects/LinearSpring.js\")\n,    Material = __webpack_require__(/*! ../material/Material */ \"./node_modules/p2/src/material/Material.js\")\n,    ContactMaterial = __webpack_require__(/*! ../material/ContactMaterial */ \"./node_modules/p2/src/material/ContactMaterial.js\")\n,    DistanceConstraint = __webpack_require__(/*! ../constraints/DistanceConstraint */ \"./node_modules/p2/src/constraints/DistanceConstraint.js\")\n,    Constraint = __webpack_require__(/*! ../constraints/Constraint */ \"./node_modules/p2/src/constraints/Constraint.js\")\n,    LockConstraint = __webpack_require__(/*! ../constraints/LockConstraint */ \"./node_modules/p2/src/constraints/LockConstraint.js\")\n,    RevoluteConstraint = __webpack_require__(/*! ../constraints/RevoluteConstraint */ \"./node_modules/p2/src/constraints/RevoluteConstraint.js\")\n,    PrismaticConstraint = __webpack_require__(/*! ../constraints/PrismaticConstraint */ \"./node_modules/p2/src/constraints/PrismaticConstraint.js\")\n,    GearConstraint = __webpack_require__(/*! ../constraints/GearConstraint */ \"./node_modules/p2/src/constraints/GearConstraint.js\")\n,    pkg = __webpack_require__(/*! ../../package.json */ \"./node_modules/p2/package.json\")\n,    Broadphase = __webpack_require__(/*! ../collision/Broadphase */ \"./node_modules/p2/src/collision/Broadphase.js\")\n,    AABB = __webpack_require__(/*! ../collision/AABB */ \"./node_modules/p2/src/collision/AABB.js\")\n,    SAPBroadphase = __webpack_require__(/*! ../collision/SAPBroadphase */ \"./node_modules/p2/src/collision/SAPBroadphase.js\")\n,    Narrowphase = __webpack_require__(/*! ../collision/Narrowphase */ \"./node_modules/p2/src/collision/Narrowphase.js\")\n,    Utils = __webpack_require__(/*! ../utils/Utils */ \"./node_modules/p2/src/utils/Utils.js\")\n,    OverlapKeeper = __webpack_require__(/*! ../utils/OverlapKeeper */ \"./node_modules/p2/src/utils/OverlapKeeper.js\")\n,    IslandManager = __webpack_require__(/*! ./IslandManager */ \"./node_modules/p2/src/world/IslandManager.js\")\n,    RotationalSpring = __webpack_require__(/*! ../objects/RotationalSpring */ \"./node_modules/p2/src/objects/RotationalSpring.js\");\n\nmodule.exports = World;\n\n/**\n * The dynamics world, where all bodies and constraints live.\n *\n * @class World\n * @constructor\n * @param {Object} [options]\n * @param {Solver} [options.solver] Defaults to GSSolver.\n * @param {Array} [options.gravity] Defaults to y=-9.78.\n * @param {Broadphase} [options.broadphase] Defaults to SAPBroadphase\n * @param {Boolean} [options.islandSplit=true]\n * @extends EventEmitter\n *\n * @example\n *     var world = new World({\n *         gravity: [0, -10],\n *         broadphase: new SAPBroadphase()\n *     });\n *     world.addBody(new Body());\n */\nfunction World(options){\n    EventEmitter.apply(this);\n\n    options = options || {};\n\n    /**\n     * All springs in the world. To add a spring to the world, use {{#crossLink \"World/addSpring:method\"}}{{/crossLink}}.\n     *\n     * @property springs\n     * @type {Array}\n     */\n    this.springs = [];\n\n    /**\n     * All bodies in the world. To add a body to the world, use {{#crossLink \"World/addBody:method\"}}{{/crossLink}}.\n     * @property {Array} bodies\n     */\n    this.bodies = [];\n\n    /**\n     * Disabled body collision pairs. See {{#crossLink \"World/disableBodyCollision:method\"}}.\n     * @private\n     * @property {Array} disabledBodyCollisionPairs\n     */\n    this.disabledBodyCollisionPairs = [];\n\n    /**\n     * The solver used to satisfy constraints and contacts. Default is {{#crossLink \"GSSolver\"}}{{/crossLink}}.\n     * @property {Solver} solver\n     */\n    this.solver = options.solver || new GSSolver();\n\n    /**\n     * The narrowphase to use to generate contacts.\n     *\n     * @property narrowphase\n     * @type {Narrowphase}\n     */\n    this.narrowphase = new Narrowphase(this);\n\n    /**\n     * The island manager of this world.\n     * @property {IslandManager} islandManager\n     */\n    this.islandManager = new IslandManager();\n\n    /**\n     * Gravity in the world. This is applied on all bodies in the beginning of each step().\n     *\n     * @property gravity\n     * @type {Array}\n     */\n    this.gravity = vec2.fromValues(0, -9.78);\n    if(options.gravity){\n        vec2.copy(this.gravity, options.gravity);\n    }\n\n    /**\n     * Gravity to use when approximating the friction max force (mu*mass*gravity).\n     * @property {Number} frictionGravity\n     */\n    this.frictionGravity = vec2.length(this.gravity) || 10;\n\n    /**\n     * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.\n     * @property {Boolean} useWorldGravityAsFrictionGravity\n     * @default true\n     */\n    this.useWorldGravityAsFrictionGravity = true;\n\n    /**\n     * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.\n     * @property {Boolean} useFrictionGravityOnZeroGravity\n     * @default true\n     */\n    this.useFrictionGravityOnZeroGravity = true;\n\n    /**\n     * The broadphase algorithm to use.\n     *\n     * @property broadphase\n     * @type {Broadphase}\n     */\n    this.broadphase = options.broadphase || new SAPBroadphase();\n    this.broadphase.setWorld(this);\n\n    /**\n     * User-added constraints.\n     *\n     * @property constraints\n     * @type {Array}\n     */\n    this.constraints = [];\n\n    /**\n     * Dummy default material in the world, used in .defaultContactMaterial\n     * @property {Material} defaultMaterial\n     */\n    this.defaultMaterial = new Material();\n\n    /**\n     * The default contact material to use, if no contact material was set for the colliding materials.\n     * @property {ContactMaterial} defaultContactMaterial\n     */\n    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial,this.defaultMaterial);\n\n    /**\n     * For keeping track of what time step size we used last step\n     * @property lastTimeStep\n     * @type {Number}\n     */\n    this.lastTimeStep = 1/60;\n\n    /**\n     * Enable to automatically apply spring forces each step.\n     * @property applySpringForces\n     * @type {Boolean}\n     * @default true\n     */\n    this.applySpringForces = true;\n\n    /**\n     * Enable to automatically apply body damping each step.\n     * @property applyDamping\n     * @type {Boolean}\n     * @default true\n     */\n    this.applyDamping = true;\n\n    /**\n     * Enable to automatically apply gravity each step.\n     * @property applyGravity\n     * @type {Boolean}\n     * @default true\n     */\n    this.applyGravity = true;\n\n    /**\n     * Enable/disable constraint solving in each step.\n     * @property solveConstraints\n     * @type {Boolean}\n     * @default true\n     */\n    this.solveConstraints = true;\n\n    /**\n     * The ContactMaterials added to the World.\n     * @property contactMaterials\n     * @type {Array}\n     */\n    this.contactMaterials = [];\n\n    /**\n     * World time.\n     * @property time\n     * @type {Number}\n     */\n    this.time = 0.0;\n    this.accumulator = 0;\n\n    /**\n     * Is true during step().\n     * @property {Boolean} stepping\n     */\n    this.stepping = false;\n\n    /**\n     * Bodies that are scheduled to be removed at the end of the step.\n     * @property {Array} bodiesToBeRemoved\n     * @private\n     */\n    this.bodiesToBeRemoved = [];\n\n    /**\n     * Whether to enable island splitting. Island splitting can be an advantage for both precision and performance. See {{#crossLink \"IslandManager\"}}{{/crossLink}}.\n     * @property {Boolean} islandSplit\n     * @default true\n     */\n    this.islandSplit = typeof(options.islandSplit)!==\"undefined\" ? !!options.islandSplit : true;\n\n    /**\n     * Set to true if you want to the world to emit the \"impact\" event. Turning this off could improve performance.\n     * @property emitImpactEvent\n     * @type {Boolean}\n     * @default true\n     */\n    this.emitImpactEvent = true;\n\n    // Id counters\n    this._constraintIdCounter = 0;\n    this._bodyIdCounter = 0;\n\n    /**\n     * Fired after the step().\n     * @event postStep\n     */\n    this.postStepEvent = {\n        type : \"postStep\"\n    };\n\n    /**\n     * Fired when a body is added to the world.\n     * @event addBody\n     * @param {Body} body\n     */\n    this.addBodyEvent = {\n        type : \"addBody\",\n        body : null\n    };\n\n    /**\n     * Fired when a body is removed from the world.\n     * @event removeBody\n     * @param {Body} body\n     */\n    this.removeBodyEvent = {\n        type : \"removeBody\",\n        body : null\n    };\n\n    /**\n     * Fired when a spring is added to the world.\n     * @event addSpring\n     * @param {Spring} spring\n     */\n    this.addSpringEvent = {\n        type : \"addSpring\",\n        spring : null\n    };\n\n    /**\n     * Fired when a first contact is created between two bodies. This event is fired after the step has been done.\n     * @event impact\n     * @param {Body} bodyA\n     * @param {Body} bodyB\n     */\n    this.impactEvent = {\n        type: \"impact\",\n        bodyA : null,\n        bodyB : null,\n        shapeA : null,\n        shapeB : null,\n        contactEquation : null\n    };\n\n    /**\n     * Fired after the Broadphase has collected collision pairs in the world.\n     * Inside the event handler, you can modify the pairs array as you like, to\n     * prevent collisions between objects that you don't want.\n     * @event postBroadphase\n     * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.\n     */\n    this.postBroadphaseEvent = {\n        type: \"postBroadphase\",\n        pairs: null\n    };\n\n    /**\n     * How to deactivate bodies during simulation. Possible modes are: {{#crossLink \"World/NO_SLEEPING:property\"}}World.NO_SLEEPING{{/crossLink}}, {{#crossLink \"World/BODY_SLEEPING:property\"}}World.BODY_SLEEPING{{/crossLink}} and {{#crossLink \"World/ISLAND_SLEEPING:property\"}}World.ISLAND_SLEEPING{{/crossLink}}.\n     * If sleeping is enabled, you might need to {{#crossLink \"Body/wakeUp:method\"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink \"Body/allowSleep:property\"}}Body.allowSleep{{/crossLink}}.\n     * @property sleepMode\n     * @type {number}\n     * @default World.NO_SLEEPING\n     */\n    this.sleepMode = World.NO_SLEEPING;\n\n    /**\n     * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.\n     * @event beginContact\n     * @param {Shape} shapeA\n     * @param {Shape} shapeB\n     * @param {Body}  bodyA\n     * @param {Body}  bodyB\n     * @param {Array} contactEquations\n     */\n    this.beginContactEvent = {\n        type: \"beginContact\",\n        shapeA: null,\n        shapeB: null,\n        bodyA: null,\n        bodyB: null,\n        contactEquations: []\n    };\n\n    /**\n     * Fired when two shapes stop overlapping, after the narrowphase (during step).\n     * @event endContact\n     * @param {Shape} shapeA\n     * @param {Shape} shapeB\n     * @param {Body}  bodyA\n     * @param {Body}  bodyB\n     */\n    this.endContactEvent = {\n        type: \"endContact\",\n        shapeA: null,\n        shapeB: null,\n        bodyA: null,\n        bodyB: null\n    };\n\n    /**\n     * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.\n     * @event preSolve\n     * @param {Array} contactEquations  An array of contacts to be solved.\n     * @param {Array} frictionEquations An array of friction equations to be solved.\n     */\n    this.preSolveEvent = {\n        type: \"preSolve\",\n        contactEquations: null,\n        frictionEquations: null\n    };\n\n    // For keeping track of overlapping shapes\n    this.overlappingShapesLastState = { keys:[] };\n    this.overlappingShapesCurrentState = { keys:[] };\n\n    /**\n     * @property {OverlapKeeper} overlapKeeper\n     */\n    this.overlapKeeper = new OverlapKeeper();\n}\nWorld.prototype = new Object(EventEmitter.prototype);\nWorld.prototype.constructor = World;\n\n/**\n * Never deactivate bodies.\n * @static\n * @property {number} NO_SLEEPING\n */\nWorld.NO_SLEEPING = 1;\n\n/**\n * Deactivate individual bodies if they are sleepy.\n * @static\n * @property {number} BODY_SLEEPING\n */\nWorld.BODY_SLEEPING = 2;\n\n/**\n * Deactivates bodies that are in contact, if all of them are sleepy. Note that you must enable {{#crossLink \"World/islandSplit:property\"}}.islandSplit{{/crossLink}} for this to work.\n * @static\n * @property {number} ISLAND_SLEEPING\n */\nWorld.ISLAND_SLEEPING = 4;\n\n/**\n * Add a constraint to the simulation.\n *\n * @method addConstraint\n * @param {Constraint} constraint\n * @example\n *     var constraint = new LockConstraint(bodyA, bodyB);\n *     world.addConstraint(constraint);\n */\nWorld.prototype.addConstraint = function(constraint){\n    this.constraints.push(constraint);\n};\n\n/**\n * Add a ContactMaterial to the simulation.\n * @method addContactMaterial\n * @param {ContactMaterial} contactMaterial\n */\nWorld.prototype.addContactMaterial = function(contactMaterial){\n    this.contactMaterials.push(contactMaterial);\n};\n\n/**\n * Removes a contact material\n *\n * @method removeContactMaterial\n * @param {ContactMaterial} cm\n */\nWorld.prototype.removeContactMaterial = function(cm){\n    var idx = this.contactMaterials.indexOf(cm);\n    if(idx!==-1){\n        Utils.splice(this.contactMaterials,idx,1);\n    }\n};\n\n/**\n * Get a contact material given two materials\n * @method getContactMaterial\n * @param {Material} materialA\n * @param {Material} materialB\n * @return {ContactMaterial} The matching ContactMaterial, or false on fail.\n * @todo Use faster hash map to lookup from material id's\n */\nWorld.prototype.getContactMaterial = function(materialA,materialB){\n    var cmats = this.contactMaterials;\n    for(var i=0, N=cmats.length; i!==N; i++){\n        var cm = cmats[i];\n        if( (cm.materialA.id === materialA.id) && (cm.materialB.id === materialB.id) ||\n            (cm.materialA.id === materialB.id) && (cm.materialB.id === materialA.id) ){\n            return cm;\n        }\n    }\n    return false;\n};\n\n/**\n * Removes a constraint\n *\n * @method removeConstraint\n * @param {Constraint} constraint\n */\nWorld.prototype.removeConstraint = function(constraint){\n    var idx = this.constraints.indexOf(constraint);\n    if(idx!==-1){\n        Utils.splice(this.constraints,idx,1);\n    }\n};\n\nvar step_r = vec2.create(),\n    step_runit = vec2.create(),\n    step_u = vec2.create(),\n    step_f = vec2.create(),\n    step_fhMinv = vec2.create(),\n    step_velodt = vec2.create(),\n    step_mg = vec2.create(),\n    xiw = vec2.fromValues(0,0),\n    xjw = vec2.fromValues(0,0),\n    zero = vec2.fromValues(0,0),\n    interpvelo = vec2.fromValues(0,0);\n\n/**\n * Step the physics world forward in time.\n *\n * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.\n *\n * @method step\n * @param {Number} dt                       The fixed time step size to use.\n * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.\n * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.\n *\n * @example\n *     // Simple fixed timestepping without interpolation\n *     var fixedTimeStep = 1 / 60;\n *     var world = new World();\n *     var body = new Body({ mass: 1 });\n *     world.addBody(body);\n *\n *     function animate(){\n *         requestAnimationFrame(animate);\n *         world.step(fixedTimeStep);\n *         renderBody(body.position, body.angle);\n *     }\n *\n *     // Start animation loop\n *     requestAnimationFrame(animate);\n *\n * @example\n *     // Fixed timestepping with interpolation\n *     var maxSubSteps = 10;\n *     var lastTimeSeconds;\n *\n *     function animate(t){\n *         requestAnimationFrame(animate);\n *         timeSeconds = t / 1000;\n *         lastTimeSeconds = lastTimeSeconds || timeSeconds;\n *\n *         deltaTime = timeSeconds - lastTimeSeconds;\n *         world.step(fixedTimeStep, deltaTime, maxSubSteps);\n *\n *         renderBody(body.interpolatedPosition, body.interpolatedAngle);\n *     }\n *\n *     // Start animation loop\n *     requestAnimationFrame(animate);\n *\n * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n */\nWorld.prototype.step = function(dt,timeSinceLastCalled,maxSubSteps){\n    maxSubSteps = maxSubSteps || 10;\n    timeSinceLastCalled = timeSinceLastCalled || 0;\n\n    if(timeSinceLastCalled === 0){ // Fixed, simple stepping\n\n        this.internalStep(dt);\n\n        // Increment time\n        this.time += dt;\n\n    } else {\n\n        this.accumulator += timeSinceLastCalled;\n        var substeps = 0;\n        while (this.accumulator >= dt && substeps < maxSubSteps) {\n            // Do fixed steps to catch up\n            this.internalStep(dt);\n            this.time += dt;\n            this.accumulator -= dt;\n            substeps++;\n        }\n\n        var t = (this.accumulator % dt) / dt;\n        for(var j=0; j!==this.bodies.length; j++){\n            var b = this.bodies[j];\n            vec2.lerp(b.interpolatedPosition, b.previousPosition, b.position, t);\n            b.interpolatedAngle = b.previousAngle + t * (b.angle - b.previousAngle);\n        }\n    }\n};\n\nvar endOverlaps = [];\n\n/**\n * Make a fixed step.\n * @method internalStep\n * @param  {number} dt\n * @private\n */\nWorld.prototype.internalStep = function(dt){\n    this.stepping = true;\n\n    var that = this,\n        Nsprings = this.springs.length,\n        springs = this.springs,\n        bodies = this.bodies,\n        g = this.gravity,\n        solver = this.solver,\n        Nbodies = this.bodies.length,\n        broadphase = this.broadphase,\n        np = this.narrowphase,\n        constraints = this.constraints,\n        t0, t1,\n        fhMinv = step_fhMinv,\n        velodt = step_velodt,\n        mg = step_mg,\n        scale = vec2.scale,\n        add = vec2.add,\n        rotate = vec2.rotate,\n        islandManager = this.islandManager;\n\n    this.overlapKeeper.tick();\n\n    this.lastTimeStep = dt;\n\n    // Update approximate friction gravity.\n    if(this.useWorldGravityAsFrictionGravity){\n        var gravityLen = vec2.length(this.gravity);\n        if(!(gravityLen === 0 && this.useFrictionGravityOnZeroGravity)){\n            // Nonzero gravity. Use it.\n            this.frictionGravity = gravityLen;\n        }\n    }\n\n    // Add gravity to bodies\n    if(this.applyGravity){\n        for(var i=0; i!==Nbodies; i++){\n            var b = bodies[i],\n                fi = b.force;\n            if(b.type !== Body.DYNAMIC || b.sleepState === Body.SLEEPING){\n                continue;\n            }\n            vec2.scale(mg,g,b.mass*b.gravityScale); // F=m*g\n            add(fi,fi,mg);\n        }\n    }\n\n    // Add spring forces\n    if(this.applySpringForces){\n        for(var i=0; i!==Nsprings; i++){\n            var s = springs[i];\n            s.applyForce();\n        }\n    }\n\n    if(this.applyDamping){\n        for(var i=0; i!==Nbodies; i++){\n            var b = bodies[i];\n            if(b.type === Body.DYNAMIC){\n                b.applyDamping(dt);\n            }\n        }\n    }\n\n    // Broadphase\n    var result = broadphase.getCollisionPairs(this);\n\n    // Remove ignored collision pairs\n    var ignoredPairs = this.disabledBodyCollisionPairs;\n    for(var i=ignoredPairs.length-2; i>=0; i-=2){\n        for(var j=result.length-2; j>=0; j-=2){\n            if( (ignoredPairs[i]   === result[j] && ignoredPairs[i+1] === result[j+1]) ||\n                (ignoredPairs[i+1] === result[j] && ignoredPairs[i]   === result[j+1])){\n                result.splice(j,2);\n            }\n        }\n    }\n\n    // Remove constrained pairs with collideConnected == false\n    var Nconstraints = constraints.length;\n    for(i=0; i!==Nconstraints; i++){\n        var c = constraints[i];\n        if(!c.collideConnected){\n            for(var j=result.length-2; j>=0; j-=2){\n                if( (c.bodyA === result[j] && c.bodyB === result[j+1]) ||\n                    (c.bodyB === result[j] && c.bodyA === result[j+1])){\n                    result.splice(j,2);\n                }\n            }\n        }\n    }\n\n    // postBroadphase event\n    this.postBroadphaseEvent.pairs = result;\n    this.emit(this.postBroadphaseEvent);\n    this.postBroadphaseEvent.pairs = null;\n\n    // Narrowphase\n    np.reset(this);\n    for(var i=0, Nresults=result.length; i!==Nresults; i+=2){\n        var bi = result[i],\n            bj = result[i+1];\n\n        // Loop over all shapes of body i\n        for(var k=0, Nshapesi=bi.shapes.length; k!==Nshapesi; k++){\n            var si = bi.shapes[k],\n                xi = si.position,\n                ai = si.angle;\n\n            // All shapes of body j\n            for(var l=0, Nshapesj=bj.shapes.length; l!==Nshapesj; l++){\n                var sj = bj.shapes[l],\n                    xj = sj.position,\n                    aj = sj.angle;\n\n                var cm = this.defaultContactMaterial;\n                if(si.material && sj.material){\n                    var tmp = this.getContactMaterial(si.material,sj.material);\n                    if(tmp){\n                        cm = tmp;\n                    }\n                }\n\n                this.runNarrowphase(np,bi,si,xi,ai,bj,sj,xj,aj,cm,this.frictionGravity);\n            }\n        }\n    }\n\n    // Wake up bodies\n    for(var i=0; i!==Nbodies; i++){\n        var body = bodies[i];\n        if(body._wakeUpAfterNarrowphase){\n            body.wakeUp();\n            body._wakeUpAfterNarrowphase = false;\n        }\n    }\n\n    // Emit end overlap events\n    if(this.has('endContact')){\n        this.overlapKeeper.getEndOverlaps(endOverlaps);\n        var e = this.endContactEvent;\n        var l = endOverlaps.length;\n        while(l--){\n            var data = endOverlaps[l];\n            e.shapeA = data.shapeA;\n            e.shapeB = data.shapeB;\n            e.bodyA = data.bodyA;\n            e.bodyB = data.bodyB;\n            this.emit(e);\n        }\n        endOverlaps.length = 0;\n    }\n\n    var preSolveEvent = this.preSolveEvent;\n    preSolveEvent.contactEquations = np.contactEquations;\n    preSolveEvent.frictionEquations = np.frictionEquations;\n    this.emit(preSolveEvent);\n    preSolveEvent.contactEquations = preSolveEvent.frictionEquations = null;\n\n    // update constraint equations\n    var Nconstraints = constraints.length;\n    for(i=0; i!==Nconstraints; i++){\n        constraints[i].update();\n    }\n\n    if(np.contactEquations.length || np.frictionEquations.length || Nconstraints){\n        if(this.islandSplit){\n            // Split into islands\n            islandManager.equations.length = 0;\n            Utils.appendArray(islandManager.equations, np.contactEquations);\n            Utils.appendArray(islandManager.equations, np.frictionEquations);\n            for(i=0; i!==Nconstraints; i++){\n                Utils.appendArray(islandManager.equations, constraints[i].equations);\n            }\n            islandManager.split(this);\n\n            for(var i=0; i!==islandManager.islands.length; i++){\n                var island = islandManager.islands[i];\n                if(island.equations.length){\n                    solver.solveIsland(dt,island);\n                }\n            }\n\n        } else {\n\n            // Add contact equations to solver\n            solver.addEquations(np.contactEquations);\n            solver.addEquations(np.frictionEquations);\n\n            // Add user-defined constraint equations\n            for(i=0; i!==Nconstraints; i++){\n                solver.addEquations(constraints[i].equations);\n            }\n\n            if(this.solveConstraints){\n                solver.solve(dt,this);\n            }\n\n            solver.removeAllEquations();\n        }\n    }\n\n    // Step forward\n    for(var i=0; i!==Nbodies; i++){\n        var body = bodies[i];\n\n        // if(body.sleepState !== Body.SLEEPING && body.type !== Body.STATIC){\n        body.integrate(dt);\n        // }\n    }\n\n    // Reset force\n    for(var i=0; i!==Nbodies; i++){\n        bodies[i].setZeroForce();\n    }\n\n    // Emit impact event\n    if(this.emitImpactEvent && this.has('impact')){\n        var ev = this.impactEvent;\n        for(var i=0; i!==np.contactEquations.length; i++){\n            var eq = np.contactEquations[i];\n            if(eq.firstImpact){\n                ev.bodyA = eq.bodyA;\n                ev.bodyB = eq.bodyB;\n                ev.shapeA = eq.shapeA;\n                ev.shapeB = eq.shapeB;\n                ev.contactEquation = eq;\n                this.emit(ev);\n            }\n        }\n    }\n\n    // Sleeping update\n    if(this.sleepMode === World.BODY_SLEEPING){\n        for(i=0; i!==Nbodies; i++){\n            bodies[i].sleepTick(this.time, false, dt);\n        }\n    } else if(this.sleepMode === World.ISLAND_SLEEPING && this.islandSplit){\n\n        // Tell all bodies to sleep tick but dont sleep yet\n        for(i=0; i!==Nbodies; i++){\n            bodies[i].sleepTick(this.time, true, dt);\n        }\n\n        // Sleep islands\n        for(var i=0; i<this.islandManager.islands.length; i++){\n            var island = this.islandManager.islands[i];\n            if(island.wantsToSleep()){\n                island.sleep();\n            }\n        }\n    }\n\n    this.stepping = false;\n\n    // Remove bodies that are scheduled for removal\n    var bodiesToBeRemoved = this.bodiesToBeRemoved;\n    for(var i=0; i!==bodiesToBeRemoved.length; i++){\n        this.removeBody(bodiesToBeRemoved[i]);\n    }\n    bodiesToBeRemoved.length = 0;\n\n    this.emit(this.postStepEvent);\n};\n\n/**\n * Runs narrowphase for the shape pair i and j.\n * @method runNarrowphase\n * @param  {Narrowphase} np\n * @param  {Body} bi\n * @param  {Shape} si\n * @param  {Array} xi\n * @param  {Number} ai\n * @param  {Body} bj\n * @param  {Shape} sj\n * @param  {Array} xj\n * @param  {Number} aj\n * @param  {Number} mu\n */\nWorld.prototype.runNarrowphase = function(np,bi,si,xi,ai,bj,sj,xj,aj,cm,glen){\n\n    // Check collision groups and masks\n    if(!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)){\n        return;\n    }\n\n    // Get world position and angle of each shape\n    vec2.rotate(xiw, xi, bi.angle);\n    vec2.rotate(xjw, xj, bj.angle);\n    vec2.add(xiw, xiw, bi.position);\n    vec2.add(xjw, xjw, bj.position);\n    var aiw = ai + bi.angle;\n    var ajw = aj + bj.angle;\n\n    np.enableFriction = cm.friction > 0;\n    np.frictionCoefficient = cm.friction;\n    var reducedMass;\n    if(bi.type === Body.STATIC || bi.type === Body.KINEMATIC){\n        reducedMass = bj.mass;\n    } else if(bj.type === Body.STATIC || bj.type === Body.KINEMATIC){\n        reducedMass = bi.mass;\n    } else {\n        reducedMass = (bi.mass*bj.mass)/(bi.mass+bj.mass);\n    }\n    np.slipForce = cm.friction*glen*reducedMass;\n    np.restitution = cm.restitution;\n    np.surfaceVelocity = cm.surfaceVelocity;\n    np.frictionStiffness = cm.frictionStiffness;\n    np.frictionRelaxation = cm.frictionRelaxation;\n    np.stiffness = cm.stiffness;\n    np.relaxation = cm.relaxation;\n    np.contactSkinSize = cm.contactSkinSize;\n    np.enabledEquations = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;\n\n    var resolver = np[si.type | sj.type],\n        numContacts = 0;\n    if (resolver) {\n        var sensor = si.sensor || sj.sensor;\n        var numFrictionBefore = np.frictionEquations.length;\n        if (si.type < sj.type) {\n            numContacts = resolver.call(np, bi,si,xiw,aiw, bj,sj,xjw,ajw, sensor);\n        } else {\n            numContacts = resolver.call(np, bj,sj,xjw,ajw, bi,si,xiw,aiw, sensor);\n        }\n        var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;\n\n        if(numContacts){\n\n            if( bi.allowSleep &&\n                bi.type === Body.DYNAMIC &&\n                bi.sleepState  === Body.SLEEPING &&\n                bj.sleepState  === Body.AWAKE &&\n                bj.type !== Body.STATIC\n            ){\n                var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity,2);\n                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);\n                if(speedSquaredB >= speedLimitSquaredB*2){\n                    bi._wakeUpAfterNarrowphase = true;\n                }\n            }\n\n            if( bj.allowSleep &&\n                bj.type === Body.DYNAMIC &&\n                bj.sleepState  === Body.SLEEPING &&\n                bi.sleepState  === Body.AWAKE &&\n                bi.type !== Body.STATIC\n            ){\n                var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity,2);\n                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);\n                if(speedSquaredA >= speedLimitSquaredA*2){\n                    bj._wakeUpAfterNarrowphase = true;\n                }\n            }\n\n            this.overlapKeeper.setOverlapping(bi, si, bj, sj);\n            if(this.has('beginContact') && this.overlapKeeper.isNewOverlap(si, sj)){\n\n                // Report new shape overlap\n                var e = this.beginContactEvent;\n                e.shapeA = si;\n                e.shapeB = sj;\n                e.bodyA = bi;\n                e.bodyB = bj;\n\n                // Reset contact equations\n                e.contactEquations.length = 0;\n\n                if(typeof(numContacts)===\"number\"){\n                    for(var i=np.contactEquations.length-numContacts; i<np.contactEquations.length; i++){\n                        e.contactEquations.push(np.contactEquations[i]);\n                    }\n                }\n\n                this.emit(e);\n            }\n\n            // divide the max friction force by the number of contacts\n            if(typeof(numContacts)===\"number\" && numFrictionEquations > 1){ // Why divide by 1?\n                for(var i=np.frictionEquations.length-numFrictionEquations; i<np.frictionEquations.length; i++){\n                    var f = np.frictionEquations[i];\n                    f.setSlipForce(f.getSlipForce() / numFrictionEquations);\n                }\n            }\n        }\n    }\n\n};\n\n/**\n * Add a spring to the simulation\n *\n * @method addSpring\n * @param {Spring} spring\n */\nWorld.prototype.addSpring = function(spring){\n    this.springs.push(spring);\n    var evt = this.addSpringEvent;\n    evt.spring = spring;\n    this.emit(evt);\n    evt.spring = null;\n};\n\n/**\n * Remove a spring\n *\n * @method removeSpring\n * @param {Spring} spring\n */\nWorld.prototype.removeSpring = function(spring){\n    var idx = this.springs.indexOf(spring);\n    if(idx !== -1){\n        Utils.splice(this.springs,idx,1);\n    }\n};\n\n/**\n * Add a body to the simulation\n *\n * @method addBody\n * @param {Body} body\n *\n * @example\n *     var world = new World(),\n *         body = new Body();\n *     world.addBody(body);\n * @todo What if this is done during step?\n */\nWorld.prototype.addBody = function(body){\n    if(this.bodies.indexOf(body) === -1){\n        this.bodies.push(body);\n        body.world = this;\n        var evt = this.addBodyEvent;\n        evt.body = body;\n        this.emit(evt);\n        evt.body = null;\n    }\n};\n\n/**\n * Remove a body from the simulation. If this method is called during step(), the body removal is scheduled to after the step.\n *\n * @method removeBody\n * @param {Body} body\n */\nWorld.prototype.removeBody = function(body){\n    if(this.stepping){\n        this.bodiesToBeRemoved.push(body);\n    } else {\n        body.world = null;\n        var idx = this.bodies.indexOf(body);\n        if(idx!==-1){\n            Utils.splice(this.bodies,idx,1);\n            this.removeBodyEvent.body = body;\n            body.resetConstraintVelocity();\n            this.emit(this.removeBodyEvent);\n            this.removeBodyEvent.body = null;\n        }\n    }\n};\n\n/**\n * Get a body by its id.\n * @method getBodyById\n * @param {number} id\n * @return {Body} The body, or false if it was not found.\n */\nWorld.prototype.getBodyById = function(id){\n    var bodies = this.bodies;\n    for(var i=0; i<bodies.length; i++){\n        var b = bodies[i];\n        if(b.id === id){\n            return b;\n        }\n    }\n    return false;\n};\n\n/**\n * Disable collision between two bodies\n * @method disableBodyCollision\n * @param {Body} bodyA\n * @param {Body} bodyB\n */\nWorld.prototype.disableBodyCollision = function(bodyA,bodyB){\n    this.disabledBodyCollisionPairs.push(bodyA,bodyB);\n};\n\n/**\n * Enable collisions between the given two bodies\n * @method enableBodyCollision\n * @param {Body} bodyA\n * @param {Body} bodyB\n */\nWorld.prototype.enableBodyCollision = function(bodyA,bodyB){\n    var pairs = this.disabledBodyCollisionPairs;\n    for(var i=0; i<pairs.length; i+=2){\n        if((pairs[i] === bodyA && pairs[i+1] === bodyB) || (pairs[i+1] === bodyA && pairs[i] === bodyB)){\n            pairs.splice(i,2);\n            return;\n        }\n    }\n};\n\n/**\n * Resets the World, removes all bodies, constraints and springs.\n *\n * @method clear\n */\nWorld.prototype.clear = function(){\n\n    this.time = 0;\n\n    // Remove all solver equations\n    if(this.solver && this.solver.equations.length){\n        this.solver.removeAllEquations();\n    }\n\n    // Remove all constraints\n    var cs = this.constraints;\n    for(var i=cs.length-1; i>=0; i--){\n        this.removeConstraint(cs[i]);\n    }\n\n    // Remove all bodies\n    var bodies = this.bodies;\n    for(var i=bodies.length-1; i>=0; i--){\n        this.removeBody(bodies[i]);\n    }\n\n    // Remove all springs\n    var springs = this.springs;\n    for(var i=springs.length-1; i>=0; i--){\n        this.removeSpring(springs[i]);\n    }\n\n    // Remove all contact materials\n    var cms = this.contactMaterials;\n    for(var i=cms.length-1; i>=0; i--){\n        this.removeContactMaterial(cms[i]);\n    }\n\n    World.apply(this);\n};\n\nvar hitTest_tmp1 = vec2.create(),\n    hitTest_zero = vec2.fromValues(0,0),\n    hitTest_tmp2 = vec2.fromValues(0,0);\n\n/**\n * Test if a world point overlaps bodies\n * @method hitTest\n * @param  {Array}  worldPoint  Point to use for intersection tests\n * @param  {Array}  bodies      A list of objects to check for intersection\n * @param  {Number} precision   Used for matching against particles and lines. Adds some margin to these infinitesimal objects.\n * @return {Array}              Array of bodies that overlap the point\n * @todo Should use an api similar to the raycast function\n * @todo Should probably implement a .containsPoint method for all shapes. Would be more efficient\n * @todo Should use the broadphase\n */\nWorld.prototype.hitTest = function(worldPoint,bodies,precision){\n    precision = precision || 0;\n\n    // Create a dummy particle body with a particle shape to test against the bodies\n    var pb = new Body({ position:worldPoint }),\n        ps = new Particle(),\n        px = worldPoint,\n        pa = 0,\n        x = hitTest_tmp1,\n        zero = hitTest_zero,\n        tmp = hitTest_tmp2;\n    pb.addShape(ps);\n\n    var n = this.narrowphase,\n        result = [];\n\n    // Check bodies\n    for(var i=0, N=bodies.length; i!==N; i++){\n        var b = bodies[i];\n\n        for(var j=0, NS=b.shapes.length; j!==NS; j++){\n            var s = b.shapes[j];\n\n            // Get shape world position + angle\n            vec2.rotate(x, s.position, b.angle);\n            vec2.add(x, x, b.position);\n            var a = s.angle + b.angle;\n\n            if( (s instanceof Circle    && n.circleParticle  (b,s,x,a,     pb,ps,px,pa, true)) ||\n                (s instanceof Convex    && n.particleConvex  (pb,ps,px,pa, b,s,x,a,     true)) ||\n                (s instanceof Plane     && n.particlePlane   (pb,ps,px,pa, b,s,x,a,     true)) ||\n                (s instanceof Capsule   && n.particleCapsule (pb,ps,px,pa, b,s,x,a,     true)) ||\n                (s instanceof Particle  && vec2.squaredLength(vec2.sub(tmp,x,worldPoint)) < precision*precision)\n                ){\n                result.push(b);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Set the stiffness for all equations and contact materials.\n * @method setGlobalStiffness\n * @param {Number} stiffness\n */\nWorld.prototype.setGlobalStiffness = function(stiffness){\n\n    // Set for all constraints\n    var constraints = this.constraints;\n    for(var i=0; i !== constraints.length; i++){\n        var c = constraints[i];\n        for(var j=0; j !== c.equations.length; j++){\n            var eq = c.equations[j];\n            eq.stiffness = stiffness;\n            eq.needsUpdate = true;\n        }\n    }\n\n    // Set for all contact materials\n    var contactMaterials = this.contactMaterials;\n    for(var i=0; i !== contactMaterials.length; i++){\n        var c = contactMaterials[i];\n        c.stiffness = c.frictionStiffness = stiffness;\n    }\n\n    // Set for default contact material\n    var c = this.defaultContactMaterial;\n    c.stiffness = c.frictionStiffness = stiffness;\n};\n\n/**\n * Set the relaxation for all equations and contact materials.\n * @method setGlobalRelaxation\n * @param {Number} relaxation\n */\nWorld.prototype.setGlobalRelaxation = function(relaxation){\n\n    // Set for all constraints\n    for(var i=0; i !== this.constraints.length; i++){\n        var c = this.constraints[i];\n        for(var j=0; j !== c.equations.length; j++){\n            var eq = c.equations[j];\n            eq.relaxation = relaxation;\n            eq.needsUpdate = true;\n        }\n    }\n\n    // Set for all contact materials\n    for(var i=0; i !== this.contactMaterials.length; i++){\n        var c = this.contactMaterials[i];\n        c.relaxation = c.frictionRelaxation = relaxation;\n    }\n\n    // Set for default contact material\n    var c = this.defaultContactMaterial;\n    c.relaxation = c.frictionRelaxation = relaxation;\n};\n\nvar tmpAABB = new AABB();\nvar tmpArray = [];\n\n/**\n * Ray cast against all bodies in the world.\n * @method raycast\n * @param  {RaycastResult} result\n * @param  {Ray} ray\n * @return {boolean} True if any body was hit.\n *\n * @example\n *     var ray = new Ray({\n *         mode: Ray.CLOSEST, // or ANY\n *         from: [0, 0],\n *         to: [10, 0],\n *     });\n *     var result = new RaycastResult();\n *     world.raycast(result, ray);\n *\n *     // Get the hit point\n *     var hitPoint = vec2.create();\n *     result.getHitPoint(hitPoint, ray);\n *     console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));\n *\n * @example\n *     var ray = new Ray({\n *         mode: Ray.ALL,\n *         from: [0, 0],\n *         to: [10, 0],\n *         callback: function(result){\n *\n *             // Print some info about the hit\n *             console.log('Hit body and shape: ', result.body, result.shape);\n *\n *             // Get the hit point\n *             var hitPoint = vec2.create();\n *             result.getHitPoint(hitPoint, ray);\n *             console.log('Hit point: ', hitPoint[0], hitPoint[1], ' at distance ' + result.getHitDistance(ray));\n *\n *             // If you are happy with the hits you got this far, you can stop the traversal here:\n *             result.stop();\n *         }\n *     });\n *     var result = new RaycastResult();\n *     world.raycast(result, ray);\n */\nWorld.prototype.raycast = function(result, ray){\n\n    // Get all bodies within the ray AABB\n    ray.getAABB(tmpAABB);\n    this.broadphase.aabbQuery(this, tmpAABB, tmpArray);\n    ray.intersectBodies(result, tmpArray);\n    tmpArray.length = 0;\n\n    return result.hasHit();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcDIvc3JjL3dvcmxkL1dvcmxkLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3AyL3NyYy93b3JsZC9Xb3JsZC5qcz9jYzcyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciAgR1NTb2x2ZXIgPSByZXF1aXJlKCcuLi9zb2x2ZXIvR1NTb2x2ZXInKVxuLCAgICBTb2x2ZXIgPSByZXF1aXJlKCcuLi9zb2x2ZXIvU29sdmVyJylcbiwgICAgUmF5ID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL1JheScpXG4sICAgIHZlYzIgPSByZXF1aXJlKCcuLi9tYXRoL3ZlYzInKVxuLCAgICBDaXJjbGUgPSByZXF1aXJlKCcuLi9zaGFwZXMvQ2lyY2xlJylcbiwgICAgQ29udmV4ID0gcmVxdWlyZSgnLi4vc2hhcGVzL0NvbnZleCcpXG4sICAgIExpbmUgPSByZXF1aXJlKCcuLi9zaGFwZXMvTGluZScpXG4sICAgIFBsYW5lID0gcmVxdWlyZSgnLi4vc2hhcGVzL1BsYW5lJylcbiwgICAgQ2Fwc3VsZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9DYXBzdWxlJylcbiwgICAgUGFydGljbGUgPSByZXF1aXJlKCcuLi9zaGFwZXMvUGFydGljbGUnKVxuLCAgICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuLi9ldmVudHMvRXZlbnRFbWl0dGVyJylcbiwgICAgQm9keSA9IHJlcXVpcmUoJy4uL29iamVjdHMvQm9keScpXG4sICAgIFNoYXBlID0gcmVxdWlyZSgnLi4vc2hhcGVzL1NoYXBlJylcbiwgICAgTGluZWFyU3ByaW5nID0gcmVxdWlyZSgnLi4vb2JqZWN0cy9MaW5lYXJTcHJpbmcnKVxuLCAgICBNYXRlcmlhbCA9IHJlcXVpcmUoJy4uL21hdGVyaWFsL01hdGVyaWFsJylcbiwgICAgQ29udGFjdE1hdGVyaWFsID0gcmVxdWlyZSgnLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJylcbiwgICAgRGlzdGFuY2VDb25zdHJhaW50ID0gcmVxdWlyZSgnLi4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50JylcbiwgICAgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKVxuLCAgICBMb2NrQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JylcbiwgICAgUmV2b2x1dGVDb25zdHJhaW50ID0gcmVxdWlyZSgnLi4vY29uc3RyYWludHMvUmV2b2x1dGVDb25zdHJhaW50JylcbiwgICAgUHJpc21hdGljQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnRzL1ByaXNtYXRpY0NvbnN0cmFpbnQnKVxuLCAgICBHZWFyQ29uc3RyYWludCA9IHJlcXVpcmUoJy4uL2NvbnN0cmFpbnRzL0dlYXJDb25zdHJhaW50JylcbiwgICAgcGtnID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJylcbiwgICAgQnJvYWRwaGFzZSA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJylcbiwgICAgQUFCQiA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9BQUJCJylcbiwgICAgU0FQQnJvYWRwaGFzZSA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlJylcbiwgICAgTmFycm93cGhhc2UgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vTmFycm93cGhhc2UnKVxuLCAgICBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJylcbiwgICAgT3ZlcmxhcEtlZXBlciA9IHJlcXVpcmUoJy4uL3V0aWxzL092ZXJsYXBLZWVwZXInKVxuLCAgICBJc2xhbmRNYW5hZ2VyID0gcmVxdWlyZSgnLi9Jc2xhbmRNYW5hZ2VyJylcbiwgICAgUm90YXRpb25hbFNwcmluZyA9IHJlcXVpcmUoJy4uL29iamVjdHMvUm90YXRpb25hbFNwcmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmxkO1xuXG4vKipcbiAqIFRoZSBkeW5hbWljcyB3b3JsZCwgd2hlcmUgYWxsIGJvZGllcyBhbmQgY29uc3RyYWludHMgbGl2ZS5cbiAqXG4gKiBAY2xhc3MgV29ybGRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTb2x2ZXJ9IFtvcHRpb25zLnNvbHZlcl0gRGVmYXVsdHMgdG8gR1NTb2x2ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5ncmF2aXR5XSBEZWZhdWx0cyB0byB5PS05Ljc4LlxuICogQHBhcmFtIHtCcm9hZHBoYXNlfSBbb3B0aW9ucy5icm9hZHBoYXNlXSBEZWZhdWx0cyB0byBTQVBCcm9hZHBoYXNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzbGFuZFNwbGl0PXRydWVdXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZCh7XG4gKiAgICAgICAgIGdyYXZpdHk6IFswLCAtMTBdLFxuICogICAgICAgICBicm9hZHBoYXNlOiBuZXcgU0FQQnJvYWRwaGFzZSgpXG4gKiAgICAgfSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShuZXcgQm9keSgpKTtcbiAqL1xuZnVuY3Rpb24gV29ybGQob3B0aW9ucyl7XG4gICAgRXZlbnRFbWl0dGVyLmFwcGx5KHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBBbGwgc3ByaW5ncyBpbiB0aGUgd29ybGQuIFRvIGFkZCBhIHNwcmluZyB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRTcHJpbmc6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319LlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHNwcmluZ3NcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5zcHJpbmdzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBbGwgYm9kaWVzIGluIHRoZSB3b3JsZC4gVG8gYWRkIGEgYm9keSB0byB0aGUgd29ybGQsIHVzZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9hZGRCb2R5Om1ldGhvZFwifX17ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBib2RpZXNcbiAgICAgKi9cbiAgICB0aGlzLmJvZGllcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZWQgYm9keSBjb2xsaXNpb24gcGFpcnMuIFNlZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9kaXNhYmxlQm9keUNvbGxpc2lvbjptZXRob2RcIn19LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnNcbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGVkQm9keUNvbGxpc2lvblBhaXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc29sdmVyIHVzZWQgdG8gc2F0aXNmeSBjb25zdHJhaW50cyBhbmQgY29udGFjdHMuIERlZmF1bHQgaXMge3sjY3Jvc3NMaW5rIFwiR1NTb2x2ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHtTb2x2ZXJ9IHNvbHZlclxuICAgICAqL1xuICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgfHwgbmV3IEdTU29sdmVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFycm93cGhhc2UgdG8gdXNlIHRvIGdlbmVyYXRlIGNvbnRhY3RzLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IG5hcnJvd3BoYXNlXG4gICAgICogQHR5cGUge05hcnJvd3BoYXNlfVxuICAgICAqL1xuICAgIHRoaXMubmFycm93cGhhc2UgPSBuZXcgTmFycm93cGhhc2UodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaXNsYW5kIG1hbmFnZXIgb2YgdGhpcyB3b3JsZC5cbiAgICAgKiBAcHJvcGVydHkge0lzbGFuZE1hbmFnZXJ9IGlzbGFuZE1hbmFnZXJcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZE1hbmFnZXIgPSBuZXcgSXNsYW5kTWFuYWdlcigpO1xuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSBpbiB0aGUgd29ybGQuIFRoaXMgaXMgYXBwbGllZCBvbiBhbGwgYm9kaWVzIGluIHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBzdGVwKCkuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgZ3Jhdml0eVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmdyYXZpdHkgPSB2ZWMyLmZyb21WYWx1ZXMoMCwgLTkuNzgpO1xuICAgIGlmKG9wdGlvbnMuZ3Jhdml0eSl7XG4gICAgICAgIHZlYzIuY29weSh0aGlzLmdyYXZpdHksIG9wdGlvbnMuZ3Jhdml0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR3Jhdml0eSB0byB1c2Ugd2hlbiBhcHByb3hpbWF0aW5nIHRoZSBmcmljdGlvbiBtYXggZm9yY2UgKG11Km1hc3MqZ3Jhdml0eSkuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uR3Jhdml0eVxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25HcmF2aXR5ID0gdmVjMi5sZW5ndGgodGhpcy5ncmF2aXR5KSB8fCAxMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IC5mcmljdGlvbkdyYXZpdHkgdG8gYmUgYXV0b21hdGljYWxseSBzZXQgdG8gdGhlIGxlbmd0aCBvZiAuZ3Jhdml0eS5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGxlbmd0aCBvZiAuZ3Jhdml0eSBpcyB6ZXJvLCBhbmQgLnVzZVdvcmxkR3Jhdml0eUFzRnJpY3Rpb25HcmF2aXR5PXRydWUsIHRoZW4gc3dpdGNoIHRvIHVzaW5nIC5mcmljdGlvbkdyYXZpdHkgZm9yIGZyaWN0aW9uIGluc3RlYWQuIFRoaXMgZmFsbGJhY2sgaXMgdXNlZnVsIGZvciBncmF2aXR5bGVzcyBnYW1lcy5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHVzZUZyaWN0aW9uR3Jhdml0eU9uWmVyb0dyYXZpdHlcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy51c2VGcmljdGlvbkdyYXZpdHlPblplcm9HcmF2aXR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBicm9hZHBoYXNlIGFsZ29yaXRobSB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYnJvYWRwaGFzZVxuICAgICAqIEB0eXBlIHtCcm9hZHBoYXNlfVxuICAgICAqL1xuICAgIHRoaXMuYnJvYWRwaGFzZSA9IG9wdGlvbnMuYnJvYWRwaGFzZSB8fCBuZXcgU0FQQnJvYWRwaGFzZSgpO1xuICAgIHRoaXMuYnJvYWRwaGFzZS5zZXRXb3JsZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFVzZXItYWRkZWQgY29uc3RyYWludHMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb25zdHJhaW50cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRHVtbXkgZGVmYXVsdCBtYXRlcmlhbCBpbiB0aGUgd29ybGQsIHVzZWQgaW4gLmRlZmF1bHRDb250YWN0TWF0ZXJpYWxcbiAgICAgKiBAcHJvcGVydHkge01hdGVyaWFsfSBkZWZhdWx0TWF0ZXJpYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY29udGFjdCBtYXRlcmlhbCB0byB1c2UsIGlmIG5vIGNvbnRhY3QgbWF0ZXJpYWwgd2FzIHNldCBmb3IgdGhlIGNvbGxpZGluZyBtYXRlcmlhbHMuXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0TWF0ZXJpYWx9IGRlZmF1bHRDb250YWN0TWF0ZXJpYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwgPSBuZXcgQ29udGFjdE1hdGVyaWFsKHRoaXMuZGVmYXVsdE1hdGVyaWFsLHRoaXMuZGVmYXVsdE1hdGVyaWFsKTtcblxuICAgIC8qKlxuICAgICAqIEZvciBrZWVwaW5nIHRyYWNrIG9mIHdoYXQgdGltZSBzdGVwIHNpemUgd2UgdXNlZCBsYXN0IHN0ZXBcbiAgICAgKiBAcHJvcGVydHkgbGFzdFRpbWVTdGVwXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RUaW1lU3RlcCA9IDEvNjA7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBzcHJpbmcgZm9yY2VzIGVhY2ggc3RlcC5cbiAgICAgKiBAcHJvcGVydHkgYXBwbHlTcHJpbmdGb3JjZXNcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hcHBseVNwcmluZ0ZvcmNlcyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdG8gYXV0b21hdGljYWxseSBhcHBseSBib2R5IGRhbXBpbmcgZWFjaCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSBhcHBseURhbXBpbmdcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hcHBseURhbXBpbmcgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkgZ3Jhdml0eSBlYWNoIHN0ZXAuXG4gICAgICogQHByb3BlcnR5IGFwcGx5R3Jhdml0eVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5R3Jhdml0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUvZGlzYWJsZSBjb25zdHJhaW50IHNvbHZpbmcgaW4gZWFjaCBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSBzb2x2ZUNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMuc29sdmVDb25zdHJhaW50cyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgQ29udGFjdE1hdGVyaWFscyBhZGRlZCB0byB0aGUgV29ybGQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RNYXRlcmlhbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0TWF0ZXJpYWxzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZCB0aW1lLlxuICAgICAqIEBwcm9wZXJ0eSB0aW1lXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWUgPSAwLjA7XG4gICAgdGhpcy5hY2N1bXVsYXRvciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0cnVlIGR1cmluZyBzdGVwKCkuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzdGVwcGluZ1xuICAgICAqL1xuICAgIHRoaXMuc3RlcHBpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEJvZGllcyB0aGF0IGFyZSBzY2hlZHVsZWQgdG8gYmUgcmVtb3ZlZCBhdCB0aGUgZW5kIG9mIHRoZSBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGJvZGllc1RvQmVSZW1vdmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJvZGllc1RvQmVSZW1vdmVkID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBpc2xhbmQgc3BsaXR0aW5nLiBJc2xhbmQgc3BsaXR0aW5nIGNhbiBiZSBhbiBhZHZhbnRhZ2UgZm9yIGJvdGggcHJlY2lzaW9uIGFuZCBwZXJmb3JtYW5jZS4gU2VlIHt7I2Nyb3NzTGluayBcIklzbGFuZE1hbmFnZXJcIn19e3svY3Jvc3NMaW5rfX0uXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc2xhbmRTcGxpdFxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmlzbGFuZFNwbGl0ID0gdHlwZW9mKG9wdGlvbnMuaXNsYW5kU3BsaXQpIT09XCJ1bmRlZmluZWRcIiA/ICEhb3B0aW9ucy5pc2xhbmRTcGxpdCA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byB0aGUgd29ybGQgdG8gZW1pdCB0aGUgXCJpbXBhY3RcIiBldmVudC4gVHVybmluZyB0aGlzIG9mZiBjb3VsZCBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgICAqIEBwcm9wZXJ0eSBlbWl0SW1wYWN0RXZlbnRcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5lbWl0SW1wYWN0RXZlbnQgPSB0cnVlO1xuXG4gICAgLy8gSWQgY291bnRlcnNcbiAgICB0aGlzLl9jb25zdHJhaW50SWRDb3VudGVyID0gMDtcbiAgICB0aGlzLl9ib2R5SWRDb3VudGVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGFmdGVyIHRoZSBzdGVwKCkuXG4gICAgICogQGV2ZW50IHBvc3RTdGVwXG4gICAgICovXG4gICAgdGhpcy5wb3N0U3RlcEV2ZW50ID0ge1xuICAgICAgICB0eXBlIDogXCJwb3N0U3RlcFwiXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkQm9keVxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICAgICAqL1xuICAgIHRoaXMuYWRkQm9keUV2ZW50ID0ge1xuICAgICAgICB0eXBlIDogXCJhZGRCb2R5XCIsXG4gICAgICAgIGJvZHkgOiBudWxsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBib2R5IGlzIHJlbW92ZWQgZnJvbSB0aGUgd29ybGQuXG4gICAgICogQGV2ZW50IHJlbW92ZUJvZHlcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAgICAgKi9cbiAgICB0aGlzLnJlbW92ZUJvZHlFdmVudCA9IHtcbiAgICAgICAgdHlwZSA6IFwicmVtb3ZlQm9keVwiLFxuICAgICAgICBib2R5IDogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgc3ByaW5nIGlzIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkU3ByaW5nXG4gICAgICogQHBhcmFtIHtTcHJpbmd9IHNwcmluZ1xuICAgICAqL1xuICAgIHRoaXMuYWRkU3ByaW5nRXZlbnQgPSB7XG4gICAgICAgIHR5cGUgOiBcImFkZFNwcmluZ1wiLFxuICAgICAgICBzcHJpbmcgOiBudWxsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYSBmaXJzdCBjb250YWN0IGlzIGNyZWF0ZWQgYmV0d2VlbiB0d28gYm9kaWVzLiBUaGlzIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBzdGVwIGhhcyBiZWVuIGRvbmUuXG4gICAgICogQGV2ZW50IGltcGFjdFxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gICAgICovXG4gICAgdGhpcy5pbXBhY3RFdmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJpbXBhY3RcIixcbiAgICAgICAgYm9keUEgOiBudWxsLFxuICAgICAgICBib2R5QiA6IG51bGwsXG4gICAgICAgIHNoYXBlQSA6IG51bGwsXG4gICAgICAgIHNoYXBlQiA6IG51bGwsXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvbiA6IG51bGxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgYWZ0ZXIgdGhlIEJyb2FkcGhhc2UgaGFzIGNvbGxlY3RlZCBjb2xsaXNpb24gcGFpcnMgaW4gdGhlIHdvcmxkLlxuICAgICAqIEluc2lkZSB0aGUgZXZlbnQgaGFuZGxlciwgeW91IGNhbiBtb2RpZnkgdGhlIHBhaXJzIGFycmF5IGFzIHlvdSBsaWtlLCB0b1xuICAgICAqIHByZXZlbnQgY29sbGlzaW9ucyBiZXR3ZWVuIG9iamVjdHMgdGhhdCB5b3UgZG9uJ3Qgd2FudC5cbiAgICAgKiBAZXZlbnQgcG9zdEJyb2FkcGhhc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBBbiBhcnJheSBvZiBjb2xsaXNpb24gcGFpcnMuIElmIHRoaXMgYXJyYXkgaXMgW2JvZHkxLGJvZHkyLGJvZHkzLGJvZHk0XSwgdGhlbiB0aGUgYm9keSBwYWlycyAxLDIgYW5kIDMsNCB3b3VsZCBhZHZhbmNlIHRvIG5hcnJvd3BoYXNlLlxuICAgICAqL1xuICAgIHRoaXMucG9zdEJyb2FkcGhhc2VFdmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJwb3N0QnJvYWRwaGFzZVwiLFxuICAgICAgICBwYWlyczogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIb3cgdG8gZGVhY3RpdmF0ZSBib2RpZXMgZHVyaW5nIHNpbXVsYXRpb24uIFBvc3NpYmxlIG1vZGVzIGFyZToge3sjY3Jvc3NMaW5rIFwiV29ybGQvTk9fU0xFRVBJTkc6cHJvcGVydHlcIn19V29ybGQuTk9fU0xFRVBJTkd7ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiV29ybGQvQk9EWV9TTEVFUElORzpwcm9wZXJ0eVwifX1Xb3JsZC5CT0RZX1NMRUVQSU5He3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIldvcmxkL0lTTEFORF9TTEVFUElORzpwcm9wZXJ0eVwifX1Xb3JsZC5JU0xBTkRfU0xFRVBJTkd7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBJZiBzbGVlcGluZyBpcyBlbmFibGVkLCB5b3UgbWlnaHQgbmVlZCB0byB7eyNjcm9zc0xpbmsgXCJCb2R5L3dha2VVcDptZXRob2RcIn19d2FrZSB1cHt7L2Nyb3NzTGlua319IHRoZSBib2RpZXMgaWYgdGhleSBmYWxsIGFzbGVlcCB3aGVuIHRoZXkgc2hvdWxkbid0LiBJZiB5b3Ugd2FudCB0byBlbmFibGUgc2xlZXBpbmcgaW4gdGhlIHdvcmxkLCBidXQgd2FudCB0byBkaXNhYmxlIGl0IGZvciBhIHBhcnRpY3VsYXIgYm9keSwgc2VlIHt7I2Nyb3NzTGluayBcIkJvZHkvYWxsb3dTbGVlcDpwcm9wZXJ0eVwifX1Cb2R5LmFsbG93U2xlZXB7ey9jcm9zc0xpbmt9fS5cbiAgICAgKiBAcHJvcGVydHkgc2xlZXBNb2RlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBXb3JsZC5OT19TTEVFUElOR1xuICAgICAqL1xuICAgIHRoaXMuc2xlZXBNb2RlID0gV29ybGQuTk9fU0xFRVBJTkc7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHR3byBzaGFwZXMgc3RhcnRzIHN0YXJ0IHRvIG92ZXJsYXAuIEZpcmVkIGluIHRoZSBuYXJyb3dwaGFzZSwgZHVyaW5nIHN0ZXAuXG4gICAgICogQGV2ZW50IGJlZ2luQ29udGFjdFxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQVxuICAgICAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlQlxuICAgICAqIEBwYXJhbSB7Qm9keX0gIGJvZHlBXG4gICAgICogQHBhcmFtIHtCb2R5fSAgYm9keUJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb250YWN0RXF1YXRpb25zXG4gICAgICovXG4gICAgdGhpcy5iZWdpbkNvbnRhY3RFdmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJiZWdpbkNvbnRhY3RcIixcbiAgICAgICAgc2hhcGVBOiBudWxsLFxuICAgICAgICBzaGFwZUI6IG51bGwsXG4gICAgICAgIGJvZHlBOiBudWxsLFxuICAgICAgICBib2R5QjogbnVsbCxcbiAgICAgICAgY29udGFjdEVxdWF0aW9uczogW11cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0d28gc2hhcGVzIHN0b3Agb3ZlcmxhcHBpbmcsIGFmdGVyIHRoZSBuYXJyb3dwaGFzZSAoZHVyaW5nIHN0ZXApLlxuICAgICAqIEBldmVudCBlbmRDb250YWN0XG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVBXG4gICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVCXG4gICAgICogQHBhcmFtIHtCb2R5fSAgYm9keUFcbiAgICAgKiBAcGFyYW0ge0JvZHl9ICBib2R5QlxuICAgICAqL1xuICAgIHRoaXMuZW5kQ29udGFjdEV2ZW50ID0ge1xuICAgICAgICB0eXBlOiBcImVuZENvbnRhY3RcIixcbiAgICAgICAgc2hhcGVBOiBudWxsLFxuICAgICAgICBzaGFwZUI6IG51bGwsXG4gICAgICAgIGJvZHlBOiBudWxsLFxuICAgICAgICBib2R5QjogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBlcXVhdGlvbnMgYXJlIGFkZGVkIHRvIHRoZSBzb2x2ZXIgdG8gYmUgc29sdmVkLiBDYW4gYmUgdXNlZCB0byBjb250cm9sIHdoYXQgZXF1YXRpb25zIGdvZXMgaW50byB0aGUgc29sdmVyLlxuICAgICAqIEBldmVudCBwcmVTb2x2ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnRhY3RFcXVhdGlvbnMgIEFuIGFycmF5IG9mIGNvbnRhY3RzIHRvIGJlIHNvbHZlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmcmljdGlvbkVxdWF0aW9ucyBBbiBhcnJheSBvZiBmcmljdGlvbiBlcXVhdGlvbnMgdG8gYmUgc29sdmVkLlxuICAgICAqL1xuICAgIHRoaXMucHJlU29sdmVFdmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJwcmVTb2x2ZVwiLFxuICAgICAgICBjb250YWN0RXF1YXRpb25zOiBudWxsLFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uczogbnVsbFxuICAgIH07XG5cbiAgICAvLyBGb3Iga2VlcGluZyB0cmFjayBvZiBvdmVybGFwcGluZyBzaGFwZXNcbiAgICB0aGlzLm92ZXJsYXBwaW5nU2hhcGVzTGFzdFN0YXRlID0geyBrZXlzOltdIH07XG4gICAgdGhpcy5vdmVybGFwcGluZ1NoYXBlc0N1cnJlbnRTdGF0ZSA9IHsga2V5czpbXSB9O1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtPdmVybGFwS2VlcGVyfSBvdmVybGFwS2VlcGVyXG4gICAgICovXG4gICAgdGhpcy5vdmVybGFwS2VlcGVyID0gbmV3IE92ZXJsYXBLZWVwZXIoKTtcbn1cbldvcmxkLnByb3RvdHlwZSA9IG5ldyBPYmplY3QoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5Xb3JsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXb3JsZDtcblxuLyoqXG4gKiBOZXZlciBkZWFjdGl2YXRlIGJvZGllcy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT19TTEVFUElOR1xuICovXG5Xb3JsZC5OT19TTEVFUElORyA9IDE7XG5cbi8qKlxuICogRGVhY3RpdmF0ZSBpbmRpdmlkdWFsIGJvZGllcyBpZiB0aGV5IGFyZSBzbGVlcHkuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge251bWJlcn0gQk9EWV9TTEVFUElOR1xuICovXG5Xb3JsZC5CT0RZX1NMRUVQSU5HID0gMjtcblxuLyoqXG4gKiBEZWFjdGl2YXRlcyBib2RpZXMgdGhhdCBhcmUgaW4gY29udGFjdCwgaWYgYWxsIG9mIHRoZW0gYXJlIHNsZWVweS4gTm90ZSB0aGF0IHlvdSBtdXN0IGVuYWJsZSB7eyNjcm9zc0xpbmsgXCJXb3JsZC9pc2xhbmRTcGxpdDpwcm9wZXJ0eVwifX0uaXNsYW5kU3BsaXR7ey9jcm9zc0xpbmt9fSBmb3IgdGhpcyB0byB3b3JrLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtudW1iZXJ9IElTTEFORF9TTEVFUElOR1xuICovXG5Xb3JsZC5JU0xBTkRfU0xFRVBJTkcgPSA0O1xuXG4vKipcbiAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHNpbXVsYXRpb24uXG4gKlxuICogQG1ldGhvZCBhZGRDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgTG9ja0NvbnN0cmFpbnQoYm9keUEsIGJvZHlCKTtcbiAqICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnQpO1xuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQpe1xuICAgIHRoaXMuY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcbn07XG5cbi8qKlxuICogQWRkIGEgQ29udGFjdE1hdGVyaWFsIHRvIHRoZSBzaW11bGF0aW9uLlxuICogQG1ldGhvZCBhZGRDb250YWN0TWF0ZXJpYWxcbiAqIEBwYXJhbSB7Q29udGFjdE1hdGVyaWFsfSBjb250YWN0TWF0ZXJpYWxcbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKGNvbnRhY3RNYXRlcmlhbCl7XG4gICAgdGhpcy5jb250YWN0TWF0ZXJpYWxzLnB1c2goY29udGFjdE1hdGVyaWFsKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGNvbnRhY3QgbWF0ZXJpYWxcbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtDb250YWN0TWF0ZXJpYWx9IGNtXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVDb250YWN0TWF0ZXJpYWwgPSBmdW5jdGlvbihjbSl7XG4gICAgdmFyIGlkeCA9IHRoaXMuY29udGFjdE1hdGVyaWFscy5pbmRleE9mKGNtKTtcbiAgICBpZihpZHghPT0tMSl7XG4gICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLmNvbnRhY3RNYXRlcmlhbHMsaWR4LDEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGEgY29udGFjdCBtYXRlcmlhbCBnaXZlbiB0d28gbWF0ZXJpYWxzXG4gKiBAbWV0aG9kIGdldENvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtNYXRlcmlhbH0gbWF0ZXJpYWxBXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtYXRlcmlhbEJcbiAqIEByZXR1cm4ge0NvbnRhY3RNYXRlcmlhbH0gVGhlIG1hdGNoaW5nIENvbnRhY3RNYXRlcmlhbCwgb3IgZmFsc2Ugb24gZmFpbC5cbiAqIEB0b2RvIFVzZSBmYXN0ZXIgaGFzaCBtYXAgdG8gbG9va3VwIGZyb20gbWF0ZXJpYWwgaWQnc1xuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Q29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24obWF0ZXJpYWxBLG1hdGVyaWFsQil7XG4gICAgdmFyIGNtYXRzID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xuICAgIGZvcih2YXIgaT0wLCBOPWNtYXRzLmxlbmd0aDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBjbSA9IGNtYXRzW2ldO1xuICAgICAgICBpZiggKGNtLm1hdGVyaWFsQS5pZCA9PT0gbWF0ZXJpYWxBLmlkKSAmJiAoY20ubWF0ZXJpYWxCLmlkID09PSBtYXRlcmlhbEIuaWQpIHx8XG4gICAgICAgICAgICAoY20ubWF0ZXJpYWxBLmlkID09PSBtYXRlcmlhbEIuaWQpICYmIChjbS5tYXRlcmlhbEIuaWQgPT09IG1hdGVyaWFsQS5pZCkgKXtcbiAgICAgICAgICAgIHJldHVybiBjbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjb25zdHJhaW50XG4gKlxuICogQG1ldGhvZCByZW1vdmVDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNvbnN0cmFpbnRcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZUNvbnN0cmFpbnQgPSBmdW5jdGlvbihjb25zdHJhaW50KXtcbiAgICB2YXIgaWR4ID0gdGhpcy5jb25zdHJhaW50cy5pbmRleE9mKGNvbnN0cmFpbnQpO1xuICAgIGlmKGlkeCE9PS0xKXtcbiAgICAgICAgVXRpbHMuc3BsaWNlKHRoaXMuY29uc3RyYWludHMsaWR4LDEpO1xuICAgIH1cbn07XG5cbnZhciBzdGVwX3IgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfcnVuaXQgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfdSA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF9mID0gdmVjMi5jcmVhdGUoKSxcbiAgICBzdGVwX2ZoTWludiA9IHZlYzIuY3JlYXRlKCksXG4gICAgc3RlcF92ZWxvZHQgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHN0ZXBfbWcgPSB2ZWMyLmNyZWF0ZSgpLFxuICAgIHhpdyA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIHhqdyA9IHZlYzIuZnJvbVZhbHVlcygwLDApLFxuICAgIHplcm8gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBpbnRlcnB2ZWxvID0gdmVjMi5mcm9tVmFsdWVzKDAsMCk7XG5cbi8qKlxuICogU3RlcCB0aGUgcGh5c2ljcyB3b3JsZCBmb3J3YXJkIGluIHRpbWUuXG4gKlxuICogVGhlcmUgYXJlIHR3byBtb2Rlcy4gVGhlIHNpbXBsZSBtb2RlIGlzIGZpeGVkIHRpbWVzdGVwcGluZyB3aXRob3V0IGludGVycG9sYXRpb24uIEluIHRoaXMgY2FzZSB5b3Ugb25seSB1c2UgdGhlIGZpcnN0IGFyZ3VtZW50LiBUaGUgc2Vjb25kIGNhc2UgdXNlcyBpbnRlcnBvbGF0aW9uLiBJbiB0aGF0IHlvdSBhbHNvIHByb3ZpZGUgdGhlIHRpbWUgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IHVzZWQsIGFzIHdlbGwgYXMgdGhlIG1heGltdW0gZml4ZWQgdGltZXN0ZXBzIHRvIHRha2UuXG4gKlxuICogQG1ldGhvZCBzdGVwXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgICAgICAgICAgICAgICAgICAgICAgIFRoZSBmaXhlZCB0aW1lIHN0ZXAgc2l6ZSB0byB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW3RpbWVTaW5jZUxhc3RDYWxsZWQ9MF0gIFRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IGNhbGxlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4U3ViU3RlcHM9MTBdICAgICAgICAgTWF4aW11bSBudW1iZXIgb2YgZml4ZWQgc3RlcHMgdG8gdGFrZSBwZXIgZnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIFNpbXBsZSBmaXhlZCB0aW1lc3RlcHBpbmcgd2l0aG91dCBpbnRlcnBvbGF0aW9uXG4gKiAgICAgdmFyIGZpeGVkVGltZVN0ZXAgPSAxIC8gNjA7XG4gKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCk7XG4gKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcbiAqXG4gKiAgICAgZnVuY3Rpb24gYW5pbWF0ZSgpe1xuICogICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gKiAgICAgICAgIHdvcmxkLnN0ZXAoZml4ZWRUaW1lU3RlcCk7XG4gKiAgICAgICAgIHJlbmRlckJvZHkoYm9keS5wb3NpdGlvbiwgYm9keS5hbmdsZSk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBTdGFydCBhbmltYXRpb24gbG9vcFxuICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIEZpeGVkIHRpbWVzdGVwcGluZyB3aXRoIGludGVycG9sYXRpb25cbiAqICAgICB2YXIgbWF4U3ViU3RlcHMgPSAxMDtcbiAqICAgICB2YXIgbGFzdFRpbWVTZWNvbmRzO1xuICpcbiAqICAgICBmdW5jdGlvbiBhbmltYXRlKHQpe1xuICogICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gKiAgICAgICAgIHRpbWVTZWNvbmRzID0gdCAvIDEwMDA7XG4gKiAgICAgICAgIGxhc3RUaW1lU2Vjb25kcyA9IGxhc3RUaW1lU2Vjb25kcyB8fCB0aW1lU2Vjb25kcztcbiAqXG4gKiAgICAgICAgIGRlbHRhVGltZSA9IHRpbWVTZWNvbmRzIC0gbGFzdFRpbWVTZWNvbmRzO1xuICogICAgICAgICB3b3JsZC5zdGVwKGZpeGVkVGltZVN0ZXAsIGRlbHRhVGltZSwgbWF4U3ViU3RlcHMpO1xuICpcbiAqICAgICAgICAgcmVuZGVyQm9keShib2R5LmludGVycG9sYXRlZFBvc2l0aW9uLCBib2R5LmludGVycG9sYXRlZEFuZ2xlKTtcbiAqICAgICB9XG4gKlxuICogICAgIC8vIFN0YXJ0IGFuaW1hdGlvbiBsb29wXG4gKiAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICpcbiAqIEBzZWUgaHR0cDovL2J1bGxldHBoeXNpY3Mub3JnL21lZGlhd2lraS0xLjUuOC9pbmRleC5waHAvU3RlcHBpbmdfVGhlX1dvcmxkXG4gKi9cbldvcmxkLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24oZHQsdGltZVNpbmNlTGFzdENhbGxlZCxtYXhTdWJTdGVwcyl7XG4gICAgbWF4U3ViU3RlcHMgPSBtYXhTdWJTdGVwcyB8fCAxMDtcbiAgICB0aW1lU2luY2VMYXN0Q2FsbGVkID0gdGltZVNpbmNlTGFzdENhbGxlZCB8fCAwO1xuXG4gICAgaWYodGltZVNpbmNlTGFzdENhbGxlZCA9PT0gMCl7IC8vIEZpeGVkLCBzaW1wbGUgc3RlcHBpbmdcblxuICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IHRpbWVcbiAgICAgICAgdGhpcy50aW1lICs9IGR0O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLmFjY3VtdWxhdG9yICs9IHRpbWVTaW5jZUxhc3RDYWxsZWQ7XG4gICAgICAgIHZhciBzdWJzdGVwcyA9IDA7XG4gICAgICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IGR0ICYmIHN1YnN0ZXBzIDwgbWF4U3ViU3RlcHMpIHtcbiAgICAgICAgICAgIC8vIERvIGZpeGVkIHN0ZXBzIHRvIGNhdGNoIHVwXG4gICAgICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XG4gICAgICAgICAgICB0aGlzLnRpbWUgKz0gZHQ7XG4gICAgICAgICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IGR0O1xuICAgICAgICAgICAgc3Vic3RlcHMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gKHRoaXMuYWNjdW11bGF0b3IgJSBkdCkgLyBkdDtcbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT10aGlzLmJvZGllcy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuYm9kaWVzW2pdO1xuICAgICAgICAgICAgdmVjMi5sZXJwKGIuaW50ZXJwb2xhdGVkUG9zaXRpb24sIGIucHJldmlvdXNQb3NpdGlvbiwgYi5wb3NpdGlvbiwgdCk7XG4gICAgICAgICAgICBiLmludGVycG9sYXRlZEFuZ2xlID0gYi5wcmV2aW91c0FuZ2xlICsgdCAqIChiLmFuZ2xlIC0gYi5wcmV2aW91c0FuZ2xlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBlbmRPdmVybGFwcyA9IFtdO1xuXG4vKipcbiAqIE1ha2UgYSBmaXhlZCBzdGVwLlxuICogQG1ldGhvZCBpbnRlcm5hbFN0ZXBcbiAqIEBwYXJhbSAge251bWJlcn0gZHRcbiAqIEBwcml2YXRlXG4gKi9cbldvcmxkLnByb3RvdHlwZS5pbnRlcm5hbFN0ZXAgPSBmdW5jdGlvbihkdCl7XG4gICAgdGhpcy5zdGVwcGluZyA9IHRydWU7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIE5zcHJpbmdzID0gdGhpcy5zcHJpbmdzLmxlbmd0aCxcbiAgICAgICAgc3ByaW5ncyA9IHRoaXMuc3ByaW5ncyxcbiAgICAgICAgYm9kaWVzID0gdGhpcy5ib2RpZXMsXG4gICAgICAgIGcgPSB0aGlzLmdyYXZpdHksXG4gICAgICAgIHNvbHZlciA9IHRoaXMuc29sdmVyLFxuICAgICAgICBOYm9kaWVzID0gdGhpcy5ib2RpZXMubGVuZ3RoLFxuICAgICAgICBicm9hZHBoYXNlID0gdGhpcy5icm9hZHBoYXNlLFxuICAgICAgICBucCA9IHRoaXMubmFycm93cGhhc2UsXG4gICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyxcbiAgICAgICAgdDAsIHQxLFxuICAgICAgICBmaE1pbnYgPSBzdGVwX2ZoTWludixcbiAgICAgICAgdmVsb2R0ID0gc3RlcF92ZWxvZHQsXG4gICAgICAgIG1nID0gc3RlcF9tZyxcbiAgICAgICAgc2NhbGUgPSB2ZWMyLnNjYWxlLFxuICAgICAgICBhZGQgPSB2ZWMyLmFkZCxcbiAgICAgICAgcm90YXRlID0gdmVjMi5yb3RhdGUsXG4gICAgICAgIGlzbGFuZE1hbmFnZXIgPSB0aGlzLmlzbGFuZE1hbmFnZXI7XG5cbiAgICB0aGlzLm92ZXJsYXBLZWVwZXIudGljaygpO1xuXG4gICAgdGhpcy5sYXN0VGltZVN0ZXAgPSBkdDtcblxuICAgIC8vIFVwZGF0ZSBhcHByb3hpbWF0ZSBmcmljdGlvbiBncmF2aXR5LlxuICAgIGlmKHRoaXMudXNlV29ybGRHcmF2aXR5QXNGcmljdGlvbkdyYXZpdHkpe1xuICAgICAgICB2YXIgZ3Jhdml0eUxlbiA9IHZlYzIubGVuZ3RoKHRoaXMuZ3Jhdml0eSk7XG4gICAgICAgIGlmKCEoZ3Jhdml0eUxlbiA9PT0gMCAmJiB0aGlzLnVzZUZyaWN0aW9uR3Jhdml0eU9uWmVyb0dyYXZpdHkpKXtcbiAgICAgICAgICAgIC8vIE5vbnplcm8gZ3Jhdml0eS4gVXNlIGl0LlxuICAgICAgICAgICAgdGhpcy5mcmljdGlvbkdyYXZpdHkgPSBncmF2aXR5TGVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGdyYXZpdHkgdG8gYm9kaWVzXG4gICAgaWYodGhpcy5hcHBseUdyYXZpdHkpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgICAgICBmaSA9IGIuZm9yY2U7XG4gICAgICAgICAgICBpZihiLnR5cGUgIT09IEJvZHkuRFlOQU1JQyB8fCBiLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmVjMi5zY2FsZShtZyxnLGIubWFzcypiLmdyYXZpdHlTY2FsZSk7IC8vIEY9bSpnXG4gICAgICAgICAgICBhZGQoZmksZmksbWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIHNwcmluZyBmb3JjZXNcbiAgICBpZih0aGlzLmFwcGx5U3ByaW5nRm9yY2VzKXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1Oc3ByaW5nczsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzID0gc3ByaW5nc1tpXTtcbiAgICAgICAgICAgIHMuYXBwbHlGb3JjZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5hcHBseURhbXBpbmcpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgIGlmKGIudHlwZSA9PT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgICAgICAgICBiLmFwcGx5RGFtcGluZyhkdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCcm9hZHBoYXNlXG4gICAgdmFyIHJlc3VsdCA9IGJyb2FkcGhhc2UuZ2V0Q29sbGlzaW9uUGFpcnModGhpcyk7XG5cbiAgICAvLyBSZW1vdmUgaWdub3JlZCBjb2xsaXNpb24gcGFpcnNcbiAgICB2YXIgaWdub3JlZFBhaXJzID0gdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycztcbiAgICBmb3IodmFyIGk9aWdub3JlZFBhaXJzLmxlbmd0aC0yOyBpPj0wOyBpLT0yKXtcbiAgICAgICAgZm9yKHZhciBqPXJlc3VsdC5sZW5ndGgtMjsgaj49MDsgai09Mil7XG4gICAgICAgICAgICBpZiggKGlnbm9yZWRQYWlyc1tpXSAgID09PSByZXN1bHRbal0gJiYgaWdub3JlZFBhaXJzW2krMV0gPT09IHJlc3VsdFtqKzFdKSB8fFxuICAgICAgICAgICAgICAgIChpZ25vcmVkUGFpcnNbaSsxXSA9PT0gcmVzdWx0W2pdICYmIGlnbm9yZWRQYWlyc1tpXSAgID09PSByZXN1bHRbaisxXSkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaiwyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBjb25zdHJhaW5lZCBwYWlycyB3aXRoIGNvbGxpZGVDb25uZWN0ZWQgPT0gZmFsc2VcbiAgICB2YXIgTmNvbnN0cmFpbnRzID0gY29uc3RyYWludHMubGVuZ3RoO1xuICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgIHZhciBjID0gY29uc3RyYWludHNbaV07XG4gICAgICAgIGlmKCFjLmNvbGxpZGVDb25uZWN0ZWQpe1xuICAgICAgICAgICAgZm9yKHZhciBqPXJlc3VsdC5sZW5ndGgtMjsgaj49MDsgai09Mil7XG4gICAgICAgICAgICAgICAgaWYoIChjLmJvZHlBID09PSByZXN1bHRbal0gJiYgYy5ib2R5QiA9PT0gcmVzdWx0W2orMV0pIHx8XG4gICAgICAgICAgICAgICAgICAgIChjLmJvZHlCID09PSByZXN1bHRbal0gJiYgYy5ib2R5QSA9PT0gcmVzdWx0W2orMV0pKXtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNwbGljZShqLDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBvc3RCcm9hZHBoYXNlIGV2ZW50XG4gICAgdGhpcy5wb3N0QnJvYWRwaGFzZUV2ZW50LnBhaXJzID0gcmVzdWx0O1xuICAgIHRoaXMuZW1pdCh0aGlzLnBvc3RCcm9hZHBoYXNlRXZlbnQpO1xuICAgIHRoaXMucG9zdEJyb2FkcGhhc2VFdmVudC5wYWlycyA9IG51bGw7XG5cbiAgICAvLyBOYXJyb3dwaGFzZVxuICAgIG5wLnJlc2V0KHRoaXMpO1xuICAgIGZvcih2YXIgaT0wLCBOcmVzdWx0cz1yZXN1bHQubGVuZ3RoOyBpIT09TnJlc3VsdHM7IGkrPTIpe1xuICAgICAgICB2YXIgYmkgPSByZXN1bHRbaV0sXG4gICAgICAgICAgICBiaiA9IHJlc3VsdFtpKzFdO1xuXG4gICAgICAgIC8vIExvb3Agb3ZlciBhbGwgc2hhcGVzIG9mIGJvZHkgaVxuICAgICAgICBmb3IodmFyIGs9MCwgTnNoYXBlc2k9Ymkuc2hhcGVzLmxlbmd0aDsgayE9PU5zaGFwZXNpOyBrKyspe1xuICAgICAgICAgICAgdmFyIHNpID0gYmkuc2hhcGVzW2tdLFxuICAgICAgICAgICAgICAgIHhpID0gc2kucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgYWkgPSBzaS5hbmdsZTtcblxuICAgICAgICAgICAgLy8gQWxsIHNoYXBlcyBvZiBib2R5IGpcbiAgICAgICAgICAgIGZvcih2YXIgbD0wLCBOc2hhcGVzaj1iai5zaGFwZXMubGVuZ3RoOyBsIT09TnNoYXBlc2o7IGwrKyl7XG4gICAgICAgICAgICAgICAgdmFyIHNqID0gYmouc2hhcGVzW2xdLFxuICAgICAgICAgICAgICAgICAgICB4aiA9IHNqLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBhaiA9IHNqLmFuZ2xlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNtID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xuICAgICAgICAgICAgICAgIGlmKHNpLm1hdGVyaWFsICYmIHNqLm1hdGVyaWFsKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuZ2V0Q29udGFjdE1hdGVyaWFsKHNpLm1hdGVyaWFsLHNqLm1hdGVyaWFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodG1wKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtID0gdG1wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5ydW5OYXJyb3dwaGFzZShucCxiaSxzaSx4aSxhaSxiaixzaix4aixhaixjbSx0aGlzLmZyaWN0aW9uR3Jhdml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXYWtlIHVwIGJvZGllc1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgdmFyIGJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgIGlmKGJvZHkuX3dha2VVcEFmdGVyTmFycm93cGhhc2Upe1xuICAgICAgICAgICAgYm9keS53YWtlVXAoKTtcbiAgICAgICAgICAgIGJvZHkuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVtaXQgZW5kIG92ZXJsYXAgZXZlbnRzXG4gICAgaWYodGhpcy5oYXMoJ2VuZENvbnRhY3QnKSl7XG4gICAgICAgIHRoaXMub3ZlcmxhcEtlZXBlci5nZXRFbmRPdmVybGFwcyhlbmRPdmVybGFwcyk7XG4gICAgICAgIHZhciBlID0gdGhpcy5lbmRDb250YWN0RXZlbnQ7XG4gICAgICAgIHZhciBsID0gZW5kT3ZlcmxhcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZShsLS0pe1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBlbmRPdmVybGFwc1tsXTtcbiAgICAgICAgICAgIGUuc2hhcGVBID0gZGF0YS5zaGFwZUE7XG4gICAgICAgICAgICBlLnNoYXBlQiA9IGRhdGEuc2hhcGVCO1xuICAgICAgICAgICAgZS5ib2R5QSA9IGRhdGEuYm9keUE7XG4gICAgICAgICAgICBlLmJvZHlCID0gZGF0YS5ib2R5QjtcbiAgICAgICAgICAgIHRoaXMuZW1pdChlKTtcbiAgICAgICAgfVxuICAgICAgICBlbmRPdmVybGFwcy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHZhciBwcmVTb2x2ZUV2ZW50ID0gdGhpcy5wcmVTb2x2ZUV2ZW50O1xuICAgIHByZVNvbHZlRXZlbnQuY29udGFjdEVxdWF0aW9ucyA9IG5wLmNvbnRhY3RFcXVhdGlvbnM7XG4gICAgcHJlU29sdmVFdmVudC5mcmljdGlvbkVxdWF0aW9ucyA9IG5wLmZyaWN0aW9uRXF1YXRpb25zO1xuICAgIHRoaXMuZW1pdChwcmVTb2x2ZUV2ZW50KTtcbiAgICBwcmVTb2x2ZUV2ZW50LmNvbnRhY3RFcXVhdGlvbnMgPSBwcmVTb2x2ZUV2ZW50LmZyaWN0aW9uRXF1YXRpb25zID0gbnVsbDtcblxuICAgIC8vIHVwZGF0ZSBjb25zdHJhaW50IGVxdWF0aW9uc1xuICAgIHZhciBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7XG4gICAgZm9yKGk9MDsgaSE9PU5jb25zdHJhaW50czsgaSsrKXtcbiAgICAgICAgY29uc3RyYWludHNbaV0udXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaWYobnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggfHwgbnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoIHx8IE5jb25zdHJhaW50cyl7XG4gICAgICAgIGlmKHRoaXMuaXNsYW5kU3BsaXQpe1xuICAgICAgICAgICAgLy8gU3BsaXQgaW50byBpc2xhbmRzXG4gICAgICAgICAgICBpc2xhbmRNYW5hZ2VyLmVxdWF0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkoaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMsIG5wLmNvbnRhY3RFcXVhdGlvbnMpO1xuICAgICAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkoaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMsIG5wLmZyaWN0aW9uRXF1YXRpb25zKTtcbiAgICAgICAgICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgICAgICAgICAgVXRpbHMuYXBwZW5kQXJyYXkoaXNsYW5kTWFuYWdlci5lcXVhdGlvbnMsIGNvbnN0cmFpbnRzW2ldLmVxdWF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc2xhbmRNYW5hZ2VyLnNwbGl0KHRoaXMpO1xuXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWlzbGFuZE1hbmFnZXIuaXNsYW5kcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgdmFyIGlzbGFuZCA9IGlzbGFuZE1hbmFnZXIuaXNsYW5kc1tpXTtcbiAgICAgICAgICAgICAgICBpZihpc2xhbmQuZXF1YXRpb25zLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIHNvbHZlci5zb2x2ZUlzbGFuZChkdCxpc2xhbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBBZGQgY29udGFjdCBlcXVhdGlvbnMgdG8gc29sdmVyXG4gICAgICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb25zKG5wLmNvbnRhY3RFcXVhdGlvbnMpO1xuICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9ucyhucC5mcmljdGlvbkVxdWF0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB1c2VyLWRlZmluZWQgY29uc3RyYWludCBlcXVhdGlvbnNcbiAgICAgICAgICAgIGZvcihpPTA7IGkhPT1OY29uc3RyYWludHM7IGkrKyl7XG4gICAgICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9ucyhjb25zdHJhaW50c1tpXS5lcXVhdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0aGlzLnNvbHZlQ29uc3RyYWludHMpe1xuICAgICAgICAgICAgICAgIHNvbHZlci5zb2x2ZShkdCx0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RlcCBmb3J3YXJkXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICB2YXIgYm9keSA9IGJvZGllc1tpXTtcblxuICAgICAgICAvLyBpZihib2R5LnNsZWVwU3RhdGUgIT09IEJvZHkuU0xFRVBJTkcgJiYgYm9keS50eXBlICE9PSBCb2R5LlNUQVRJQyl7XG4gICAgICAgIGJvZHkuaW50ZWdyYXRlKGR0KTtcbiAgICAgICAgLy8gfVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGZvcmNlXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICBib2RpZXNbaV0uc2V0WmVyb0ZvcmNlKCk7XG4gICAgfVxuXG4gICAgLy8gRW1pdCBpbXBhY3QgZXZlbnRcbiAgICBpZih0aGlzLmVtaXRJbXBhY3RFdmVudCAmJiB0aGlzLmhhcygnaW1wYWN0Jykpe1xuICAgICAgICB2YXIgZXYgPSB0aGlzLmltcGFjdEV2ZW50O1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PW5wLmNvbnRhY3RFcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGVxID0gbnAuY29udGFjdEVxdWF0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmKGVxLmZpcnN0SW1wYWN0KXtcbiAgICAgICAgICAgICAgICBldi5ib2R5QSA9IGVxLmJvZHlBO1xuICAgICAgICAgICAgICAgIGV2LmJvZHlCID0gZXEuYm9keUI7XG4gICAgICAgICAgICAgICAgZXYuc2hhcGVBID0gZXEuc2hhcGVBO1xuICAgICAgICAgICAgICAgIGV2LnNoYXBlQiA9IGVxLnNoYXBlQjtcbiAgICAgICAgICAgICAgICBldi5jb250YWN0RXF1YXRpb24gPSBlcTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2xlZXBpbmcgdXBkYXRlXG4gICAgaWYodGhpcy5zbGVlcE1vZGUgPT09IFdvcmxkLkJPRFlfU0xFRVBJTkcpe1xuICAgICAgICBmb3IoaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIGJvZGllc1tpXS5zbGVlcFRpY2sodGhpcy50aW1lLCBmYWxzZSwgZHQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKHRoaXMuc2xlZXBNb2RlID09PSBXb3JsZC5JU0xBTkRfU0xFRVBJTkcgJiYgdGhpcy5pc2xhbmRTcGxpdCl7XG5cbiAgICAgICAgLy8gVGVsbCBhbGwgYm9kaWVzIHRvIHNsZWVwIHRpY2sgYnV0IGRvbnQgc2xlZXAgeWV0XG4gICAgICAgIGZvcihpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwVGljayh0aGlzLnRpbWUsIHRydWUsIGR0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsZWVwIGlzbGFuZHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5pc2xhbmRNYW5hZ2VyLmlzbGFuZHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGlzbGFuZCA9IHRoaXMuaXNsYW5kTWFuYWdlci5pc2xhbmRzW2ldO1xuICAgICAgICAgICAgaWYoaXNsYW5kLndhbnRzVG9TbGVlcCgpKXtcbiAgICAgICAgICAgICAgICBpc2xhbmQuc2xlZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RlcHBpbmcgPSBmYWxzZTtcblxuICAgIC8vIFJlbW92ZSBib2RpZXMgdGhhdCBhcmUgc2NoZWR1bGVkIGZvciByZW1vdmFsXG4gICAgdmFyIGJvZGllc1RvQmVSZW1vdmVkID0gdGhpcy5ib2RpZXNUb0JlUmVtb3ZlZDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PWJvZGllc1RvQmVSZW1vdmVkLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5yZW1vdmVCb2R5KGJvZGllc1RvQmVSZW1vdmVkW2ldKTtcbiAgICB9XG4gICAgYm9kaWVzVG9CZVJlbW92ZWQubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuZW1pdCh0aGlzLnBvc3RTdGVwRXZlbnQpO1xufTtcblxuLyoqXG4gKiBSdW5zIG5hcnJvd3BoYXNlIGZvciB0aGUgc2hhcGUgcGFpciBpIGFuZCBqLlxuICogQG1ldGhvZCBydW5OYXJyb3dwaGFzZVxuICogQHBhcmFtICB7TmFycm93cGhhc2V9IG5wXG4gKiBAcGFyYW0gIHtCb2R5fSBiaVxuICogQHBhcmFtICB7U2hhcGV9IHNpXG4gKiBAcGFyYW0gIHtBcnJheX0geGlcbiAqIEBwYXJhbSAge051bWJlcn0gYWlcbiAqIEBwYXJhbSAge0JvZHl9IGJqXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2pcbiAqIEBwYXJhbSAge0FycmF5fSB4alxuICogQHBhcmFtICB7TnVtYmVyfSBhalxuICogQHBhcmFtICB7TnVtYmVyfSBtdVxuICovXG5Xb3JsZC5wcm90b3R5cGUucnVuTmFycm93cGhhc2UgPSBmdW5jdGlvbihucCxiaSxzaSx4aSxhaSxiaixzaix4aixhaixjbSxnbGVuKXtcblxuICAgIC8vIENoZWNrIGNvbGxpc2lvbiBncm91cHMgYW5kIG1hc2tzXG4gICAgaWYoISgoc2kuY29sbGlzaW9uR3JvdXAgJiBzai5jb2xsaXNpb25NYXNrKSAhPT0gMCAmJiAoc2ouY29sbGlzaW9uR3JvdXAgJiBzaS5jb2xsaXNpb25NYXNrKSAhPT0gMCkpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IHdvcmxkIHBvc2l0aW9uIGFuZCBhbmdsZSBvZiBlYWNoIHNoYXBlXG4gICAgdmVjMi5yb3RhdGUoeGl3LCB4aSwgYmkuYW5nbGUpO1xuICAgIHZlYzIucm90YXRlKHhqdywgeGosIGJqLmFuZ2xlKTtcbiAgICB2ZWMyLmFkZCh4aXcsIHhpdywgYmkucG9zaXRpb24pO1xuICAgIHZlYzIuYWRkKHhqdywgeGp3LCBiai5wb3NpdGlvbik7XG4gICAgdmFyIGFpdyA9IGFpICsgYmkuYW5nbGU7XG4gICAgdmFyIGFqdyA9IGFqICsgYmouYW5nbGU7XG5cbiAgICBucC5lbmFibGVGcmljdGlvbiA9IGNtLmZyaWN0aW9uID4gMDtcbiAgICBucC5mcmljdGlvbkNvZWZmaWNpZW50ID0gY20uZnJpY3Rpb247XG4gICAgdmFyIHJlZHVjZWRNYXNzO1xuICAgIGlmKGJpLnR5cGUgPT09IEJvZHkuU1RBVElDIHx8IGJpLnR5cGUgPT09IEJvZHkuS0lORU1BVElDKXtcbiAgICAgICAgcmVkdWNlZE1hc3MgPSBiai5tYXNzO1xuICAgIH0gZWxzZSBpZihiai50eXBlID09PSBCb2R5LlNUQVRJQyB8fCBiai50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHJlZHVjZWRNYXNzID0gYmkubWFzcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZWR1Y2VkTWFzcyA9IChiaS5tYXNzKmJqLm1hc3MpLyhiaS5tYXNzK2JqLm1hc3MpO1xuICAgIH1cbiAgICBucC5zbGlwRm9yY2UgPSBjbS5mcmljdGlvbipnbGVuKnJlZHVjZWRNYXNzO1xuICAgIG5wLnJlc3RpdHV0aW9uID0gY20ucmVzdGl0dXRpb247XG4gICAgbnAuc3VyZmFjZVZlbG9jaXR5ID0gY20uc3VyZmFjZVZlbG9jaXR5O1xuICAgIG5wLmZyaWN0aW9uU3RpZmZuZXNzID0gY20uZnJpY3Rpb25TdGlmZm5lc3M7XG4gICAgbnAuZnJpY3Rpb25SZWxheGF0aW9uID0gY20uZnJpY3Rpb25SZWxheGF0aW9uO1xuICAgIG5wLnN0aWZmbmVzcyA9IGNtLnN0aWZmbmVzcztcbiAgICBucC5yZWxheGF0aW9uID0gY20ucmVsYXhhdGlvbjtcbiAgICBucC5jb250YWN0U2tpblNpemUgPSBjbS5jb250YWN0U2tpblNpemU7XG4gICAgbnAuZW5hYmxlZEVxdWF0aW9ucyA9IGJpLmNvbGxpc2lvblJlc3BvbnNlICYmIGJqLmNvbGxpc2lvblJlc3BvbnNlICYmIHNpLmNvbGxpc2lvblJlc3BvbnNlICYmIHNqLmNvbGxpc2lvblJlc3BvbnNlO1xuXG4gICAgdmFyIHJlc29sdmVyID0gbnBbc2kudHlwZSB8IHNqLnR5cGVdLFxuICAgICAgICBudW1Db250YWN0cyA9IDA7XG4gICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgIHZhciBzZW5zb3IgPSBzaS5zZW5zb3IgfHwgc2ouc2Vuc29yO1xuICAgICAgICB2YXIgbnVtRnJpY3Rpb25CZWZvcmUgPSBucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7XG4gICAgICAgIGlmIChzaS50eXBlIDwgc2oudHlwZSkge1xuICAgICAgICAgICAgbnVtQ29udGFjdHMgPSByZXNvbHZlci5jYWxsKG5wLCBiaSxzaSx4aXcsYWl3LCBiaixzaix4ancsYWp3LCBzZW5zb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbnVtQ29udGFjdHMgPSByZXNvbHZlci5jYWxsKG5wLCBiaixzaix4ancsYWp3LCBiaSxzaSx4aXcsYWl3LCBzZW5zb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1GcmljdGlvbkVxdWF0aW9ucyA9IG5wLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aCAtIG51bUZyaWN0aW9uQmVmb3JlO1xuXG4gICAgICAgIGlmKG51bUNvbnRhY3RzKXtcblxuICAgICAgICAgICAgaWYoIGJpLmFsbG93U2xlZXAgJiZcbiAgICAgICAgICAgICAgICBiaS50eXBlID09PSBCb2R5LkRZTkFNSUMgJiZcbiAgICAgICAgICAgICAgICBiaS5zbGVlcFN0YXRlICA9PT0gQm9keS5TTEVFUElORyAmJlxuICAgICAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgID09PSBCb2R5LkFXQUtFICYmXG4gICAgICAgICAgICAgICAgYmoudHlwZSAhPT0gQm9keS5TVEFUSUNcbiAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWVkU3F1YXJlZEIgPSB2ZWMyLnNxdWFyZWRMZW5ndGgoYmoudmVsb2NpdHkpICsgTWF0aC5wb3coYmouYW5ndWxhclZlbG9jaXR5LDIpO1xuICAgICAgICAgICAgICAgIHZhciBzcGVlZExpbWl0U3F1YXJlZEIgPSBNYXRoLnBvdyhiai5zbGVlcFNwZWVkTGltaXQsMik7XG4gICAgICAgICAgICAgICAgaWYoc3BlZWRTcXVhcmVkQiA+PSBzcGVlZExpbWl0U3F1YXJlZEIqMil7XG4gICAgICAgICAgICAgICAgICAgIGJpLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBiai5hbGxvd1NsZWVwICYmXG4gICAgICAgICAgICAgICAgYmoudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmXG4gICAgICAgICAgICAgICAgYmouc2xlZXBTdGF0ZSAgPT09IEJvZHkuU0xFRVBJTkcgJiZcbiAgICAgICAgICAgICAgICBiaS5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgICAgIGJpLnR5cGUgIT09IEJvZHkuU1RBVElDXG4gICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRBID0gdmVjMi5zcXVhcmVkTGVuZ3RoKGJpLnZlbG9jaXR5KSArIE1hdGgucG93KGJpLmFuZ3VsYXJWZWxvY2l0eSwyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWRBID0gTWF0aC5wb3coYmkuc2xlZXBTcGVlZExpbWl0LDIpO1xuICAgICAgICAgICAgICAgIGlmKHNwZWVkU3F1YXJlZEEgPj0gc3BlZWRMaW1pdFNxdWFyZWRBKjIpe1xuICAgICAgICAgICAgICAgICAgICBiai5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm92ZXJsYXBLZWVwZXIuc2V0T3ZlcmxhcHBpbmcoYmksIHNpLCBiaiwgc2opO1xuICAgICAgICAgICAgaWYodGhpcy5oYXMoJ2JlZ2luQ29udGFjdCcpICYmIHRoaXMub3ZlcmxhcEtlZXBlci5pc05ld092ZXJsYXAoc2ksIHNqKSl7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXBvcnQgbmV3IHNoYXBlIG92ZXJsYXBcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuYmVnaW5Db250YWN0RXZlbnQ7XG4gICAgICAgICAgICAgICAgZS5zaGFwZUEgPSBzaTtcbiAgICAgICAgICAgICAgICBlLnNoYXBlQiA9IHNqO1xuICAgICAgICAgICAgICAgIGUuYm9keUEgPSBiaTtcbiAgICAgICAgICAgICAgICBlLmJvZHlCID0gYmo7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXNldCBjb250YWN0IGVxdWF0aW9uc1xuICAgICAgICAgICAgICAgIGUuY29udGFjdEVxdWF0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mKG51bUNvbnRhY3RzKT09PVwibnVtYmVyXCIpe1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGk9bnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGgtbnVtQ29udGFjdHM7IGk8bnAuY29udGFjdEVxdWF0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmNvbnRhY3RFcXVhdGlvbnMucHVzaChucC5jb250YWN0RXF1YXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGl2aWRlIHRoZSBtYXggZnJpY3Rpb24gZm9yY2UgYnkgdGhlIG51bWJlciBvZiBjb250YWN0c1xuICAgICAgICAgICAgaWYodHlwZW9mKG51bUNvbnRhY3RzKT09PVwibnVtYmVyXCIgJiYgbnVtRnJpY3Rpb25FcXVhdGlvbnMgPiAxKXsgLy8gV2h5IGRpdmlkZSBieSAxP1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaT1ucC5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGgtbnVtRnJpY3Rpb25FcXVhdGlvbnM7IGk8bnAuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IG5wLmZyaWN0aW9uRXF1YXRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBmLnNldFNsaXBGb3JjZShmLmdldFNsaXBGb3JjZSgpIC8gbnVtRnJpY3Rpb25FcXVhdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuLyoqXG4gKiBBZGQgYSBzcHJpbmcgdG8gdGhlIHNpbXVsYXRpb25cbiAqXG4gKiBAbWV0aG9kIGFkZFNwcmluZ1xuICogQHBhcmFtIHtTcHJpbmd9IHNwcmluZ1xuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkU3ByaW5nID0gZnVuY3Rpb24oc3ByaW5nKXtcbiAgICB0aGlzLnNwcmluZ3MucHVzaChzcHJpbmcpO1xuICAgIHZhciBldnQgPSB0aGlzLmFkZFNwcmluZ0V2ZW50O1xuICAgIGV2dC5zcHJpbmcgPSBzcHJpbmc7XG4gICAgdGhpcy5lbWl0KGV2dCk7XG4gICAgZXZ0LnNwcmluZyA9IG51bGw7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHNwcmluZ1xuICpcbiAqIEBtZXRob2QgcmVtb3ZlU3ByaW5nXG4gKiBAcGFyYW0ge1NwcmluZ30gc3ByaW5nXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVTcHJpbmcgPSBmdW5jdGlvbihzcHJpbmcpe1xuICAgIHZhciBpZHggPSB0aGlzLnNwcmluZ3MuaW5kZXhPZihzcHJpbmcpO1xuICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICBVdGlscy5zcGxpY2UodGhpcy5zcHJpbmdzLGlkeCwxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIGJvZHkgdG8gdGhlIHNpbXVsYXRpb25cbiAqXG4gKiBAbWV0aG9kIGFkZEJvZHlcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIHdvcmxkID0gbmV3IFdvcmxkKCksXG4gKiAgICAgICAgIGJvZHkgPSBuZXcgQm9keSgpO1xuICogICAgIHdvcmxkLmFkZEJvZHkoYm9keSk7XG4gKiBAdG9kbyBXaGF0IGlmIHRoaXMgaXMgZG9uZSBkdXJpbmcgc3RlcD9cbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZEJvZHkgPSBmdW5jdGlvbihib2R5KXtcbiAgICBpZih0aGlzLmJvZGllcy5pbmRleE9mKGJvZHkpID09PSAtMSl7XG4gICAgICAgIHRoaXMuYm9kaWVzLnB1c2goYm9keSk7XG4gICAgICAgIGJvZHkud29ybGQgPSB0aGlzO1xuICAgICAgICB2YXIgZXZ0ID0gdGhpcy5hZGRCb2R5RXZlbnQ7XG4gICAgICAgIGV2dC5ib2R5ID0gYm9keTtcbiAgICAgICAgdGhpcy5lbWl0KGV2dCk7XG4gICAgICAgIGV2dC5ib2R5ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGJvZHkgZnJvbSB0aGUgc2ltdWxhdGlvbi4gSWYgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGR1cmluZyBzdGVwKCksIHRoZSBib2R5IHJlbW92YWwgaXMgc2NoZWR1bGVkIHRvIGFmdGVyIHRoZSBzdGVwLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQm9keVxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVCb2R5ID0gZnVuY3Rpb24oYm9keSl7XG4gICAgaWYodGhpcy5zdGVwcGluZyl7XG4gICAgICAgIHRoaXMuYm9kaWVzVG9CZVJlbW92ZWQucHVzaChib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBib2R5LndvcmxkID0gbnVsbDtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYm9kaWVzLmluZGV4T2YoYm9keSk7XG4gICAgICAgIGlmKGlkeCE9PS0xKXtcbiAgICAgICAgICAgIFV0aWxzLnNwbGljZSh0aGlzLmJvZGllcyxpZHgsMSk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudC5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIGJvZHkucmVzZXRDb25zdHJhaW50VmVsb2NpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh0aGlzLnJlbW92ZUJvZHlFdmVudCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJvZHlFdmVudC5ib2R5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGEgYm9keSBieSBpdHMgaWQuXG4gKiBAbWV0aG9kIGdldEJvZHlCeUlkXG4gKiBAcGFyYW0ge251bWJlcn0gaWRcbiAqIEByZXR1cm4ge0JvZHl9IFRoZSBib2R5LCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGZvdW5kLlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Qm9keUJ5SWQgPSBmdW5jdGlvbihpZCl7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xuICAgIGZvcih2YXIgaT0wOyBpPGJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiLmlkID09PSBpZCl7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERpc2FibGUgY29sbGlzaW9uIGJldHdlZW4gdHdvIGJvZGllc1xuICogQG1ldGhvZCBkaXNhYmxlQm9keUNvbGxpc2lvblxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZGlzYWJsZUJvZHlDb2xsaXNpb24gPSBmdW5jdGlvbihib2R5QSxib2R5Qil7XG4gICAgdGhpcy5kaXNhYmxlZEJvZHlDb2xsaXNpb25QYWlycy5wdXNoKGJvZHlBLGJvZHlCKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIGNvbGxpc2lvbnMgYmV0d2VlbiB0aGUgZ2l2ZW4gdHdvIGJvZGllc1xuICogQG1ldGhvZCBlbmFibGVCb2R5Q29sbGlzaW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKi9cbldvcmxkLnByb3RvdHlwZS5lbmFibGVCb2R5Q29sbGlzaW9uID0gZnVuY3Rpb24oYm9keUEsYm9keUIpe1xuICAgIHZhciBwYWlycyA9IHRoaXMuZGlzYWJsZWRCb2R5Q29sbGlzaW9uUGFpcnM7XG4gICAgZm9yKHZhciBpPTA7IGk8cGFpcnMubGVuZ3RoOyBpKz0yKXtcbiAgICAgICAgaWYoKHBhaXJzW2ldID09PSBib2R5QSAmJiBwYWlyc1tpKzFdID09PSBib2R5QikgfHwgKHBhaXJzW2krMV0gPT09IGJvZHlBICYmIHBhaXJzW2ldID09PSBib2R5Qikpe1xuICAgICAgICAgICAgcGFpcnMuc3BsaWNlKGksMik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgV29ybGQsIHJlbW92ZXMgYWxsIGJvZGllcywgY29uc3RyYWludHMgYW5kIHNwcmluZ3MuXG4gKlxuICogQG1ldGhvZCBjbGVhclxuICovXG5Xb3JsZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuXG4gICAgdGhpcy50aW1lID0gMDtcblxuICAgIC8vIFJlbW92ZSBhbGwgc29sdmVyIGVxdWF0aW9uc1xuICAgIGlmKHRoaXMuc29sdmVyICYmIHRoaXMuc29sdmVyLmVxdWF0aW9ucy5sZW5ndGgpe1xuICAgICAgICB0aGlzLnNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGNvbnN0cmFpbnRzXG4gICAgdmFyIGNzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICBmb3IodmFyIGk9Y3MubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29uc3RyYWludChjc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBib2RpZXNcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XG4gICAgZm9yKHZhciBpPWJvZGllcy5sZW5ndGgtMTsgaT49MDsgaS0tKXtcbiAgICAgICAgdGhpcy5yZW1vdmVCb2R5KGJvZGllc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFsbCBzcHJpbmdzXG4gICAgdmFyIHNwcmluZ3MgPSB0aGlzLnNwcmluZ3M7XG4gICAgZm9yKHZhciBpPXNwcmluZ3MubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlU3ByaW5nKHNwcmluZ3NbaV0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbGwgY29udGFjdCBtYXRlcmlhbHNcbiAgICB2YXIgY21zID0gdGhpcy5jb250YWN0TWF0ZXJpYWxzO1xuICAgIGZvcih2YXIgaT1jbXMubGVuZ3RoLTE7IGk+PTA7IGktLSl7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29udGFjdE1hdGVyaWFsKGNtc1tpXSk7XG4gICAgfVxuXG4gICAgV29ybGQuYXBwbHkodGhpcyk7XG59O1xuXG52YXIgaGl0VGVzdF90bXAxID0gdmVjMi5jcmVhdGUoKSxcbiAgICBoaXRUZXN0X3plcm8gPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKSxcbiAgICBoaXRUZXN0X3RtcDIgPSB2ZWMyLmZyb21WYWx1ZXMoMCwwKTtcblxuLyoqXG4gKiBUZXN0IGlmIGEgd29ybGQgcG9pbnQgb3ZlcmxhcHMgYm9kaWVzXG4gKiBAbWV0aG9kIGhpdFRlc3RcbiAqIEBwYXJhbSAge0FycmF5fSAgd29ybGRQb2ludCAgUG9pbnQgdG8gdXNlIGZvciBpbnRlcnNlY3Rpb24gdGVzdHNcbiAqIEBwYXJhbSAge0FycmF5fSAgYm9kaWVzICAgICAgQSBsaXN0IG9mIG9iamVjdHMgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvblxuICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gICBVc2VkIGZvciBtYXRjaGluZyBhZ2FpbnN0IHBhcnRpY2xlcyBhbmQgbGluZXMuIEFkZHMgc29tZSBtYXJnaW4gdG8gdGhlc2UgaW5maW5pdGVzaW1hbCBvYmplY3RzLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBBcnJheSBvZiBib2RpZXMgdGhhdCBvdmVybGFwIHRoZSBwb2ludFxuICogQHRvZG8gU2hvdWxkIHVzZSBhbiBhcGkgc2ltaWxhciB0byB0aGUgcmF5Y2FzdCBmdW5jdGlvblxuICogQHRvZG8gU2hvdWxkIHByb2JhYmx5IGltcGxlbWVudCBhIC5jb250YWluc1BvaW50IG1ldGhvZCBmb3IgYWxsIHNoYXBlcy4gV291bGQgYmUgbW9yZSBlZmZpY2llbnRcbiAqIEB0b2RvIFNob3VsZCB1c2UgdGhlIGJyb2FkcGhhc2VcbiAqL1xuV29ybGQucHJvdG90eXBlLmhpdFRlc3QgPSBmdW5jdGlvbih3b3JsZFBvaW50LGJvZGllcyxwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuXG4gICAgLy8gQ3JlYXRlIGEgZHVtbXkgcGFydGljbGUgYm9keSB3aXRoIGEgcGFydGljbGUgc2hhcGUgdG8gdGVzdCBhZ2FpbnN0IHRoZSBib2RpZXNcbiAgICB2YXIgcGIgPSBuZXcgQm9keSh7IHBvc2l0aW9uOndvcmxkUG9pbnQgfSksXG4gICAgICAgIHBzID0gbmV3IFBhcnRpY2xlKCksXG4gICAgICAgIHB4ID0gd29ybGRQb2ludCxcbiAgICAgICAgcGEgPSAwLFxuICAgICAgICB4ID0gaGl0VGVzdF90bXAxLFxuICAgICAgICB6ZXJvID0gaGl0VGVzdF96ZXJvLFxuICAgICAgICB0bXAgPSBoaXRUZXN0X3RtcDI7XG4gICAgcGIuYWRkU2hhcGUocHMpO1xuXG4gICAgdmFyIG4gPSB0aGlzLm5hcnJvd3BoYXNlLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIC8vIENoZWNrIGJvZGllc1xuICAgIGZvcih2YXIgaT0wLCBOPWJvZGllcy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tpXTtcblxuICAgICAgICBmb3IodmFyIGo9MCwgTlM9Yi5zaGFwZXMubGVuZ3RoOyBqIT09TlM7IGorKyl7XG4gICAgICAgICAgICB2YXIgcyA9IGIuc2hhcGVzW2pdO1xuXG4gICAgICAgICAgICAvLyBHZXQgc2hhcGUgd29ybGQgcG9zaXRpb24gKyBhbmdsZVxuICAgICAgICAgICAgdmVjMi5yb3RhdGUoeCwgcy5wb3NpdGlvbiwgYi5hbmdsZSk7XG4gICAgICAgICAgICB2ZWMyLmFkZCh4LCB4LCBiLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciBhID0gcy5hbmdsZSArIGIuYW5nbGU7XG5cbiAgICAgICAgICAgIGlmKCAocyBpbnN0YW5jZW9mIENpcmNsZSAgICAmJiBuLmNpcmNsZVBhcnRpY2xlICAoYixzLHgsYSwgICAgIHBiLHBzLHB4LHBhLCB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIENvbnZleCAgICAmJiBuLnBhcnRpY2xlQ29udmV4ICAocGIscHMscHgscGEsIGIscyx4LGEsICAgICB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIFBsYW5lICAgICAmJiBuLnBhcnRpY2xlUGxhbmUgICAocGIscHMscHgscGEsIGIscyx4LGEsICAgICB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIENhcHN1bGUgICAmJiBuLnBhcnRpY2xlQ2Fwc3VsZSAocGIscHMscHgscGEsIGIscyx4LGEsICAgICB0cnVlKSkgfHxcbiAgICAgICAgICAgICAgICAocyBpbnN0YW5jZW9mIFBhcnRpY2xlICAmJiB2ZWMyLnNxdWFyZWRMZW5ndGgodmVjMi5zdWIodG1wLHgsd29ybGRQb2ludCkpIDwgcHJlY2lzaW9uKnByZWNpc2lvbilcbiAgICAgICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzdGlmZm5lc3MgZm9yIGFsbCBlcXVhdGlvbnMgYW5kIGNvbnRhY3QgbWF0ZXJpYWxzLlxuICogQG1ldGhvZCBzZXRHbG9iYWxTdGlmZm5lc3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGlmZm5lc3NcbiAqL1xuV29ybGQucHJvdG90eXBlLnNldEdsb2JhbFN0aWZmbmVzcyA9IGZ1bmN0aW9uKHN0aWZmbmVzcyl7XG5cbiAgICAvLyBTZXQgZm9yIGFsbCBjb25zdHJhaW50c1xuICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgZm9yKHZhciBpPTA7IGkgIT09IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGMuZXF1YXRpb25zLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBlcSA9IGMuZXF1YXRpb25zW2pdO1xuICAgICAgICAgICAgZXEuc3RpZmZuZXNzID0gc3RpZmZuZXNzO1xuICAgICAgICAgICAgZXEubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGZvciBhbGwgY29udGFjdCBtYXRlcmlhbHNcbiAgICB2YXIgY29udGFjdE1hdGVyaWFscyA9IHRoaXMuY29udGFjdE1hdGVyaWFscztcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gY29udGFjdE1hdGVyaWFscy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjID0gY29udGFjdE1hdGVyaWFsc1tpXTtcbiAgICAgICAgYy5zdGlmZm5lc3MgPSBjLmZyaWN0aW9uU3RpZmZuZXNzID0gc3RpZmZuZXNzO1xuICAgIH1cblxuICAgIC8vIFNldCBmb3IgZGVmYXVsdCBjb250YWN0IG1hdGVyaWFsXG4gICAgdmFyIGMgPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG4gICAgYy5zdGlmZm5lc3MgPSBjLmZyaWN0aW9uU3RpZmZuZXNzID0gc3RpZmZuZXNzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHJlbGF4YXRpb24gZm9yIGFsbCBlcXVhdGlvbnMgYW5kIGNvbnRhY3QgbWF0ZXJpYWxzLlxuICogQG1ldGhvZCBzZXRHbG9iYWxSZWxheGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmVsYXhhdGlvblxuICovXG5Xb3JsZC5wcm90b3R5cGUuc2V0R2xvYmFsUmVsYXhhdGlvbiA9IGZ1bmN0aW9uKHJlbGF4YXRpb24pe1xuXG4gICAgLy8gU2V0IGZvciBhbGwgY29uc3RyYWludHNcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gdGhpcy5jb25zdHJhaW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjID0gdGhpcy5jb25zdHJhaW50c1tpXTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGMuZXF1YXRpb25zLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciBlcSA9IGMuZXF1YXRpb25zW2pdO1xuICAgICAgICAgICAgZXEucmVsYXhhdGlvbiA9IHJlbGF4YXRpb247XG4gICAgICAgICAgICBlcS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgZm9yIGFsbCBjb250YWN0IG1hdGVyaWFsc1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSB0aGlzLmNvbnRhY3RNYXRlcmlhbHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYyA9IHRoaXMuY29udGFjdE1hdGVyaWFsc1tpXTtcbiAgICAgICAgYy5yZWxheGF0aW9uID0gYy5mcmljdGlvblJlbGF4YXRpb24gPSByZWxheGF0aW9uO1xuICAgIH1cblxuICAgIC8vIFNldCBmb3IgZGVmYXVsdCBjb250YWN0IG1hdGVyaWFsXG4gICAgdmFyIGMgPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG4gICAgYy5yZWxheGF0aW9uID0gYy5mcmljdGlvblJlbGF4YXRpb24gPSByZWxheGF0aW9uO1xufTtcblxudmFyIHRtcEFBQkIgPSBuZXcgQUFCQigpO1xudmFyIHRtcEFycmF5ID0gW107XG5cbi8qKlxuICogUmF5IGNhc3QgYWdhaW5zdCBhbGwgYm9kaWVzIGluIHRoZSB3b3JsZC5cbiAqIEBtZXRob2QgcmF5Y2FzdFxuICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAcGFyYW0gIHtSYXl9IHJheVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIHJheSA9IG5ldyBSYXkoe1xuICogICAgICAgICBtb2RlOiBSYXkuQ0xPU0VTVCwgLy8gb3IgQU5ZXG4gKiAgICAgICAgIGZyb206IFswLCAwXSxcbiAqICAgICAgICAgdG86IFsxMCwgMF0sXG4gKiAgICAgfSk7XG4gKiAgICAgdmFyIHJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG4gKiAgICAgd29ybGQucmF5Y2FzdChyZXN1bHQsIHJheSk7XG4gKlxuICogICAgIC8vIEdldCB0aGUgaGl0IHBvaW50XG4gKiAgICAgdmFyIGhpdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcbiAqICAgICByZXN1bHQuZ2V0SGl0UG9pbnQoaGl0UG9pbnQsIHJheSk7XG4gKiAgICAgY29uc29sZS5sb2coJ0hpdCBwb2ludDogJywgaGl0UG9pbnRbMF0sIGhpdFBvaW50WzFdLCAnIGF0IGRpc3RhbmNlICcgKyByZXN1bHQuZ2V0SGl0RGlzdGFuY2UocmF5KSk7XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgcmF5ID0gbmV3IFJheSh7XG4gKiAgICAgICAgIG1vZGU6IFJheS5BTEwsXG4gKiAgICAgICAgIGZyb206IFswLCAwXSxcbiAqICAgICAgICAgdG86IFsxMCwgMF0sXG4gKiAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihyZXN1bHQpe1xuICpcbiAqICAgICAgICAgICAgIC8vIFByaW50IHNvbWUgaW5mbyBhYm91dCB0aGUgaGl0XG4gKiAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGl0IGJvZHkgYW5kIHNoYXBlOiAnLCByZXN1bHQuYm9keSwgcmVzdWx0LnNoYXBlKTtcbiAqXG4gKiAgICAgICAgICAgICAvLyBHZXQgdGhlIGhpdCBwb2ludFxuICogICAgICAgICAgICAgdmFyIGhpdFBvaW50ID0gdmVjMi5jcmVhdGUoKTtcbiAqICAgICAgICAgICAgIHJlc3VsdC5nZXRIaXRQb2ludChoaXRQb2ludCwgcmF5KTtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaXQgcG9pbnQ6ICcsIGhpdFBvaW50WzBdLCBoaXRQb2ludFsxXSwgJyBhdCBkaXN0YW5jZSAnICsgcmVzdWx0LmdldEhpdERpc3RhbmNlKHJheSkpO1xuICpcbiAqICAgICAgICAgICAgIC8vIElmIHlvdSBhcmUgaGFwcHkgd2l0aCB0aGUgaGl0cyB5b3UgZ290IHRoaXMgZmFyLCB5b3UgY2FuIHN0b3AgdGhlIHRyYXZlcnNhbCBoZXJlOlxuICogICAgICAgICAgICAgcmVzdWx0LnN0b3AoKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICogICAgIHZhciByZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xuICogICAgIHdvcmxkLnJheWNhc3QocmVzdWx0LCByYXkpO1xuICovXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdCA9IGZ1bmN0aW9uKHJlc3VsdCwgcmF5KXtcblxuICAgIC8vIEdldCBhbGwgYm9kaWVzIHdpdGhpbiB0aGUgcmF5IEFBQkJcbiAgICByYXkuZ2V0QUFCQih0bXBBQUJCKTtcbiAgICB0aGlzLmJyb2FkcGhhc2UuYWFiYlF1ZXJ5KHRoaXMsIHRtcEFBQkIsIHRtcEFycmF5KTtcbiAgICByYXkuaW50ZXJzZWN0Qm9kaWVzKHJlc3VsdCwgdG1wQXJyYXkpO1xuICAgIHRtcEFycmF5Lmxlbmd0aCA9IDA7XG5cbiAgICByZXR1cm4gcmVzdWx0Lmhhc0hpdCgpO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/p2/src/world/World.js\n");

/***/ }),

/***/ "./node_modules/poly-decomp/src/Line.js":
/*!**********************************************!*\
  !*** ./node_modules/poly-decomp/src/Line.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Scalar = __webpack_require__(/*! ./Scalar */ \"./node_modules/poly-decomp/src/Scalar.js\");\n\nmodule.exports = Line;\n\n/**\n * Container for line-related functions\n * @class Line\n */\nfunction Line(){};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nLine.lineInt = function(l1,l2,precision){\n    precision = precision || 0;\n    var i = [0,0]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2*b1;\n    if (!Scalar.eq(det, 0, precision)) { // lines are not parallel\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n};\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nLine.segmentsIntersect = function(p1, p2, q1, q2){\n   var dx = p2[0] - p1[0];\n   var dy = p2[1] - p1[1];\n   var da = q2[0] - q1[0];\n   var db = q2[1] - q1[1];\n\n   // segments are parallel\n   if(da*dy - db*dx == 0)\n      return false;\n\n   var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx)\n   var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy)\n\n   return (s>=0 && s<=1 && t>=0 && t<=1);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL0xpbmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL0xpbmUuanM/ZDM3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU2NhbGFyID0gcmVxdWlyZSgnLi9TY2FsYXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG4vKipcbiAqIENvbnRhaW5lciBmb3IgbGluZS1yZWxhdGVkIGZ1bmN0aW9uc1xuICogQGNsYXNzIExpbmVcbiAqL1xuZnVuY3Rpb24gTGluZSgpe307XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdHdvIGxpbmVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBsaW5lSW50XG4gKiBAcGFyYW0gIHtBcnJheX0gIGwxICAgICAgICAgIExpbmUgdmVjdG9yIDFcbiAqIEBwYXJhbSAge0FycmF5fSAgbDIgICAgICAgICAgTGluZSB2ZWN0b3IgMlxuICogQHBhcmFtICB7TnVtYmVyfSBwcmVjaXNpb24gICBQcmVjaXNpb24gdG8gdXNlIHdoZW4gY2hlY2tpbmcgaWYgdGhlIGxpbmVzIGFyZSBwYXJhbGxlbFxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBUaGUgaW50ZXJzZWN0aW9uIHBvaW50LlxuICovXG5MaW5lLmxpbmVJbnQgPSBmdW5jdGlvbihsMSxsMixwcmVjaXNpb24pe1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuICAgIHZhciBpID0gWzAsMF07IC8vIHBvaW50XG4gICAgdmFyIGExLCBiMSwgYzEsIGEyLCBiMiwgYzIsIGRldDsgLy8gc2NhbGFyc1xuICAgIGExID0gbDFbMV1bMV0gLSBsMVswXVsxXTtcbiAgICBiMSA9IGwxWzBdWzBdIC0gbDFbMV1bMF07XG4gICAgYzEgPSBhMSAqIGwxWzBdWzBdICsgYjEgKiBsMVswXVsxXTtcbiAgICBhMiA9IGwyWzFdWzFdIC0gbDJbMF1bMV07XG4gICAgYjIgPSBsMlswXVswXSAtIGwyWzFdWzBdO1xuICAgIGMyID0gYTIgKiBsMlswXVswXSArIGIyICogbDJbMF1bMV07XG4gICAgZGV0ID0gYTEgKiBiMiAtIGEyKmIxO1xuICAgIGlmICghU2NhbGFyLmVxKGRldCwgMCwgcHJlY2lzaW9uKSkgeyAvLyBsaW5lcyBhcmUgbm90IHBhcmFsbGVsXG4gICAgICAgIGlbMF0gPSAoYjIgKiBjMSAtIGIxICogYzIpIC8gZGV0O1xuICAgICAgICBpWzFdID0gKGExICogYzIgLSBhMiAqIGMxKSAvIGRldDtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0d28gbGluZSBzZWdtZW50cyBpbnRlcnNlY3RzLlxuICogQG1ldGhvZCBzZWdtZW50c0ludGVyc2VjdFxuICogQHBhcmFtIHtBcnJheX0gcDEgVGhlIHN0YXJ0IHZlcnRleCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LlxuICogQHBhcmFtIHtBcnJheX0gcDIgVGhlIGVuZCB2ZXJ0ZXggb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC5cbiAqIEBwYXJhbSB7QXJyYXl9IHExIFRoZSBzdGFydCB2ZXJ0ZXggb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuXG4gKiBAcGFyYW0ge0FycmF5fSBxMiBUaGUgZW5kIHZlcnRleCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdFxuICovXG5MaW5lLnNlZ21lbnRzSW50ZXJzZWN0ID0gZnVuY3Rpb24ocDEsIHAyLCBxMSwgcTIpe1xuICAgdmFyIGR4ID0gcDJbMF0gLSBwMVswXTtcbiAgIHZhciBkeSA9IHAyWzFdIC0gcDFbMV07XG4gICB2YXIgZGEgPSBxMlswXSAtIHExWzBdO1xuICAgdmFyIGRiID0gcTJbMV0gLSBxMVsxXTtcblxuICAgLy8gc2VnbWVudHMgYXJlIHBhcmFsbGVsXG4gICBpZihkYSpkeSAtIGRiKmR4ID09IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgIHZhciBzID0gKGR4ICogKHExWzFdIC0gcDFbMV0pICsgZHkgKiAocDFbMF0gLSBxMVswXSkpIC8gKGRhICogZHkgLSBkYiAqIGR4KVxuICAgdmFyIHQgPSAoZGEgKiAocDFbMV0gLSBxMVsxXSkgKyBkYiAqIChxMVswXSAtIHAxWzBdKSkgLyAoZGIgKiBkeCAtIGRhICogZHkpXG5cbiAgIHJldHVybiAocz49MCAmJiBzPD0xICYmIHQ+PTAgJiYgdDw9MSk7XG59O1xuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/poly-decomp/src/Line.js\n");

/***/ }),

/***/ "./node_modules/poly-decomp/src/Point.js":
/*!***********************************************!*\
  !*** ./node_modules/poly-decomp/src/Point.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = Point;\n\n/**\n * Point related functions\n * @class Point\n */\nfunction Point(){};\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nPoint.area = function(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\n};\n\nPoint.left = function(a,b,c){\n    return Point.area(a,b,c) > 0;\n};\n\nPoint.leftOn = function(a,b,c) {\n    return Point.area(a, b, c) >= 0;\n};\n\nPoint.right = function(a,b,c) {\n    return Point.area(a, b, c) < 0;\n};\n\nPoint.rightOn = function(a,b,c) {\n    return Point.area(a, b, c) <= 0;\n};\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nPoint.collinear = function(a,b,c,thresholdAngle) {\n    if(!thresholdAngle)\n        return Point.area(a, b, c) == 0;\n    else {\n        var ab = tmpPoint1,\n            bc = tmpPoint2;\n\n        ab[0] = b[0]-a[0];\n        ab[1] = b[1]-a[1];\n        bc[0] = c[0]-b[0];\n        bc[1] = c[1]-b[1];\n\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\n            angle = Math.acos(dot/(magA*magB));\n        return angle < thresholdAngle;\n    }\n};\n\nPoint.sqdist = function(a,b){\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL1BvaW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BvbHktZGVjb21wL3NyYy9Qb2ludC5qcz80N2QzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbi8qKlxuICogUG9pbnQgcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBjbGFzcyBQb2ludFxuICovXG5mdW5jdGlvbiBQb2ludCgpe307XG5cbi8qKlxuICogR2V0IHRoZSBhcmVhIG9mIGEgdHJpYW5nbGUgc3Bhbm5lZCBieSB0aGUgdGhyZWUgZ2l2ZW4gcG9pbnRzLiBOb3RlIHRoYXQgdGhlIGFyZWEgd2lsbCBiZSBuZWdhdGl2ZSBpZiB0aGUgcG9pbnRzIGFyZSBub3QgZ2l2ZW4gaW4gY291bnRlci1jbG9ja3dpc2Ugb3JkZXIuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGFyZWFcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcGFyYW0gIHtBcnJheX0gYlxuICogQHBhcmFtICB7QXJyYXl9IGNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuUG9pbnQuYXJlYSA9IGZ1bmN0aW9uKGEsYixjKXtcbiAgICByZXR1cm4gKCgoYlswXSAtIGFbMF0pKihjWzFdIC0gYVsxXSkpLSgoY1swXSAtIGFbMF0pKihiWzFdIC0gYVsxXSkpKTtcbn07XG5cblBvaW50LmxlZnQgPSBmdW5jdGlvbihhLGIsYyl7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSxiLGMpID4gMDtcbn07XG5cblBvaW50LmxlZnRPbiA9IGZ1bmN0aW9uKGEsYixjKSB7XG4gICAgcmV0dXJuIFBvaW50LmFyZWEoYSwgYiwgYykgPj0gMDtcbn07XG5cblBvaW50LnJpZ2h0ID0gZnVuY3Rpb24oYSxiLGMpIHtcbiAgICByZXR1cm4gUG9pbnQuYXJlYShhLCBiLCBjKSA8IDA7XG59O1xuXG5Qb2ludC5yaWdodE9uID0gZnVuY3Rpb24oYSxiLGMpIHtcbiAgICByZXR1cm4gUG9pbnQuYXJlYShhLCBiLCBjKSA8PSAwO1xufTtcblxudmFyIHRtcFBvaW50MSA9IFtdLFxuICAgIHRtcFBvaW50MiA9IFtdO1xuXG4vKipcbiAqIENoZWNrIGlmIHRocmVlIHBvaW50cyBhcmUgY29sbGluZWFyXG4gKiBAbWV0aG9kIGNvbGxpbmVhclxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEBwYXJhbSAge0FycmF5fSBiXG4gKiBAcGFyYW0gIHtBcnJheX0gY1xuICogQHBhcmFtICB7TnVtYmVyfSBbdGhyZXNob2xkQW5nbGU9MF0gVGhyZXNob2xkIGFuZ2xlIHRvIHVzZSB3aGVuIGNvbXBhcmluZyB0aGUgdmVjdG9ycy4gVGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIHJlc3VsdGluZyB2ZWN0b3JzIGlzIGxlc3MgdGhhbiB0aGlzIHZhbHVlLiBVc2UgemVybyBmb3IgbWF4IHByZWNpc2lvbi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblBvaW50LmNvbGxpbmVhciA9IGZ1bmN0aW9uKGEsYixjLHRocmVzaG9sZEFuZ2xlKSB7XG4gICAgaWYoIXRocmVzaG9sZEFuZ2xlKVxuICAgICAgICByZXR1cm4gUG9pbnQuYXJlYShhLCBiLCBjKSA9PSAwO1xuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYWIgPSB0bXBQb2ludDEsXG4gICAgICAgICAgICBiYyA9IHRtcFBvaW50MjtcblxuICAgICAgICBhYlswXSA9IGJbMF0tYVswXTtcbiAgICAgICAgYWJbMV0gPSBiWzFdLWFbMV07XG4gICAgICAgIGJjWzBdID0gY1swXS1iWzBdO1xuICAgICAgICBiY1sxXSA9IGNbMV0tYlsxXTtcblxuICAgICAgICB2YXIgZG90ID0gYWJbMF0qYmNbMF0gKyBhYlsxXSpiY1sxXSxcbiAgICAgICAgICAgIG1hZ0EgPSBNYXRoLnNxcnQoYWJbMF0qYWJbMF0gKyBhYlsxXSphYlsxXSksXG4gICAgICAgICAgICBtYWdCID0gTWF0aC5zcXJ0KGJjWzBdKmJjWzBdICsgYmNbMV0qYmNbMV0pLFxuICAgICAgICAgICAgYW5nbGUgPSBNYXRoLmFjb3MoZG90LyhtYWdBKm1hZ0IpKTtcbiAgICAgICAgcmV0dXJuIGFuZ2xlIDwgdGhyZXNob2xkQW5nbGU7XG4gICAgfVxufTtcblxuUG9pbnQuc3FkaXN0ID0gZnVuY3Rpb24oYSxiKXtcbiAgICB2YXIgZHggPSBiWzBdIC0gYVswXTtcbiAgICB2YXIgZHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/poly-decomp/src/Point.js\n");

/***/ }),

/***/ "./node_modules/poly-decomp/src/Polygon.js":
/*!*************************************************!*\
  !*** ./node_modules/poly-decomp/src/Polygon.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("var Line = __webpack_require__(/*! ./Line */ \"./node_modules/poly-decomp/src/Line.js\")\n,   Point = __webpack_require__(/*! ./Point */ \"./node_modules/poly-decomp/src/Point.js\")\n,   Scalar = __webpack_require__(/*! ./Scalar */ \"./node_modules/poly-decomp/src/Scalar.js\")\n\nmodule.exports = Polygon;\n\n/**\n * Polygon class.\n * @class Polygon\n * @constructor\n */\nfunction Polygon(){\n\n    /**\n     * Vertices that this polygon consists of. An array of array of numbers, example: [[0,0],[1,0],..]\n     * @property vertices\n     * @type {Array}\n     */\n    this.vertices = [];\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nPolygon.prototype.at = function(i){\n    var v = this.vertices,\n        s = v.length;\n    return v[i < 0 ? i % s + s : i % s];\n};\n\n/**\n * Get first vertex\n * @method first\n * @return {Array}\n */\nPolygon.prototype.first = function(){\n    return this.vertices[0];\n};\n\n/**\n * Get last vertex\n * @method last\n * @return {Array}\n */\nPolygon.prototype.last = function(){\n    return this.vertices[this.vertices.length-1];\n};\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nPolygon.prototype.clear = function(){\n    this.vertices.length = 0;\n};\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nPolygon.prototype.append = function(poly,from,to){\n    if(typeof(from) == \"undefined\") throw new Error(\"From is not given!\");\n    if(typeof(to) == \"undefined\")   throw new Error(\"To is not given!\");\n\n    if(to-1 < from)                 throw new Error(\"lol1\");\n    if(to > poly.vertices.length)   throw new Error(\"lol2\");\n    if(from < 0)                    throw new Error(\"lol3\");\n\n    for(var i=from; i<to; i++){\n        this.vertices.push(poly.vertices[i]);\n    }\n};\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nPolygon.prototype.makeCCW = function(){\n    var br = 0,\n        v = this.vertices;\n\n    // find bottom right point\n    for (var i = 1; i < this.vertices.length; ++i) {\n        if (v[i][1] < v[br][1] || (v[i][1] == v[br][1] && v[i][0] > v[br][0])) {\n            br = i;\n        }\n    }\n\n    // reverse poly if clockwise\n    if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {\n        this.reverse();\n    }\n};\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nPolygon.prototype.reverse = function(){\n    var tmp = [];\n    for(var i=0, N=this.vertices.length; i!==N; i++){\n        tmp.push(this.vertices.pop());\n    }\n    this.vertices = tmp;\n};\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nPolygon.prototype.isReflex = function(i){\n    return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));\n};\n\nvar tmpLine1=[],\n    tmpLine2=[];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nPolygon.prototype.canSee = function(a,b) {\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\n\n    if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {\n        return false;\n    }\n    dist = Point.sqdist(this.at(a), this.at(b));\n    for (var i = 0; i !== this.vertices.length; ++i) { // for each edge\n        if ((i + 1) % this.vertices.length === a || i === a) // ignore incident edges\n            continue;\n        if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) { // if diag intersects an edge\n            l1[0] = this.at(a);\n            l1[1] = this.at(b);\n            l2[0] = this.at(i);\n            l2[1] = this.at(i + 1);\n            p = Line.lineInt(l1,l2);\n            if (Point.sqdist(this.at(a), p) < dist) { // if edge is blocking visibility to b\n                return false;\n            }\n        }\n    }\n\n    return true;\n};\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nPolygon.prototype.copy = function(i,j,targetPoly){\n    var p = targetPoly || new Polygon();\n    p.clear();\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k=i; k<=j; k++)\n            p.vertices.push(this.vertices[k]);\n\n    } else {\n\n        // Insert vertices 0 to j\n        for(var k=0; k<=j; k++)\n            p.vertices.push(this.vertices[k]);\n\n        // Insert vertices i to end\n        for(var k=i; k<this.vertices.length; k++)\n            p.vertices.push(this.vertices[k]);\n    }\n\n    return p;\n};\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nPolygon.prototype.getCutEdges = function() {\n    var min=[], tmp1=[], tmp2=[], tmpPoly = new Polygon();\n    var nDiags = Number.MAX_VALUE;\n\n    for (var i = 0; i < this.vertices.length; ++i) {\n        if (this.isReflex(i)) {\n            for (var j = 0; j < this.vertices.length; ++j) {\n                if (this.canSee(i, j)) {\n                    tmp1 = this.copy(i, j, tmpPoly).getCutEdges();\n                    tmp2 = this.copy(j, i, tmpPoly).getCutEdges();\n\n                    for(var k=0; k<tmp2.length; k++)\n                        tmp1.push(tmp2[k]);\n\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([this.at(i), this.at(j)]);\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n};\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nPolygon.prototype.decomp = function(){\n    var edges = this.getCutEdges();\n    if(edges.length > 0)\n        return this.slice(edges);\n    else\n        return [this];\n};\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nPolygon.prototype.slice = function(cutEdges){\n    if(cutEdges.length == 0) return [this];\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length==2 && cutEdges[0][0] instanceof Array){\n\n        var polys = [this];\n\n        for(var i=0; i<cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j=0; j<polys.length; j++){\n                var poly = polys[j];\n                var result = poly.slice(cutEdge);\n                if(result){\n                    // Found poly! Cut and quit\n                    polys.splice(j,1);\n                    polys.push(result[0],result[1]);\n                    break;\n                }\n            }\n        }\n\n        return polys;\n    } else {\n\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = this.vertices.indexOf(cutEdge[0]);\n        var j = this.vertices.indexOf(cutEdge[1]);\n\n        if(i != -1 && j != -1){\n            return [this.copy(i,j),\n                    this.copy(j,i)];\n        } else {\n            return false;\n        }\n    }\n};\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nPolygon.prototype.isSimple = function(){\n    var path = this.vertices;\n    // Check\n    for(var i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(Line.segmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(var i=1; i<path.length-2; i++){\n        if(Line.segmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n};\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\n    delta = delta || 0;\n   var a1 = p2[1] - p1[1];\n   var b1 = p1[0] - p2[0];\n   var c1 = (a1 * p1[0]) + (b1 * p1[1]);\n   var a2 = q2[1] - q1[1];\n   var b2 = q1[0] - q2[0];\n   var c2 = (a2 * q1[0]) + (b2 * q1[1]);\n   var det = (a1 * b2) - (a2 * b1);\n\n   if(!Scalar.eq(det,0,delta))\n      return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det]\n   else\n      return [0,0]\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nPolygon.prototype.quickDecomp = function(result,reflexVertices,steinerPoints,delta,maxlevel,level){\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof(result)!=\"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\n    var lowerPoly=new Polygon(), upperPoly=new Polygon(); // polygons\n    var poly = this,\n        v = this.vertices;\n\n    if(v.length < 3) return result;\n\n    level++;\n    if(level > maxlevel){\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\n        return result;\n    }\n\n    for (var i = 0; i < this.vertices.length; ++i) {\n        if (poly.isReflex(i)) {\n            reflexVertices.push(poly.vertices[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n\n\n            for (var j = 0; j < this.vertices.length; ++j) {\n                if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j))\n                        && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) { // if line intersects with an edge\n                    p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1)); // find the point of intersection\n                    if (Point.right(poly.at(i + 1), poly.at(i), p)) { // make sure it's inside the poly\n                        d = Point.sqdist(poly.vertices[i], p);\n                        if (d < lowerDist) { // keep only the closest intersection\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1))\n                        && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {\n                    p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));\n                    if (Point.left(poly.at(i - 1), poly.at(i), p)) {\n                        d = Point.sqdist(poly.vertices[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex == (upperIndex + 1) % this.vertices.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+this.vertices.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    lowerPoly.append(poly, i, upperIndex+1);\n                    lowerPoly.vertices.push(p);\n                    upperPoly.vertices.push(p);\n                    if (lowerIndex != 0){\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        upperPoly.append(poly,lowerIndex,poly.vertices.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    upperPoly.append(poly,0,i+1);\n                } else {\n                    if (i != 0){\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        lowerPoly.append(poly,i,poly.vertices.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    lowerPoly.append(poly,0,upperIndex+1);\n                    lowerPoly.vertices.push(p);\n                    upperPoly.vertices.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    upperPoly.append(poly,lowerIndex,i+1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+this.vertices.length+\")\\n\");\n\n                if (lowerIndex > upperIndex) {\n                    upperIndex += this.vertices.length;\n                }\n                closestDist = Number.MAX_VALUE;\n\n                if(upperIndex < lowerIndex){\n                    return result;\n                }\n\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\n                    if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j))\n                            && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {\n                        d = Point.sqdist(poly.at(i), poly.at(j));\n                        if (d < closestDist) {\n                            closestDist = d;\n                            closestIndex = j % this.vertices.length;\n                        }\n                    }\n                }\n\n                if (i < closestIndex) {\n                    lowerPoly.append(poly,i,closestIndex+1);\n                    if (closestIndex != 0){\n                        upperPoly.append(poly,closestIndex,v.length);\n                    }\n                    upperPoly.append(poly,0,i+1);\n                } else {\n                    if (i != 0){\n                        lowerPoly.append(poly,i,v.length);\n                    }\n                    lowerPoly.append(poly,0,closestIndex+1);\n                    upperPoly.append(poly,closestIndex,i+1);\n                }\n            }\n\n            // solve smallest poly first\n            if (lowerPoly.vertices.length < upperPoly.vertices.length) {\n                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            } else {\n                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            }\n\n            return result;\n        }\n    }\n    result.push(this);\n\n    return result;\n};\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nPolygon.prototype.removeCollinearPoints = function(precision){\n    var num = 0;\n    for(var i=this.vertices.length-1; this.vertices.length>3 && i>=0; --i){\n        if(Point.collinear(this.at(i-1),this.at(i),this.at(i+1),precision)){\n            // Remove the middle point\n            this.vertices.splice(i%this.vertices.length,1);\n            i--; // Jump one point forward. Otherwise we may get a chain removal\n            num++;\n        }\n    }\n    return num;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL1BvbHlnb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL1BvbHlnb24uanM/ODA4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTGluZSA9IHJlcXVpcmUoXCIuL0xpbmVcIilcbiwgICBQb2ludCA9IHJlcXVpcmUoXCIuL1BvaW50XCIpXG4sICAgU2NhbGFyID0gcmVxdWlyZShcIi4vU2NhbGFyXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcblxuLyoqXG4gKiBQb2x5Z29uIGNsYXNzLlxuICogQGNsYXNzIFBvbHlnb25cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQb2x5Z29uKCl7XG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNlcyB0aGF0IHRoaXMgcG9seWdvbiBjb25zaXN0cyBvZi4gQW4gYXJyYXkgb2YgYXJyYXkgb2YgbnVtYmVycywgZXhhbXBsZTogW1swLDBdLFsxLDBdLC4uXVxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG59XG5cbi8qKlxuICogR2V0IGEgdmVydGV4IGF0IHBvc2l0aW9uIGkuIEl0IGRvZXMgbm90IG1hdHRlciBpZiBpIGlzIG91dCBvZiBib3VuZHMsIHRoaXMgZnVuY3Rpb24gd2lsbCBqdXN0IGN5Y2xlLlxuICogQG1ldGhvZCBhdFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihpKXtcbiAgICB2YXIgdiA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIHMgPSB2Lmxlbmd0aDtcbiAgICByZXR1cm4gdltpIDwgMCA/IGkgJSBzICsgcyA6IGkgJSBzXTtcbn07XG5cbi8qKlxuICogR2V0IGZpcnN0IHZlcnRleFxuICogQG1ldGhvZCBmaXJzdFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNlc1swXTtcbn07XG5cbi8qKlxuICogR2V0IGxhc3QgdmVydGV4XG4gKiBAbWV0aG9kIGxhc3RcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNlc1t0aGlzLnZlcnRpY2VzLmxlbmd0aC0xXTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIHBvbHlnb24gZGF0YVxuICogQG1ldGhvZCBjbGVhclxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnZlcnRpY2VzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIEFwcGVuZCBwb2ludHMgXCJmcm9tXCIgdG8gXCJ0b1wiLTEgZnJvbSBhbiBvdGhlciBwb2x5Z29uIFwicG9seVwiIG9udG8gdGhpcyBvbmUuXG4gKiBAbWV0aG9kIGFwcGVuZFxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5IFRoZSBwb2x5Z29uIHRvIGdldCBwb2ludHMgZnJvbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgZnJvbSBUaGUgdmVydGV4IGluZGV4IGluIFwicG9seVwiLlxuICogQHBhcmFtIHtOdW1iZXJ9ICB0byBUaGUgZW5kIHZlcnRleCBpbmRleCBpbiBcInBvbHlcIi4gTm90ZSB0aGF0IHRoaXMgdmVydGV4IGlzIE5PVCBpbmNsdWRlZCB3aGVuIGFwcGVuZGluZy5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihwb2x5LGZyb20sdG8pe1xuICAgIGlmKHR5cGVvZihmcm9tKSA9PSBcInVuZGVmaW5lZFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJGcm9tIGlzIG5vdCBnaXZlbiFcIik7XG4gICAgaWYodHlwZW9mKHRvKSA9PSBcInVuZGVmaW5lZFwiKSAgIHRocm93IG5ldyBFcnJvcihcIlRvIGlzIG5vdCBnaXZlbiFcIik7XG5cbiAgICBpZih0by0xIDwgZnJvbSkgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxvbDFcIik7XG4gICAgaWYodG8gPiBwb2x5LnZlcnRpY2VzLmxlbmd0aCkgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2wyXCIpO1xuICAgIGlmKGZyb20gPCAwKSAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9sM1wiKTtcblxuICAgIGZvcih2YXIgaT1mcm9tOyBpPHRvOyBpKyspe1xuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2gocG9seS52ZXJ0aWNlc1tpXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgdGhhdCB0aGUgcG9seWdvbiB2ZXJ0aWNlcyBhcmUgb3JkZXJlZCBjb3VudGVyLWNsb2Nrd2lzZS5cbiAqIEBtZXRob2QgbWFrZUNDV1xuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5tYWtlQ0NXID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYnIgPSAwLFxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlcztcblxuICAgIC8vIGZpbmQgYm90dG9tIHJpZ2h0IHBvaW50XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh2W2ldWzFdIDwgdlticl1bMV0gfHwgKHZbaV1bMV0gPT0gdlticl1bMV0gJiYgdltpXVswXSA+IHZbYnJdWzBdKSkge1xuICAgICAgICAgICAgYnIgPSBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV2ZXJzZSBwb2x5IGlmIGNsb2Nrd2lzZVxuICAgIGlmICghUG9pbnQubGVmdCh0aGlzLmF0KGJyIC0gMSksIHRoaXMuYXQoYnIpLCB0aGlzLmF0KGJyICsgMSkpKSB7XG4gICAgICAgIHRoaXMucmV2ZXJzZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV2ZXJzZSB0aGUgdmVydGljZXMgaW4gdGhlIHBvbHlnb25cbiAqIEBtZXRob2QgcmV2ZXJzZVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdG1wID0gW107XG4gICAgZm9yKHZhciBpPTAsIE49dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkhPT1OOyBpKyspe1xuICAgICAgICB0bXAucHVzaCh0aGlzLnZlcnRpY2VzLnBvcCgpKTtcbiAgICB9XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHRtcDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBwb2ludCBpbiB0aGUgcG9seWdvbiBpcyBhIHJlZmxleCBwb2ludFxuICogQG1ldGhvZCBpc1JlZmxleFxuICogQHBhcmFtICB7TnVtYmVyfSAgaVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuUG9seWdvbi5wcm90b3R5cGUuaXNSZWZsZXggPSBmdW5jdGlvbihpKXtcbiAgICByZXR1cm4gUG9pbnQucmlnaHQodGhpcy5hdChpIC0gMSksIHRoaXMuYXQoaSksIHRoaXMuYXQoaSArIDEpKTtcbn07XG5cbnZhciB0bXBMaW5lMT1bXSxcbiAgICB0bXBMaW5lMj1bXTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmVydGljZXMgaW4gdGhlIHBvbHlnb24gY2FuIHNlZSBlYWNoIG90aGVyXG4gKiBAbWV0aG9kIGNhblNlZVxuICogQHBhcmFtICB7TnVtYmVyfSBhIFZlcnRleCBpbmRleCAxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGIgVmVydGV4IGluZGV4IDJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmNhblNlZSA9IGZ1bmN0aW9uKGEsYikge1xuICAgIHZhciBwLCBkaXN0LCBsMT10bXBMaW5lMSwgbDI9dG1wTGluZTI7XG5cbiAgICBpZiAoUG9pbnQubGVmdE9uKHRoaXMuYXQoYSArIDEpLCB0aGlzLmF0KGEpLCB0aGlzLmF0KGIpKSAmJiBQb2ludC5yaWdodE9uKHRoaXMuYXQoYSAtIDEpLCB0aGlzLmF0KGEpLCB0aGlzLmF0KGIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRpc3QgPSBQb2ludC5zcWRpc3QodGhpcy5hdChhKSwgdGhpcy5hdChiKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2kpIHsgLy8gZm9yIGVhY2ggZWRnZVxuICAgICAgICBpZiAoKGkgKyAxKSAlIHRoaXMudmVydGljZXMubGVuZ3RoID09PSBhIHx8IGkgPT09IGEpIC8vIGlnbm9yZSBpbmNpZGVudCBlZGdlc1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChQb2ludC5sZWZ0T24odGhpcy5hdChhKSwgdGhpcy5hdChiKSwgdGhpcy5hdChpICsgMSkpICYmIFBvaW50LnJpZ2h0T24odGhpcy5hdChhKSwgdGhpcy5hdChiKSwgdGhpcy5hdChpKSkpIHsgLy8gaWYgZGlhZyBpbnRlcnNlY3RzIGFuIGVkZ2VcbiAgICAgICAgICAgIGwxWzBdID0gdGhpcy5hdChhKTtcbiAgICAgICAgICAgIGwxWzFdID0gdGhpcy5hdChiKTtcbiAgICAgICAgICAgIGwyWzBdID0gdGhpcy5hdChpKTtcbiAgICAgICAgICAgIGwyWzFdID0gdGhpcy5hdChpICsgMSk7XG4gICAgICAgICAgICBwID0gTGluZS5saW5lSW50KGwxLGwyKTtcbiAgICAgICAgICAgIGlmIChQb2ludC5zcWRpc3QodGhpcy5hdChhKSwgcCkgPCBkaXN0KSB7IC8vIGlmIGVkZ2UgaXMgYmxvY2tpbmcgdmlzaWJpbGl0eSB0byBiXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHBvbHlnb24gZnJvbSB2ZXJ0ZXggaSB0byB2ZXJ0ZXggai5cbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEBwYXJhbSAge1BvbHlnb259IFt0YXJnZXRQb2x5XSAgIE9wdGlvbmFsIHRhcmdldCBwb2x5Z29uIHRvIHNhdmUgaW4uXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSAgICAgICAgICAgICAgICBUaGUgcmVzdWx0aW5nIGNvcHkuXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihpLGosdGFyZ2V0UG9seSl7XG4gICAgdmFyIHAgPSB0YXJnZXRQb2x5IHx8IG5ldyBQb2x5Z29uKCk7XG4gICAgcC5jbGVhcigpO1xuICAgIGlmIChpIDwgaikge1xuICAgICAgICAvLyBJbnNlcnQgYWxsIHZlcnRpY2VzIGZyb20gaSB0byBqXG4gICAgICAgIGZvcih2YXIgaz1pOyBrPD1qOyBrKyspXG4gICAgICAgICAgICBwLnZlcnRpY2VzLnB1c2godGhpcy52ZXJ0aWNlc1trXSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIEluc2VydCB2ZXJ0aWNlcyAwIHRvIGpcbiAgICAgICAgZm9yKHZhciBrPTA7IGs8PWo7IGsrKylcbiAgICAgICAgICAgIHAudmVydGljZXMucHVzaCh0aGlzLnZlcnRpY2VzW2tdKTtcblxuICAgICAgICAvLyBJbnNlcnQgdmVydGljZXMgaSB0byBlbmRcbiAgICAgICAgZm9yKHZhciBrPWk7IGs8dGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGsrKylcbiAgICAgICAgICAgIHAudmVydGljZXMucHVzaCh0aGlzLnZlcnRpY2VzW2tdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qKlxuICogRGVjb21wb3NlcyB0aGUgcG9seWdvbiBpbnRvIGNvbnZleCBwaWVjZXMuIFJldHVybnMgYSBsaXN0IG9mIGVkZ2VzIFtbcDEscDJdLFtwMixwM10sLi4uXSB0aGF0IGN1dHMgdGhlIHBvbHlnb24uXG4gKiBOb3RlIHRoYXQgdGhpcyBhbGdvcml0aG0gaGFzIGNvbXBsZXhpdHkgTyhOXjQpIGFuZCB3aWxsIGJlIHZlcnkgc2xvdyBmb3IgcG9seWdvbnMgd2l0aCBtYW55IHZlcnRpY2VzLlxuICogQG1ldGhvZCBnZXRDdXRFZGdlc1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmdldEN1dEVkZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1pbj1bXSwgdG1wMT1bXSwgdG1wMj1bXSwgdG1wUG9seSA9IG5ldyBQb2x5Z29uKCk7XG4gICAgdmFyIG5EaWFncyA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWZsZXgoaSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhblNlZShpLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICB0bXAxID0gdGhpcy5jb3B5KGksIGosIHRtcFBvbHkpLmdldEN1dEVkZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcDIgPSB0aGlzLmNvcHkoaiwgaSwgdG1wUG9seSkuZ2V0Q3V0RWRnZXMoKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDsgazx0bXAyLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wMS5wdXNoKHRtcDJba10pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0bXAxLmxlbmd0aCA8IG5EaWFncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gdG1wMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5EaWFncyA9IHRtcDEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluLnB1c2goW3RoaXMuYXQoaSksIHRoaXMuYXQoaildKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW47XG59O1xuXG4vKipcbiAqIERlY29tcG9zZXMgdGhlIHBvbHlnb24gaW50byBvbmUgb3IgbW9yZSBjb252ZXggc3ViLVBvbHlnb25zLlxuICogQG1ldGhvZCBkZWNvbXBcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvciBQb2x5Z29uIG9iamVjdHMuXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLmRlY29tcCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5nZXRDdXRFZGdlcygpO1xuICAgIGlmKGVkZ2VzLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKGVkZ2VzKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBbdGhpc107XG59O1xuXG4vKipcbiAqIFNsaWNlcyB0aGUgcG9seWdvbiBnaXZlbiBvbmUgb3IgbW9yZSBjdXQgZWRnZXMuIElmIGdpdmVuIG9uZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0d28gcG9seWdvbnMgKGZhbHNlIG9uIGZhaWx1cmUpLiBJZiBtYW55LCBhbiBhcnJheSBvZiBwb2x5Z29ucy5cbiAqIEBtZXRob2Qgc2xpY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGN1dEVkZ2VzIEEgbGlzdCBvZiBlZGdlcywgYXMgcmV0dXJuZWQgYnkgLmdldEN1dEVkZ2VzKClcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKGN1dEVkZ2VzKXtcbiAgICBpZihjdXRFZGdlcy5sZW5ndGggPT0gMCkgcmV0dXJuIFt0aGlzXTtcbiAgICBpZihjdXRFZGdlcyBpbnN0YW5jZW9mIEFycmF5ICYmIGN1dEVkZ2VzLmxlbmd0aCAmJiBjdXRFZGdlc1swXSBpbnN0YW5jZW9mIEFycmF5ICYmIGN1dEVkZ2VzWzBdLmxlbmd0aD09MiAmJiBjdXRFZGdlc1swXVswXSBpbnN0YW5jZW9mIEFycmF5KXtcblxuICAgICAgICB2YXIgcG9seXMgPSBbdGhpc107XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8Y3V0RWRnZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIGN1dEVkZ2UgPSBjdXRFZGdlc1tpXTtcbiAgICAgICAgICAgIC8vIEN1dCBhbGwgcG9seXNcbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHBvbHlzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICB2YXIgcG9seSA9IHBvbHlzW2pdO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwb2x5LnNsaWNlKGN1dEVkZ2UpO1xuICAgICAgICAgICAgICAgIGlmKHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIHBvbHkhIEN1dCBhbmQgcXVpdFxuICAgICAgICAgICAgICAgICAgICBwb2x5cy5zcGxpY2UoaiwxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seXMucHVzaChyZXN1bHRbMF0scmVzdWx0WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbHlzO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gV2FzIGdpdmVuIG9uZSBlZGdlXG4gICAgICAgIHZhciBjdXRFZGdlID0gY3V0RWRnZXM7XG4gICAgICAgIHZhciBpID0gdGhpcy52ZXJ0aWNlcy5pbmRleE9mKGN1dEVkZ2VbMF0pO1xuICAgICAgICB2YXIgaiA9IHRoaXMudmVydGljZXMuaW5kZXhPZihjdXRFZGdlWzFdKTtcblxuICAgICAgICBpZihpICE9IC0xICYmIGogIT0gLTEpe1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmNvcHkoaSxqKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3B5KGosaSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgdGhhdCB0aGUgbGluZSBzZWdtZW50cyBvZiB0aGlzIHBvbHlnb24gZG8gbm90IGludGVyc2VjdCBlYWNoIG90aGVyLlxuICogQG1ldGhvZCBpc1NpbXBsZVxuICogQHBhcmFtICB7QXJyYXl9IHBhdGggQW4gYXJyYXkgb2YgdmVydGljZXMgZS5nLiBbWzAsMF0sWzAsMV0sLi4uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEB0b2RvIFNob3VsZCBpdCBjaGVjayBhbGwgc2VnbWVudHMgd2l0aCBhbGwgb3RoZXJzP1xuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5pc1NpbXBsZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhdGggPSB0aGlzLnZlcnRpY2VzO1xuICAgIC8vIENoZWNrXG4gICAgZm9yKHZhciBpPTA7IGk8cGF0aC5sZW5ndGgtMTsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aS0xOyBqKyspe1xuICAgICAgICAgICAgaWYoTGluZS5zZWdtZW50c0ludGVyc2VjdChwYXRoW2ldLCBwYXRoW2krMV0sIHBhdGhbal0sIHBhdGhbaisxXSApKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgc2VnbWVudCBiZXR3ZWVuIHRoZSBsYXN0IGFuZCB0aGUgZmlyc3QgcG9pbnQgdG8gYWxsIG90aGVyc1xuICAgIGZvcih2YXIgaT0xOyBpPHBhdGgubGVuZ3RoLTI7IGkrKyl7XG4gICAgICAgIGlmKExpbmUuc2VnbWVudHNJbnRlcnNlY3QocGF0aFswXSwgcGF0aFtwYXRoLmxlbmd0aC0xXSwgcGF0aFtpXSwgcGF0aFtpKzFdICkpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25Qb2ludChwMSwgcDIsIHExLCBxMiwgZGVsdGEpe1xuICAgIGRlbHRhID0gZGVsdGEgfHwgMDtcbiAgIHZhciBhMSA9IHAyWzFdIC0gcDFbMV07XG4gICB2YXIgYjEgPSBwMVswXSAtIHAyWzBdO1xuICAgdmFyIGMxID0gKGExICogcDFbMF0pICsgKGIxICogcDFbMV0pO1xuICAgdmFyIGEyID0gcTJbMV0gLSBxMVsxXTtcbiAgIHZhciBiMiA9IHExWzBdIC0gcTJbMF07XG4gICB2YXIgYzIgPSAoYTIgKiBxMVswXSkgKyAoYjIgKiBxMVsxXSk7XG4gICB2YXIgZGV0ID0gKGExICogYjIpIC0gKGEyICogYjEpO1xuXG4gICBpZighU2NhbGFyLmVxKGRldCwwLGRlbHRhKSlcbiAgICAgIHJldHVybiBbKChiMiAqIGMxKSAtIChiMSAqIGMyKSkgLyBkZXQsICgoYTEgKiBjMikgLSAoYTIgKiBjMSkpIC8gZGV0XVxuICAgZWxzZVxuICAgICAgcmV0dXJuIFswLDBdXG59XG5cbi8qKlxuICogUXVpY2tseSBkZWNvbXBvc2UgdGhlIFBvbHlnb24gaW50byBjb252ZXggc3ViLXBvbHlnb25zLlxuICogQG1ldGhvZCBxdWlja0RlY29tcFxuICogQHBhcmFtICB7QXJyYXl9IHJlc3VsdFxuICogQHBhcmFtICB7QXJyYXl9IFtyZWZsZXhWZXJ0aWNlc11cbiAqIEBwYXJhbSAge0FycmF5fSBbc3RlaW5lclBvaW50c11cbiAqIEBwYXJhbSAge051bWJlcn0gW2RlbHRhXVxuICogQHBhcmFtICB7TnVtYmVyfSBbbWF4bGV2ZWxdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtsZXZlbF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Qb2x5Z29uLnByb3RvdHlwZS5xdWlja0RlY29tcCA9IGZ1bmN0aW9uKHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKXtcbiAgICBtYXhsZXZlbCA9IG1heGxldmVsIHx8IDEwMDtcbiAgICBsZXZlbCA9IGxldmVsIHx8IDA7XG4gICAgZGVsdGEgPSBkZWx0YSB8fCAyNTtcbiAgICByZXN1bHQgPSB0eXBlb2YocmVzdWx0KSE9XCJ1bmRlZmluZWRcIiA/IHJlc3VsdCA6IFtdO1xuICAgIHJlZmxleFZlcnRpY2VzID0gcmVmbGV4VmVydGljZXMgfHwgW107XG4gICAgc3RlaW5lclBvaW50cyA9IHN0ZWluZXJQb2ludHMgfHwgW107XG5cbiAgICB2YXIgdXBwZXJJbnQ9WzAsMF0sIGxvd2VySW50PVswLDBdLCBwPVswLDBdOyAvLyBQb2ludHNcbiAgICB2YXIgdXBwZXJEaXN0PTAsIGxvd2VyRGlzdD0wLCBkPTAsIGNsb3Nlc3REaXN0PTA7IC8vIHNjYWxhcnNcbiAgICB2YXIgdXBwZXJJbmRleD0wLCBsb3dlckluZGV4PTAsIGNsb3Nlc3RJbmRleD0wOyAvLyBJbnRlZ2Vyc1xuICAgIHZhciBsb3dlclBvbHk9bmV3IFBvbHlnb24oKSwgdXBwZXJQb2x5PW5ldyBQb2x5Z29uKCk7IC8vIHBvbHlnb25zXG4gICAgdmFyIHBvbHkgPSB0aGlzLFxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlcztcblxuICAgIGlmKHYubGVuZ3RoIDwgMykgcmV0dXJuIHJlc3VsdDtcblxuICAgIGxldmVsKys7XG4gICAgaWYobGV2ZWwgPiBtYXhsZXZlbCl7XG4gICAgICAgIGNvbnNvbGUud2FybihcInF1aWNrRGVjb21wOiBtYXggbGV2ZWwgKFwiK21heGxldmVsK1wiKSByZWFjaGVkLlwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHBvbHkuaXNSZWZsZXgoaSkpIHtcbiAgICAgICAgICAgIHJlZmxleFZlcnRpY2VzLnB1c2gocG9seS52ZXJ0aWNlc1tpXSk7XG4gICAgICAgICAgICB1cHBlckRpc3QgPSBsb3dlckRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChQb2ludC5sZWZ0KHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgUG9pbnQucmlnaHRPbihwb2x5LmF0KGkgLSAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqIC0gMSkpKSB7IC8vIGlmIGxpbmUgaW50ZXJzZWN0cyB3aXRoIGFuIGVkZ2VcbiAgICAgICAgICAgICAgICAgICAgcCA9IGdldEludGVyc2VjdGlvblBvaW50KHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopLCBwb2x5LmF0KGogLSAxKSk7IC8vIGZpbmQgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoUG9pbnQucmlnaHQocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHApKSB7IC8vIG1ha2Ugc3VyZSBpdCdzIGluc2lkZSB0aGUgcG9seVxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IFBvaW50LnNxZGlzdChwb2x5LnZlcnRpY2VzW2ldLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgbG93ZXJEaXN0KSB7IC8vIGtlZXAgb25seSB0aGUgY2xvc2VzdCBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckRpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySW50ID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoUG9pbnQubGVmdChwb2x5LmF0KGkgKyAxKSwgcG9seS5hdChpKSwgcG9seS5hdChqICsgMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBQb2ludC5yaWdodE9uKHBvbHkuYXQoaSArIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gZ2V0SW50ZXJzZWN0aW9uUG9pbnQocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaiksIHBvbHkuYXQoaiArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBvaW50LmxlZnQocG9seS5hdChpIC0gMSksIHBvbHkuYXQoaSksIHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gUG9pbnQuc3FkaXN0KHBvbHkudmVydGljZXNbaV0sIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCB1cHBlckRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckRpc3QgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVySW50ID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHZlcnRpY2VzIHRvIGNvbm5lY3QgdG8sIGNob29zZSBhIHBvaW50IGluIHRoZSBtaWRkbGVcbiAgICAgICAgICAgIGlmIChsb3dlckluZGV4ID09ICh1cHBlckluZGV4ICsgMSkgJSB0aGlzLnZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYXNlIDE6IFZlcnRleChcIitpK1wiKSwgbG93ZXJJbmRleChcIitsb3dlckluZGV4K1wiKSwgdXBwZXJJbmRleChcIit1cHBlckluZGV4K1wiKSwgcG9seS5zaXplKFwiK3RoaXMudmVydGljZXMubGVuZ3RoK1wiKVwiKTtcbiAgICAgICAgICAgICAgICBwWzBdID0gKGxvd2VySW50WzBdICsgdXBwZXJJbnRbMF0pIC8gMjtcbiAgICAgICAgICAgICAgICBwWzFdID0gKGxvd2VySW50WzFdICsgdXBwZXJJbnRbMV0pIC8gMjtcbiAgICAgICAgICAgICAgICBzdGVpbmVyUG9pbnRzLnB1c2gocCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IHVwcGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9sb3dlclBvbHkuaW5zZXJ0KGxvd2VyUG9seS5lbmQoKSwgcG9seS5iZWdpbigpICsgaSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksIGksIHVwcGVySW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkudmVydGljZXMucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggIT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCkgKyBsb3dlckluZGV4LCBwb2x5LmVuZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5hcHBlbmQocG9seSxsb3dlckluZGV4LHBvbHkudmVydGljZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL3VwcGVyUG9seS5pbnNlcnQodXBwZXJQb2x5LmVuZCgpLCBwb2x5LmJlZ2luKCksIHBvbHkuYmVnaW4oKSArIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LDAsaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGksIHBvbHkuZW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LmFwcGVuZChwb2x5LGkscG9seS52ZXJ0aWNlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vbG93ZXJQb2x5Lmluc2VydChsb3dlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSwgcG9seS5iZWdpbigpICsgdXBwZXJJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksMCx1cHBlckluZGV4KzEpO1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkudmVydGljZXMucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LnZlcnRpY2VzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIC8vdXBwZXJQb2x5Lmluc2VydCh1cHBlclBvbHkuZW5kKCksIHBvbHkuYmVnaW4oKSArIGxvd2VySW5kZXgsIHBvbHkuYmVnaW4oKSArIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LGxvd2VySW5kZXgsaSsxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgd2l0aGluIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYXNlIDI6IFZlcnRleChcIitpK1wiKSwgY2xvc2VzdEluZGV4KFwiK2Nsb3Nlc3RJbmRleCtcIiksIHBvbHkuc2l6ZShcIit0aGlzLnZlcnRpY2VzLmxlbmd0aCtcIilcXG5cIik7XG5cbiAgICAgICAgICAgICAgICBpZiAobG93ZXJJbmRleCA+IHVwcGVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCArPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgICAgICAgICAgaWYodXBwZXJJbmRleCA8IGxvd2VySW5kZXgpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBsb3dlckluZGV4OyBqIDw9IHVwcGVySW5kZXg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUG9pbnQubGVmdE9uKHBvbHkuYXQoaSAtIDEpLCBwb2x5LmF0KGkpLCBwb2x5LmF0KGopKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIFBvaW50LnJpZ2h0T24ocG9seS5hdChpICsgMSksIHBvbHkuYXQoaSksIHBvbHkuYXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gUG9pbnQuc3FkaXN0KHBvbHkuYXQoaSksIHBvbHkuYXQoaikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBjbG9zZXN0RGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBqICUgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA8IGNsb3Nlc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuYXBwZW5kKHBvbHksaSxjbG9zZXN0SW5kZXgrMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0SW5kZXggIT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksY2xvc2VzdEluZGV4LHYubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1cHBlclBvbHkuYXBwZW5kKHBvbHksMCxpKzEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJQb2x5LmFwcGVuZChwb2x5LGksdi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seS5hcHBlbmQocG9seSwwLGNsb3Nlc3RJbmRleCsxKTtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5LmFwcGVuZChwb2x5LGNsb3Nlc3RJbmRleCxpKzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc29sdmUgc21hbGxlc3QgcG9seSBmaXJzdFxuICAgICAgICAgICAgaWYgKGxvd2VyUG9seS52ZXJ0aWNlcy5sZW5ndGggPCB1cHBlclBvbHkudmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG93ZXJQb2x5LnF1aWNrRGVjb21wKHJlc3VsdCxyZWZsZXhWZXJ0aWNlcyxzdGVpbmVyUG9pbnRzLGRlbHRhLG1heGxldmVsLGxldmVsKTtcbiAgICAgICAgICAgICAgICB1cHBlclBvbHkucXVpY2tEZWNvbXAocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cHBlclBvbHkucXVpY2tEZWNvbXAocmVzdWx0LHJlZmxleFZlcnRpY2VzLHN0ZWluZXJQb2ludHMsZGVsdGEsbWF4bGV2ZWwsbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxvd2VyUG9seS5xdWlja0RlY29tcChyZXN1bHQscmVmbGV4VmVydGljZXMsc3RlaW5lclBvaW50cyxkZWx0YSxtYXhsZXZlbCxsZXZlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2godGhpcyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZW1vdmUgY29sbGluZWFyIHBvaW50cyBpbiB0aGUgcG9seWdvbi5cbiAqIEBtZXRob2QgcmVtb3ZlQ29sbGluZWFyUG9pbnRzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFtwcmVjaXNpb25dIFRoZSB0aHJlc2hvbGQgYW5nbGUgdG8gdXNlIHdoZW4gZGV0ZXJtaW5pbmcgd2hldGhlciB0d28gZWRnZXMgYXJlIGNvbGxpbmVhci4gVXNlIHplcm8gZm9yIGZpbmVzdCBwcmVjaXNpb24uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHBvaW50cyByZW1vdmVkXG4gKi9cblBvbHlnb24ucHJvdG90eXBlLnJlbW92ZUNvbGxpbmVhclBvaW50cyA9IGZ1bmN0aW9uKHByZWNpc2lvbil7XG4gICAgdmFyIG51bSA9IDA7XG4gICAgZm9yKHZhciBpPXRoaXMudmVydGljZXMubGVuZ3RoLTE7IHRoaXMudmVydGljZXMubGVuZ3RoPjMgJiYgaT49MDsgLS1pKXtcbiAgICAgICAgaWYoUG9pbnQuY29sbGluZWFyKHRoaXMuYXQoaS0xKSx0aGlzLmF0KGkpLHRoaXMuYXQoaSsxKSxwcmVjaXNpb24pKXtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbWlkZGxlIHBvaW50XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnNwbGljZShpJXRoaXMudmVydGljZXMubGVuZ3RoLDEpO1xuICAgICAgICAgICAgaS0tOyAvLyBKdW1wIG9uZSBwb2ludCBmb3J3YXJkLiBPdGhlcndpc2Ugd2UgbWF5IGdldCBhIGNoYWluIHJlbW92YWxcbiAgICAgICAgICAgIG51bSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/poly-decomp/src/Polygon.js\n");

/***/ }),

/***/ "./node_modules/poly-decomp/src/Scalar.js":
/*!************************************************!*\
  !*** ./node_modules/poly-decomp/src/Scalar.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = Scalar;\n\n/**\n * Scalar functions\n * @class Scalar\n */\nfunction Scalar(){}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nScalar.eq = function(a,b,precision){\n    precision = precision || 0;\n    return Math.abs(a-b) < precision;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL1NjYWxhci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb2x5LWRlY29tcC9zcmMvU2NhbGFyLmpzP2FiZmYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBTY2FsYXI7XG5cbi8qKlxuICogU2NhbGFyIGZ1bmN0aW9uc1xuICogQGNsYXNzIFNjYWxhclxuICovXG5mdW5jdGlvbiBTY2FsYXIoKXt9XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHNjYWxhcnMgYXJlIGVxdWFsXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGVxXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSAge051bWJlcn0gYlxuICogQHBhcmFtICB7TnVtYmVyfSBbcHJlY2lzaW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuU2NhbGFyLmVxID0gZnVuY3Rpb24oYSxiLHByZWNpc2lvbil7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEtYikgPCBwcmVjaXNpb247XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/poly-decomp/src/Scalar.js\n");

/***/ }),

/***/ "./node_modules/poly-decomp/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/poly-decomp/src/index.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n    Polygon : __webpack_require__(/*! ./Polygon */ \"./node_modules/poly-decomp/src/Polygon.js\"),\n    Point : __webpack_require__(/*! ./Point */ \"./node_modules/poly-decomp/src/Point.js\"),\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9seS1kZWNvbXAvc3JjL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BvbHktZGVjb21wL3NyYy9pbmRleC5qcz82ZDMxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFBvbHlnb24gOiByZXF1aXJlKFwiLi9Qb2x5Z29uXCIpLFxuICAgIFBvaW50IDogcmVxdWlyZShcIi4vUG9pbnRcIiksXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/poly-decomp/src/index.js\n");

/***/ })

}]);